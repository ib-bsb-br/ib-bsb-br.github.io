---
tags: [scripts>python]
info: aberto.
date: 2025-02-05
type: post
layout: post
published: true
slug: ftp-py
title: 'files-to-prompt ftp.py'
---
Installation:

    pip install click rarfile py7zr pathspec
    # For optional templating features:
    pip install jinja2

Usage:

    python framework3.py [OPTIONS] [PATHS...]

Options:

| Flag/Option            | Type          | Default | Description                                                                              |
|------------------------|---------------|---------|------------------------------------------------------------------------------------------|
| --extension, -e        | multiple=True | None    | Restrict processing to specific extensions (archives & Office docs still processed).     |
| --include-hidden       | is_flag=True  | False   | Include hidden (dot) files/folders.                                                      |
| --ignore-gitignore     | is_flag=True  | False   | Do not load/respect .gitignore rules.                                                    |
| --ignore (patterns)    | multiple=True | None    | Exclude additional glob patterns (e.g., *.log).                                          |
| --output, -o           | file path     | None    | Output results to a file instead of console.                                             |
| --xml                  | is_flag=True  | False   | Wrap content in an XML-like output structure.                                            |
| --template-file, -t    | file path     | None    | (Optional) Use a Jinja2 template for custom formatting.                                  |
| --max-depth, -d        | integer       | 5       | Maximum recursion depth for nested archives/directories.                                 |

Notes:
• “jinja2” is only needed if you plan to use the --template-file option.  
• Additional features from the “raw_data” set—like scheduling or collaboration—can be integrated into this framework as optional modules.  

Example Command:

    python framework3.py -e .py --ignore=*.log --template-file=my_template.j2 /path/to/files


{% codeblock python %}
import os
import sys
import tempfile
import shutil
import zipfile
import tarfile
import click
import logging
from fnmatch import fnmatch
from typing import Callable, List, Optional, Tuple

# Optional imports from ‘raw_data’ (Jinja2, etc.)
try:
    import rarfile
except ImportError:
    rarfile = None
try:
    import py7zr
except ImportError:
    py7zr = None
try:
    import pathspec
except ImportError:
    pathspec = None
try:
    from jinja2 import Environment, FileSystemLoader
except ImportError:
    Environment = None
    FileSystemLoader = None

logging.basicConfig(
    level=logging.INFO,
    format=“%(asctime)s - %(levelname)s - %(message)s”,
    stream=sys.stderr,
)
logger = logging.getLogger(__name__)

# ———————————————————————
# “framework1” core: safe archive extraction & ignoring hidden files
# ———————————————————————
def is_within_directory(directory: str, target: str) -> bool:
    “””
    Checks if the target path is within the specified directory,
    preventing path traversal.
    “””
    abs_directory = os.path.abspath(directory)
    abs_target = os.path.abspath(target)
    return os.path.commonprefix([abs_directory, abs_target]) == abs_directory

def safe_extract(tar: tarfile.TarFile, path: str = “.”, members=None) -> None:
    “””
    Safely extract tar contents, preventing directory traversal.
    “””
    for member in (members or tar.getmembers()):
        member_path = os.path.join(path, member.name)
        if not is_within_directory(path, member_path):
            raise ValueError(“Detected path traversal attempt.”)
    tar.extractall(path=path, members=members)

# ———————————————————————
# Archive handlers from “framework1”
# ———————————————————————
def handle_zip(file_path: str, extract_dir: str) -> bool:
    try:
        with zipfile.ZipFile(file_path, “r”) as zf:
            zf.extractall(extract_dir)
        return True
    except zipfile.BadZipFile as e:
        logger.warning(f”Bad ZIP file {file_path}: {str(e)}”)
        return False

def handle_rar(file_path: str, extract_dir: str) -> bool:
    if not rarfile:
        logger.warning(“RAR handling requires ‘rarfile’ to be installed.”)
        return False
    try:
        with rarfile.RarFile(file_path, “r”) as rf:
            rf.extractall(extract_dir)
        return True
    except rarfile.Error as e:
        logger.warning(f”RAR extraction failed: {str(e)}”)
        return False

def handle_7z(file_path: str, extract_dir: str) -> bool:
    if not py7zr:
        logger.warning(“7z handling requires ‘py7zr’ to be installed.”)
        return False
    try:
        with py7zr.SevenZipFile(file_path, “r”) as sz:
            sz.extractall(extract_dir)
        return True
    except py7zr.exceptions.Bad7zFile as e:
        logger.warning(f”7z extraction failed: {str(e)}”)
        return False

def handle_tar(file_path: str, extract_dir: str) -> bool:
    try:
        with tarfile.open(file_path, “r:*”) as tf:
            safe_extract(tf, extract_dir)
        return True
    except tarfile.TarError as e:
        logger.warning(f”TAR extraction failed: {str(e)}”)
        return False

ARCHIVE_HANDLERS = {
    “.zip”: handle_zip,
    “.rar”: handle_rar,
    “.7z”: handle_7z,
    “.tar”: handle_tar,
    “.gz”: handle_tar,
    “.bz2”: handle_tar,
}
OFFICE_EXTENSIONS = [“.docx”, “.xlsx”, “.pptx”, “.odt”, “.ods”, “.odp”]

# ———————————————————————
# “raw_data” integration: ignoring and templating
# ———————————————————————
def read_gitignore(directory: str) -> List[str]:
    “””
    Reads lines from .gitignore if present.
    “””
    path = os.path.join(directory, “.gitignore”)
    if os.path.isfile(path):
        with open(path, “r”, encoding=“utf-8”) as f:
            return [line.strip() for line in f if line.strip() and not line.startswith(“#”)]
    return []

def should_ignore(path: str, rules: List[str]) -> bool:
    “””
    Basic fnmatch-based ignoring for files or directories.
    “””
    base = os.path.basename(path)
    if os.path.isdir(path):
        base += “/“
    return any(fnmatch(base, rule) for rule in rules)

class GitignoreHandler:
    “””
    If pathspec is installed, use it; otherwise fallback to a basic approach.
    “””
    def __init__(self, directory: str):
        self.pathspec_spec = None
        self.fallback_rules = []
        lines = read_gitignore(directory)
        if pathspec:
            self.pathspec_spec = pathspec.PathSpec.from_lines(“gitwildmatch”, lines)
        else:
            self.fallback_rules = lines

    def should_ignore(self, path_to_check: str) -> bool:
        if self.pathspec_spec:
            return self.pathspec_spec.match_file(path_to_check)
        return should_ignore(path_to_check, self.fallback_rules)

class OutputFormatter:
    “””
    Output in plain text, XML mode, or via Jinja2 template.
    “””
    def __init__(
        self,
        writer: Callable[[str], None],
        xml_mode: bool = False,
        template_file: Optional[str] = None
    ):
        self.writer = writer
        self.xml_mode = xml_mode
        self.xml_index = 1
        self.template_file = template_file
        self.jinja_env = None

        if template_file and Environment and FileSystemLoader:
            template_dir = os.path.dirname(template_file)
            self.jinja_env = Environment(loader=FileSystemLoader(template_dir))

    def write(self, path: str, content: str) -> None:
        “””
        Dispatches writing logic based on Jinja2 usage or XML vs. plain text.
        “””
        if self.jinja_env and self.template_file:
            try:
                template_name = os.path.basename(self.template_file)
                template = self.jinja_env.get_template(template_name)
                rendered = template.render(path=path, content=content, index=self.xml_index)
                self.writer(rendered)
            except Exception as e:
                logger.warning(f”Jinja2 rendering error: {e}”)
                self._fallback_write(path, content)
        elif self.xml_mode:
            self.writer(f’<section data-filename=“xml_code-block xml” data-code=“”>’)
            self.writer(f’    {path}</source>’)
            self.writer(‘    ‘)
            for line in content.splitlines():
                self.writer(f’        {line}’)
            self.writer(‘    ‘)
            self.writer(‘</section>’)
            self.xml_index += 1
        else:
            self._fallback_write(path, content)

    def _fallback_write(self, path: str, content: str):
        self.writer(path)
        self.writer(“—“)
        self.writer(content)
        self.writer(“”)
        self.writer(“—“)
        self.xml_index += 1

# ———————————————————————
# “framework3”: Extended version of “framework1” + “raw_data”
# ———————————————————————
class FileProcessor:
    “””
    Combines the original archive handling with the ignoring
    and templating features from ‘raw_data.’
    “””
    def __init__(
        self,
        extensions: Tuple[str, ...],
        include_hidden: bool,
        ignore_gitignore: bool,
        ignore_patterns: Tuple[str, ...],
        formatter: OutputFormatter,
        max_depth: int = 5,
    ):
        self.extensions = [ext.lower() for ext in extensions]
        self.include_hidden = include_hidden
        self.ignore_gitignore = ignore_gitignore
        self.ignore_patterns = ignore_patterns
        self.formatter = formatter
        self.max_depth = max_depth

    def process_path(self, path: str, depth: int = 0, extra_gitignore_rules: List[str] = None) -> None:
        if extra_gitignore_rules is None:
            extra_gitignore_rules = []

        if depth > self.max_depth:
            logger.warning(f”Max recursion depth ({self.max_depth}) reached at {path}.”)
            return

        if os.path.isfile(path):
            self._handle_file(path, depth)
        elif os.path.isdir(path):
            if not self.ignore_gitignore:
                extra_gitignore_rules.extend(read_gitignore(path))
            self._handle_directory(path, depth, extra_gitignore_rules)

    def _handle_file(self, path: str, depth: int) -> None:
        ext = os.path.splitext(path)[1].lower()
        if ext in ARCHIVE_HANDLERS or ext in OFFICE_EXTENSIONS:
            self._extract_and_recurse(path, ext, depth)
        else:
            self._read_and_output(path)

    def _extract_and_recurse(self, path: str, ext: str, depth: int) -> None:
        handler_func = ARCHIVE_HANDLERS.get(ext)
        if ext in OFFICE_EXTENSIONS:
            handler_func = ARCHIVE_HANDLERS[“.zip”]  # Office docs are ZIP-based
        if not handler_func:
            logger.warning(f”No valid handler for extension: {ext}”)
            return
        with tempfile.TemporaryDirectory() as tmpdir:
            success = handler_func(path, tmpdir)
            if success:
                self.process_path(tmpdir, depth + 1)
            else:
                logger.warning(f”Extraction failed for {path}”)

    def _read_and_output(self, path: str) -> None:
        encodings_to_try = [“utf-8”, “latin-1”]
        for encoding in encodings_to_try:
            try:
                with open(path, “r”, encoding=encoding) as f:
                    content = f.read()
                self.formatter.write(path, content)
                return
            except UnicodeDecodeError:
                continue
            except Exception as e:
                logger.warning(f”File read error {path}: {e}”)
                return
        logger.warning(f”Could not read file {path} with provided encodings.”)

    def _handle_directory(self, directory: str, depth: int, extra_gitignore_rules: List[str]) -> None:
        gitignore_handler = None
        if not self.ignore_gitignore:
            gitignore_handler = GitignoreHandler(directory)

        for root, dirs, files in os.walk(directory):
            if not self.include_hidden:
                dirs[:] = [d for d in dirs if not d.startswith(“.”)]
                files = [f for f in files if not f.startswith(“.”)]

            # Merge local .gitignore with previous if not ignoring it
            if gitignore_handler:
                dirs[:] = [d for d in dirs if not gitignore_handler.should_ignore(os.path.join(root, d))]
                files = [f for f in files if not gitignore_handler.should_ignore(os.path.join(root, f))]

            # Additional ignoring from user-supplied patterns or globally merged .gitignore
            dirs[:] = [d for d in dirs if not should_ignore(os.path.join(root, d), extra_gitignore_rules)]
            files = [f for f in files if not should_ignore(os.path.join(root, f), extra_gitignore_rules)]

            # Command-line ignore patterns
            if self.ignore_patterns:
                files = [
                    f for f in files
                    if not any(fnmatch(f, pattern) for pattern in self.ignore_patterns)
                ]

            # Extension filtering
            if self.extensions:
                files = [
                    f for f in files
                    if any(f.lower().endswith(ext) for ext in self.extensions)
                ]

            for file_name in sorted(files):
                self.process_path(os.path.join(root, file_name), depth + 1, extra_gitignore_rules)

@click.command()
@click.argument(“paths”, nargs=-1, type=click.Path(exists=True))
@click.option(“-e”, “—extension”, “extensions”, multiple=True,
              help=“Specify file extensions, e.g. .txt, .md.”)
@click.option(“—include-hidden”, is_flag=True, default=False,
              help=“Include hidden files and subdirectories.”)
@click.option(“—ignore-gitignore”, is_flag=True, default=False,
              help=“Do not apply .gitignore-based filtering.”)
@click.option(“—ignore”, “ignore_patterns”, multiple=True,
              help=“Specify one or more glob patterns to exclude.”)
@click.option(“-o”, “—output”, “output_file”, type=click.Path(writable=True),
              help=“Output file path (stdout by default).”)
@click.option(“—xml”, “output_xml”, is_flag=True, default=False,
              help=“Output in XML-like format.”)
@click.option(“-t”, “—template-file”, “template_file”, type=click.Path(exists=True),
              help=“Use a Jinja2 template for output.”)
@click.option(“-d”, “—max-depth”, default=5,
              help=“Maximum recursion depth for nested archives.”)
def cli(paths, extensions, include_hidden, ignore_gitignore, ignore_patterns,
        output_file, output_xml, template_file, max_depth):
    “””
    “framework3” — Enhanced from ‘framework1’ using ‘raw_data’:
    1) Safe recursion-based file and archive handling.
    2) Advanced ignoring logic from .gitignore or pathspec.
    3) Optional Jinja2-based templating for output formatting.
    “””
    writer = click.echo
    file_handle = None
    if output_file:
        try:
            file_handle = open(output_file, “w”, encoding=“utf-8”)
            writer = lambda msg: print(msg, file=file_handle)
        except IOError as e:
            logger.error(f”Could not open output file {output_file}: {e}”)
            sys.exit(1)

    formatter = OutputFormatter(
        writer=writer,
        xml_mode=output_xml,
        template_file=template_file
    )

    # For XML output without templating, wrap top-level tags
    if output_xml and not template_file:
        writer(“<root>”)

    processor = FileProcessor(
        extensions=extensions,
        include_hidden=include_hidden,
        ignore_gitignore=ignore_gitignore,
        ignore_patterns=ignore_patterns,
        formatter=formatter,
        max_depth=max_depth
    )

    for path in paths:
        processor.process_path(path)

    if output_xml and not template_file:
        writer(“</root>”)

    if file_handle:
        file_handle.close()

if __name__ == “__main__”:
    cli()
{% endcodeblock %}
