<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Rust CLI parallel processing for copy/move files - infoBAG
      
    </title>
    <meta name="title" content="Rust CLI parallel processing for copy/move files - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/rust-cli-parallel-processing-for-copymove-files/">
    <meta property="og:title" content="Rust CLI parallel processing for copy/move files - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/rust-cli-parallel-processing-for-copymove-files/">
    <meta name="twitter:title" content="Rust CLI parallel processing for copy/move files - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/rust-cli-parallel-processing-for-copymove-files/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="software&gt;rust">
      
        <meta property="article:tag" content="software&gt;rust">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Rust CLI parallel processing for copy/move files
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-05-16T00:00:00+00:00" class="post-date">
          16 May 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-05-16T19:02:11+00:00">
              16 May 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/rust-cli-parallel-processing-for-copymove-files" class="tag">rust-cli-parallel-processing-for-copymove-files</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#software-rust" class="tag">software>rust</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        35533 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        2431 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-05-16-rust-cli-parallel-processing-for-copymove-files.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-05-16-rust-cli-parallel-processing-for-copymove-files.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#1-creating-the-project-and-adding-code">1. Creating the Project and Adding Code</a></li><li><a href="#to-build-and-run">To Build and Run</a></li></ul>
          <p>This tool provides basic file and directory <code class="language-plaintext highlighter-rouge">copy</code>, <code class="language-plaintext highlighter-rouge">move</code> (cut-and-paste), and <code class="language-plaintext highlighter-rouge">delete</code> operations, with an option for parallel processing on multi-core systems.</p>

<p>This guide is tailored for an <code class="language-plaintext highlighter-rouge">arm64 Debian Bullseye</code> environment, such as those found on RK3588-based single-board computers or servers.</p>
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<p>Before you begin, ensure your <code class="language-plaintext highlighter-rouge">arm64 Debian Bullseye</code> system is set up with the following:</p>

<ol>
  <li><strong>Rust Language Toolchain:</strong>
    <ul>
      <li>If you don’t have Rust installed, visit <a href="https://rustup.rs/">https://rustup.rs/</a> and follow the instructions. This will install <code class="language-plaintext highlighter-rouge">rustc</code> (the compiler) and <code class="language-plaintext highlighter-rouge">cargo</code> (the build tool and package manager).
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>curl <span class="nt">--proto</span> <span class="s1">'=https'</span> <span class="nt">--tlsv1</span>.2 <span class="nt">-sSf</span> https://sh.rustup.rs | sh
<span class="nb">source</span> <span class="nv">$HOME</span>/.cargo/env 
<span class="c"># You might need to open a new terminal or re-login for changes to take effect</span>
</code></section></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Essential Build Tools:</strong>
    <ul>
      <li>Install common build utilities often required by Rust crates that might link against C libraries or need system configuration.
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>build-essential pkg-config libssl-dev
</code></section></div>        </div>
        <p><em>(Note: <code class="language-plaintext highlighter-rouge">libssl-dev</code> is a common dependency for many Rust crates, though not strictly required by this specific MVP’s direct dependencies, it’s good practice to have it for broader Rust development).</em></p>
      </li>
    </ul>
  </li>
</ol>
  <h2 id="1-creating-the-project-and-adding-code">
    
    
     <a href="#1-creating-the-project-and-adding-code">#</a><a href="#" aria-label="Back to top">1. Creating the Project and Adding Code</a>
        
    
  </h2>
      

<p>First, create a new Rust project using Cargo and navigate into its directory:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo new rapidcopy_rust_cli_mvp
<span class="nb">cd </span>rapidcopy_rust_cli_mvp
</code></section></div></div>

<p>Next, you’ll replace the default <code class="language-plaintext highlighter-rouge">src/main.rs</code> and <code class="language-plaintext highlighter-rouge">Cargo.toml</code> files with the code for our RapidCopy-rs MVP.</p>

<p><strong>Replace the contents of <code class="language-plaintext highlighter-rouge">Cargo.toml</code> with the following:</strong></p>

<div class="language-toml highlighter-rouge"><div class="highlight"><section><code><span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"rapidcopy_rust_cli_mvp"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>

<span class="nn">[dependencies]</span>
<span class="py">clap</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"4.5.38"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"derive"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">indicatif</span> <span class="p">=</span> <span class="s">"0.17.11"</span>
<span class="py">rayon</span> <span class="p">=</span> <span class="s">"1.10.0"</span>
<span class="py">thiserror</span> <span class="p">=</span> <span class="s">"1.0.69"</span>
<span class="py">walkdir</span> <span class="p">=</span> <span class="s">"2.5.0"</span>
<span class="py">libc</span> <span class="p">=</span> <span class="s">"0.2.172"</span>
<span class="py">path-absolutize</span> <span class="p">=</span> <span class="s">"3.1.1"</span>
</code></section></div></div>

<p><strong>Replace the contents of <code class="language-plaintext highlighter-rouge">src/main.rs</code> with the following Rust code:</strong></p>

<section class="code-block-container" role="group" aria-label="Rust Code Block" data-filename="rust_code_block.rs" data-code="// src/main.rs

use clap::{Parser, Subcommand};
use indicatif::{HumanBytes, MultiProgress, ProgressBar, ProgressStyle};
use path_absolutize::*; // For Path::absolutize()
use rayon::prelude::*;
use std::{
    ffi::OsString,
    fs,
    io::{self, ErrorKind, Read, Write},
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicU64, Ordering as AtomicOrdering},
        Arc, Mutex,
    },
    thread,
    time::Duration,
};
use thiserror::Error;
use walkdir::{DirEntry, WalkDir};

// --- Argument Parsing ---
#[derive(Parser, Debug)]
#[clap(author, version, about = &quot;RapidCopy-rs (MVP): Fast file operations CLI&quot;, long_about = None)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,

    #[clap(short, long, global = true, help = &quot;Enable verbose output&quot;)]
    verbose: bool,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Copies a file or directory recursively
    Copy {
        /// Source path
        source: PathBuf,
        /// Destination path
        destination: PathBuf,
        #[clap(short, long, help = &quot;Overwrite existing files at the destination&quot;)]
        overwrite: bool,
        #[clap(long, help = &quot;Enable parallel processing for directory contents&quot;)]
        parallel: bool,
    },
    /// Moves a file or directory recursively (cut and paste)
    Move {
        /// Source path
        source: PathBuf,
        /// Destination path
        destination: PathBuf,
        #[clap(short, long, help = &quot;Overwrite existing files at the destination if copying&quot;)]
        overwrite: bool,
        #[clap(short = &#39;f&#39;, long, help = &quot;Force deletion of source without interactive confirmation (used in move)&quot;)]
        force_delete_source: bool,
        #[clap(long, help = &quot;Enable parallel processing for directory contents during copy phase&quot;)]
        parallel: bool,
    },
    /// Deletes a file or directory recursively
    Delete {
        /// Path to delete
        path: PathBuf,
        #[clap(short, long, help = &quot;Force deletion without interactive confirmation&quot;)]
        force: bool,
    },
}

// --- Error Handling ---
#[derive(Error, Debug)]
pub enum AppError {
    #[error(&quot;I/O error accessing &#39;{path:?}&#39;: {source}&quot;)]
    Io {
        source: io::Error,
        path: PathBuf,
    },
    #[error(&quot;WalkDir error for path &#39;{path:?}&#39;: {source}&quot;)]
    WalkDir {
        source: walkdir::Error,
        path: PathBuf,
    },
    #[error(&quot;Source path does not exist: {0}&quot;)]
    SourceDoesNotExist(PathBuf),
    #[error(&quot;Destination path &#39;{0}&#39; already exists and overwrite is false&quot;)]
    DestinationExists(PathBuf),
    #[error(&quot;Cannot copy/move directory &#39;{source_dir}&#39; to existing file &#39;{dest_file}&#39;&quot;)]
    DirToExistingFile {
        source_dir: PathBuf,
        dest_file: PathBuf,
    },
    #[error(&quot;Cannot copy/move file &#39;{source_file}&#39; to existing directory &#39;{dest_dir}&#39; (ambiguous destination name or destination is a file and overwrite is false)&quot;)]
    FileToExistingDirAmbiguous {
        source_file: PathBuf,
        dest_dir: PathBuf,
    },
    #[error(&quot;User did not confirm deletion of &#39;{0}&#39;&quot;)]
    DeletionNotConfirmed(PathBuf),
    #[error(&quot;Failed to get metadata for path: {0}&quot;)]
    MetadataError(PathBuf),
    #[error(&quot;Source path &#39;{0}&#39; has no filename component&quot;)]
    NoFileName(PathBuf),
    #[error(&quot;Failed to strip prefix for path processing: &#39;{path}&#39; relative to &#39;{base}&#39;&quot;)]
    StripPrefixError { path: PathBuf, base: PathBuf },
    #[error(&quot;Operation failed with multiple errors during parallel processing:\n{0:#?}&quot;)]
    ParallelOperationFailed(Vec&lt;String&gt;),
    #[error(&quot;Cannot move/copy &#39;{0}&#39; to a subdirectory of itself &#39;{1}&#39;&quot;)]
    RecursiveMoveOrCopy(PathBuf, PathBuf),
    #[error(&quot;Indicatif style template error: {0}&quot;)]
    TemplateError(String),
}

impl From&lt;walkdir::Error&gt; for AppError {
    fn from(err: walkdir::Error) -&gt; Self {
        let path = err
            .path()
            .unwrap_or_else(|| Path::new(&quot;&lt;unknown path from walkdir error&gt;&quot;))
            .to_path_buf();
        AppError::WalkDir { source: err, path }
    }
}

fn io_err_with_path(err: io::Error, path: &amp;Path) -&gt; AppError {
    AppError::Io {
        source: err,
        path: path.to_path_buf(),
    }
}

impl From&lt;indicatif::style::TemplateError&gt; for AppError {
    fn from(err: indicatif::style::TemplateError) -&gt; Self {
        AppError::TemplateError(err.to_string())
    }
}

// --- Core Logic Module ---
mod core_logic {
    use super::*;

    const BUFFER_SIZE: usize = 128 * 1024;

    #[derive(Debug)]
    struct ProgressInfo {
        items_processed: AtomicU64,
        bytes_processed: AtomicU64,
        total_items_to_process: u64,
        total_bytes_to_process: u64,
    }

    impl ProgressInfo {
        fn new(total_items: u64, total_bytes: u64) -&gt; Self {
            Self {
                items_processed: AtomicU64::new(0),
                bytes_processed: AtomicU64::new(0),
                total_items_to_process: total_items,
                total_bytes_to_process: total_bytes,
            }
        }
    }

    fn pre_scan_directory(dir: &amp;Path, verbose: bool) -&gt; Result&lt;(u64, u64), AppError&gt; {
        if verbose {
            println!(&quot;Pre-scanning directory &#39;{}&#39;...&quot;, dir.display());
        }
        let mut total_items = 0u64;
        let mut total_bytes = 0u64;
        total_items += 1; // Count the root directory itself
        for entry_result in WalkDir::new(dir).min_depth(1).follow_links(false) {
            let entry = entry_result?; 
            total_items += 1;
            if entry.file_type().is_file() {
                total_bytes += entry.metadata()?.len(); 
            }
        }
        if verbose {
            println!(
                &quot;Pre-scan complete: {} items, {}&quot;,
                total_items,
                HumanBytes(total_bytes)
            );
        }
        Ok((total_items, total_bytes))
    }

    fn copy_single_file(
        source: &amp;Path,
        destination: &amp;Path,
        overwrite: bool,
        mp_opt: Option&lt;&amp;MultiProgress&gt;,
        overall_progress_info_opt: Option&lt;&amp;Arc&lt;ProgressInfo&gt;&gt;,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if destination.exists() {
            let dest_meta =
                fs::metadata(destination).map_err(|e| io_err_with_path(e, destination))?;
            if dest_meta.is_dir() {
                return Err(AppError::FileToExistingDirAmbiguous {
                    source_file: source.to_path_buf(),
                    dest_dir: destination.to_path_buf(),
                });
            }
            if !overwrite {
                if verbose {
                    println!(
                        &quot;Skipping &#39;{}&#39;: destination file exists and overwrite is false.&quot;,
                        destination.display()
                    );
                }
                if let Some(stats) = overall_progress_info_opt {
                    stats.items_processed.fetch_add(1, AtomicOrdering::Relaxed);
                }
                return Ok(0);
            }
        }

        if let Some(parent) = destination.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent).map_err(|e| io_err_with_path(e, parent))?;
            }
        }

        let file_size = fs::metadata(source)
            .map_err(|e| io_err_with_path(e, source))?
            .len();

        let pb = if let Some(mp) = mp_opt {
            let p = mp.add(ProgressBar::new(file_size));
            p.enable_steady_tick(Duration::from_millis(250));
            p
        } else {
            let p = ProgressBar::new(file_size);
            p.enable_steady_tick(Duration::from_millis(100));
            p
        };

        pb.set_style(
            ProgressStyle::default_bar()
                .template(
                    &quot;{msg:&lt;30.bold.dim} [{bar:40.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec}, {eta})&quot;,
                )?
                .progress_chars(&quot;=&gt; &quot;),
        );
        let filename = source.file_name().unwrap_or_default().to_string_lossy();
        pb.set_message(filename.chars().take(30).collect::&lt;String&gt;());

        let mut source_file = fs::File::open(source).map_err(|e| io_err_with_path(e, source))?;
        let mut dest_file =
            fs::File::create(destination).map_err(|e| io_err_with_path(e, destination))?;

        let mut buffer = vec![0; BUFFER_SIZE];
        let mut copied_bytes_for_this_file = 0u64;

        loop {
            let bytes_read = source_file
                .read(&amp;mut buffer)
                .map_err(|e| io_err_with_path(e, source))?;
            if bytes_read == 0 {
                break;
            }
            dest_file
                .write_all(&amp;buffer[..bytes_read])
                .map_err(|e| io_err_with_path(e, destination))?;
            copied_bytes_for_this_file += bytes_read as u64;
            pb.set_position(copied_bytes_for_this_file);
            if let Some(stats) = overall_progress_info_opt {
                stats
                    .bytes_processed
                    .fetch_add(bytes_read as u64, AtomicOrdering::Relaxed);
            }
        }
        pb.finish_with_message(format!(&quot;Copied {} ({})&quot;, filename, HumanBytes(file_size)));
        if let Some(stats) = overall_progress_info_opt {
            stats.items_processed.fetch_add(1, AtomicOrdering::Relaxed);
        }
        Ok(file_size)
    }

    fn copy_dir_recursive(
        source_dir: &amp;Path,
        target_dest_dir: &amp;Path, 
        overwrite: bool,
        parallel: bool,
        _overall_item_pb: &amp;ProgressBar, 
        progress_info: &amp;Arc&lt;ProgressInfo&gt;,
        verbose: bool, // verbose is available here
    ) -&gt; Result&lt;(), Vec&lt;String&gt;&gt; {
        if verbose {
            println!(
                &quot;Recursively copying contents of &#39;{}&#39; into &#39;{}&#39;&quot;,
                source_dir.display(),
                target_dest_dir.display()
            );
        }

        if !target_dest_dir.exists() {
            fs::create_dir_all(target_dest_dir)
                .map_err(|e| vec![io_err_with_path(e, target_dest_dir).to_string()])?;
            if verbose {
                println!(&quot;Created directory &#39;{}&#39;&quot;, target_dest_dir.display());
            }
        }
      
        let entries: Vec&lt;DirEntry&gt; = WalkDir::new(source_dir)
            .min_depth(1) 
            .follow_links(false)
            .into_iter()
            .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
            .map_err(|e| {
                vec![AppError::WalkDir {
                    source: e,
                    path: source_dir.to_path_buf(),
                }
                .to_string()]
            })?;

        let multi_progress_manager_opt = if parallel &amp;&amp; entries.iter().filter(|e| e.path().is_file()).count() &gt; 1 {
            Some(MultiProgress::new())
        } else {
            None
        };

        let errors_arc = Arc::new(Mutex::new(Vec::&lt;String&gt;::new()));

        let process_entry_closure = |entry: DirEntry| {
            let entry_path = entry.path();
            let relative_path = match entry_path.strip_prefix(source_dir) {
                Ok(p) =&gt; p,
                Err(_) =&gt; {
                    errors_arc.lock().unwrap().push(
                        AppError::StripPrefixError {
                            path: entry_path.to_path_buf(),
                            base: source_dir.to_path_buf(),
                        }
                        .to_string(),
                    );
                    return;
                }
            };
            let dest_path = target_dest_dir.join(relative_path);

            if entry.file_type().is_dir() {
                if verbose {
                    println!(&quot;Creating directory &#39;{}&#39;&quot;, dest_path.display());
                }
                if let Err(e) = fs::create_dir_all(&amp;dest_path) {
                    errors_arc
                        .lock()
                        .unwrap()
                        .push(io_err_with_path(e, &amp;dest_path).to_string());
                    return;
                }
                progress_info
                    .items_processed
                    .fetch_add(1, AtomicOrdering::Relaxed);
            } else if entry.file_type().is_file() {
                match copy_single_file(
                    entry_path,
                    &amp;dest_path,
                    overwrite,
                    multi_progress_manager_opt.as_ref(),
                    Some(progress_info), 
                    verbose,
                ) {
                    Ok(_) =&gt; {}
                    Err(e) =&gt; {
                        errors_arc.lock().unwrap().push(format!(
                            &quot;Error copying file &#39;{}&#39;: {}&quot;,
                            entry_path.display(),
                            e
                        ));
                    }
                }
            } else {
                progress_info
                    .items_processed
                    .fetch_add(1, AtomicOrdering::Relaxed);
                if verbose {
                    println!(&quot;Skipping non-file/non-directory entry: {}&quot;, entry_path.display());
                }
            }
        };

        if parallel &amp;&amp; entries.len() &gt; 1 {
            entries.into_par_iter().for_each(process_entry_closure);
        } else {
            for entry in entries {
                process_entry_closure(entry);
            }
        }

        if let Some(mp) = multi_progress_manager_opt {
            if let Err(e) = mp.clear() {
                if verbose {
                    // Error during UI cleanup is not critical to the copy operation itself.
                    eprintln!(&quot;Warning: Failed to clear multi-progress display: {}&quot;, e);
                }
            }
        }

        let final_errors = Arc::try_unwrap(errors_arc)
            .expect(&quot;Mutex still has multiple owners for errors_arc&quot;)
            .into_inner()
            .expect(&quot;Mutex was poisoned for errors_arc&quot;);

        if !final_errors.is_empty() {
            return Err(final_errors);
        }
        Ok(())
    }

    pub fn handle_copy_operation_main(
        source: &amp;Path,
        destination: &amp;Path,
        overwrite: bool,
        parallel: bool,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if verbose {
            println!(
                &quot;Copy operation: &#39;{}&#39; -&gt; &#39;{}&#39;&quot;,
                source.display(),
                destination.display()
            );
        }
        if !source.exists() {
            return Err(AppError::SourceDoesNotExist(source.to_path_buf()));
        }

        let source_meta = fs::metadata(source).map_err(|e| io_err_with_path(e, source))?;
        let source_abs = source.absolutize().map_err(|e| io_err_with_path(e, source))?.into_owned();


        let target_path_for_item: PathBuf; 
        let effective_dest_dir_for_contents: PathBuf; 

        if source_meta.is_dir() {
            let source_name = source
                .file_name()
                .ok_or_else(|| AppError::NoFileName(source.to_path_buf()))?;
            if destination.exists()
                &amp;&amp; fs::metadata(destination)
                    .map_err(|e| io_err_with_path(e, destination))?
                    .is_dir()
            {
                target_path_for_item = destination.join(source_name);
            } else if destination.exists()
                &amp;&amp; fs::metadata(destination)
                    .map_err(|e| io_err_with_path(e, destination))?
                    .is_file()
            {
                return Err(AppError::DirToExistingFile {
                    source_dir: source.to_path_buf(),
                    dest_file: destination.to_path_buf(),
                });
            } else {
                target_path_for_item = destination.to_path_buf();
            }
            effective_dest_dir_for_contents = target_path_for_item.clone(); 
            
            let target_abs_check = target_path_for_item.absolutize().map_err(|e| io_err_with_path(e, &amp;target_path_for_item))?.into_owned();
            if target_abs_check.starts_with(&amp;source_abs) {
                 return Err(AppError::RecursiveMoveOrCopy(source.to_path_buf(), target_path_for_item));
            }

        } else { // Source is a file
            if destination.exists()
                &amp;&amp; fs::metadata(destination)
                    .map_err(|e| io_err_with_path(e, destination))?
                    .is_dir()
            {
                target_path_for_item = destination.join(
                    source
                        .file_name()
                        .ok_or_else(|| AppError::NoFileName(source.to_path_buf()))?,
                );
            } else if !destination.exists()
                &amp;&amp; destination.to_string_lossy().ends_with(std::path::MAIN_SEPARATOR)
            {
                fs::create_dir_all(destination).map_err(|e| io_err_with_path(e, destination))?;
                target_path_for_item = destination.join(
                    source
                        .file_name()
                        .ok_or_else(|| AppError::NoFileName(source.to_path_buf()))?,
                );
            } else {
                target_path_for_item = destination.to_path_buf();
            }
            effective_dest_dir_for_contents = target_path_for_item
                .parent()
                .unwrap_or_else(|| Path::new(&quot;.&quot;))
                .to_path_buf();
        }

        let (total_items_scanned, total_bytes_scanned) = if source_meta.is_dir() {
            pre_scan_directory(source, verbose)?
        } else {
            (1, source_meta.len()) 
        };
        let progress_info = Arc::new(ProgressInfo::new(
            total_items_scanned,
            total_bytes_scanned,
        ));

        let overall_pb = ProgressBar::new(total_items_scanned.max(1)); 
        overall_pb.set_style(
            ProgressStyle::default_bar()
                .template(&quot;{msg} [{elapsed_precise}] {wide_bar:.cyan/blue} Overall Items: {pos}/{len} ({items_per_sec}, ETA {eta})&quot;)?
                .progress_chars(&quot;=&gt; &quot;),
        );
        let source_filename_owned: OsString =
            source.file_name().unwrap_or_default().to_os_string();

        overall_pb.set_message(format!(
            &quot;Preparing to copy {}&quot;,
            source_filename_owned.to_string_lossy()
        ));
        overall_pb.enable_steady_tick(Duration::from_millis(200));

        let overall_pb_clone_for_updater = overall_pb.clone();
        let progress_info_clone_for_updater = progress_info.clone();
        let source_filename_clone_for_updater = source_filename_owned.clone();

        let bytes_updater_thread = thread::spawn(move || {
            while !overall_pb_clone_for_updater.is_finished() {
                let items_done = progress_info_clone_for_updater
                    .items_processed
                    .load(AtomicOrdering::Relaxed);
                let bytes_done = progress_info_clone_for_updater
                    .bytes_processed
                    .load(AtomicOrdering::Relaxed);

                overall_pb_clone_for_updater.set_position(items_done); 
                overall_pb_clone_for_updater.set_message(format!(
                    &quot;Copying {} (Bytes: {} / {}) | Items: {}/{}&quot;,
                    source_filename_clone_for_updater.to_string_lossy(),
                    HumanBytes(bytes_done),
                    HumanBytes(progress_info_clone_for_updater.total_bytes_to_process),
                    items_done,
                    progress_info_clone_for_updater.total_items_to_process
                ));
                thread::sleep(Duration::from_millis(200));
            }
            let items_done = progress_info_clone_for_updater
                .items_processed
                .load(AtomicOrdering::Relaxed);
            let bytes_done = progress_info_clone_for_updater
                .bytes_processed
                .load(AtomicOrdering::Relaxed);
            overall_pb_clone_for_updater.set_position(items_done);
            overall_pb_clone_for_updater.set_message(format!(
                &quot;Finished {} (Bytes: {} / {}) | Items: {}/{}&quot;,
                source_filename_clone_for_updater.to_string_lossy(),
                HumanBytes(bytes_done),
                HumanBytes(progress_info_clone_for_updater.total_bytes_to_process),
                items_done,
                progress_info_clone_for_updater.total_items_to_process
            ));
        });

        let result = if source_meta.is_dir() {
            if !target_path_for_item.exists() {
                 fs::create_dir_all(&amp;target_path_for_item).map_err(|e| io_err_with_path(e, &amp;target_path_for_item))?;
                 if verbose { println!(&quot;Created target base directory &#39;{}&#39;&quot;, target_path_for_item.display()); }
            }
            progress_info.items_processed.fetch_add(1, AtomicOrdering::Relaxed);

            copy_dir_recursive(
                source, 
                &amp;effective_dest_dir_for_contents, 
                overwrite,
                parallel,
                &amp;overall_pb,
                &amp;progress_info,
                verbose,
            )
            .map_err(AppError::ParallelOperationFailed)?;
            Ok(progress_info.items_processed.load(AtomicOrdering::Relaxed))
        } else if source_meta.is_file() {
            copy_single_file(
                source,
                &amp;target_path_for_item,
                overwrite,
                None, 
                Some(&amp;progress_info),
                verbose,
            )?;
            Ok(1) 
        } else {
            if verbose {
                println!(
                    &quot;Warning: Source &#39;{}&#39; is not a regular file or directory. Skipping.&quot;,
                    source.display()
                );
            }
            Ok(0)
        };

        overall_pb.set_position(progress_info.items_processed.load(AtomicOrdering::Relaxed)); 
        overall_pb.finish_with_message(format!(&quot;Copy of &#39;{}&#39; complete.&quot;, source.display()));
        bytes_updater_thread
            .join()
            .expect(&quot;Bytes updater thread panicked&quot;);
        result
    }

    pub fn handle_delete_operation(
        path: &amp;Path,
        force: bool,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if verbose {
            println!(
                &quot;Delete operation: &#39;{}&#39; (Force: {})&quot;,
                path.display(),
                force
            );
        }

        if !path.exists() {
            if force {
                if verbose {
                    println!(
                        &quot;Path &#39;{}&#39; does not exist. Nothing to delete (forced).&quot;,
                        path.display()
                    );
                }
                return Ok(0);
            }
            return Err(AppError::SourceDoesNotExist(path.to_path_buf()));
        }

        if !force {
            print!(
                &quot;Are you sure you want to delete &#39;{}&#39; and all its contents? (yes/no): &quot;,
                path.display()
            );
            io::stdout().flush().map_err(|e| io_err_with_path(e, path))?;
            let mut confirmation = String::new();
            io::stdin()
                .read_line(&amp;mut confirmation)
                .map_err(|e| io_err_with_path(e, path))?;
            if confirmation.trim().to_lowercase() != &quot;yes&quot; {
                return Err(AppError::DeletionNotConfirmed(path.to_path_buf()));
            }
        }

        let items_deleted_count: u64;

        if path.is_dir() {
            let (total_items, _) = pre_scan_directory(path, verbose)?; 

            let pb = ProgressBar::new(total_items.max(1));
            pb.set_style(
                ProgressStyle::default_bar()
                    .template(
                        &quot;{msg:.red.bold} [{bar:40.red/yellow}] Items: {pos}/{len} ({elapsed_precise})&quot;,
                    )?
                    .progress_chars(&quot;=&gt; &quot;),
            );
            pb.set_message(format!(
                &quot;Deleting dir {}&quot;,
                path.file_name().unwrap_or_default().to_string_lossy()
            ));
            pb.enable_steady_tick(Duration::from_millis(200));
            
            fs::remove_dir_all(path).map_err(|e| io_err_with_path(e, path))?;
            items_deleted_count = total_items; 
            pb.set_position(items_deleted_count);
            pb.finish_with_message(format!(&quot;Deleted directory &#39;{}&#39;&quot;, path.display()));
        } else {
            if verbose {
                println!(&quot;Deleting file &#39;{}&#39;...&quot;, path.display());
            }
            fs::remove_file(path).map_err(|e| io_err_with_path(e, path))?;
            items_deleted_count = 1;
        }

        if verbose {
            println!(
                &quot;Deletion of &#39;{}&#39; complete. {} items affected.&quot;,
                path.display(),
                items_deleted_count
            );
        }
        Ok(items_deleted_count)
    }

    pub fn handle_move_operation(
        source: PathBuf,
        destination: PathBuf,
        overwrite: bool,
        force_delete_source: bool, 
        parallel: bool,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if verbose {
            println!(
                &quot;Move operation: &#39;{}&#39; -&gt; &#39;{}&#39;&quot;,
                source.display(),
                destination.display()
            );
        }
        if !source.exists() {
            return Err(AppError::SourceDoesNotExist(source.clone()));
        }

        let source_meta = fs::metadata(&amp;source).map_err(|io_e| io_err_with_path(io_e, &amp;source))?;
        let source_abs = source.absolutize().map_err(|e| io_err_with_path(e, &amp;source))?.into_owned();

        let final_dest_target = if destination.exists()
            &amp;&amp; fs::metadata(&amp;destination)
                .map_err(|e| io_err_with_path(e, &amp;destination))?
                .is_dir()
        {
            destination.join(
                source
                    .file_name()
                    .ok_or_else(|| AppError::NoFileName(source.clone()))?,
            )
        } else {
            destination.clone()
        };

        if source_meta.is_dir() {
            let target_abs_check = final_dest_target.absolutize().map_err(|e| io_err_with_path(e, &amp;final_dest_target))?.into_owned();
            if target_abs_check.starts_with(&amp;source_abs) {
                 return Err(AppError::RecursiveMoveOrCopy(source, final_dest_target));
            }
        }

        if final_dest_target.exists() &amp;&amp; !overwrite {
            if source_meta.is_file() {
                 let dest_meta = fs::metadata(&amp;final_dest_target).map_err(|e| io_err_with_path(e, &amp;final_dest_target))?;
                 if dest_meta.is_file() {
                    return Err(AppError::DestinationExists(final_dest_target));
                 }
            } else if source_meta.is_dir() {
                let dest_meta = fs::metadata(&amp;final_dest_target).map_err(|e| io_err_with_path(e, &amp;final_dest_target))?;
                if dest_meta.is_file() {
                    return Err(AppError::DirToExistingFile { source_dir: source.clone(), dest_file: final_dest_target });
                }
                 return Err(AppError::DestinationExists(final_dest_target));
            }
        }

        match fs::rename(&amp;source, &amp;final_dest_target) {
            Ok(_) =&gt; {
                if verbose {
                    println!(
                        &quot;Successfully moved (renamed) &#39;{}&#39; to &#39;{}&#39;&quot;,
                        source.display(),
                        final_dest_target.display()
                    );
                }
                Ok(1) 
            }
            Err(e) =&gt; {
                let should_fallback_to_copy_delete = e.kind() == ErrorKind::CrossesDevices
                    || e.raw_os_error() == Some(libc::EXDEV)
                    || (source_meta.is_file()
                        &amp;&amp; destination.exists() 
                        &amp;&amp; fs::metadata(&amp;destination)
                            .map_err(|io_e| io_err_with_path(io_e, &amp;destination))?
                            .is_dir());

                if should_fallback_to_copy_delete {
                    if verbose {
                        println!(
                            &quot;Rename failed (reason: {}, OS error: {:?}), attempting copy then delete...&quot;,
                            e.kind(),
                            e.raw_os_error()
                        );
                    }
                    
                    let items_copied = handle_copy_operation_main(
                        &amp;source,
                        &amp;destination, 
                        overwrite,
                        parallel,
                        verbose,
                    )?;
                    if verbose {
                        println!(
                            &quot;Copy phase of move complete. Now deleting source &#39;{}&#39;.&quot;,
                            source.display()
                        );
                    }

                    match handle_delete_operation(&amp;source, force_delete_source, verbose) { 
                        Ok(_) =&gt; {
                            if verbose {
                                println!(
                                    &quot;Source &#39;{}&#39; deleted successfully after copy.&quot;,
                                    source.display()
                                );
                            }
                            Ok(items_copied)
                        }
                        Err(del_err) =&gt; {
                            eprintln!(&quot;CRITICAL: Error deleting source &#39;{}&#39; after copy: {}. Copied files remain at &#39;{}&#39;. Manual cleanup of source may be required.&quot;, source.display(), del_err, destination.display());
                            Err(AppError::Io {
                                source: io::Error::new(
                                    ErrorKind::Other,
                                    &quot;Failed to delete source after successful copy during move operation&quot;,
                                ),
                                path: source,
                            })
                        }
                    }
                } else {
                    Err(io_err_with_path(e, &amp;source))
                }
            }
        }
    }
}

// --- Main Application Logic ---
fn main() -&gt; Result&lt;(), ()&gt; {
    let cli = Cli::parse();

    let result: Result&lt;u64, AppError&gt; = match cli.command {
        Commands::Copy {
            source,
            destination,
            overwrite,
            parallel,
        } =&gt; core_logic::handle_copy_operation_main(
            &amp;source,
            &amp;destination,
            overwrite,
            parallel,
            cli.verbose,
        ),
        Commands::Move {
            source,
            destination,
            overwrite,
            force_delete_source,
            parallel,
        } =&gt; core_logic::handle_move_operation(
            source,
            destination,
            overwrite,
            force_delete_source,
            parallel,
            cli.verbose,
        ),
        Commands::Delete { path, force } =&gt; {
            core_logic::handle_delete_operation(&amp;path, force, cli.verbose)
        }
    };

    match result {
        Ok(items_affected) =&gt; {
            if items_affected &gt; 0 || cli.verbose {
                println!(
                    &quot;Operation completed successfully. {} items affected.&quot;,
                    items_affected
                );
            } else if !cli.verbose {
                println!(
                    &quot;Operation completed (no items affected or action skipped). Use --verbose for details.&quot;
                );
            }
            Ok(())
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            if let AppError::ParallelOperationFailed(errors) = e {
                for (i, err_msg) in errors.iter().enumerate() {
                    eprintln!(&quot;  Parallel error {}: {}&quot;, i + 1, err_msg);
                }
            }
            Err(())
        }
    }
}" data-download-link="" data-download-label="Download Rust">
  <code class="language-rust">// src/main.rs

use clap::{Parser, Subcommand};
use indicatif::{HumanBytes, MultiProgress, ProgressBar, ProgressStyle};
use path_absolutize::*; // For Path::absolutize()
use rayon::prelude::*;
use std::{
    ffi::OsString,
    fs,
    io::{self, ErrorKind, Read, Write},
    path::{Path, PathBuf},
    sync::{
        atomic::{AtomicU64, Ordering as AtomicOrdering},
        Arc, Mutex,
    },
    thread,
    time::Duration,
};
use thiserror::Error;
use walkdir::{DirEntry, WalkDir};

// --- Argument Parsing ---
#[derive(Parser, Debug)]
#[clap(author, version, about = &quot;RapidCopy-rs (MVP): Fast file operations CLI&quot;, long_about = None)]
struct Cli {
    #[clap(subcommand)]
    command: Commands,

    #[clap(short, long, global = true, help = &quot;Enable verbose output&quot;)]
    verbose: bool,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Copies a file or directory recursively
    Copy {
        /// Source path
        source: PathBuf,
        /// Destination path
        destination: PathBuf,
        #[clap(short, long, help = &quot;Overwrite existing files at the destination&quot;)]
        overwrite: bool,
        #[clap(long, help = &quot;Enable parallel processing for directory contents&quot;)]
        parallel: bool,
    },
    /// Moves a file or directory recursively (cut and paste)
    Move {
        /// Source path
        source: PathBuf,
        /// Destination path
        destination: PathBuf,
        #[clap(short, long, help = &quot;Overwrite existing files at the destination if copying&quot;)]
        overwrite: bool,
        #[clap(short = &#39;f&#39;, long, help = &quot;Force deletion of source without interactive confirmation (used in move)&quot;)]
        force_delete_source: bool,
        #[clap(long, help = &quot;Enable parallel processing for directory contents during copy phase&quot;)]
        parallel: bool,
    },
    /// Deletes a file or directory recursively
    Delete {
        /// Path to delete
        path: PathBuf,
        #[clap(short, long, help = &quot;Force deletion without interactive confirmation&quot;)]
        force: bool,
    },
}

// --- Error Handling ---
#[derive(Error, Debug)]
pub enum AppError {
    #[error(&quot;I/O error accessing &#39;{path:?}&#39;: {source}&quot;)]
    Io {
        source: io::Error,
        path: PathBuf,
    },
    #[error(&quot;WalkDir error for path &#39;{path:?}&#39;: {source}&quot;)]
    WalkDir {
        source: walkdir::Error,
        path: PathBuf,
    },
    #[error(&quot;Source path does not exist: {0}&quot;)]
    SourceDoesNotExist(PathBuf),
    #[error(&quot;Destination path &#39;{0}&#39; already exists and overwrite is false&quot;)]
    DestinationExists(PathBuf),
    #[error(&quot;Cannot copy/move directory &#39;{source_dir}&#39; to existing file &#39;{dest_file}&#39;&quot;)]
    DirToExistingFile {
        source_dir: PathBuf,
        dest_file: PathBuf,
    },
    #[error(&quot;Cannot copy/move file &#39;{source_file}&#39; to existing directory &#39;{dest_dir}&#39; (ambiguous destination name or destination is a file and overwrite is false)&quot;)]
    FileToExistingDirAmbiguous {
        source_file: PathBuf,
        dest_dir: PathBuf,
    },
    #[error(&quot;User did not confirm deletion of &#39;{0}&#39;&quot;)]
    DeletionNotConfirmed(PathBuf),
    #[error(&quot;Failed to get metadata for path: {0}&quot;)]
    MetadataError(PathBuf),
    #[error(&quot;Source path &#39;{0}&#39; has no filename component&quot;)]
    NoFileName(PathBuf),
    #[error(&quot;Failed to strip prefix for path processing: &#39;{path}&#39; relative to &#39;{base}&#39;&quot;)]
    StripPrefixError { path: PathBuf, base: PathBuf },
    #[error(&quot;Operation failed with multiple errors during parallel processing:\n{0:#?}&quot;)]
    ParallelOperationFailed(Vec&lt;String&gt;),
    #[error(&quot;Cannot move/copy &#39;{0}&#39; to a subdirectory of itself &#39;{1}&#39;&quot;)]
    RecursiveMoveOrCopy(PathBuf, PathBuf),
    #[error(&quot;Indicatif style template error: {0}&quot;)]
    TemplateError(String),
}

impl From&lt;walkdir::Error&gt; for AppError {
    fn from(err: walkdir::Error) -&gt; Self {
        let path = err
            .path()
            .unwrap_or_else(|| Path::new(&quot;&lt;unknown path from walkdir error&gt;&quot;))
            .to_path_buf();
        AppError::WalkDir { source: err, path }
    }
}

fn io_err_with_path(err: io::Error, path: &amp;Path) -&gt; AppError {
    AppError::Io {
        source: err,
        path: path.to_path_buf(),
    }
}

impl From&lt;indicatif::style::TemplateError&gt; for AppError {
    fn from(err: indicatif::style::TemplateError) -&gt; Self {
        AppError::TemplateError(err.to_string())
    }
}

// --- Core Logic Module ---
mod core_logic {
    use super::*;

    const BUFFER_SIZE: usize = 128 * 1024;

    #[derive(Debug)]
    struct ProgressInfo {
        items_processed: AtomicU64,
        bytes_processed: AtomicU64,
        total_items_to_process: u64,
        total_bytes_to_process: u64,
    }

    impl ProgressInfo {
        fn new(total_items: u64, total_bytes: u64) -&gt; Self {
            Self {
                items_processed: AtomicU64::new(0),
                bytes_processed: AtomicU64::new(0),
                total_items_to_process: total_items,
                total_bytes_to_process: total_bytes,
            }
        }
    }

    fn pre_scan_directory(dir: &amp;Path, verbose: bool) -&gt; Result&lt;(u64, u64), AppError&gt; {
        if verbose {
            println!(&quot;Pre-scanning directory &#39;{}&#39;...&quot;, dir.display());
        }
        let mut total_items = 0u64;
        let mut total_bytes = 0u64;
        total_items += 1; // Count the root directory itself
        for entry_result in WalkDir::new(dir).min_depth(1).follow_links(false) {
            let entry = entry_result?; 
            total_items += 1;
            if entry.file_type().is_file() {
                total_bytes += entry.metadata()?.len(); 
            }
        }
        if verbose {
            println!(
                &quot;Pre-scan complete: {} items, {}&quot;,
                total_items,
                HumanBytes(total_bytes)
            );
        }
        Ok((total_items, total_bytes))
    }

    fn copy_single_file(
        source: &amp;Path,
        destination: &amp;Path,
        overwrite: bool,
        mp_opt: Option&lt;&amp;MultiProgress&gt;,
        overall_progress_info_opt: Option&lt;&amp;Arc&lt;ProgressInfo&gt;&gt;,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if destination.exists() {
            let dest_meta =
                fs::metadata(destination).map_err(|e| io_err_with_path(e, destination))?;
            if dest_meta.is_dir() {
                return Err(AppError::FileToExistingDirAmbiguous {
                    source_file: source.to_path_buf(),
                    dest_dir: destination.to_path_buf(),
                });
            }
            if !overwrite {
                if verbose {
                    println!(
                        &quot;Skipping &#39;{}&#39;: destination file exists and overwrite is false.&quot;,
                        destination.display()
                    );
                }
                if let Some(stats) = overall_progress_info_opt {
                    stats.items_processed.fetch_add(1, AtomicOrdering::Relaxed);
                }
                return Ok(0);
            }
        }

        if let Some(parent) = destination.parent() {
            if !parent.exists() {
                fs::create_dir_all(parent).map_err(|e| io_err_with_path(e, parent))?;
            }
        }

        let file_size = fs::metadata(source)
            .map_err(|e| io_err_with_path(e, source))?
            .len();

        let pb = if let Some(mp) = mp_opt {
            let p = mp.add(ProgressBar::new(file_size));
            p.enable_steady_tick(Duration::from_millis(250));
            p
        } else {
            let p = ProgressBar::new(file_size);
            p.enable_steady_tick(Duration::from_millis(100));
            p
        };

        pb.set_style(
            ProgressStyle::default_bar()
                .template(
                    &quot;{msg:&lt;30.bold.dim} [{bar:40.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec}, {eta})&quot;,
                )?
                .progress_chars(&quot;=&gt; &quot;),
        );
        let filename = source.file_name().unwrap_or_default().to_string_lossy();
        pb.set_message(filename.chars().take(30).collect::&lt;String&gt;());

        let mut source_file = fs::File::open(source).map_err(|e| io_err_with_path(e, source))?;
        let mut dest_file =
            fs::File::create(destination).map_err(|e| io_err_with_path(e, destination))?;

        let mut buffer = vec![0; BUFFER_SIZE];
        let mut copied_bytes_for_this_file = 0u64;

        loop {
            let bytes_read = source_file
                .read(&amp;mut buffer)
                .map_err(|e| io_err_with_path(e, source))?;
            if bytes_read == 0 {
                break;
            }
            dest_file
                .write_all(&amp;buffer[..bytes_read])
                .map_err(|e| io_err_with_path(e, destination))?;
            copied_bytes_for_this_file += bytes_read as u64;
            pb.set_position(copied_bytes_for_this_file);
            if let Some(stats) = overall_progress_info_opt {
                stats
                    .bytes_processed
                    .fetch_add(bytes_read as u64, AtomicOrdering::Relaxed);
            }
        }
        pb.finish_with_message(format!(&quot;Copied {} ({})&quot;, filename, HumanBytes(file_size)));
        if let Some(stats) = overall_progress_info_opt {
            stats.items_processed.fetch_add(1, AtomicOrdering::Relaxed);
        }
        Ok(file_size)
    }

    fn copy_dir_recursive(
        source_dir: &amp;Path,
        target_dest_dir: &amp;Path, 
        overwrite: bool,
        parallel: bool,
        _overall_item_pb: &amp;ProgressBar, 
        progress_info: &amp;Arc&lt;ProgressInfo&gt;,
        verbose: bool, // verbose is available here
    ) -&gt; Result&lt;(), Vec&lt;String&gt;&gt; {
        if verbose {
            println!(
                &quot;Recursively copying contents of &#39;{}&#39; into &#39;{}&#39;&quot;,
                source_dir.display(),
                target_dest_dir.display()
            );
        }

        if !target_dest_dir.exists() {
            fs::create_dir_all(target_dest_dir)
                .map_err(|e| vec![io_err_with_path(e, target_dest_dir).to_string()])?;
            if verbose {
                println!(&quot;Created directory &#39;{}&#39;&quot;, target_dest_dir.display());
            }
        }
      
        let entries: Vec&lt;DirEntry&gt; = WalkDir::new(source_dir)
            .min_depth(1) 
            .follow_links(false)
            .into_iter()
            .collect::&lt;Result&lt;Vec&lt;_&gt;, _&gt;&gt;()
            .map_err(|e| {
                vec![AppError::WalkDir {
                    source: e,
                    path: source_dir.to_path_buf(),
                }
                .to_string()]
            })?;

        let multi_progress_manager_opt = if parallel &amp;&amp; entries.iter().filter(|e| e.path().is_file()).count() &gt; 1 {
            Some(MultiProgress::new())
        } else {
            None
        };

        let errors_arc = Arc::new(Mutex::new(Vec::&lt;String&gt;::new()));

        let process_entry_closure = |entry: DirEntry| {
            let entry_path = entry.path();
            let relative_path = match entry_path.strip_prefix(source_dir) {
                Ok(p) =&gt; p,
                Err(_) =&gt; {
                    errors_arc.lock().unwrap().push(
                        AppError::StripPrefixError {
                            path: entry_path.to_path_buf(),
                            base: source_dir.to_path_buf(),
                        }
                        .to_string(),
                    );
                    return;
                }
            };
            let dest_path = target_dest_dir.join(relative_path);

            if entry.file_type().is_dir() {
                if verbose {
                    println!(&quot;Creating directory &#39;{}&#39;&quot;, dest_path.display());
                }
                if let Err(e) = fs::create_dir_all(&amp;dest_path) {
                    errors_arc
                        .lock()
                        .unwrap()
                        .push(io_err_with_path(e, &amp;dest_path).to_string());
                    return;
                }
                progress_info
                    .items_processed
                    .fetch_add(1, AtomicOrdering::Relaxed);
            } else if entry.file_type().is_file() {
                match copy_single_file(
                    entry_path,
                    &amp;dest_path,
                    overwrite,
                    multi_progress_manager_opt.as_ref(),
                    Some(progress_info), 
                    verbose,
                ) {
                    Ok(_) =&gt; {}
                    Err(e) =&gt; {
                        errors_arc.lock().unwrap().push(format!(
                            &quot;Error copying file &#39;{}&#39;: {}&quot;,
                            entry_path.display(),
                            e
                        ));
                    }
                }
            } else {
                progress_info
                    .items_processed
                    .fetch_add(1, AtomicOrdering::Relaxed);
                if verbose {
                    println!(&quot;Skipping non-file/non-directory entry: {}&quot;, entry_path.display());
                }
            }
        };

        if parallel &amp;&amp; entries.len() &gt; 1 {
            entries.into_par_iter().for_each(process_entry_closure);
        } else {
            for entry in entries {
                process_entry_closure(entry);
            }
        }

        if let Some(mp) = multi_progress_manager_opt {
            if let Err(e) = mp.clear() {
                if verbose {
                    // Error during UI cleanup is not critical to the copy operation itself.
                    eprintln!(&quot;Warning: Failed to clear multi-progress display: {}&quot;, e);
                }
            }
        }

        let final_errors = Arc::try_unwrap(errors_arc)
            .expect(&quot;Mutex still has multiple owners for errors_arc&quot;)
            .into_inner()
            .expect(&quot;Mutex was poisoned for errors_arc&quot;);

        if !final_errors.is_empty() {
            return Err(final_errors);
        }
        Ok(())
    }

    pub fn handle_copy_operation_main(
        source: &amp;Path,
        destination: &amp;Path,
        overwrite: bool,
        parallel: bool,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if verbose {
            println!(
                &quot;Copy operation: &#39;{}&#39; -&gt; &#39;{}&#39;&quot;,
                source.display(),
                destination.display()
            );
        }
        if !source.exists() {
            return Err(AppError::SourceDoesNotExist(source.to_path_buf()));
        }

        let source_meta = fs::metadata(source).map_err(|e| io_err_with_path(e, source))?;
        let source_abs = source.absolutize().map_err(|e| io_err_with_path(e, source))?.into_owned();


        let target_path_for_item: PathBuf; 
        let effective_dest_dir_for_contents: PathBuf; 

        if source_meta.is_dir() {
            let source_name = source
                .file_name()
                .ok_or_else(|| AppError::NoFileName(source.to_path_buf()))?;
            if destination.exists()
                &amp;&amp; fs::metadata(destination)
                    .map_err(|e| io_err_with_path(e, destination))?
                    .is_dir()
            {
                target_path_for_item = destination.join(source_name);
            } else if destination.exists()
                &amp;&amp; fs::metadata(destination)
                    .map_err(|e| io_err_with_path(e, destination))?
                    .is_file()
            {
                return Err(AppError::DirToExistingFile {
                    source_dir: source.to_path_buf(),
                    dest_file: destination.to_path_buf(),
                });
            } else {
                target_path_for_item = destination.to_path_buf();
            }
            effective_dest_dir_for_contents = target_path_for_item.clone(); 
            
            let target_abs_check = target_path_for_item.absolutize().map_err(|e| io_err_with_path(e, &amp;target_path_for_item))?.into_owned();
            if target_abs_check.starts_with(&amp;source_abs) {
                 return Err(AppError::RecursiveMoveOrCopy(source.to_path_buf(), target_path_for_item));
            }

        } else { // Source is a file
            if destination.exists()
                &amp;&amp; fs::metadata(destination)
                    .map_err(|e| io_err_with_path(e, destination))?
                    .is_dir()
            {
                target_path_for_item = destination.join(
                    source
                        .file_name()
                        .ok_or_else(|| AppError::NoFileName(source.to_path_buf()))?,
                );
            } else if !destination.exists()
                &amp;&amp; destination.to_string_lossy().ends_with(std::path::MAIN_SEPARATOR)
            {
                fs::create_dir_all(destination).map_err(|e| io_err_with_path(e, destination))?;
                target_path_for_item = destination.join(
                    source
                        .file_name()
                        .ok_or_else(|| AppError::NoFileName(source.to_path_buf()))?,
                );
            } else {
                target_path_for_item = destination.to_path_buf();
            }
            effective_dest_dir_for_contents = target_path_for_item
                .parent()
                .unwrap_or_else(|| Path::new(&quot;.&quot;))
                .to_path_buf();
        }

        let (total_items_scanned, total_bytes_scanned) = if source_meta.is_dir() {
            pre_scan_directory(source, verbose)?
        } else {
            (1, source_meta.len()) 
        };
        let progress_info = Arc::new(ProgressInfo::new(
            total_items_scanned,
            total_bytes_scanned,
        ));

        let overall_pb = ProgressBar::new(total_items_scanned.max(1)); 
        overall_pb.set_style(
            ProgressStyle::default_bar()
                .template(&quot;{msg} [{elapsed_precise}] {wide_bar:.cyan/blue} Overall Items: {pos}/{len} ({items_per_sec}, ETA {eta})&quot;)?
                .progress_chars(&quot;=&gt; &quot;),
        );
        let source_filename_owned: OsString =
            source.file_name().unwrap_or_default().to_os_string();

        overall_pb.set_message(format!(
            &quot;Preparing to copy {}&quot;,
            source_filename_owned.to_string_lossy()
        ));
        overall_pb.enable_steady_tick(Duration::from_millis(200));

        let overall_pb_clone_for_updater = overall_pb.clone();
        let progress_info_clone_for_updater = progress_info.clone();
        let source_filename_clone_for_updater = source_filename_owned.clone();

        let bytes_updater_thread = thread::spawn(move || {
            while !overall_pb_clone_for_updater.is_finished() {
                let items_done = progress_info_clone_for_updater
                    .items_processed
                    .load(AtomicOrdering::Relaxed);
                let bytes_done = progress_info_clone_for_updater
                    .bytes_processed
                    .load(AtomicOrdering::Relaxed);

                overall_pb_clone_for_updater.set_position(items_done); 
                overall_pb_clone_for_updater.set_message(format!(
                    &quot;Copying {} (Bytes: {} / {}) | Items: {}/{}&quot;,
                    source_filename_clone_for_updater.to_string_lossy(),
                    HumanBytes(bytes_done),
                    HumanBytes(progress_info_clone_for_updater.total_bytes_to_process),
                    items_done,
                    progress_info_clone_for_updater.total_items_to_process
                ));
                thread::sleep(Duration::from_millis(200));
            }
            let items_done = progress_info_clone_for_updater
                .items_processed
                .load(AtomicOrdering::Relaxed);
            let bytes_done = progress_info_clone_for_updater
                .bytes_processed
                .load(AtomicOrdering::Relaxed);
            overall_pb_clone_for_updater.set_position(items_done);
            overall_pb_clone_for_updater.set_message(format!(
                &quot;Finished {} (Bytes: {} / {}) | Items: {}/{}&quot;,
                source_filename_clone_for_updater.to_string_lossy(),
                HumanBytes(bytes_done),
                HumanBytes(progress_info_clone_for_updater.total_bytes_to_process),
                items_done,
                progress_info_clone_for_updater.total_items_to_process
            ));
        });

        let result = if source_meta.is_dir() {
            if !target_path_for_item.exists() {
                 fs::create_dir_all(&amp;target_path_for_item).map_err(|e| io_err_with_path(e, &amp;target_path_for_item))?;
                 if verbose { println!(&quot;Created target base directory &#39;{}&#39;&quot;, target_path_for_item.display()); }
            }
            progress_info.items_processed.fetch_add(1, AtomicOrdering::Relaxed);

            copy_dir_recursive(
                source, 
                &amp;effective_dest_dir_for_contents, 
                overwrite,
                parallel,
                &amp;overall_pb,
                &amp;progress_info,
                verbose,
            )
            .map_err(AppError::ParallelOperationFailed)?;
            Ok(progress_info.items_processed.load(AtomicOrdering::Relaxed))
        } else if source_meta.is_file() {
            copy_single_file(
                source,
                &amp;target_path_for_item,
                overwrite,
                None, 
                Some(&amp;progress_info),
                verbose,
            )?;
            Ok(1) 
        } else {
            if verbose {
                println!(
                    &quot;Warning: Source &#39;{}&#39; is not a regular file or directory. Skipping.&quot;,
                    source.display()
                );
            }
            Ok(0)
        };

        overall_pb.set_position(progress_info.items_processed.load(AtomicOrdering::Relaxed)); 
        overall_pb.finish_with_message(format!(&quot;Copy of &#39;{}&#39; complete.&quot;, source.display()));
        bytes_updater_thread
            .join()
            .expect(&quot;Bytes updater thread panicked&quot;);
        result
    }

    pub fn handle_delete_operation(
        path: &amp;Path,
        force: bool,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if verbose {
            println!(
                &quot;Delete operation: &#39;{}&#39; (Force: {})&quot;,
                path.display(),
                force
            );
        }

        if !path.exists() {
            if force {
                if verbose {
                    println!(
                        &quot;Path &#39;{}&#39; does not exist. Nothing to delete (forced).&quot;,
                        path.display()
                    );
                }
                return Ok(0);
            }
            return Err(AppError::SourceDoesNotExist(path.to_path_buf()));
        }

        if !force {
            print!(
                &quot;Are you sure you want to delete &#39;{}&#39; and all its contents? (yes/no): &quot;,
                path.display()
            );
            io::stdout().flush().map_err(|e| io_err_with_path(e, path))?;
            let mut confirmation = String::new();
            io::stdin()
                .read_line(&amp;mut confirmation)
                .map_err(|e| io_err_with_path(e, path))?;
            if confirmation.trim().to_lowercase() != &quot;yes&quot; {
                return Err(AppError::DeletionNotConfirmed(path.to_path_buf()));
            }
        }

        let items_deleted_count: u64;

        if path.is_dir() {
            let (total_items, _) = pre_scan_directory(path, verbose)?; 

            let pb = ProgressBar::new(total_items.max(1));
            pb.set_style(
                ProgressStyle::default_bar()
                    .template(
                        &quot;{msg:.red.bold} [{bar:40.red/yellow}] Items: {pos}/{len} ({elapsed_precise})&quot;,
                    )?
                    .progress_chars(&quot;=&gt; &quot;),
            );
            pb.set_message(format!(
                &quot;Deleting dir {}&quot;,
                path.file_name().unwrap_or_default().to_string_lossy()
            ));
            pb.enable_steady_tick(Duration::from_millis(200));
            
            fs::remove_dir_all(path).map_err(|e| io_err_with_path(e, path))?;
            items_deleted_count = total_items; 
            pb.set_position(items_deleted_count);
            pb.finish_with_message(format!(&quot;Deleted directory &#39;{}&#39;&quot;, path.display()));
        } else {
            if verbose {
                println!(&quot;Deleting file &#39;{}&#39;...&quot;, path.display());
            }
            fs::remove_file(path).map_err(|e| io_err_with_path(e, path))?;
            items_deleted_count = 1;
        }

        if verbose {
            println!(
                &quot;Deletion of &#39;{}&#39; complete. {} items affected.&quot;,
                path.display(),
                items_deleted_count
            );
        }
        Ok(items_deleted_count)
    }

    pub fn handle_move_operation(
        source: PathBuf,
        destination: PathBuf,
        overwrite: bool,
        force_delete_source: bool, 
        parallel: bool,
        verbose: bool,
    ) -&gt; Result&lt;u64, AppError&gt; {
        if verbose {
            println!(
                &quot;Move operation: &#39;{}&#39; -&gt; &#39;{}&#39;&quot;,
                source.display(),
                destination.display()
            );
        }
        if !source.exists() {
            return Err(AppError::SourceDoesNotExist(source.clone()));
        }

        let source_meta = fs::metadata(&amp;source).map_err(|io_e| io_err_with_path(io_e, &amp;source))?;
        let source_abs = source.absolutize().map_err(|e| io_err_with_path(e, &amp;source))?.into_owned();

        let final_dest_target = if destination.exists()
            &amp;&amp; fs::metadata(&amp;destination)
                .map_err(|e| io_err_with_path(e, &amp;destination))?
                .is_dir()
        {
            destination.join(
                source
                    .file_name()
                    .ok_or_else(|| AppError::NoFileName(source.clone()))?,
            )
        } else {
            destination.clone()
        };

        if source_meta.is_dir() {
            let target_abs_check = final_dest_target.absolutize().map_err(|e| io_err_with_path(e, &amp;final_dest_target))?.into_owned();
            if target_abs_check.starts_with(&amp;source_abs) {
                 return Err(AppError::RecursiveMoveOrCopy(source, final_dest_target));
            }
        }

        if final_dest_target.exists() &amp;&amp; !overwrite {
            if source_meta.is_file() {
                 let dest_meta = fs::metadata(&amp;final_dest_target).map_err(|e| io_err_with_path(e, &amp;final_dest_target))?;
                 if dest_meta.is_file() {
                    return Err(AppError::DestinationExists(final_dest_target));
                 }
            } else if source_meta.is_dir() {
                let dest_meta = fs::metadata(&amp;final_dest_target).map_err(|e| io_err_with_path(e, &amp;final_dest_target))?;
                if dest_meta.is_file() {
                    return Err(AppError::DirToExistingFile { source_dir: source.clone(), dest_file: final_dest_target });
                }
                 return Err(AppError::DestinationExists(final_dest_target));
            }
        }

        match fs::rename(&amp;source, &amp;final_dest_target) {
            Ok(_) =&gt; {
                if verbose {
                    println!(
                        &quot;Successfully moved (renamed) &#39;{}&#39; to &#39;{}&#39;&quot;,
                        source.display(),
                        final_dest_target.display()
                    );
                }
                Ok(1) 
            }
            Err(e) =&gt; {
                let should_fallback_to_copy_delete = e.kind() == ErrorKind::CrossesDevices
                    || e.raw_os_error() == Some(libc::EXDEV)
                    || (source_meta.is_file()
                        &amp;&amp; destination.exists() 
                        &amp;&amp; fs::metadata(&amp;destination)
                            .map_err(|io_e| io_err_with_path(io_e, &amp;destination))?
                            .is_dir());

                if should_fallback_to_copy_delete {
                    if verbose {
                        println!(
                            &quot;Rename failed (reason: {}, OS error: {:?}), attempting copy then delete...&quot;,
                            e.kind(),
                            e.raw_os_error()
                        );
                    }
                    
                    let items_copied = handle_copy_operation_main(
                        &amp;source,
                        &amp;destination, 
                        overwrite,
                        parallel,
                        verbose,
                    )?;
                    if verbose {
                        println!(
                            &quot;Copy phase of move complete. Now deleting source &#39;{}&#39;.&quot;,
                            source.display()
                        );
                    }

                    match handle_delete_operation(&amp;source, force_delete_source, verbose) { 
                        Ok(_) =&gt; {
                            if verbose {
                                println!(
                                    &quot;Source &#39;{}&#39; deleted successfully after copy.&quot;,
                                    source.display()
                                );
                            }
                            Ok(items_copied)
                        }
                        Err(del_err) =&gt; {
                            eprintln!(&quot;CRITICAL: Error deleting source &#39;{}&#39; after copy: {}. Copied files remain at &#39;{}&#39;. Manual cleanup of source may be required.&quot;, source.display(), del_err, destination.display());
                            Err(AppError::Io {
                                source: io::Error::new(
                                    ErrorKind::Other,
                                    &quot;Failed to delete source after successful copy during move operation&quot;,
                                ),
                                path: source,
                            })
                        }
                    }
                } else {
                    Err(io_err_with_path(e, &amp;source))
                }
            }
        }
    }
}

// --- Main Application Logic ---
fn main() -&gt; Result&lt;(), ()&gt; {
    let cli = Cli::parse();

    let result: Result&lt;u64, AppError&gt; = match cli.command {
        Commands::Copy {
            source,
            destination,
            overwrite,
            parallel,
        } =&gt; core_logic::handle_copy_operation_main(
            &amp;source,
            &amp;destination,
            overwrite,
            parallel,
            cli.verbose,
        ),
        Commands::Move {
            source,
            destination,
            overwrite,
            force_delete_source,
            parallel,
        } =&gt; core_logic::handle_move_operation(
            source,
            destination,
            overwrite,
            force_delete_source,
            parallel,
            cli.verbose,
        ),
        Commands::Delete { path, force } =&gt; {
            core_logic::handle_delete_operation(&amp;path, force, cli.verbose)
        }
    };

    match result {
        Ok(items_affected) =&gt; {
            if items_affected &gt; 0 || cli.verbose {
                println!(
                    &quot;Operation completed successfully. {} items affected.&quot;,
                    items_affected
                );
            } else if !cli.verbose {
                println!(
                    &quot;Operation completed (no items affected or action skipped). Use --verbose for details.&quot;
                );
            }
            Ok(())
        }
        Err(e) =&gt; {
            eprintln!(&quot;Error: {}&quot;, e);
            if let AppError::ParallelOperationFailed(errors) = e {
                for (i, err_msg) in errors.iter().enumerate() {
                    eprintln!(&quot;  Parallel error {}: {}&quot;, i + 1, err_msg);
                }
            }
            Err(())
        }
    }
}</code>
</section>
  <h2 id="to-build-and-run">
    
    
     <a href="#to-build-and-run">#</a><a href="#" aria-label="Back to top">To Build and Run</a>
        
    
  </h2>
      

<ol>
  <li>Save <code class="language-plaintext highlighter-rouge">src/main.rs</code> and <code class="language-plaintext highlighter-rouge">Cargo.toml</code>.</li>
  <li>Ensure Rust and build essentials are installed on your <code class="language-plaintext highlighter-rouge">arm64 Debian Bullseye</code> machine.</li>
  <li>Build: <code class="language-plaintext highlighter-rouge">cargo build --release</code></li>
</ol>

        </div>
        
          URL: https://ib.bsb.br/rust-cli-parallel-processing-for-copymove-files
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/ragflow-documentation/" title="ragflow documentation" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/bash-script-to-setup-wifish-on-linux/" title="bash script to setup 'wifish' on Linux" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "software>rust"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-software-rust" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/files-by-type/" title="Organize files by type" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-06-30 00:21:10
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="software-rust">
                  software>rust
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/rust-cli-parallel-processing-for-copymove-files/"
        },
        "headline": "Rust CLI parallel processing for copy/move files",
        "description": "",
        "datePublished": "2025-05-16T00:00:00+00:00",
        "dateModified": "2025-05-16T19:02:11+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
