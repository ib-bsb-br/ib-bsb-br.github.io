<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <title>Index of / - Advanced File Storage & Pastebin</title>
    <meta name="description" content="File listing, upload, and persistent text/image pasting.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body class="dark:bg-gray-900">
    <style>
      .pkm-nav { background: #111827; padding: 8px 25px; display: flex; gap: 24px; align-items: center; border-bottom: 1px solid #374151; }
      .pkm-nav a { color: #d1d5db; text-decoration: none; font-size: 14px; font-weight: 500; }
      .pkm-nav a:hover { text-decoration: underline; color: #fff; }
      .pkm-nav .brand { font-weight: bold; color: #fff; margin-right: auto; }
    </style>
    <nav class="pkm-nav">
      <span class="brand">PKM System</span>
      <a href="https://memor.ia.br/?b=inbox" title="Tasks and Notes">Workshop</a>
      <a href="https://arcreformas.com.br" title="File Storage">Storage</a>
      <a href="https://cut.ia.br" title="Capture and Tools">Gateway</a>
      <a href="https://ib-bsb-br.github.io/" title="Public Site" target="_blank" rel="noopener">Published</a>
    </nav>
    <div class="header-bar dark:bg-gray-800"> <h1 class="text-white">Advanced File Storage & Pastebin</h1>
    </div>

    <div class="container dark:bg-gray-800 dark:border-gray-700">
        <div id="uploadSection" class="dark:bg-gray-700 dark:border-gray-600">
            <h2 class="text-2xl font-semibold mb-5 text-gray-800 dark:text-gray-200">Upload New File</h2>
            <form id="uploadForm" enctype="multipart/form-data">
                <div>
                    <label for="fileToUpload" class="text-gray-700 dark:text-gray-300">Choose file to upload:</label>
                    <input type="file" name="fileToUpload" id="fileToUpload" required="" class="dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 dark:placeholder-gray-400">
                </div>
                <button type="submit" id="uploadButton" class="dark:bg-blue-600 dark:hover:bg-blue-700">
                    <span class="spinner"></span>
                    <span class="button-text">Upload File</span>
                </button>
            </form>
            <progress id="uploadProgress" value="0" max="100"></progress>
            <div id="uploadStatus" class="message-base mt-4"></div>
        </div>

        <div id="pasteContentSection" class="dark:bg-gray-700 dark:border-gray-600">
            <h2 class="text-2xl font-semibold mb-5 text-gray-800 dark:text-gray-200">Create File from Text or Pasted Image</h2>
            <form id="pasteContentForm">
                <div>
                    <label for="pasteArea" class="text-gray-700 dark:text-gray-300">Enter text or paste image here:</label>
                    <textarea id="pasteArea" name="pasteData" rows="8"
                              placeholder="Type text directly, or paste an image from your clipboard (Ctrl+V or Cmd+V)."
                              class="dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 dark:placeholder-gray-400"></textarea>
                </div>
                <div id="imagePreviewContainer" style="display: none;" class="dark:bg-gray-600 p-2 rounded my-2">
                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-1">Pasted image preview:</p>
                    <img id="imagePreview" src="#" alt="Pasted image" class="max-w-full max-h-48 border border-gray-400 dark:border-gray-500 rounded-md shadow-sm"/>
                </div>
                <div class="mt-4">
                    <label for="pasteOptionalFilename" class="text-gray-700 dark:text-gray-300">Optional Filename (extension added automatically):</label>
                    <input type="text" id="pasteOptionalFilename" name="pasteOptionalFilename"
                           placeholder="e.g., my_notes or cool_image_idea"
                           class="dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 dark:placeholder-gray-400">
                </div>
                <button type="submit" id="savePastedContentButton" class="dark:bg-green-600 dark:hover:bg-green-700 mt-2">
                    <span class="spinner"></span>
                    <span class="button-text">Save Text as File</span> </button>
            </form>
            <progress id="pasteProgress" value="0" max="100"></progress>
            <div id="pasteStatus" class="message-base mt-4"></div>
        </div>


        <h2 class="text-2xl font-semibold mb-5 text-gray-800 dark:text-gray-200 mt-8">Stored Files</h2>
        <div id="statusMessage" class="message-base info-message" style="display: block;">Listed 0 item(s). Total files size: 0 B.</div>

        <div class="overflow-x-auto">
            <table id="fileTable" class="mt-1 min-w-full dark:border-gray-600" style="display: none;">
                <thead class="dark:bg-gray-700">
                    <tr>
                        <th class="icon-cell dark:text-gray-300" title="Icon" aria-label="Icon\"></th>
                        <th data-sort="name" title="Sort by Name" aria-sort="ascending" class="sort-asc dark:text-gray-300">Name</th>
                        <th data-sort="displayType" title="Sort by Type" aria-sort="none" class="dark:text-gray-300">Type</th>
                        <th data-sort="size" class="size-cell dark:text-gray-400" title="Sort by Size" aria-sort="none">Size</th>
                        <th data-sort="lastModified" class="date-cell dark:text-gray-400" title="Sort by Last Modified" aria-sort="none">
                            Last Modified</th>
                        <th data-sort="creationDate" class="date-cell hidden-sm dark:text-gray-400" title="Sort by Creation Date" aria-sort="none">Created</th>
                    </tr>
                </thead>
                <tbody id="fileTableBody" class="dark:bg-gray-800">
                    </tbody>
            </table>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const API_BASE_URL = '/api'; // Use relative path to call our own API

        // --- GLOBAL STATE ---
        let currentSortColumn = 'lastModified'; // Default sort by most recent
        let currentSortDirection = 'desc';
        let filesData = [];
        let currentPastedImageFile = null;

        // Client-side size limits
        const MAX_CLIENT_IMAGE_PASTE_SIZE = 10 * 1024 * 1024; // 10MB
        const MAX_CLIENT_TEXT_CONTENT_SIZE = 2 * 1024 * 1024; // 2MB

        // --- DOM Elements ---
        const uploadFormEl = document.getElementById('uploadForm');
        const fileInputEl = document.getElementById('fileToUpload');
        const uploadButtonEl = document.getElementById('uploadButton');
        const uploadButtonTextEl = uploadButtonEl.querySelector('.button-text');
        const uploadButtonSpinnerEl = uploadButtonEl.querySelector('.spinner');
        const uploadProgressEl = document.getElementById('uploadProgress');
        const pasteContentFormEl = document.getElementById('pasteContentForm');
        const pasteAreaEl = document.getElementById('pasteArea');
        const imagePreviewContainerEl = document.getElementById('imagePreviewContainer');
        const imagePreviewEl = document.getElementById('imagePreview');
        const pasteOptionalFilenameEl = document.getElementById('pasteOptionalFilename');
        const savePastedContentButtonEl = document.getElementById('savePastedContentButton');
        const savePastedContentButtonTextEl = savePastedContentButtonEl.querySelector('.button-text');
        const savePastedContentButtonSpinnerEl = savePastedContentButtonEl.querySelector('.spinner');
        const pasteProgressEl = document.getElementById('pasteProgress');

        // --- Utility Functions ---
        function formatSize(bytes) {
            if (bytes === null || bytes === undefined || isNaN(parseFloat(bytes))) return 'â€”';
            bytes = Number(bytes);
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }
        function formatDate(dateString) {
            if (!dateString) return 'â€”';
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'â€”';
                const year = date.getFullYear();
                const month = ('0' + (date.getMonth() + 1)).slice(-2);
                const day = ('0' + date.getDate()).slice(-2);
                const hours = ('0' + date.getHours()).slice(-2);
                const minutes = ('0' + date.getMinutes()).slice(-2);
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            } catch (e) { console.error("Error formatting date:", dateString, e); return 'â€”'; }
        }
        function getIcon(type, name) {
            if (type === 'folder') return 'ðŸ“';
            const extension = name.includes('.') ? name.split('.').pop().toLowerCase() : '';
            const iconMap = { image: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'bmp', 'ico', 'heic', 'heif'], video: ['mp4', 'webm', 'mov', 'avi', 'mkv', 'flv', 'wmv', 'm4v', 'mpg', 'mpeg'], audio: ['mp3', 'wav', 'ogg', 'aac', 'flac', 'm4a', 'wma'], pdf: ['pdf'], document: ['doc', 'docx', 'odt', 'rtf', 'pages', 'tex', 'wpd'], spreadsheet: ['xls', 'xlsx', 'ods', 'csv', 'numbers'], presentation: ['ppt', 'pptx', 'odp', 'key'], archive: ['zip', 'rar', 'tar', 'gz', '7z', 'bz2', 'xz', 'iso'], text: ['txt', 'md', 'log', 'ini', 'conf', 'json', 'xml', 'yaml', 'cfg', 'srt'], code: ['js', 'html', 'css', 'php', 'py', 'java', 'c', 'cpp', 'cs', 'rb', 'go', 'swift', 'kt', 'sh', 'bat', 'ps1', 'sql'], executable: ['exe', 'dmg', 'app', 'msi', 'deb', 'rpm', 'bin'], font: ['ttf', 'otf', 'woff', 'woff2'] };
            const iconChars = { image: 'ðŸ–¼ï¸', video: 'ðŸŽžï¸', audio: 'ðŸŽµ', pdf: 'ðŸ“•', document: 'ðŸ“„', spreadsheet: 'ðŸ“Š', presentation: 'ðŸ–¥ï¸', archive: 'ðŸ“¦', text: 'ðŸ“', code: 'ðŸ’»', executable: 'âš™ï¸', font: 'ðŸ”¤' };
            for (const category in iconMap) { if (iconMap[category].includes(extension)) return iconChars[category]; }
            return 'ðŸ“Ž';
        }
        function showUserMessage(elementId, messageHTML, type = 'info', autoHideDelay = 0) {
            const el = document.getElementById(elementId);
            if (!el) { console.warn(`Element with ID '${elementId}' not found.`); return; }
            el.innerHTML = messageHTML;
            el.className = '';
            el.classList.add('message-base', `${type}-message`);
            el.style.display = 'block';
            if ((type === 'success' || type === 'error') && autoHideDelay > 0) {
                setTimeout(() => { if (el.innerHTML === messageHTML && el.style.display !== 'none') { el.style.display = 'none'; } }, autoHideDelay);
            }
        }
        function clearUserMessage(elementId) {
            const el = document.getElementById(elementId);
            if (el) { el.innerHTML = ''; el.style.display = 'none'; el.className = 'message-base'; }
        }
        function getFileExtensionFromMime(mimeType) {
            if (!mimeType) return 'bin';
            const parts = mimeType.split('/');
            const subtype = parts[1];
            if (subtype) {
                if (subtype === 'jpeg') return 'jpg';
                if (subtype === 'svg+xml') return 'svg';
                if (subtype.startsWith('vnd.')) {
                     const specific = subtype.substring(4);
                     if (specific === 'microsoft.icon') return 'ico';
                }
                return subtype.split('+')[0];
            }
            return 'bin';
        }

        // --- File Listing Logic ---
        function renderTable() {
            const tableBody = document.getElementById('fileTableBody');
            const statusMessageEl = document.getElementById('statusMessage');
            const fileTableEl = document.getElementById('fileTable');
            tableBody.innerHTML = '';

            if (statusMessageEl.classList.contains('error-message') && filesData.length === 0) {
                fileTableEl.style.display = 'none';
                return;
            }

            if (!filesData || filesData.length === 0) {
                if (!statusMessageEl.classList.contains('error-message')) {
                    showUserMessage('statusMessage', 'No files found. Upload something!', 'info');
                }
                fileTableEl.style.display = 'none';
                return;
            }

            fileTableEl.style.display = '';

            const sortedData = [...filesData].sort((a, b) => {
                let valA = a[currentSortColumn];
                let valB = b[currentSortColumn];

                if (currentSortColumn === 'size') {
                    valA = Number(a.size);
                    valB = Number(b.size);
                } else if (currentSortColumn === 'lastModified' || currentSortColumn === 'creationDate') {
                    valA = a[currentSortColumn] ? new Date(a[currentSortColumn]).getTime() : 0;
                    valB = b[currentSortColumn] ? new Date(b[currentSortColumn]).getTime() : 0;
                } else if (typeof valA === 'string' && typeof valB === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (valA < valB) return currentSortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return currentSortDirection === 'asc' ? 1 : -1;

                // Secondary sort by name
                if (a.name.toLowerCase() < b.name.toLowerCase()) return -1;
                if (a.name.toLowerCase() > b.name.toLowerCase()) return 1;
                return 0;
            });

            let totalFilesSize = 0;
            sortedData.forEach(item => {
                totalFilesSize += Number(item.size);
                const row = tableBody.insertRow();
                row.className = 'dark:hover:bg-gray-600';
                row.insertCell().outerHTML = `<td class="icon-cell dark:text-gray-300">${getIcon(item.mime_type, item.name)}</td>`;
                const nameCell = row.insertCell();
                nameCell.className = 'dark:text-gray-300';
                const link = document.createElement('a');
                link.href = item.url;
                link.textContent = item.name;
                link.title = `Download ${item.name}`;
                link.className = 'dark:text-blue-400 dark:hover:text-blue-300';
                link.setAttribute('download', item.name);
                nameCell.appendChild(link);
                row.insertCell().outerHTML = `<td class="dark:text-gray-300">${item.displayType || 'File'}</td>`;
                row.insertCell().outerHTML = `<td class="size-cell dark:text-gray-400">${formatSize(item.size)}</td>`;
                row.insertCell().outerHTML = `<td class="date-cell dark:text-gray-400">${formatDate(item.lastModified)}</td>`;
                row.insertCell().outerHTML = `<td class="date-cell hidden-sm dark:text-gray-400">${formatDate(item.created_at)}</td>`;
            });

            if (!statusMessageEl.classList.contains('error-message')) {
                const summaryMessage = `Listed ${sortedData.length} item(s). Total size: ${formatSize(totalFilesSize)}.`;
                showUserMessage('statusMessage', summaryMessage, 'info');
            }
        }
        function updateSortIndicators() {
            document.querySelectorAll('#fileTable th[data-sort]').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                th.setAttribute('aria-sort', 'none');
                if (th.dataset.sort === currentSortColumn) {
                    th.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                    th.setAttribute('aria-sort', currentSortDirection === 'asc' ? 'ascending' : 'descending');
                }
            });
        }
        async function fetchFiles() {
            const statusMessageEl = document.getElementById('statusMessage');
            showUserMessage('statusMessage', 'Loading file list...', 'info');

            try {
                const response = await fetch(`${API_BASE_URL}/files`);
                if (!response.ok) {
                    const errorJson = await response.json().catch(() => ({}));
                    throw new Error(errorJson.error || `Server responded with ${response.status}`);
                }
                const responseData = await response.json();
                if (responseData.status !== 'success') {
                    throw new Error(responseData.message || 'Failed to fetch file list.');
                }
                filesData = responseData.data || [];
                clearUserMessage('statusMessage');
                renderTable();
            } catch (error) {
                console.error('Failed to fetch files:', error);
                showUserMessage('statusMessage', `<strong>Error fetching files:</strong> ${error.message}`, 'error', 0);
                filesData = [];
                renderTable();
            } finally {
                updateSortIndicators();
            }
        }

        // --- Unified Upload Function ---
        function performUpload(formData, progressBarEl, statusElementId, buttonEl, buttonTextEl, buttonSpinnerEl, successCallback, errorCallback) {
            buttonEl.disabled = true;
            buttonTextEl.textContent = 'Processing...';
            if (buttonSpinnerEl) buttonSpinnerEl.style.display = 'inline-block';

            progressBarEl.style.display = 'block';
            progressBarEl.value = 0;
            clearUserMessage(statusElementId);

            const xhr = new XMLHttpRequest();
            xhr.open('POST', `${API_BASE_URL}/files`, true);

            xhr.upload.onprogress = function(e) {
                if (e.lengthComputable) {
                    const percentComplete = Math.round((e.loaded / e.total) * 100);
                    progressBarEl.value = percentComplete;
                }
            };

            xhr.onload = function() {
                buttonEl.disabled = false;
                if (buttonSpinnerEl) buttonSpinnerEl.style.display = 'none';

                if (xhr.status >= 200 && xhr.status < 300) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (response.status === 'success') {
                            showUserMessage(statusElementId, response.message || 'Operation successful!', 'success', 5000);
                            fetchFiles(); // Refresh file list on success
                            if (successCallback) successCallback(response);
                        } else {
                            showUserMessage(statusElementId, `<strong>Operation failed:</strong> ${response.error || 'Unknown server error.'}`, 'error', 7000);
                            if (errorCallback) errorCallback(response);
                        }
                    } catch (e) {
                        showUserMessage(statusElementId, '<strong>Error:</strong> Server sent an unreadable response.', 'error', 7000);
                        if (errorCallback) errorCallback({error: "Unreadable server response"});
                    }
                } else {
                    const errResponse = JSON.parse(xhr.responseText || '{}');
                    const errorMsg = `<strong>Upload failed:</strong> ${errResponse.error || `Server responded with ${xhr.status}`}`;
                    showUserMessage(statusElementId, errorMsg, 'error', 7000);
                    if (errorCallback) errorCallback({error: errorMsg});
                }
            };

            xhr.onerror = function() {
                if (buttonSpinnerEl) buttonSpinnerEl.style.display = 'none';
                showUserMessage(statusElementId, '<strong>Error:</strong> Network issue or server unavailable.', 'error', 7000);
                if (errorCallback) errorCallback({error: "Network issue"});
            };
            xhr.send(formData);
        }

        // --- Event Listeners ---
        uploadFormEl.addEventListener('submit', function(e) {
            e.preventDefault();
            if (fileInputEl.files.length === 0) return;
            const file = fileInputEl.files[0];
            const formData = new FormData();
            formData.append('fileToUpload', file);

            performUpload(formData, uploadProgressEl, 'uploadStatus', uploadButtonEl, uploadButtonTextEl, uploadButtonSpinnerEl,
                () => { // Success
                    fileInputEl.value = '';
                    uploadButtonTextEl.textContent = 'Upload File';
                },
                () => { // Error
                    uploadButtonTextEl.textContent = 'Upload File';
                }
            );
        });

        pasteAreaEl.addEventListener('paste', function(e) {
            const items = (e.clipboardData || window.clipboardData)?.items;
            if (!items) return;

            for (const item of items) {
                if (item.type.indexOf("image") !== -1) {
                    e.preventDefault();
                    const imageFile = item.getAsFile();
                    if (imageFile.size > MAX_CLIENT_IMAGE_PASTE_SIZE) {
                        showUserMessage('pasteStatus', `Pasted image is too large (max ${formatSize(MAX_CLIENT_IMAGE_PASTE_SIZE)}).`, 'error', 7000);
                        return;
                    }
                    currentPastedImageFile = imageFile;
                    imagePreviewEl.src = URL.createObjectURL(currentPastedImageFile);
                    imagePreviewContainerEl.style.display = 'block';
                    savePastedContentButtonTextEl.textContent = 'Save Pasted Image';
                    pasteOptionalFilenameEl.value = `image_${Date.now()}`;
                    pasteOptionalFilenameEl.focus();
                    return;
                }
            }
            resetPasteAreaForText();
        });

        pasteAreaEl.addEventListener('input', resetPasteAreaForText);

        function resetPasteAreaForText() {
            if (!currentPastedImageFile) return;
            currentPastedImageFile = null;
            imagePreviewContainerEl.style.display = 'none';
            URL.revokeObjectURL(imagePreviewEl.src);
            imagePreviewEl.src = '#';
            savePastedContentButtonTextEl.textContent = 'Save Text as File';
        }

        pasteContentFormEl.addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData();
            let baseFilename = pasteOptionalFilenameEl.value.trim();

            if (currentPastedImageFile) {
                if (!baseFilename) baseFilename = `pasted_image_${Date.now()}`;
                const extension = getFileExtensionFromMime(currentPastedImageFile.type);
                const finalFilename = baseFilename.endsWith('.' + extension) ? baseFilename : `${baseFilename}.${extension}`;
                formData.append('fileToUpload', currentPastedImageFile, finalFilename);

                performUpload(formData, pasteProgressEl, 'pasteStatus', savePastedContentButtonEl, savePastedContentButtonTextEl, savePastedContentButtonSpinnerEl,
                    () => { // Success
                        resetPasteAreaForText();
                        pasteOptionalFilenameEl.value = '';
                        pasteAreaEl.value = '';
                    },
                    () => { // Error
                        savePastedContentButtonTextEl.textContent = 'Save Pasted Image';
                    }
                );
            } else {
                const textToSave = pasteAreaEl.value.trim();
                if (!textToSave) return;
                if (new TextEncoder().encode(textToSave).length > MAX_CLIENT_TEXT_CONTENT_SIZE) {
                     showUserMessage('pasteStatus', `Text content is too large (max ${formatSize(MAX_CLIENT_TEXT_CONTENT_SIZE)}).`, 'error', 7000);
                    return;
                }
                if (!baseFilename) baseFilename = `text_snippet_${Date.now()}`;
                const finalFilename = baseFilename.endsWith('.txt') ? baseFilename : `${baseFilename}.txt`;
                formData.append('fileToUpload', new Blob([textToSave], { type: 'text/plain' }), finalFilename);

                performUpload(formData, pasteProgressEl, 'pasteStatus', savePastedContentButtonEl, savePastedContentButtonTextEl, savePastedContentButtonSpinnerEl,
                    () => { // Success
                        pasteAreaEl.value = '';
                        pasteOptionalFilenameEl.value = '';
                        savePastedContentButtonTextEl.textContent = 'Save Text as File';
                    },
                    () => { // Error
                        savePastedContentButtonTextEl.textContent = 'Save Text as File';
                    }
                );
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            fetchFiles();
            document.querySelectorAll('#fileTable th[data-sort]').forEach(headerCell => {
                headerCell.addEventListener('click', () => {
                    const sortKey = headerCell.dataset.sort;
                    if (currentSortColumn === sortKey) {
                        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSortColumn = sortKey;
                        currentSortDirection = 'asc'; // Default to ascending when changing column
                    }
                    renderTable();
                    updateSortIndicators();
                });
            });
            updateSortIndicators();
        });
    </script>
</body></html>
