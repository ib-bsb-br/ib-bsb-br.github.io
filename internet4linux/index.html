<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Internet Connectivity Solution for linux - infoBAG
      
    </title>
    <meta name="title" content="Internet Connectivity Solution for linux - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/internet4linux/">
    <meta property="og:title" content="Internet Connectivity Solution for linux - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/internet4linux/">
    <meta name="twitter:title" content="Internet Connectivity Solution for linux - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/internet4linux/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scripts&gt;bash">
      
        <meta property="article:tag" content="scripts&gt;bash">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Internet Connectivity Solution for linux
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-05-26T00:00:00+00:00" class="post-date">
          26 May 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-05-28T00:07:28+00:00">
              28 May 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/internet4linux" class="tag">internet4linux</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scripts-bash" class="tag">scripts>bash</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        88131 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        8087 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-05-26-internet4linux.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-05-26-internet4linux.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#sudo-apt-install">sudo apt install</a></li><li><a href="#bash-wifish">bash wifi.sh</a></li></ul>
          <h1 id="sudo-apt-install">
    
    
     <a href="#sudo-apt-install">#</a><a href="#" aria-label="Back to top">sudo apt install</a>
        
    
  </h1>
      
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>sudo apt install -y dialog network-manager wpasupplicant isc-dhcp-client iproute2 iw iputils-ping wireless-tools procps mawk
</code></section></div></div>
  <h1 id="bash-wifish">
    
    
     <a href="#bash-wifish">#</a><a href="#" aria-label="Back to top">bash wifi.sh</a>
        
    
  </h1>
      

<section class="code-block-container" role="group" aria-label="Bash Code Block" data-filename="bash_code_block.sh" data-code="#!/usr/bin/env bash
#
# Universal Network Connectivity Script for RK3588 (Debian Bullseye)
# Version 8.1 - Refined Integration and Robustness
#
# Changelog from v8.0:
# - Refined debug_exec temp file handling (local management).
# - Enhanced cleanup function to handle temporary NetworkManager connections.
# - Improved nmcli scan parsing in scan_wifi_networks for better robustness.
# - Minor improvements to wpa_supplicant PID file usage.
# - Updated documentation.
#
# Features:
# - Interactive TUI using &#39;dialog&#39; for easier configuration
# - Automatic network configuration via Ethernet or Wi-Fi
# - Support for WPA/WPA2/WPA3, WEP, and open networks
# - Hidden SSID support
# - IPv4 and IPv6 configuration
# - Multiple DHCP client support (dhclient, dhcpcd, udhcpc)
# - Multiple Network Management tool support (NetworkManager, wpa_supplicant, iwd)
# - Connection profile management (passwords base64 encoded)
# - Comprehensive error handling, logging, and recovery (e.g., Wi-Fi driver reload)
# - Progress indicators and colored console output
# - Optional package dependency checking and installation
# - Non-interactive mode for automated setups
#
# Requirements:
# - Root privileges
# - &#39;dialog&#39; utility for interactive mode (will offer to install)
# - Basic utilities: ip, ping, awk, grep, sed, systemctl, mktemp, base64, pkill
# - At least one of: NetworkManager, wpa_supplicant, iwd
# - At least one of: dhclient, dhcpcd, udhcpc
#

# Strict mode
set -euo pipefail
IFS=$&#39;\n\t&#39;

# --- Constants and Configuration ---
readonly SCRIPT_VERSION=&quot;8.1&quot;
readonly SCRIPT_NAME=&quot;$(basename &quot;$0&quot;)&quot;
readonly CONFIG_DIR=&quot;/etc/netconnect&quot;
readonly PROFILE_DIR=&quot;${CONFIG_DIR}/profiles&quot;
readonly LOG_DIR=&quot;/var/log/netconnect&quot;
readonly MAIN_LOG_FILE=&quot;${LOG_DIR}/netconnect.log&quot;
readonly LOCK_FILE=&quot;/var/run/netconnect.lock&quot;

# Network testing parameters
readonly PING_IP_PRIMARY=&quot;8.8.8.8&quot;
readonly PING_IP_SECONDARY=&quot;1.1.1.1&quot;
readonly PING_HOSTNAME=&quot;google.com&quot;
readonly PING_COUNT=3
readonly PING_TIMEOUT=2 # seconds
readonly DHCP_TIMEOUT=30 # seconds
readonly WIFI_SCAN_TIMEOUT=10 # seconds for wpa_cli scan, nmcli/iw might be faster
readonly WIFI_CONNECT_TIMEOUT=30 # seconds

# Dialog UI settings
DIALOG_CMD=&quot;dialog&quot;
DIALOG_AVAILABLE=false
DIALOG_SUCCESS_CODE=0
DIALOG_CANCEL_CODE=1
DIALOG_HELP_CODE=2
DIALOG_EXTRA_CODE=3
DIALOG_ESC_CODE=255
DIALOG_DEFAULT_HEIGHT=15
DIALOG_DEFAULT_WIDTH=70
DIALOG_INPUT_WIDTH=50

# Color codes (disabled if not in terminal or if NON_INTERACTIVE)
if [[ -t 1 &amp;&amp; -t 2 ]]; then
    readonly COLOR_RED=&#39;\033[0;31m&#39;
    readonly COLOR_GREEN=&#39;\033[0;32m&#39;
    readonly COLOR_YELLOW=&#39;\033[0;33m&#39;
    readonly COLOR_BLUE=&#39;\033[0;34m&#39;
    readonly COLOR_PURPLE=&#39;\033[0;35m&#39;
    readonly COLOR_CYAN=&#39;\033[0;36m&#39;
    readonly COLOR_RESET=&#39;\033[0m&#39;
else
    readonly COLOR_RED=&#39;&#39;
    readonly COLOR_GREEN=&#39;&#39;
    readonly COLOR_YELLOW=&#39;&#39;
    readonly COLOR_BLUE=&#39;&#39;
    readonly COLOR_PURPLE=&#39;&#39;
    readonly COLOR_CYAN=&#39;&#39;
    readonly COLOR_RESET=&#39;&#39;
fi

# --- Global Variables ---
declare -a ETH_IFACES=()
declare -a WIFI_IFACES=()
declare -a TMP_FILES_TO_CLEAN=() # For files/items needing cleanup at script exit
declare SELECTED_IFACE=&quot;&quot;
declare NM_AVAILABLE=false
declare WPA_CLI_AVAILABLE=false
declare IWD_AVAILABLE=false
declare WPA_SUPPLICANT_SERVICE_ACTIVE=false
declare DHCP_CLIENT=&quot;&quot;

DBG=${DBG:-false}
DEBUG_LEVEL=${DEBUG_LEVEL:-1} # 1:basic, 2:verbose, 3:full
DEBUG_LOG_FILE=&quot;&quot;
VERBOSE_COMMANDS=${VERBOSE_COMMANDS:-true}
XTRACE_FD=6

NON_INTERACTIVE=false
CONNECTION_TYPE_ARG=&quot;&quot;
CHECK_ONLY_ARG=false

# --- Prerequisite Check &amp; Installation ---
check_command() {
    local cmd_to_check=&quot;$1&quot;
    if command -v &quot;$cmd_to_check&quot; &gt;/dev/null 2&gt;&amp;1; then
        return 0
    else
        return 1
    fi
}

install_packages_dialog() {
    local missing_packages_to_install=(&quot;$@&quot;)
    local choice

    if [[ ${#missing_packages_to_install[@]} -eq 0 ]]; then
        return 0 # Nothing to install
    fi

    warning_log &quot;Missing packages: ${missing_packages_to_install[*]}&quot;
    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local install_prompt_msg=&quot;The following essential packages are missing: ${missing_packages_to_install[*]}.\n\nDo you want to try and install them now?\n(Requires an existing temporary internet connection or cached packages)&quot;
        if $DIALOG_AVAILABLE ; then
            &quot;$DIALOG_CMD&quot; --title &quot;Missing Packages&quot; \
                   --yesno &quot;$install_prompt_msg&quot; \
                   12 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
            choice=$?
        else # Fallback for when dialog itself might be missing
            read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}$install_prompt_msg (y/N): ${COLOR_RESET}&quot;)&quot; response
            [[ &quot;$response&quot; =~ ^[yY]$ ]] &amp;&amp; choice=0 || choice=1
        fi
    else
        info_log &quot;Non-interactive mode: Attempting to install missing packages automatically.&quot;
        choice=0 # Auto-yes in non-interactive
    fi

    if [[ $choice -eq $DIALOG_SUCCESS_CODE ]]; then
        info_log &quot;User opted to install missing packages: ${missing_packages_to_install[*]}&quot;
        _show_progress_message &quot;Attempting to install: ${missing_packages_to_install[*]}...&quot; &quot;transient&quot;
        
        # Temporarily allow script to continue if apt-get update fails, but warn
        set +e
        apt-get update -qq
        local apt_update_ec=$?
        set -e
        if [[ $apt_update_ec -ne 0 ]]; then
             error_log &quot;&#39;apt-get update&#39; failed (EC: $apt_update_ec). Package installation might fail.&quot;
             _show_progress_message &quot;&#39;apt-get update&#39; failed. Please check your network connection and apt sources.&quot; &quot;error&quot;
             # Continue to try install, it might work with cached lists
        fi
        
        # shellcheck disable=SC2068 # We want word splitting for the array
        if apt-get install -y ${missing_packages_to_install[@]}; then
            _show_progress_message &quot;Successfully installed missing packages.&quot; &quot;persistent&quot;
            # Re-check for dialog if it was installed
            if [[ &quot; ${missing_packages_to_install[*]} &quot; =~ &quot; dialog &quot; ]] &amp;&amp; check_command dialog; then
                DIALOG_AVAILABLE=true
            fi
            return 0
        else
            error_log &quot;Failed to install packages: ${missing_packages_to_install[*]}.&quot;
            _show_progress_message &quot;Failed to install some packages. Please install them manually and re-run the script.\nPackages: ${missing_packages_to_install[*]}&quot; &quot;error&quot;
            return 1
        fi
    else
        error_log &quot;User declined package installation or cancelled.&quot;
        _show_progress_message &quot;Cannot proceed without essential packages: ${missing_packages_to_install[*]}. Exiting.&quot; &quot;error&quot;
        return 1
    fi
}

# --- Logging Functions ---
_log_to_file() {
    if $DBG &amp;&amp; [[ -n &quot;$DEBUG_LOG_FILE&quot; ]] &amp;&amp; [[ -w &quot;$DEBUG_LOG_FILE&quot; || -w &quot;$(dirname &quot;$DEBUG_LOG_FILE&quot;)&quot; ]]; then
        echo -e &quot;$1&quot; &gt;&gt; &quot;$DEBUG_LOG_FILE&quot;
    fi
}

_base_log() {
    local level=&quot;$1&quot;
    local color=&quot;$2&quot;
    shift 2
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local log_entry=&quot;[$timestamp] [$level] $message&quot;

    _log_to_file &quot;$log_entry&quot;

    if [[ &quot;$level&quot; != &quot;DEBUG&quot; &amp;&amp; &quot;$level&quot; != &quot;VERB&quot; &amp;&amp; &quot;$level&quot; != &quot;FULL&quot; ]] || $DBG; then
        if [[ &quot;$level&quot; == &quot;DEBUG&quot; &amp;&amp; &quot;$DEBUG_LEVEL&quot; -lt 1 ]]; then return; fi
        if [[ &quot;$level&quot; == &quot;VERB&quot; &amp;&amp; &quot;$DEBUG_LEVEL&quot; -lt 2 ]]; then return; fi
        if [[ &quot;$level&quot; == &quot;FULL&quot; &amp;&amp; &quot;$DEBUG_LEVEL&quot; -lt 3 ]]; then return; fi
        
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]] || ! $DIALOG_AVAILABLE || [[ &quot;$level&quot; == &quot;DEBUG&quot; || &quot;$level&quot; == &quot;VERB&quot; || &quot;$level&quot; == &quot;FULL&quot; ]]; then
             echo -e &quot;${color}[$level]${COLOR_RESET} $message&quot; &gt;&amp;2
        fi
    fi
}

debug_log()   { if $DBG &amp;&amp; [[ &quot;$DEBUG_LEVEL&quot; -ge 1 ]]; then local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;DEBUG&quot; &quot;$COLOR_BLUE&quot; &quot;[$caller_info] $*&quot;; fi; }
debug_verbose() { if $DBG &amp;&amp; [[ &quot;$DEBUG_LEVEL&quot; -ge 2 ]]; then local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;VERB&quot; &quot;$COLOR_CYAN&quot; &quot;[$caller_info] $*&quot;; fi; }
debug_full()    { if $DBG &amp;&amp; [[ &quot;$DEBUG_LEVEL&quot; -ge 3 ]]; then local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;FULL&quot; &quot;$COLOR_PURPLE&quot; &quot;[$caller_info] $*&quot;; fi; }
info_log()    { _base_log &quot;INFO&quot; &quot;$COLOR_GREEN&quot; &quot;$@&quot;; }
warning_log() { local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;WARN&quot; &quot;$COLOR_YELLOW&quot; &quot;[$caller_info] $*&quot;; }
error_log()   { local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;ERROR&quot; &quot;$COLOR_RED&quot; &quot;[$caller_info] $*&quot;; }

debug_var() {
    if ! $DBG || [[ &quot;$DEBUG_LEVEL&quot; -lt 2 ]]; then return 0; fi
    local var_name=&quot;$1&quot;
    local var_value
    var_value=&quot;${!var_name}&quot; # Indirect expansion
    debug_verbose &quot;Variable $var_name = &#39;$var_value&#39; (length: ${#var_value})&quot;
    if [[ &quot;$var_value&quot; =~ [[:cntrl:]] ]]; then # Check for control characters
        debug_log &quot;WARNING: Variable $var_name contains control characters.&quot;
        debug_full &quot;Hex dump for $var_name:\n$(echo -n &quot;$var_value&quot; | hexdump -C)&quot;
    fi
}

# --- UI and Progress Functions ---
_show_dialog_message() {
    local type=&quot;$1&quot; title=&quot;$2&quot; message=&quot;$3&quot;
    local height=${4:-8} width=${5:-60}
    local dialog_exit_code=$DIALOG_CANCEL_CODE

    debug_verbose &quot;Showing dialog: type=$type, title=&#39;$title&#39;, message snippet=&#39;${message:0:50}...&#39;&quot;
    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;$title&quot; --&quot;$type&quot; &quot;$message&quot; &quot;$height&quot; &quot;$width&quot; 2&gt;/dev/tty
        dialog_exit_code=$?
        # Some dialog versions might not clear screen fully on exit
        # clear # Uncomment if needed, but can be disruptive
    else
        echo -e &quot;${COLOR_GREEN}$title:${COLOR_RESET}\n$message&quot; &gt;&amp;2
        if [[ &quot;$type&quot; == &quot;msgbox&quot; || &quot;$type&quot; == &quot;infobox&quot; ]]; then
            dialog_exit_code=$DIALOG_SUCCESS_CODE
        elif [[ &quot;$type&quot; == &quot;yesno&quot; ]]; then
             read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}$message (y/N): ${COLOR_RESET}&quot;)&quot; response
             [[ &quot;$response&quot; =~ ^[yY]$ ]] &amp;&amp; dialog_exit_code=$DIALOG_SUCCESS_CODE || dialog_exit_code=$DIALOG_CANCEL_CODE
        fi
    fi
    debug_verbose &quot;Dialog (&#39;$title&#39;) exit code: $dialog_exit_code&quot;
    return $dialog_exit_code
}

_show_progress_message() {
    local message=&quot;$1&quot;
    local type=&quot;${2:-info}&quot; # info, persistent, error, transient
    
    info_log &quot;$message&quot; # Always log it

    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then return; fi

    case &quot;$type&quot; in
        persistent) _show_dialog_message &quot;msgbox&quot; &quot;Information&quot; &quot;$message&quot; ;;
        error) _show_dialog_message &quot;msgbox&quot; &quot;Error&quot; &quot;$message&quot; 10 70 ;; # Slightly larger for errors
        transient) 
            if $DIALOG_AVAILABLE; then
                &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Information&quot; --infobox &quot;$message&quot; 6 60 2&gt;/dev/tty || true
                sleep 1
            else
                echo -e &quot;${COLOR_GREEN}INFO:${COLOR_RESET} $message&quot; &gt;&amp;2; sleep 1;
            fi ;;
        *) _show_dialog_message &quot;msgbox&quot; &quot;Information&quot; &quot;$message&quot; ;;
    esac
}

show_progress_spinner() {
    local message=&quot;$1&quot;
    local duration_s=&quot;${2:-0}&quot;

    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]] || ! $DIALOG_AVAILABLE; then
        echo -n -e &quot;${COLOR_GREEN}$message${COLOR_RESET}&quot; &gt;&amp;2
        if [[ &quot;$duration_s&quot; -gt 0 ]]; then
            local sleep_interval=0.2 spin_chars=&quot;/-\\|&quot;
            local num_steps=$(( (duration_s * 1000) / (sleep_interval * 1000) )) # Integer arithmetic
            for ((i=0; i&lt;num_steps; i++)); do
                echo -n -e &quot; ${spin_chars:i%${#spin_chars}:1}&quot; &gt;&amp;2; sleep &quot;$sleep_interval&quot;; echo -n -e &quot;\b\b&quot; &gt;&amp;2;
            done
            echo -e &quot;  done.&quot; &gt;&amp;2
        else echo -e &quot; done.&quot; &gt;&amp;2; fi
        return
    fi

    if [[ &quot;$duration_s&quot; -gt 0 ]]; then
        ( local percentage_per_step=$(( 100 / duration_s ));
          for ((i=0; i&lt;=duration_s; i++)); do echo &quot;$(( i * percentage_per_step ))&quot;; sleep 1; done; echo 100;
        ) | &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Progress&quot; --gauge &quot;$message&quot; 8 70 0 2&gt;/dev/tty
    else _show_progress_message &quot;$message ...done.&quot; &quot;transient&quot;; fi
}

# --- Utility Functions ---
debug_exec() {
    local cmd_string=&quot;$*&quot;
    debug_verbose &quot;Executing: $cmd_string&quot;
    local output exit_code
    local tmp_stdout_de tmp_stderr_de # Specific temp files for this function instance

    # Create temp files locally, do not add to global cleanup array
    tmp_stdout_de=$(mktemp &quot;/tmp/netconnect_cmd_stdout.XXXXXX&quot;)
    if [[ $? -ne 0 || -z &quot;$tmp_stdout_de&quot; ]]; then error_log &quot;debug_exec: Failed to create stdout temp file&quot;; return 1; fi
    tmp_stderr_de=$(mktemp &quot;/tmp/netconnect_cmd_stderr.XXXXXX&quot;)
    if [[ $? -ne 0 || -z &quot;$tmp_stderr_de&quot; ]]; then 
        error_log &quot;debug_exec: Failed to create stderr temp file&quot;; 
        rm -f &quot;$tmp_stdout_de&quot; 2&gt;/dev/null; # Clean up first temp file
        return 1; 
    fi

    # Execute command
    eval &quot;$cmd_string&quot; &gt; &quot;$tmp_stdout_de&quot; 2&gt; &quot;$tmp_stderr_de&quot;
    exit_code=$?
    
    local stdout_content stderr_content
    stdout_content=$(cat &quot;$tmp_stdout_de&quot;)
    stderr_content=$(cat &quot;$tmp_stderr_de&quot;)

    debug_verbose &quot;Exit code: $exit_code&quot;
    [[ -n &quot;$stdout_content&quot; ]] &amp;&amp; debug_full &quot;STDOUT:\n$stdout_content&quot;
    [[ -n &quot;$stderr_content&quot; ]] &amp;&amp; debug_full &quot;STDERR:\n$stderr_content&quot;
    
    if [[ $exit_code -ne 0 ]]; then
        debug_log &quot;FAILED command: $cmd_string (Exit Code: $exit_code)&quot;
        [[ -n &quot;$stderr_content&quot; ]] &amp;&amp; debug_log &quot;Stderr from failed command was logged in FULL debug.&quot;
    fi
    
    # Output the actual stdout of the command for capture by caller
    echo &quot;$stdout_content&quot;
    
    # Cleanup these specific temp files
    rm -f &quot;$tmp_stdout_de&quot; &quot;$tmp_stderr_de&quot; 2&gt;/dev/null || warning_log &quot;debug_exec: Failed to clean up its local temp files.&quot;

    return $exit_code
}

create_temp_file() {
    local prefix=&quot;${1:-netconnect}&quot; suffix_val=&quot;${2:-}&quot;
    local temp_file sane_prefix sane_suffix

    sane_prefix=$(echo &quot;$prefix&quot; | tr -cd &#39;[:alnum:]_-&#39;)
    sane_suffix=$(echo &quot;$suffix_val&quot; | tr -cs &#39;[:alnum:]_.-&#39; &#39;_&#39;)
    [[ -n &quot;$sane_suffix&quot; &amp;&amp; ! &quot;$sane_suffix&quot; =~ ^\. ]] &amp;&amp; sane_suffix=&quot;.$sane_suffix&quot;

    temp_file=$(mktemp &quot;/tmp/${sane_prefix}.XXXXXX${sane_suffix}&quot;)
    if [[ $? -ne 0 || -z &quot;$temp_file&quot; || ! -e &quot;$temp_file&quot; ]]; then
        error_log &quot;Failed to create temporary file (prefix &#39;$sane_prefix&#39;, suffix &#39;$sane_suffix&#39;)&quot;
        return 1
    fi
    debug_verbose &quot;Created global temporary file: &#39;$temp_file&#39;&quot;
    TMP_FILES_TO_CLEAN+=(&quot;$temp_file&quot;)
    echo &quot;$temp_file&quot;
    return 0
}

safe_rm() {
    local file_to_remove=&quot;$1&quot;
    debug_verbose &quot;safe_rm: Attempting to remove &#39;$file_to_remove&#39;&quot;
    if [[ -z &quot;$file_to_remove&quot; ]]; then warning_log &quot;safe_rm: Empty filename provided.&quot;; return 1; fi
    if [[ ! -e &quot;$file_to_remove&quot; ]]; then debug_verbose &quot;safe_rm: File &#39;$file_to_remove&#39; does not exist, skipping.&quot;; return 0; fi
    
    local critical_paths=(&quot;/&quot; &quot;/bin&quot; &quot;/etc&quot; &quot;/usr&quot; &quot;/var&quot; &quot;/tmp&quot; &quot;/sbin&quot; &quot;/lib&quot; &quot;/boot&quot; &quot;/home&quot; &quot;/root&quot;)
    for crit_path in &quot;${critical_paths[@]}&quot;; do
        if [[ &quot;$file_to_remove&quot; == &quot;$crit_path&quot; ]]; then
            error_log &quot;safe_rm: Critical path removal protection for &#39;$file_to_remove&#39;!&quot;
            return 1
        fi
    done
    if [[ &quot;$file_to_remove&quot; =~ (/|([[:alnum:]_-]+)/)\.\. ]]; then # Basic path traversal check
        error_log &quot;safe_rm: Path traversal attempt suspected in &#39;$file_to_remove&#39;!&quot;
        return 1
    fi

    if rm -f &quot;$file_to_remove&quot;; then
        debug_verbose &quot;safe_rm: Successfully removed &#39;$file_to_remove&#39;&quot;
        for i in &quot;${!TMP_FILES_TO_CLEAN[@]}&quot;; do
            if [[ &quot;${TMP_FILES_TO_CLEAN[i]}&quot; == &quot;$file_to_remove&quot; ]]; then
                unset &#39;TMP_FILES_TO_CLEAN[i]&#39;; break;
            fi
        done
        return 0
    else
        error_log &quot;safe_rm: Failed to remove &#39;$file_to_remove&#39; (Error: $?)&quot;; return 1;
    fi
}

cleanup() {
    local exit_code=$?
    debug_log &quot;Cleanup: Script exiting with code $exit_code&quot;
    local item_processed_flags=() # To avoid processing an item multiple times if it appears due to error

    # Process special cleanup items first (like nmcli connections)
    local remaining_items=()
    for item_idx in &quot;${!TMP_FILES_TO_CLEAN[@]}&quot;; do
        local item=&quot;${TMP_FILES_TO_CLEAN[$item_idx]}&quot;
        if [[ -z &quot;$item&quot; ]] || [[ &quot; ${item_processed_flags[*]} &quot; =~ &quot; ${item_idx} &quot; ]]; then continue; fi

        if [[ &quot;$item&quot; == nmcli_con_del_* ]]; then
            local con_name_to_del=&quot;${item#nmcli_con_del_}&quot;
            if [[ -n &quot;$con_name_to_del&quot; ]] &amp;&amp; $NM_AVAILABLE; then
                info_log &quot;Cleaning up temporary NetworkManager connection: $con_name_to_del&quot;
                nmcli connection delete id &quot;$con_name_to_del&quot; &gt;/dev/null 2&gt;&amp;1 || \
                    warning_log &quot;Failed to delete temporary NM connection &#39;$con_name_to_del&#39; during cleanup.&quot;
            fi
            item_processed_flags+=(&quot;$item_idx&quot;)
        else
            remaining_items+=(&quot;$item&quot;) # It&#39;s a file path for safe_rm
        fi
    done
    
    # Update TMP_FILES_TO_CLEAN with only file paths remaining
    TMP_FILES_TO_CLEAN=(&quot;${remaining_items[@]}&quot;)

    # Regular file cleanup
    if [[ ${#TMP_FILES_TO_CLEAN[@]} -gt 0 ]]; then
        debug_verbose &quot;Cleaning up ${#TMP_FILES_TO_CLEAN[@]} temporary file(s): ${TMP_FILES_TO_CLEAN[*]}&quot;
        for temp_file in &quot;${TMP_FILES_TO_CLEAN[@]}&quot;; do
            [[ -n &quot;$temp_file&quot; ]] &amp;&amp; safe_rm &quot;$temp_file&quot;
        done
    else
        debug_verbose &quot;No standard temporary files registered for cleanup.&quot;
    fi
    
    [[ -f &quot;$LOCK_FILE&quot; ]] &amp;&amp; safe_rm &quot;$LOCK_FILE&quot;
    
    if [[ -t 1 ]]; then
      stty sane 2&gt;/dev/null || debug_verbose &quot;stty sane failed&quot;
      tput cnorm 2&gt;/dev/null || debug_verbose &quot;tput cnorm failed&quot;
    fi
    
    if $DBG &amp;&amp; [[ -n &quot;$DEBUG_LOG_FILE&quot; ]]; then
        set +x
        eval &quot;exec $XTRACE_FD&gt;&amp;-&quot; 2&gt;/dev/null || debug_verbose &quot;Failed to close XTRACE_FD $XTRACE_FD&quot;
        info_log &quot;Script exited (Code: $exit_code). Debug log: $DEBUG_LOG_FILE&quot;
        [[ -t 2 ]] &amp;&amp; echo -e &quot;${COLOR_CYAN}Debug log available at: $DEBUG_LOG_FILE${COLOR_RESET}&quot; &gt;&amp;2
    else
        info_log &quot;Script exited (Code: $exit_code).&quot;
    fi
    exit &quot;$exit_code&quot;
}
trap cleanup EXIT
# SIGINT/SIGTERM are more complex; a simple message is fine, cleanup will run on EXIT.
trap &#39;error_log &quot;Script interrupted by SIGINT/SIGTERM.&quot;; exit 130&#39; SIGINT SIGTERM


check_root() {
    if [[ $EUID -ne 0 ]]; then
        error_log &quot;This script must be run as root&quot;
        _show_progress_message &quot;ERROR: This script must be run as root. Usage: sudo $SCRIPT_NAME [options]&quot; &quot;error&quot;
        exit 1
    fi
}

acquire_lock() {
    if [[ -f &quot;$LOCK_FILE&quot; ]]; then
        local pid; pid=$(cat &quot;$LOCK_FILE&quot; 2&gt;/dev/null)
        if [[ -n &quot;$pid&quot; ]] &amp;&amp; kill -0 &quot;$pid&quot; 2&gt;/dev/null; then
            error_log &quot;Another instance is already running (PID: $pid)&quot;; exit 1;
        fi
        safe_rm &quot;$LOCK_FILE&quot; # Stale lock file
    fi
    echo $$ &gt; &quot;$LOCK_FILE&quot; || { error_log &quot;Failed to create lock file: $LOCK_FILE&quot;; exit 1; }
}

init_directories() {
    local dirs=(&quot;$CONFIG_DIR&quot; &quot;$PROFILE_DIR&quot; &quot;$LOG_DIR&quot;)
    for dir in &quot;${dirs[@]}&quot;; do
        if [[ ! -d &quot;$dir&quot; ]]; then
            debug_log &quot;Creating directory: $dir&quot;
            mkdir -p &quot;$dir&quot; || warning_log &quot;Could not create directory: $dir.&quot;
        fi
    done
    touch &quot;$MAIN_LOG_FILE&quot; 2&gt;/dev/null || warning_log &quot;Main log file $MAIN_LOG_FILE is not writable.&quot;
}

sanitize_iface_name() {
    local val=&quot;$1&quot;; val=$(echo -n &quot;$val&quot; | tr -cd &#39;[:alnum:]_-&#39;); echo &quot;$val&quot;
}

sanitize_dialog_output() {
    local val=&quot;$1&quot;; val=$(echo -n &quot;$val&quot; | tr -cd &#39;[:print:]\n\r&#39;); val=$(echo -n &quot;$val&quot; | sed &#39;s/^[[:space:]]*//;s/[[:space:]]*$//&#39;); echo &quot;$val&quot;
}

# --- User Interaction Functions (Dialog-based with fallbacks) ---
prompt_user_input() {
    local prompt_text=&quot;$1&quot; default_value=&quot;${2:-}&quot; is_password=&quot;${3:-false}&quot;
    local input_value=&quot;&quot; dialog_exit_status

    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local dialog_option=&quot;--inputbox&quot;; [[ &quot;$is_password&quot; == &quot;true&quot; ]] &amp;&amp; dialog_option=&quot;--passwordbox&quot;
        local temp_out; temp_out=$(create_temp_file &quot;dialog_input&quot;) || return 1

        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Input Required&quot; &quot;$dialog_option&quot; &quot;$prompt_text&quot; \
            10 ${DIALOG_INPUT_WIDTH} &quot;$default_value&quot; 2&gt; &quot;$temp_out&quot;
        dialog_exit_status=$?
        
        input_value=$(sanitize_dialog_output &quot;$(cat &quot;$temp_out&quot;)&quot;)
        safe_rm &quot;$temp_out&quot;

        if [[ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]]; then
            info_log &quot;User cancelled input for: $prompt_text&quot;; return 1;
        fi
    else
        local read_options=&quot;&quot;; [[ &quot;$is_password&quot; == &quot;true&quot; ]] &amp;&amp; read_options=&quot;-s&quot;
        local prompt_full=&quot;$prompt_text&quot;; [[ -n &quot;$default_value&quot; ]] &amp;&amp; prompt_full+=&quot; [$default_value]&quot;
        prompt_full+=&quot;: &quot;
        
        read -r $read_options -p &quot;$(echo -e &quot;${COLOR_YELLOW}$prompt_full${COLOR_RESET}&quot;)&quot; input_value
        [[ &quot;$is_password&quot; == &quot;true&quot; ]] &amp;&amp; echo &gt;&amp;2
        [[ -z &quot;$input_value&quot; &amp;&amp; -n &quot;$default_value&quot; ]] &amp;&amp; input_value=&quot;$default_value&quot;
    fi
    echo &quot;$input_value&quot;; return 0
}

prompt_yes_no() {
    local prompt_text=&quot;$1&quot; default_choice=&quot;${2:-n}&quot;
    local response_code=$DIALOG_CANCEL_CODE

    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local default_opt=&quot;&quot;; [[ &quot;$default_choice&quot; == &quot;n&quot; ]] &amp;&amp; default_opt=&quot;--defaultno&quot;
        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Confirmation&quot; --yesno &quot;$prompt_text&quot; 8 ${DIALOG_DEFAULT_WIDTH} ${default_opt} 2&gt;/dev/tty
        response_code=$?
    else
        local yn_prompt=&quot;[y/N]&quot;; [[ &quot;$default_choice&quot; == &quot;y&quot; ]] &amp;&amp; yn_prompt=&quot;[Y/n]&quot;
        read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}$prompt_text $yn_prompt: ${COLOR_RESET}&quot;)&quot; response
        response=&quot;${response:-$default_choice}&quot;
        [[ &quot;$response&quot; =~ ^[yY]$ ]] &amp;&amp; response_code=$DIALOG_SUCCESS_CODE || response_code=$DIALOG_CANCEL_CODE
    fi
    [[ $response_code -eq $DIALOG_SUCCESS_CODE ]] &amp;&amp; return 0 || return 1
}

prompt_select_option() {
    local prompt_text=&quot;$1&quot;; shift
    local -a options_array=(&quot;$@&quot;) # Pairs: &quot;tag1&quot; &quot;description1&quot; ...
    local selected_tag=&quot;&quot; dialog_exit_status

    if [[ $((${#options_array[@]} % 2)) -ne 0 || ${#options_array[@]} -eq 0 ]]; then
        error_log &quot;prompt_select_option: Options array error.&quot;; return 1;
    fi
    if [[ ${#options_array[@]} -eq 2 &amp;&amp; &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        info_log &quot;Auto-selecting only option: ${options_array[1]}&quot;; echo &quot;${options_array[0]}&quot;; return 0;
    fi

    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local temp_out; temp_out=$(create_temp_file &quot;dialog_menu&quot;) || return 1
        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Select Option&quot; --menu &quot;$prompt_text&quot; \
            ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} $((${#options_array[@]} / 2)) \
            &quot;${options_array[@]}&quot; 2&gt; &quot;$temp_out&quot;
        dialog_exit_status=$?
        selected_tag=$(sanitize_dialog_output &quot;$(cat &quot;$temp_out&quot;)&quot;)
        safe_rm &quot;$temp_out&quot;
        if [[ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]]; then info_log &quot;User cancelled selection.&quot;; return 1; fi
    else
        echo -e &quot;${COLOR_YELLOW}$prompt_text${COLOR_RESET}&quot; &gt;&amp;2
        local display_options_tags=()
        for ((i=0; i &lt; ${#options_array[@]}; i+=2)); do
            echo &quot;  $((i/2 + 1)). ${options_array[i+1]} (${options_array[i]})&quot; &gt;&amp;2
            display_options_tags+=(&quot;${options_array[i]}&quot;)
        done
        local choice_num
        while true; do
            read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}Enter choice (1-$((${#options_array[@]}/2))): ${COLOR_RESET}&quot;)&quot; choice_num
            if [[ &quot;$choice_num&quot; =~ ^[0-9]+$ &amp;&amp; &quot;$choice_num&quot; -ge 1 &amp;&amp; &quot;$choice_num&quot; -le $((${#options_array[@]}/2)) ]]; then
                selected_tag=&quot;${display_options_tags[$((choice_num-1))]}&quot;; break
            else echo -e &quot;${COLOR_RED}Invalid choice.${COLOR_RESET}&quot; &gt;&amp;2; fi
        done
    fi
    echo &quot;$selected_tag&quot;; return 0
}

# --- Network Detection Functions ---
# (detect_network_tools, detect_ethernet_interfaces, detect_wifi_interfaces from v8.0 are largely okay)
# Minor refinement to detect_wifi_interfaces to ensure unique entries robustly
detect_network_tools() {
    info_log &quot;Detecting available network management tools...&quot;
    NM_AVAILABLE=false; WPA_CLI_AVAILABLE=false; IWD_AVAILABLE=false; DHCP_CLIENT=&quot;&quot;

    if check_command nmcli &amp;&amp; systemctl is-active NetworkManager &gt;/dev/null 2&gt;&amp;1; then
        NM_AVAILABLE=true; info_log &quot;NetworkManager (nmcli) is available and active.&quot;
    else info_log &quot;NetworkManager (nmcli) is not active or not found.&quot;; fi
    
    if check_command wpa_cli; then
        WPA_CLI_AVAILABLE=true; info_log &quot;wpa_supplicant (wpa_cli command) is available.&quot;
    else info_log &quot;wpa_supplicant (wpa_cli command) not found.&quot;; fi
    
    if check_command iwctl &amp;&amp; systemctl is-active iwd &gt;/dev/null 2&gt;&amp;1; then
        IWD_AVAILABLE=true; info_log &quot;iwd (iwctl) is available and active.&quot;
    else info_log &quot;iwd (iwctl) is not active or not found.&quot;; fi
    
    for client in dhclient dhcpcd udhcpc; do
        if check_command &quot;$client&quot;; then DHCP_CLIENT=&quot;$client&quot;; info_log &quot;DHCP client found: $client&quot;; break; fi
    done
    if [[ -z &quot;$DHCP_CLIENT&quot; ]]; then warning_log &quot;No DHCP client found. DHCP may fail.&quot;; fi
}

detect_ethernet_interfaces() {
    debug_log &quot;Detecting Ethernet interfaces...&quot;
    ETH_IFACES=()
    local detected_output
    detected_output=$(debug_exec &quot;ip -o link show type ether 2&gt;/dev/null | awk -F&#39;: &#39; &#39;!/master|link\\/ether 00:00:00:00:00:00/{print \$2}&#39; | awk &#39;{print \$1}&#39; | grep -Ev &#39;^(lo|br|bond|dummy|veth|virbr|docker|tun|tap|vlan|vxlan|macvlan|macvtap|nlmon|gre|ipip|sit|ip6tnl|rename|wg)&#39; || true&quot;)
    if [[ -n &quot;$detected_output&quot; ]]; then
        while IFS= read -r iface; do
            local iface_clean; iface_clean=$(sanitize_iface_name &quot;$iface&quot;)
            if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; &amp;&amp; -e &quot;/sys/class/net/$iface_clean/device&quot; &amp;&amp; ! -e &quot;/sys/class/net/$iface_clean/virtual&quot; ]]; then
                ETH_IFACES+=(&quot;$iface_clean&quot;); debug_verbose &quot;Added Ethernet interface: &#39;$iface_clean&#39;&quot;
            elif [[ -n &quot;$iface&quot; ]]; then warning_log &quot;Skipped potentially invalid/virtual Ethernet interface: &#39;$iface&#39;&quot;; fi
        done &lt;&lt;&lt; &quot;$detected_output&quot;
    fi
    info_log &quot;Ethernet interfaces found: ${ETH_IFACES[*]:-(None)}&quot;
}

detect_wifi_interfaces() {
    debug_log &quot;Detecting Wi-Fi interfaces...&quot;
    WIFI_IFACES=()
    local detected_output=&quot;&quot; unique_wifi_ifaces_map # Use map for uniqueness

    declare -A unique_wifi_ifaces_map # Associative array for unique interface names

    # Try &#39;iw dev&#39; first
    if check_command iw; then
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;iw dev&#39;&quot;
        detected_output=$(debug_exec &quot;iw dev 2&gt;/dev/null | awk &#39;\$1==\&quot;Interface\&quot;{print \$2}&#39; || true&quot;)
        if [[ -n &quot;$detected_output&quot; ]]; then
            while IFS= read -r iface; do
                local iface_clean; iface_clean=$(sanitize_iface_name &quot;$iface&quot;)
                if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; &amp;&amp; -d &quot;/sys/class/net/${iface_clean}/wireless&quot; ]]; then
                    unique_wifi_ifaces_map[&quot;$iface_clean&quot;]=1
                fi
            done &lt;&lt;&lt; &quot;$detected_output&quot;
        fi
    fi
    
    # Fallback to &#39;ip link&#39; if &#39;iw dev&#39; found nothing or &#39;iw&#39; not present
    if [[ ${#unique_wifi_ifaces_map[@]} -eq 0 ]] &amp;&amp; check_command ip; then
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;ip link&#39; (fallback)&quot;
        detected_output=$(debug_exec &quot;ip -o link show 2&gt;/dev/null | awk -F&#39;: &#39; &#39;/wlan|wifi|wlp/{gsub(/@.*/, \&quot;\&quot;, \$2); print \$2}&#39; | awk &#39;{print \$1}&#39; | grep -E &#39;^(wlan|wlp|wifi)&#39; || true&quot;)
         if [[ -n &quot;$detected_output&quot; ]]; then
            while IFS= read -r iface; do
                local iface_clean; iface_clean=$(sanitize_iface_name &quot;$iface&quot;)
                if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; &amp;&amp; -d &quot;/sys/class/net/${iface_clean}/wireless&quot; ]]; then
                     unique_wifi_ifaces_map[&quot;$iface_clean&quot;]=1
                fi
            done &lt;&lt;&lt; &quot;$detected_output&quot;
        fi
    fi
    
    # Populate WIFI_IFACES array from the unique map keys
    for iface_key in &quot;${!unique_wifi_ifaces_map[@]}&quot;; do
        WIFI_IFACES+=(&quot;$iface_key&quot;)
        debug_verbose &quot;Added Wi-Fi interface: &#39;$iface_key&#39;&quot;
    done
    info_log &quot;Wi-Fi interfaces found: ${WIFI_IFACES[*]:-(None)}&quot;
}


# --- Interface Management Functions ---
# (ensure_interface_up from v8.0 is largely okay, minor logging tweaks if needed)
ensure_interface_up() {
    local iface=&quot;$1&quot; type=&quot;${2:-ethernet}&quot; max_attempts=3 attempt=1
    debug_log &quot;Ensuring interface $iface (type: $type) is up...&quot;
    if [[ &quot;$type&quot; == &quot;wifi&quot; ]] &amp;&amp; check_command rfkill; then
        if rfkill list wifi 2&gt;/dev/null | grep -i &quot;$iface&quot; -A2 | grep -q &quot;Hard blocked: yes&quot;; then error_log &quot;Wi-Fi $iface hard-blocked.&quot;; return 1; fi
        if rfkill list wifi 2&gt;/dev/null | grep -i &quot;$iface&quot; -A2 | grep -q &quot;Soft blocked: yes&quot;; then info_log &quot;Wi-Fi $iface soft-blocked. Unblocking...&quot;; debug_exec &quot;rfkill unblock wifi&quot;; sleep 1; fi
    fi
    if $NM_AVAILABLE; then
        local nm_state; nm_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_state&quot; == *&quot;unmanaged&quot;* ]]; then debug_log &quot;$iface unmanaged by NM. Setting managed...&quot;; nmcli device set &quot;$iface&quot; managed yes 2&gt;/dev/null || true; sleep 2; fi
    fi
    while [[ $attempt -le $max_attempts ]]; do
        debug_log &quot;Bringing up $iface (attempt $attempt/$max_attempts)...&quot;
        debug_exec &quot;ip link set \&quot;$iface\&quot; down&quot; 2&gt;/dev/null || true; sleep 0.5
        if debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then
            local wait_time=0 max_wait=5 current_state
            while [[ $wait_time -lt $max_wait ]]; do
                current_state=$(ip link show &quot;$iface&quot; 2&gt;/dev/null | grep -Po &#39;(?&lt;=state )\w+&#39; || echo &quot;UNKNOWN&quot;)
                debug_verbose &quot;$iface state: $current_state (wait: $wait_time)&quot;
                case &quot;$current_state&quot; in UP) debug_log &quot;$iface is UP.&quot;; return 0 ;;
                    DORMANT) if [[ &quot;$type&quot; == &quot;wifi&quot; ]]; then debug_log &quot;$iface DORMANT (OK for Wi-Fi).&quot;; return 0; fi ;;
                    UNKNOWN) debug_log &quot;$iface UNKNOWN (assuming OK).&quot;; return 0 ;; esac
                sleep 1; ((wait_time++)); done
            debug_log &quot;$iface up, but state $current_state after $max_wait s.&quot;; return 0;
        else warning_log &quot;&#39;ip link set $iface up&#39; failed (attempt $attempt).&quot;; fi
        if [[ &quot;$type&quot; == &quot;wifi&quot; &amp;&amp; $attempt -gt 1 ]]; then
            local driver; driver=$(basename &quot;$(readlink -f &quot;/sys/class/net/$iface/device/driver&quot; 2&gt;/dev/null)&quot; 2&gt;/dev/null || echo &quot;&quot;)
            if [[ -n &quot;$driver&quot; ]]; then _show_progress_message &quot;Reloading Wi-Fi driver $driver for $iface...&quot; &quot;transient&quot;; debug_exec &quot;pkill -f \&quot;wpa_supplicant.*$iface\&quot;&quot; || true;
                if debug_exec &quot;modprobe -r $driver&quot; 2&gt;/dev/null; then sleep 2; if debug_exec &quot;modprobe $driver&quot;; then sleep 3; info_log &quot;Driver $driver reloaded.&quot;; debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot; || true; else warning_log &quot;Failed to load $driver.&quot;; fi
                else warning_log &quot;Failed to remove $driver.&quot;; fi
            else debug_log &quot;No driver module found for $iface.&quot;; fi
        fi
        ((attempt++)); if [[ $attempt -le $max_attempts ]]; then sleep 2; fi; done
    error_log &quot;Failed to bring up $iface after $max_attempts attempts.&quot;; return 1
}

# --- Ethernet Configuration Functions ---
# (configure_dhcp, configure_static_ip, configure_ethernet from v8.0 are largely okay, will benefit from debug_exec fix)
# Example: configure_dhcp (core logic unchanged, benefits from fixed debug_exec)
configure_dhcp() {
    local iface=&quot;${1}&quot;
    info_log &quot;Configuring DHCP on $iface...&quot;
    ensure_interface_up &quot;$iface&quot; &quot;ethernet&quot; || return 1
    if $NM_AVAILABLE; then
        local nm_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_state&quot; != *&quot;unmanaged&quot;* ]]; then
            debug_log &quot;Attempting DHCP with NetworkManager for $iface.&quot;
            local profile_name=&quot;netconnect-dhcp-$iface-$$&quot;
            nmcli con delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true # Clean previous temp
            if nmcli connection add type ethernet con-name &quot;$profile_name&quot; ifname &quot;$iface&quot; ipv4.method auto ipv6.method auto connection.autoconnect no &gt;/dev/null 2&gt;&amp;1; then
                TMP_FILES_TO_CLEAN+=(&quot;nmcli_con_del_$profile_name&quot;)
                if nmcli connection up &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1; then
                    show_progress_spinner &quot;Obtaining IP via NetworkManager on $iface&quot; 5 &amp; local ppid=$!; disown $ppid 2&gt;/dev/null; wait $ppid 2&gt;/dev/null
                    sleep 2; if ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;DHCP OK via NM.&quot;; return 0;
                    else warning_log &quot;NM connected but no IP.&quot;; nmcli connection delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
                else warning_log &quot;NM &#39;con up $profile_name&#39; failed.&quot;; nmcli connection delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
            else warning_log &quot;NM &#39;con add&#39; for DHCP failed.&quot;; fi
        else debug_log &quot;NM reports $iface unmanaged, skipping NM for DHCP.&quot;; fi
    fi
    if [[ -z &quot;$DHCP_CLIENT&quot; ]]; then error_log &quot;No DHCP client for $iface.&quot;; return 1; fi
    debug_log &quot;Attempting DHCP with $DHCP_CLIENT for $iface&quot;
    case &quot;$DHCP_CLIENT&quot; in dhclient) debug_exec &quot;dhclient -r \&quot;$iface\&quot;&quot; || true ;; dhcpcd) debug_exec &quot;dhcpcd -k \&quot;$iface\&quot;&quot; || true ;; esac; sleep 1
    local dhcp_cmd_success=false
    show_progress_spinner &quot;Obtaining IP via $DHCP_CLIENT on $iface&quot; &quot;$DHCP_TIMEOUT&quot; &amp; local ppid2=$!; disown $ppid2 2&gt;/dev/null
    case &quot;$DHCP_CLIENT&quot; in
        dhclient) timeout &quot;$DHCP_TIMEOUT&quot; dhclient -v &quot;$iface&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; dhcp_cmd_success=true ;;
        dhcpcd)   timeout &quot;$DHCP_TIMEOUT&quot; dhcpcd -w &quot;$iface&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; dhcp_cmd_success=true ;;
        udhcpc)   timeout &quot;$DHCP_TIMEOUT&quot; udhcpc -i &quot;$iface&quot; -q -f -n &gt;/dev/null 2&gt;&amp;1 &amp;&amp; dhcp_cmd_success=true ;;
    esac; wait $ppid2 2&gt;/dev/null
    if $dhcp_cmd_success; then sleep 2; if ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;DHCP OK via $DHCP_CLIENT.&quot;; return 0;
        else error_log &quot;$DHCP_CLIENT OK, but no IP on $iface.&quot;; return 1; fi
    else error_log &quot;DHCP failed via $DHCP_CLIENT for $iface.&quot;; return 1; fi
}

configure_static_ip() {
    local iface=&quot;${1}&quot;
    info_log &quot;Configuring static IP on $iface...&quot;
    local ip_addr_cidr gateway dns_servers
    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then error_log &quot;Static IP not supported in non-interactive mode here.&quot;; return 1; fi
    ip_addr_cidr=$(prompt_user_input &quot;Enter IP address with CIDR (e.g., 192.168.1.100/24)&quot;) || return 1
    if [[ -z &quot;$ip_addr_cidr&quot; ]] || ! echo &quot;$ip_addr_cidr&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$&quot;; then error_log &quot;Invalid IP/CIDR: $ip_addr_cidr&quot;; return 1; fi
    gateway=$(prompt_user_input &quot;Enter gateway IP (e.g., 192.168.1.1)&quot;) || return 1
    if [[ -z &quot;$gateway&quot; ]] || ! echo &quot;$gateway&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$&quot;; then error_log &quot;Invalid Gateway: $gateway&quot;; return 1; fi
    dns_servers=$(prompt_user_input &quot;Enter DNS servers (comma-sep, optional)&quot; &quot;8.8.8.8,1.1.1.1&quot;) || dns_servers=&quot;8.8.8.8,1.1.1.1&quot;
    ensure_interface_up &quot;$iface&quot; &quot;ethernet&quot; || return 1
    if $NM_AVAILABLE; then
        local nm_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_state&quot; != *&quot;unmanaged&quot;* ]]; then
            debug_log &quot;Attempting static IP with NetworkManager for $iface.&quot;
            local profile_name=&quot;netconnect-static-$iface-$$&quot;; nmcli con delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true
            local nm_cmd_add=(nmcli con add type ethernet con-name &quot;$profile_name&quot; ifname &quot;$iface&quot; ipv4.method manual ipv4.addresses &quot;$ip_addr_cidr&quot; ipv4.gateway &quot;$gateway&quot;)
            [[ -n &quot;$dns_servers&quot; ]] &amp;&amp; nm_cmd_add+=(ipv4.dns &quot;$dns_servers&quot;); nm_cmd_add+=(ipv6.method auto connection.autoconnect no)
            if &quot;${nm_cmd_add[@]}&quot; &gt;/dev/null 2&gt;&amp;1; then TMP_FILES_TO_CLEAN+=(&quot;nmcli_con_del_$profile_name&quot;);
                if nmcli con up &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;Static IP OK via NM.&quot;; return 0;
                else warning_log &quot;NM &#39;con up $profile_name&#39; static failed.&quot;; nmcli con delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
            else warning_log &quot;NM &#39;con add&#39; static failed.&quot;; fi
        else debug_log &quot;NM reports $iface unmanaged, skipping NM for static IP.&quot;; fi
    fi
    debug_log &quot;Configuring static IP manually for $iface using iproute2&quot;
    debug_exec &quot;ip addr flush dev \&quot;$iface\&quot;&quot; || true; debug_exec &quot;ip route flush dev \&quot;$iface\&quot;&quot; || true
    if ! debug_exec &quot;ip addr add \&quot;$ip_addr_cidr\&quot; dev \&quot;$iface\&quot;&quot;; then error_log &quot;Failed to add IP $ip_addr_cidr to $iface&quot;; return 1; fi
    debug_exec &quot;ip route del default&quot; 2&gt;/dev/null || true 
    if ! debug_exec &quot;ip route add default via \&quot;$gateway\&quot; dev \&quot;$iface\&quot;&quot;; then error_log &quot;Failed to add default route via $gateway&quot;; debug_exec &quot;ip addr del \&quot;$ip_addr_cidr\&quot; dev \&quot;$iface\&quot;&quot; || true; return 1; fi
    if [[ -n &quot;$dns_servers&quot; ]]; then if ! configure_dns &quot;$dns_servers&quot; &quot;$iface&quot;; then warning_log &quot;Manual DNS config failed, IP/GW set.&quot;; fi; else info_log &quot;No DNS servers for manual config.&quot;; fi
    info_log &quot;Static IP OK via iproute2.&quot;; return 0
}

configure_ethernet() {
    local iface_to_configure=&quot;${1:-}&quot;
    if [[ ${#ETH_IFACES[@]} -eq 0 ]]; then _show_progress_message &quot;No Ethernet interfaces available.&quot; &quot;warning&quot;; return 1; fi
    if [[ -z &quot;$iface_to_configure&quot; ]]; then
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then iface_to_configure=&quot;${ETH_IFACES[0]}&quot;; info_log &quot;Non-interactive: selected Ethernet $iface_to_configure&quot;;
        else local opts=(); for eth in &quot;${ETH_IFACES[@]}&quot;; do opts+=(&quot;$eth&quot; &quot;$eth&quot;); done; iface_to_configure=$(prompt_select_option &quot;Select Ethernet interface:&quot; &quot;${opts[@]}&quot;) || return 1; fi
        [[ -z &quot;$iface_to_configure&quot; ]] &amp;&amp; { info_log &quot;No Ethernet interface selected.&quot;; return 1; }
    elif ! [[ &quot; ${ETH_IFACES[*]} &quot; =~ &quot; ${iface_to_configure} &quot; ]]; then error_log &quot;Specified Ethernet &#39;$iface_to_configure&#39; not found.&quot;; return 1; fi
    SELECTED_IFACE=&quot;$iface_to_configure&quot;; info_log &quot;Configuring Ethernet: $SELECTED_IFACE&quot;
    local cfg_choice=&quot;dhcp&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then cfg_choice=$(prompt_select_option &quot;Method for $SELECTED_IFACE:&quot; &quot;dhcp&quot; &quot;DHCP (Auto)&quot; &quot;static&quot; &quot;Static IP (Manual)&quot;) || return 1; fi
    case &quot;$cfg_choice&quot; in
        dhcp) if configure_dhcp &quot;$SELECTED_IFACE&quot;; then return 0; else warning_log &quot;DHCP failed for $SELECTED_IFACE.&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]] &amp;&amp; prompt_yes_no &quot;DHCP failed. Try static IP?&quot; &quot;n&quot;; then return configure_static_ip &quot;$SELECTED_IFACE&quot;; fi; return 1; fi ;;
        static) if configure_static_ip &quot;$SELECTED_IFACE&quot;; then return 0; else warning_log &quot;Static IP failed for $SELECTED_IFACE.&quot;; return 1; fi ;;
        *) error_log &quot;Invalid Ethernet config choice.&quot;; return 1 ;;
    esac
}

configure_dns() {
    local dns_servers_csv=&quot;$1&quot; interface_context=&quot;${2:-}&quot;
    [[ -z &quot;$dns_servers_csv&quot; ]] &amp;&amp; { debug_log &quot;No DNS servers provided.&quot;; return 0; }
    info_log &quot;Configuring DNS: $dns_servers_csv&quot;
    if [[ -f /etc/resolv.conf &amp;&amp; ! -L /etc/resolv.conf ]]; then local bak=&quot;/etc/resolv.conf.bak.$(date +%s)&quot;; if cp /etc/resolv.conf &quot;$bak&quot; 2&gt;/dev/null; then debug_log &quot;Backed up /etc/resolv.conf to $bak&quot;; else warning_log &quot;Failed to backup /etc/resolv.conf&quot;; fi; fi
    local -a dns_arr; IFS=&#39;,&#39; read -r -a dns_arr &lt;&lt;&lt; &quot;$dns_servers_csv&quot;
    if systemctl is-active systemd-resolved &gt;/dev/null 2&gt;&amp;1 &amp;&amp; check_command resolvectl; then
        local eff_iface=&quot;global&quot;; if [[ -n &quot;$interface_context&quot; ]] &amp;&amp; ip link show &quot;$interface_context&quot; &gt;/dev/null 2&gt;&amp;1; then local idx; idx=$(cat &quot;/sys/class/net/$interface_context/ifindex&quot; 2&gt;/dev/null); [[ -n &quot;$idx&quot; ]] &amp;&amp; eff_iface=&quot;$idx&quot;; fi
        if debug_exec &quot;resolvectl dns \&quot;$eff_iface\&quot; ${dns_arr[*]}&quot;; then info_log &quot;DNS OK via systemd-resolved for $eff_iface.&quot;; debug_exec &quot;resolvectl flush-caches&quot;; return 0; else warning_log &quot;systemd-resolved failed.&quot;; fi
    fi
    if check_command resolvconf; then
        local res_iface=&quot;${interface_context:-netconnect_dns}&quot;; local res_input=&quot;&quot;; for dns in &quot;${dns_arr[@]}&quot;; do res_input+=&quot;nameserver $dns\n&quot;; done
        echo &quot;&quot; | resolvconf -d &quot;$res_iface&quot; 2&gt;/dev/null || true 
        if echo -e &quot;$res_input&quot; | resolvconf -a &quot;$res_iface&quot; 2&gt;/dev/null; then info_log &quot;DNS OK via resolvconf for $res_iface.&quot;; resolvconf -u 2&gt;/dev/null || true; return 0; else warning_log &quot;resolvconf failed.&quot;; fi
    fi
    if [[ -L /etc/resolv.conf ]]; then warning_log &quot;/etc/resolv.conf is symlink. Direct write risky.&quot;; if $NM_AVAILABLE; then warning_log &quot;NM active, should handle DNS.&quot;; fi; return 1; fi
    local res_content=&quot;# Generated by $SCRIPT_NAME at $(date)\n&quot;; for dns in &quot;${dns_arr[@]}&quot;; do res_content+=&quot;nameserver $dns\n&quot;; done
    if [[ -w /etc/resolv.conf ]] || ( [[ ! -e /etc/resolv.conf ]] &amp;&amp; [[ -w /etc ]] ); then
        if echo -e &quot;$res_content&quot; &gt; /etc/resolv.conf; then info_log &quot;DNS OK via direct write to /etc/resolv.conf.&quot;; warning_log &quot;Direct write may be overwritten.&quot;; return 0; else error_log &quot;Failed direct write to /etc/resolv.conf.&quot;; return 1; fi
    else error_log &quot;Cannot write /etc/resolv.conf (permissions).&quot;; return 1; fi
}

# --- Wi-Fi Configuration Functions ---
# (ensure_wpa_supplicant_running, scan_wifi_networks, connect_wifi, configure_wifi, save_network_profile from v8.0 are complex.
# Key changes for v8.1:
# - scan_wifi_networks: nmcli part uses -g or -t -f for robust parsing.
# - ensure_wpa_supplicant_running: use PID file for termination if available.
# )

ensure_wpa_supplicant_running() {
    local iface=&quot;$1&quot;
    debug_log &quot;Ensuring wpa_supplicant is running for $iface...&quot;
    if ! $WPA_CLI_AVAILABLE; then error_log &quot;wpa_cli not found.&quot;; install_packages_dialog &quot;wpa_cli,wpasupplicant&quot; || return 1; check_command wpa_cli &amp;&amp; WPA_CLI_AVAILABLE=true || { error_log &quot;wpa_cli still not available.&quot;; return 1; }; fi
    if $NM_AVAILABLE || $IWD_AVAILABLE; then debug_log &quot;NM or iwd active, assuming they handle supplicant needs.&quot;; if $WPA_CLI_AVAILABLE; then if debug_exec &quot;wpa_cli -i \&quot;$iface\&quot; status&quot;; then WPA_SUPPLICANT_SERVICE_ACTIVE=true; return 0; else WPA_SUPPLICANT_SERVICE_ACTIVE=false; return 0; fi; fi; return 0; fi
    
    local pid_file=&quot;/var/run/wpa_supplicant_${iface}.pid&quot;
    if [[ -f &quot;$pid_file&quot; ]]; then local pid_val; pid_val=$(cat &quot;$pid_file&quot; 2&gt;/dev/null); if [[ -n &quot;$pid_val&quot; ]] &amp;&amp; kill -0 &quot;$pid_val&quot; 2&gt;/dev/null; then if debug_exec &quot;wpa_cli -i \&quot;$iface\&quot; status&quot;; then debug_log &quot;wpa_supplicant running (PID $pid_val) and responsive.&quot;; WPA_SUPPLICANT_SERVICE_ACTIVE=true; return 0; else warning_log &quot;wpa_supplicant (PID $pid_val) running but unresponsive. Killing...&quot;; kill &quot;$pid_val&quot; 2&gt;/dev/null; sleep 1; fi; else debug_log &quot;Stale PID file $pid_file. Removing.&quot;; rm -f &quot;$pid_file&quot;; fi; fi
    debug_exec &quot;pkill -f \&quot;wpa_supplicant.*[[:space:]]-i[[:space:]]*$iface\&quot;&quot; || true; sleep 1

    local wpa_conf=&quot;/etc/wpa_supplicant/wpa_supplicant-${iface}.conf&quot; wpa_ctrl=&quot;/run/wpa_supplicant&quot;
    mkdir -p &quot;$(dirname &quot;$wpa_conf&quot;)&quot; &quot;$wpa_ctrl&quot;; if [[ ! -f &quot;$wpa_conf&quot; ]]; then echo -e &quot;ctrl_interface=DIR=${wpa_ctrl} GROUP=netdev\nupdate_config=1\nap_scan=1&quot; &gt; &quot;$wpa_conf&quot;; chmod 600 &quot;$wpa_conf&quot;; fi
    info_log &quot;Starting wpa_supplicant for $iface...&quot;; local drvs=(&quot;nl80211&quot; &quot;wext&quot;) started=false
    for drv in &quot;${drvs[@]}&quot;; do debug_log &quot;Trying wpa_supplicant for $iface with driver $drv&quot;
        if debug_exec &quot;wpa_supplicant -B -P \&quot;$pid_file\&quot; -i \&quot;$iface\&quot; -c \&quot;$wpa_conf\&quot; -D\&quot;$drv\&quot;&quot;; then sleep 2; if debug_exec &quot;wpa_cli -i \&quot;$iface\&quot; status&quot;; then info_log &quot;wpa_supplicant started (driver $drv).&quot;; started=true; break; else warning_log &quot;wpa_supplicant started (driver $drv) but wpa_cli cannot connect. Killing.&quot;; local kpid; kpid=$(cat &quot;$pid_file&quot; 2&gt;/dev/null); if [[ -n &quot;$kpid&quot; ]]; then kill &quot;$kpid&quot; 2&gt;/dev/null; else pkill -f &quot;wpa_supplicant.*[[:space:]]-i[[:space:]]*$iface.*-D$drv&quot;; fi; sleep 1; fi
        else warning_log &quot;Failed to start wpa_supplicant (driver $drv).&quot;; fi; done
    if ! $started; then error_log &quot;Failed to start wpa_supplicant for $iface.&quot;; WPA_SUPPLICANT_SERVICE_ACTIVE=false; return 1; fi
    WPA_SUPPLICANT_SERVICE_ACTIVE=true; return 0
}

scan_wifi_networks() {
    local iface=&quot;$1&quot;
    info_log &quot;Scanning for Wi-Fi networks on $iface...&quot;
    local temp_scan_file; temp_scan_file=$(create_temp_file &quot;wifi_scan_${iface}&quot;) || return 1
    ensure_interface_up &quot;$iface&quot; &quot;wifi&quot; || { safe_rm &quot;$temp_scan_file&quot;; return 1; }
    
    # This global associative array will be populated.
    # Bash functions don&#39;t easily return arrays, so this is a common pattern.
    # Caller (configure_wifi) must be aware of this.
    declare -gA unique_networks_scan_result=() # Ensure it&#39;s an assoc. array
    unique_networks_scan_result=() # Clear previous results

    # Method 1: NetworkManager (refined parsing)
    if $NM_AVAILABLE; then
        local nm_dev_state; nm_dev_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_dev_state&quot; != *&quot;unavailable&quot;* &amp;&amp; &quot;$nm_dev_state&quot; != *&quot;unmanaged&quot;* ]]; then
            debug_log &quot;Scanning with NetworkManager on $iface...&quot;
            nmcli device wifi rescan ifname &quot;$iface&quot; &gt;/dev/null 2&gt;&amp;1 || true; sleep &quot;$WIFI_SCAN_TIMEOUT&quot;
            # Use -g (generic) or -t -f for machine-readable output
            # nmcli -g SSID,SECURITY,SIGNAL,FREQ dev wifi list ifname &quot;$iface&quot; --rescan no
            local nm_scan_output; nm_scan_output=$(nmcli -t -f SSID,SECURITY,SIGNAL,FREQ dev wifi list ifname &quot;$iface&quot; --rescan no 2&gt;/dev/null || true)
            if [[ -n &quot;$nm_scan_output&quot; ]]; then
                debug_log &quot;Parsing NetworkManager scan results...&quot;
                while IFS=&#39;:&#39; read -r ssid security signal freq _; do
                    # nmcli -t -f might escape colons in SSID with \:
                    ssid=&quot;${ssid//\\:/ៈ}&quot; # Temp replace escaped colon
                    ssid=&quot;${ssid//:/ }&quot; # Replace non-escaped colons (should not happen in SSID field with -f)
                    ssid=&quot;${ssid//ៈ/:}&quot; # Restore escaped colon
                    [[ -z &quot;$ssid&quot; || &quot;$ssid&quot; == &quot;--&quot; ]] &amp;&amp; continue
                    local desc=&quot;Sig: ${signal}% | Sec: ${security:-Open} | Freq: ${freq}&quot;
                    unique_networks_scan_result[&quot;$ssid&quot;]=&quot;$desc&quot;
                done &lt;&lt;&lt; &quot;$nm_scan_output&quot;
                if [[ ${#unique_networks_scan_result[@]} -gt 0 ]]; then info_log &quot;Wi-Fi scan via NM OK.&quot;; cat &quot;$temp_scan_file&quot;; return 0; fi # temp_scan_file not used here
            else warning_log &quot;NM scan on $iface yielded no results.&quot;; fi
        else warning_log &quot;NM reports $iface $nm_dev_state, skipping NM scan.&quot;; fi
    fi

    # Method 2: wpa_cli (v8.0 logic was decent, ensure robust parsing)
    if $WPA_CLI_AVAILABLE &amp;&amp; [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then
        debug_log &quot;Scanning with wpa_cli on $iface...&quot;
        ensure_wpa_supplicant_running &quot;$iface&quot; || warning_log &quot;wpa_supplicant not running, wpa_cli scan might fail.&quot;
        if wpa_cli -i &quot;$iface&quot; scan &gt;/dev/null 2&gt;&amp;1; then sleep &quot;$WIFI_SCAN_TIMEOUT&quot;;
            local wpa_scan_raw; wpa_scan_raw=$(wpa_cli -i &quot;$iface&quot; scan_results 2&gt;/dev/null | tail -n +2)
            if [[ -n &quot;$wpa_scan_raw&quot; ]]; then debug_log &quot;Parsing wpa_cli scan results...&quot;
                echo &quot;$wpa_scan_raw&quot; | awk -F&#39;\t&#39; &#39;NF&gt;=5 {ssid_val=substr($0, index($0,$5)); flags=$4; sec=&quot;Open&quot;; if(flags ~ /WPA2-PSK/||flags ~ /RSN-PSK/)sec=&quot;WPA2-PSK&quot;; else if(flags ~ /WPA-PSK/)sec=&quot;WPA-PSK&quot;; else if(flags ~ /WEP/)sec=&quot;WEP&quot;; else if(flags ~ /SAE/)sec=&quot;WPA3-SAE&quot;; if(ssid_val!=&quot;&quot;&amp;&amp;ssid_val!=&quot;\\x00&quot;&amp;&amp;flags~/ESS/){gsub(/^&quot;|&quot;$/,&quot;&quot;,ssid_val);gsub(/[[:cntrl:]]/,&quot;&quot;,ssid_val);sig_val=$3;sq=sig_val;if(sig_val&lt;=-100)sq=0;else if(sig_val&gt;=-50)sq=100;else sq=2*(sig_val+100); printf &quot;%s|%s|%s|%s\n&quot;,ssid_val,sec,sq,$2;}}&#39; &gt; &quot;$temp_scan_file&quot;
                if [[ -s &quot;$temp_scan_file&quot; ]]; then 
                    while IFS=&#39;|&#39; read -r ssid security signal freq; do unique_networks_scan_result[&quot;$ssid&quot;]=&quot;Sig: ${signal}% | Sec: ${security} | Freq: ${freq}&quot;; done &lt; &quot;$temp_scan_file&quot;
                    if [[ ${#unique_networks_scan_result[@]} -gt 0 ]]; then info_log &quot;Wi-Fi scan via wpa_cli OK.&quot;; return 0; fi
                fi
            else warning_log &quot;wpa_cli scan yielded no results.&quot;; fi
        else warning_log &quot;wpa_cli scan command failed.&quot;; fi
    fi
    
    # Method 3: iw (fallback, parsing is simplified)
    if check_command iw &amp;&amp; [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then
        debug_log &quot;Scanning with iw on $iface...&quot;
        local iw_scan_raw; iw_scan_raw=$(iw dev &quot;$iface&quot; scan 2&gt;/dev/null || true)
        if [[ -n &quot;$iw_scan_raw&quot; ]]; then debug_log &quot;Parsing iw scan results...&quot;
            echo &quot;$iw_scan_raw&quot; | awk &#39;/^BSS / {if(cs!=&quot;&quot;)pn();cb=substr($2,1,17);cs=&quot;&quot;;csig=&quot;&quot;;cf=&quot;&quot;;csec=&quot;Open&quot;;} /\tSSID: / {cs=substr($0,index($0,$2));} /\tsignal: / {csig=sprintf(&quot;%.0f&quot;,$2);} /\tfreq: / {cf=$2;} /\tRSN:/ {csec=&quot;WPA2&quot;;} /\tWPA:/ {if(csec==&quot;Open&quot;)csec=&quot;WPA&quot;;} /\tPrivacy: / {if($2==&quot;on&quot;&amp;&amp;csec==&quot;Open&quot;)csec=&quot;WEP&quot;;} /\tcapability:.*ESS/{ie=1;} END{if(cs!=&quot;&quot;)pn();} function pn(){if(ie&amp;&amp;cs!~/^\\x00/){gsub(/[[:cntrl:]]/,&quot;&quot;,cs);sq=csig;if(csig&lt;=-100)sq=0;else if(csig&gt;=-50)sq=100;else sq=2*(csig+100);printf &quot;%s|%s|%s|%s\n&quot;,cs,csec,sq,cf;}ie=0;}&#39; &gt; &quot;$temp_scan_file&quot;
            if [[ -s &quot;$temp_scan_file&quot; ]]; then
                while IFS=&#39;|&#39; read -r ssid security signal freq; do unique_networks_scan_result[&quot;$ssid&quot;]=&quot;Sig: ${signal}% | Sec: ${security} | Freq: ${freq}&quot;; done &lt; &quot;$temp_scan_file&quot;
                if [[ ${#unique_networks_scan_result[@]} -gt 0 ]]; then info_log &quot;Wi-Fi scan via iw OK.&quot;; return 0; fi
            fi
        else warning_log &quot;iw scan yielded no results.&quot;; fi
    fi

    safe_rm &quot;$temp_scan_file&quot;
    if [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then error_log &quot;All Wi-Fi scanning methods failed or no networks found.&quot;; return 1; fi
    return 0 # unique_networks_scan_result is populated
}

connect_wifi() {
    local iface=&quot;$1&quot; ssid=&quot;$2&quot; password=&quot;${3:-}&quot; security_type=&quot;${4:-}&quot; is_hidden=&quot;${5:-false}&quot;
    info_log &quot;Attempting to connect to Wi-Fi: &#39;$ssid&#39; on $iface (Sec: ${security_type:-auto}, Hidden: $is_hidden)&quot;
    ensure_interface_up &quot;$iface&quot; &quot;wifi&quot; || return 1
    if $NM_AVAILABLE; then debug_log &quot;Trying NM for &#39;$ssid&#39;...&quot;
        local nm_cmd=(&quot;nmcli&quot; &quot;dev&quot; &quot;wifi&quot; &quot;connect&quot; &quot;$ssid&quot; &quot;ifname&quot; &quot;$iface&quot;); [[ -n &quot;$password&quot; ]] &amp;&amp; nm_cmd+=(&quot;password&quot; &quot;$password&quot;); [[ &quot;$is_hidden&quot; == &quot;true&quot; ]] &amp;&amp; nm_cmd+=(&quot;hidden&quot; &quot;yes&quot;)
        local nm_con=&quot;netconnect-$ssid-$$&quot;; nm_cmd+=(&quot;name&quot; &quot;$nm_con&quot;); nmcli con delete id &quot;$nm_con&quot; &gt;/dev/null 2&gt;&amp;1 || true
        show_progress_spinner &quot;Connecting &#39;$ssid&#39; via NM&quot; &quot;$WIFI_CONNECT_TIMEOUT&quot; &amp; local ppid=$!; disown $ppid 2&gt;/dev/null
        if &quot;${nm_cmd[@]}&quot; &gt;/dev/null 2&gt;&amp;1; then wait $ppid 2&gt;/dev/null; TMP_FILES_TO_CLEAN+=(&quot;nmcli_con_del_$nm_con&quot;); sleep 3; if nmcli -t -f GENERAL.STATE dev show &quot;$iface&quot; 2&gt;/dev/null | grep -q &quot;100 (connected)&quot; &amp;&amp; ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;NM connected to &#39;$ssid&#39;.&quot;; return 0; else warning_log &quot;NM connected to &#39;$ssid&#39; but no IP/full state.&quot;; nmcli con delete id &quot;$nm_con&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
        else wait $ppid 2&gt;/dev/null; warning_log &quot;NM failed to connect to &#39;$ssid&#39;.&quot;; nmcli con delete id &quot;$nm_con&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
    fi
    if $WPA_CLI_AVAILABLE; then debug_log &quot;Trying wpa_cli for &#39;$ssid&#39;...&quot;
        ensure_wpa_supplicant_running &quot;$iface&quot; || return 1
        wpa_cli -i &quot;$iface&quot; list_networks | grep &quot;$ssid&quot; | awk &#39;{print $1}&#39; | while read -r nid; do wpa_cli -i &quot;$iface&quot; remove_network &quot;$nid&quot; &gt;/dev/null 2&gt;&amp;1; done
        local net_id; net_id=$(wpa_cli -i &quot;$iface&quot; add_network | tail -1); if ! [[ &quot;$net_id&quot; =~ ^[0-9]+$ ]]; then error_log &quot;Failed to add net via wpa_cli for &#39;$ssid&#39;.&quot;; return 1; fi
        wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; ssid &quot;\&quot;$ssid\&quot;&quot; &gt;/dev/null; [[ &quot;$is_hidden&quot; == &quot;true&quot; ]] &amp;&amp; wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; scan_ssid 1 &gt;/dev/null
        local km_set=false; if [[ -n &quot;$security_type&quot; ]]; then case &quot;$security_type&quot; in Open)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt NONE &gt;/dev/null;km_set=true;; WEP)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt NONE &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; wep_key0 &quot;\&quot;$password\&quot;&quot; &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; wep_tx_keyidx 0 &gt;/dev/null;km_set=true;; *PSK)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt WPA-PSK &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; psk &quot;\&quot;$password\&quot;&quot; &gt;/dev/null;km_set=true;; *SAE)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt SAE &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; sae_password &quot;\&quot;$password\&quot;&quot; &gt;/dev/null;km_set=true;; esac; fi
        if [[ -z &quot;$password&quot; &amp;&amp; &quot;$security_type&quot; != &quot;Open&quot; &amp;&amp; &quot;$km_set&quot; == &quot;false&quot; ]]; then warning_log &quot;No pass for secured &#39;$ssid&#39; ($security_type).&quot;; elif [[ -n &quot;$password&quot; &amp;&amp; &quot;$km_set&quot; == &quot;false&quot; ]]; then wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; psk &quot;\&quot;$password\&quot;&quot; &gt;/dev/null; fi
        wpa_cli -i &quot;$iface&quot; enable_network &quot;$net_id&quot; &gt;/dev/null; wpa_cli -i &quot;$iface&quot; select_network &quot;$net_id&quot; &gt;/dev/null
        show_progress_spinner &quot;Connecting &#39;$ssid&#39; via wpa_cli&quot; &quot;$WIFI_CONNECT_TIMEOUT&quot; &amp; local ppid_wpa=$!; disown $ppid_wpa 2&gt;/dev/null
        local conn_wpa=false wpa_tries=$((WIFI_CONNECT_TIMEOUT/2)); for ((i=0;i&lt;wpa_tries;i++)); do local st; st=$(wpa_cli -i &quot;$iface&quot; status 2&gt;/dev/null); if echo &quot;$st&quot;|grep -q &quot;wpa_state=COMPLETED&quot;; then conn_wpa=true;break; fi; if echo &quot;$st&quot;|grep -q &quot;reason=WRONG_KEY&quot;; then error_log &quot;wpa_cli: WRONG KEY for &#39;$ssid&#39;.&quot;; break; fi; sleep 2; done; wait $ppid_wpa 2&gt;/dev/null
        if $conn_wpa; then info_log &quot;wpa_cli associated &#39;$ssid&#39;. DHCP...&quot;; wpa_cli -i &quot;$iface&quot; save_config &gt;/dev/null 2&gt;&amp;1 || warning_log &quot;Failed to save wpa_supplicant config.&quot;; if configure_dhcp &quot;$iface&quot;; then return 0; else error_log &quot;wpa_cli associated, DHCP failed.&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]] &amp;&amp; prompt_yes_no &quot;DHCP failed for &#39;$ssid&#39;. Static IP?&quot; &quot;n&quot;; then if configure_static_ip &quot;$iface&quot;; then return 0; fi; fi; fi
        else warning_log &quot;wpa_cli connect to &#39;$ssid&#39; failed.&quot;; fi; wpa_cli -i &quot;$iface&quot; remove_network &quot;$net_id&quot; &gt;/dev/null 2&gt;&amp;1
    fi
    if $IWD_AVAILABLE; then debug_log &quot;Trying iwd for &#39;$ssid&#39;...&quot;
        local iw_cmd=(&quot;iwctl&quot; &quot;--no-pager&quot; &quot;station&quot; &quot;$iface&quot; &quot;connect&quot; &quot;$ssid&quot;); [[ -n &quot;$password&quot; ]] &amp;&amp; iw_cmd+=(&quot;--passphrase&quot; &quot;$password&quot;)
        show_progress_spinner &quot;Connecting &#39;$ssid&#39; via iwd&quot; &quot;$WIFI_CONNECT_TIMEOUT&quot; &amp; local ppid_iwd=$!; disown $ppid_iwd 2&gt;/dev/null
        if debug_exec &quot;${iw_cmd[@]}&quot;; then wait $ppid_iwd 2&gt;/dev/null; sleep 3; if iwctl station &quot;$iface&quot; show 2&gt;/dev/null | grep -q &quot;State.*connected&quot; &amp;&amp; ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;iwd connected to &#39;$ssid&#39;.&quot;; return 0; else warning_log &quot;iwd connected but no IP/full state.&quot;; fi
        else wait $ppid_iwd 2&gt;/dev/null; warning_log &quot;iwd failed to connect to &#39;$ssid&#39;.&quot;; fi
    fi
    error_log &quot;All Wi-Fi connection methods failed for &#39;$ssid&#39;.&quot;; return 1
}

# Global associative array for scan results, populated by scan_wifi_networks
declare -gA unique_networks_scan_result=()
configure_wifi() {
    local iface_to_configure=&quot;${1:-}&quot;
    unique_networks_scan_result=() # Clear previous
    if [[ ${#WIFI_IFACES[@]} -eq 0 ]]; then _show_progress_message &quot;No Wi-Fi interfaces.&quot; &quot;warning&quot;; return 1; fi
    if [[ -z &quot;$iface_to_configure&quot; ]]; then
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then iface_to_configure=&quot;${WIFI_IFACES[0]}&quot;; info_log &quot;Non-interactive: selected Wi-Fi $iface_to_configure&quot;;
        else local opts=(); for wf in &quot;${WIFI_IFACES[@]}&quot;; do opts+=(&quot;$wf&quot; &quot;$wf&quot;); done; iface_to_configure=$(prompt_select_option &quot;Select Wi-Fi interface:&quot; &quot;${opts[@]}&quot;) || return 1; fi
        [[ -z &quot;$iface_to_configure&quot; ]] &amp;&amp; { info_log &quot;No Wi-Fi interface selected.&quot;; return 1; }
    elif ! [[ &quot; ${WIFI_IFACES[*]} &quot; =~ &quot; ${iface_to_configure} &quot; ]]; then error_log &quot;Specified Wi-Fi &#39;$iface_to_configure&#39; not found.&quot;; return 1; fi
    SELECTED_IFACE=&quot;$iface_to_configure&quot;; info_log &quot;Configuring Wi-Fi: $SELECTED_IFACE&quot;
    _show_progress_message &quot;Scanning for networks on $SELECTED_IFACE...&quot; &quot;transient&quot;
    if ! scan_wifi_networks &quot;$SELECTED_IFACE&quot;; then # Populates global unique_networks_scan_result
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]] &amp;&amp; prompt_yes_no &quot;No networks found. Connect to hidden?&quot; &quot;n&quot;; then
            local h_ssid h_pass h_sec=&quot;WPA2-PSK&quot;; h_ssid=$(prompt_user_input &quot;Hidden SSID:&quot;) || return 1; [[ -z &quot;$h_ssid&quot; ]] &amp;&amp; { error_log &quot;Hidden SSID empty.&quot;; return 1; }
            h_pass=$(prompt_user_input &quot;Password for &#39;$h_ssid&#39; (empty for open):&quot; &quot;&quot; true); if [[ -z &quot;$h_pass&quot; ]]; then h_sec=&quot;Open&quot;; if ! prompt_yes_no &quot;Connect to &#39;$h_ssid&#39; as Open?&quot; &quot;y&quot;; then return 1; fi; fi
            return connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$h_ssid&quot; &quot;$h_pass&quot; &quot;$h_sec&quot; &quot;true&quot;
        fi; _show_progress_message &quot;No Wi-Fi networks found/selected for $SELECTED_IFACE.&quot; &quot;warning&quot;; return 1;
    fi
    if [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then _show_progress_message &quot;No Wi-Fi networks from scan.&quot; &quot;warning&quot;; return 1; fi
    local -a dlg_scan_opts=(); for skey in &quot;${!unique_networks_scan_result[@]}&quot;; do local s_trunc=&quot;$skey&quot;; [[ ${#s_trunc} -gt 30 ]] &amp;&amp; s_trunc=&quot;${s_trunc:0:27}...&quot;; dlg_scan_opts+=(&quot;$skey&quot; &quot;$s_trunc (${unique_networks_scan_result[$skey]})&quot;); done
    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then error_log &quot;Interactive Wi-Fi selection not supported here in non-interactive. Use profiles.&quot;; return 1; fi
    local sel_ssid_tag; sel_ssid_tag=$(prompt_select_option &quot;Select Wi-Fi network on $SELECTED_IFACE:&quot; &quot;${dlg_scan_opts[@]}&quot;) || return 1; [[ -z &quot;$sel_ssid_tag&quot; ]] &amp;&amp; { info_log &quot;No network selected.&quot;; return 1; }
    local sel_desc=&quot;${unique_networks_scan_result[$sel_ssid_tag]}&quot; sel_sec=&quot;WPA2-PSK&quot;; if [[ &quot;$sel_desc&quot; =~ Sec:[[:space:]]*([^[:space:]]+) ]]; then sel_sec=&quot;${BASH_REMATCH[1]}&quot;; elif [[ &quot;$sel_desc&quot; =~ Open ]]; then sel_sec=&quot;Open&quot;; fi
    local wf_pass=&quot;&quot;; if ! [[ &quot;$sel_sec&quot; =~ ^(Open|--)$ || -z &quot;$sel_sec&quot; ]]; then wf_pass=$(prompt_user_input &quot;Password for &#39;$sel_ssid_tag&#39;:&quot; &quot;&quot; true) || return 1; if [[ &quot;$sel_sec&quot; != &quot;WEP&quot; &amp;&amp; ${#wf_pass} -lt 8 &amp;&amp; -n &quot;$wf_pass&quot; ]]; then if ! prompt_yes_no &quot;Password for &#39;$sel_ssid_tag&#39; short. Continue?&quot; &quot;y&quot;; then return 1; fi; elif [[ -z &quot;$wf_pass&quot; ]]; then if ! prompt_yes_no &quot;Empty pass for secured &#39;$sel_ssid_tag&#39;. Treat as Open?&quot; &quot;n&quot;; then return 1; else sel_sec=&quot;Open&quot;; fi; fi; fi
    if connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$sel_ssid_tag&quot; &quot;$wf_pass&quot; &quot;$sel_sec&quot; &quot;false&quot;; then save_network_profile &quot;$SELECTED_IFACE&quot; &quot;$sel_ssid_tag&quot; &quot;$wf_pass&quot; &quot;$sel_sec&quot; &quot;false&quot;; return 0; fi
    return 1
}

save_network_profile() {
    local iface=&quot;$1&quot; ssid=&quot;$2&quot; password=&quot;$3&quot; security=&quot;$4&quot; hidden=&quot;$5&quot;
    local safe_fn=&quot;${ssid//[^a-zA-Z0-9._-]/_}&quot;; [[ -z &quot;$safe_fn&quot; ]] &amp;&amp; safe_fn=&quot;unnamed_ssid&quot;
    local pf=&quot;${PROFILE_DIR}/${iface}_${safe_fn}.conf&quot;; debug_log &quot;Saving profile: $pf&quot;
    mkdir -p &quot;$PROFILE_DIR&quot; 2&gt;/dev/null || warning_log &quot;Could not create $PROFILE_DIR&quot;
    (umask 077; cat &gt; &quot;$pf&quot; &lt;&lt;EOF
# Profile for SSID: $ssid on $iface by $SCRIPT_NAME v$SCRIPT_VERSION at $(date -Iseconds)
INTERFACE=&quot;$iface&quot;
SSID=&quot;$ssid&quot;
SECURITY=&quot;$security&quot;
HIDDEN=&quot;$hidden&quot;
$( [[ -n &quot;$password&quot; ]] &amp;&amp; echo &quot;PASSWORD_ENC=\&quot;$(echo -n &quot;$password&quot; | base64)\&quot;&quot; )
EOF
    ) &amp;&amp; info_log &quot;Profile saved: $pf&quot; || error_log &quot;Failed to save profile $pf&quot;
}

# --- Connectivity Check ---
# (check_connectivity from v8.0 is largely okay)
check_connectivity() {
    local test_type=&quot;${1:-full}&quot;
    _show_progress_message &quot;Checking network connectivity...&quot; &quot;transient&quot;
    local ping_tgt_ip=&quot;$PING_IP_PRIMARY&quot;; if ! ping -c 1 -W &quot;$PING_TIMEOUT&quot; &quot;$ping_tgt_ip&quot; &gt;/dev/null 2&gt;&amp;1; then ping_tgt_ip=&quot;$PING_IP_SECONDARY&quot;; fi
    if ping -c &quot;$PING_COUNT&quot; -W &quot;$PING_TIMEOUT&quot; &quot;$ping_tgt_ip&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;✓ IP connectivity to $ping_tgt_ip OK.&quot;; if [[ &quot;$test_type&quot; == &quot;basic&quot; ]]; then return 0; fi
        if ping -c &quot;$PING_COUNT&quot; -W &quot;$PING_TIMEOUT&quot; &quot;$PING_HOSTNAME&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;✓ DNS for $PING_HOSTNAME OK.&quot;; if check_command curl; then if curl -s --connect-timeout 5 -L &quot;http://$PING_HOSTNAME&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;✓ HTTP to $PING_HOSTNAME OK.&quot;; else warning_log &quot;HTTP to $PING_HOSTNAME failed (curl).&quot;; fi; fi; _show_progress_message &quot;Network UP (IP, DNS, HTTP tested).&quot; &quot;persistent&quot;; return 0;
        else warning_log &quot;DNS for $PING_HOSTNAME failed.&quot;; _show_progress_message &quot;Network PARTIAL (IP OK, DNS FAILED).&quot; &quot;warning&quot;; return 2; fi
    else warning_log &quot;No IP connectivity to $PING_IP_PRIMARY or $PING_IP_SECONDARY.&quot;; _show_progress_message &quot;Network DOWN (No IP connectivity).&quot; &quot;error&quot;; return 1; fi
}

# --- Main Script Functions ---
# (usage, parse_arguments, show_network_status, main from v8.0 are largely okay but need to use new prompt functions and integrate argument handling better)
usage() {
    local usage_text=&quot;Usage: sudo $SCRIPT_NAME [OPTIONS]

Universal Network Connectivity Script v$SCRIPT_VERSION

Configure Ethernet/Wi-Fi. Uses &#39;dialog&#39; for TUI if available.

OPTIONS:
  -h, --help             Show help and exit.
  -v, --version          Show version and exit.
  -d, --debug            Enable full debug (level 3).
  --debug-level LEVEL    Set debug level (1:basic, 2:verbose, 3:full).
  -V, --verbose          Alias for --debug-level 2.
  -n, --non-interactive  Run non-interactively (auto-config).
  -i, --interface IFACE  Specify interface to configure.
  -t, --type TYPE        Specify type (&#39;ethernet&#39;|&#39;wifi&#39;) for -i.
  -c, --check-only       Check connectivity, don&#39;t configure.
  --ssid SSID            (Wi-Fi) SSID to connect to (used with -i, -t wifi).
  --password PASS        (Wi-Fi) Password for SSID.
  --security SEC         (Wi-Fi) Security (WPA2-PSK, Open, WEP, WPA3-SAE).
  --hidden               (Wi-Fi) SSID is hidden.
  --install-deps         Check/install dependencies then exit.
  --status               Show network status and exit.

EXAMPLES:
  sudo $SCRIPT_NAME                     # Interactive mode
  sudo $SCRIPT_NAME -n                  # Non-interactive auto
  sudo $SCRIPT_NAME -i eth0 -t ethernet # Configure eth0
  sudo $SCRIPT_NAME -i wlan0 -t wifi --ssid \&quot;MyNet\&quot; --password \&quot;MyPass\&quot; 
&quot;
    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then _show_dialog_message &quot;msgbox&quot; &quot;Help - $SCRIPT_NAME v$SCRIPT_VERSION&quot; &quot;$usage_text&quot; 25 78; else echo -e &quot;$usage_text&quot;; fi
}

parse_arguments() {
    declare -g cli_ssid=&quot;&quot; cli_password=&quot;&quot; cli_security=&quot;&quot; cli_hidden=false # For direct Wi-Fi args
    # Reset flags that might be set if script is sourced/re-run in same shell
    DBG=false; DEBUG_LEVEL=1; NON_INTERACTIVE=false; SELECTED_IFACE=&quot;&quot;; CONNECTION_TYPE_ARG=&quot;&quot;; CHECK_ONLY_ARG=false
    INSTALL_DEPS_ARG=false; SHOW_STATUS_ARG=false

    while [[ $# -gt 0 ]]; do
        case &quot;$1&quot; in -h|--help) usage; exit 0 ;; -v|--version) echo &quot;$SCRIPT_NAME v$SCRIPT_VERSION&quot;; exit 0 ;;
            -d|--debug) DBG=true; DEBUG_LEVEL=3; shift ;;
            --debug-level) DBG=true; if [[ &quot;$2&quot; =~ ^[1-3]$ ]]; then DEBUG_LEVEL=&quot;$2&quot;; else echo &quot;Invalid debug level: $2&quot; &gt;&amp;2; exit 1; fi; shift 2 ;;
            -V|--verbose) DBG=true; DEBUG_LEVEL=2; shift ;;
            -n|--non-interactive) NON_INTERACTIVE=true; shift ;;
            -i|--interface) SELECTED_IFACE=&quot;$2&quot;; shift 2 ;;
            -t|--type) CONNECTION_TYPE_ARG=$(echo &quot;$2&quot;|tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;); shift 2 ;;
            -c|--check-only) CHECK_ONLY_ARG=true; shift ;;
            --ssid) cli_ssid=&quot;$2&quot;; shift 2 ;; --password) cli_password=&quot;$2&quot;; shift 2 ;;
            --security) cli_security=&quot;$2&quot;; shift 2 ;; --hidden) cli_hidden=true; shift ;;
            --install-deps) INSTALL_DEPS_ARG=true; shift ;; --status) SHOW_STATUS_ARG=true; shift ;;
            *) _base_log &quot;ERROR&quot; &quot;$COLOR_RED&quot; &quot;Unknown option: $1&quot;; usage; exit 1 ;;
        esac; done
    if [[ -n &quot;$cli_ssid&quot; ]]; then if [[ -z &quot;$SELECTED_IFACE&quot; || &quot;$CONNECTION_TYPE_ARG&quot; != &quot;wifi&quot; ]]; then _base_log &quot;ERROR&quot; &quot;$COLOR_RED&quot; &quot;--ssid requires -i &lt;wifi-iface&gt; and -t wifi.&quot;; usage; exit 1; fi; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then info_log &quot;Direct Wi-Fi params for non-interactive: $SELECTED_IFACE, SSID:$cli_ssid&quot;; declare -g DIRECT_WIFI_SSID=&quot;$cli_ssid&quot;; declare -g DIRECT_WIFI_PASS=&quot;$cli_password&quot;; declare -g DIRECT_WIFI_SEC=&quot;$cli_security&quot;; declare -g DIRECT_WIFI_HIDDEN=&quot;$cli_hidden&quot;; else warning_log &quot;--ssid etc. for non-interactive use primarily.&quot;; fi; fi
}

show_network_status() {
    _show_progress_message &quot;Gathering network status...&quot; &quot;transient&quot;
    local status_text=&quot;&quot;
    status_text+=&quot;\n=== Network Status ===\n&quot;
    status_text+=&quot;\n--- Network Interfaces (ip -br addr) ---\n$(ip -br addr show 2&gt;/dev/null || echo &quot;Failed to get interface addresses.&quot;)\n&quot;
    status_text+=&quot;\n--- Routing Table (ip route) ---\n$(ip route show 2&gt;/dev/null || echo &quot;Failed to get routing table.&quot;)\n&quot;
    status_text+=&quot;\n--- DNS Configuration (/etc/resolv.conf) ---\n&quot;
    if [[ -f /etc/resolv.conf ]]; then status_text+=&quot;$(grep -v &#39;^#&#39; /etc/resolv.conf | grep &#39;nameserver&#39; || echo &quot;No nameservers in /etc/resolv.conf.&quot;)&quot;; else status_text+=&quot;/etc/resolv.conf not found.&quot;; fi
    status_text+=&quot;\n&quot;
    if systemctl is-active systemd-resolved &gt;/dev/null 2&gt;&amp;1 &amp;&amp; check_command resolvectl; then status_text+=&quot;\n--- Systemd-Resolved Status ---\n$(resolvectl status 2&gt;/dev/null || echo &quot;Failed to get resolvectl status.&quot;)\n&quot;; fi
    status_text+=&quot;\n--- Connectivity Test ---\n&quot; # check_connectivity will print its own messages
    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then _show_dialog_message &quot;msgbox&quot; &quot;Network Status&quot; &quot;$status_text&quot; 20 75; else echo -e &quot;$status_text&quot;; fi
    check_connectivity &quot;full&quot;
}

main() {
    # Global flags that parse_arguments will set.
    declare -g INSTALL_DEPS_ARG=false SHOW_STATUS_ARG=false
    parse_arguments &quot;$@&quot;
    if $DBG; then mkdir -p &quot;$LOG_DIR&quot; 2&gt;/dev/null; DEBUG_LOG_FILE=&quot;${LOG_DIR}/netconnect_debug_$(date +%Y%m%d_%H%M%S)_$$.log&quot;; if ! touch &quot;$DEBUG_LOG_FILE&quot; 2&gt;/dev/null; then echo &quot;WARN: Cannot write debug log $DEBUG_LOG_FILE&quot; &gt;&amp;2; DEBUG_LOG_FILE=&quot;&quot;; else _base_log &quot;INFO&quot; &quot;$COLOR_GREEN&quot; &quot;Debug mode L$DEBUG_LEVEL. Log: $DEBUG_LOG_FILE&quot;; eval &quot;exec $XTRACE_FD&gt;&gt;\&quot;\$DEBUG_LOG_FILE\&quot;&quot;; export BASH_XTRACEFD=&quot;$XTRACE_FD&quot;; set -x; fi; fi
    debug_log &quot;Script $SCRIPT_NAME v$SCRIPT_VERSION started (PID $$)&quot;; debug_var_array=(&quot;NON_INTERACTIVE&quot; &quot;SELECTED_IFACE&quot; &quot;CONNECTION_TYPE_ARG&quot; &quot;CHECK_ONLY_ARG&quot;); for v in &quot;${debug_var_array[@]}&quot;; do debug_var &quot;$v&quot;; done
    check_root; acquire_lock; init_directories
    if check_command dialog; then DIALOG_AVAILABLE=true; debug_log &quot;Dialog available.&quot;; else DIALOG_AVAILABLE=false; info_log &quot;Dialog not found. Basic prompts.&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then install_packages_dialog &quot;dialog,dialog&quot; || info_log &quot;Proceeding without dialog.&quot;; fi; fi
    if ! $DIALOG_AVAILABLE || [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then echo -e &quot;${COLOR_GREEN}=== $SCRIPT_NAME v$SCRIPT_VERSION ===${COLOR_RESET}\n&quot; &gt;&amp;2; else &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;$SCRIPT_NAME&quot; --msgbox &quot;Welcome to Universal Network Connectivity Script v$SCRIPT_VERSION&quot; 8 60 2&gt;/dev/tty; fi
    if $INSTALL_DEPS_ARG; then info_log &quot;Checking/installing dependencies...&quot;; local deps=(&quot;dialog,dialog&quot; &quot;ip,iproute2&quot; &quot;ping,iputils-ping&quot; &quot;curl,curl&quot; &quot;nmcli,network-manager&quot; &quot;wpa_cli,wpasupplicant&quot; &quot;iw,iw&quot;); install_packages_dialog &quot;${deps[@]}&quot;; exit 0; fi
    detect_network_tools; detect_ethernet_interfaces; detect_wifi_interfaces
    if $SHOW_STATUS_ARG; then show_network_status; exit 0; fi
    if check_connectivity &quot;basic&quot;; then info_log &quot;✓ Internet connection active.&quot;; if $CHECK_ONLY_ARG; then exit 0; fi; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then if ! prompt_yes_no &quot;Connection active. Reconfigure?&quot; &quot;n&quot;; then exit 0; fi; else info_log &quot;Non-interactive: Exiting, connection active.&quot;; exit 0; fi; else info_log &quot;No active connection. Proceeding...&quot;; if $CHECK_ONLY_ARG; then exit 1; fi; fi

    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then info_log &quot;Non-interactive mode...&quot;; local connected=false
        if [[ -n &quot;$SELECTED_IFACE&quot; &amp;&amp; -n &quot;$CONNECTION_TYPE_ARG&quot; ]]; then info_log &quot;Configuring specified $SELECTED_IFACE ($CONNECTION_TYPE_ARG)...&quot;
            if [[ &quot;$CONNECTION_TYPE_ARG&quot; == &quot;ethernet&quot; ]]; then if configure_ethernet &quot;$SELECTED_IFACE&quot;; then check_connectivity &amp;&amp; connected=true; fi
            elif [[ &quot;$CONNECTION_TYPE_ARG&quot; == &quot;wifi&quot; ]]; then if [[ -n &quot;${DIRECT_WIFI_SSID:-}&quot; ]]; then if connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$DIRECT_WIFI_SSID&quot; &quot;${DIRECT_WIFI_PASS:-}&quot; &quot;${DIRECT_WIFI_SEC:-}&quot; &quot;${DIRECT_WIFI_HIDDEN:-false}&quot;; then check_connectivity &amp;&amp; connected=true; fi; else info_log &quot;No direct SSID for $SELECTED_IFACE. Trying profiles...&quot;; for pf in &quot;${PROFILE_DIR}/${SELECTED_IFACE}_&quot;*.conf; do if [[ -f &quot;$pf&quot; ]]; then debug_log &quot;Profile: $pf&quot;; local PI PS PSEC PPASSENC PHID; source &quot;$pf&quot;; PI=&quot;${INTERFACE:-}&quot;; PS=&quot;${SSID:-}&quot;; PSEC=&quot;${SECURITY:-}&quot;; PPASSENC=&quot;${PASSWORD_ENC:-}&quot;; PHID=&quot;${HIDDEN:-false}&quot;; if [[ &quot;$PI&quot; == &quot;$SELECTED_IFACE&quot; &amp;&amp; -n &quot;$PS&quot; ]]; then local pp; [[ -n &quot;$PPASSENC&quot; ]] &amp;&amp; pp=$(echo &quot;$PPASSENC&quot;|base64 -d); if connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$PS&quot; &quot;$pp&quot; &quot;$PSEC&quot; &quot;$PHID&quot;; then if check_connectivity; then connected=true; break; fi; fi; fi; fi; done; fi; fi
        fi
        if ! $connected; then info_log &quot;Specified config failed or no specific args. Trying auto...&quot;; for eth_if in &quot;${ETH_IFACES[@]}&quot;; do if configure_dhcp &quot;$eth_if&quot;; then if check_connectivity; then connected=true; break; fi; fi; done
            if ! $connected &amp;&amp; [[ ${#WIFI_IFACES[@]} -gt 0 ]]; then for wifi_if in &quot;${WIFI_IFACES[@]}&quot;; do for pf in &quot;${PROFILE_DIR}/${wifi_if}_&quot;*.conf; do if [[ -f &quot;$pf&quot; ]]; then debug_log &quot;Profile: $pf for $wifi_if&quot;; local PI PS PSEC PPASSENC PHID; source &quot;$pf&quot;; PI=&quot;${INTERFACE:-}&quot;; PS=&quot;${SSID:-}&quot;; PSEC=&quot;${SECURITY:-}&quot;; PPASSENC=&quot;${PASSWORD_ENC:-}&quot;; PHID=&quot;${HIDDEN:-false}&quot;; if [[ &quot;$PI&quot; == &quot;$wifi_if&quot; &amp;&amp; -n &quot;$PS&quot; ]]; then local pp; [[ -n &quot;$PPASSENC&quot; ]] &amp;&amp; pp=$(echo &quot;$PPASSENC&quot;|base64 -d); if connect_wifi &quot;$wifi_if&quot; &quot;$PS&quot; &quot;$pp&quot; &quot;$PSEC&quot; &quot;$PHID&quot;; then if check_connectivity; then connected=true; break 2; fi; fi; fi; fi; done; done; fi
        fi
        if $connected; then info_log &quot;✓ Non-interactive connection OK.&quot;; exit 0; else error_log &quot;Non-interactive connection FAILED.&quot;; exit 1; fi
    fi

    while true; do echo; local menu_opts=(); if [[ ${#ETH_IFACES[@]} -gt 0 ]]; then menu_opts+=(&quot;ETH&quot; &quot;Ethernet (${#ETH_IFACES[@]})&quot;); fi; if [[ ${#WIFI_IFACES[@]} -gt 0 ]]; then menu_opts+=(&quot;WIFI&quot; &quot;Wi-Fi (${#WIFI_IFACES[@]})&quot;); fi; menu_opts+=(&quot;STATUS&quot; &quot;Network Status&quot; &quot;CHECK&quot; &quot;Re-check Connectivity&quot; &quot;EXIT&quot; &quot;Exit&quot;);
        local choice; choice=$(prompt_select_option &quot;Select action:&quot; &quot;${menu_opts[@]}&quot;) || { info_log &quot;Exiting (cancel).&quot;; exit 0; }
        case &quot;$choice&quot; in
            ETH) if [[ ${#ETH_IFACES[@]} -gt 0 ]]; then if configure_ethernet &quot;$SELECTED_IFACE&quot;; then check_connectivity &amp;&amp; _show_progress_message &quot;Ethernet OK!&quot; &quot;persistent&quot; &amp;&amp; exit 0; fi; else _show_progress_message &quot;No Ethernet.&quot; &quot;warning&quot;; fi; SELECTED_IFACE=&quot;&quot;;;
            WIFI) if [[ ${#WIFI_IFACES[@]} -gt 0 ]]; then if configure_wifi &quot;$SELECTED_IFACE&quot;; then check_connectivity &amp;&amp; _show_progress_message &quot;Wi-Fi OK!&quot; &quot;persistent&quot; &amp;&amp; exit 0; fi; else _show_progress_message &quot;No Wi-Fi.&quot; &quot;warning&quot;; fi; SELECTED_IFACE=&quot;&quot;;;
            STATUS) show_network_status ;; CHECK) check_connectivity ;; EXIT) info_log &quot;User Exit.&quot;; exit 0 ;; *) error_log &quot;Invalid choice: $choice&quot; ;;
        esac
        if ! check_connectivity &quot;basic&quot;; then if ! prompt_yes_no &quot;Connection failed/none. Try again?&quot; &quot;y&quot;; then error_log &quot;Exiting (failed attempts).&quot;; exit 1; fi; fi
    done
    exit 1 # Should not reach
}

# Run main function
main &quot;$@&quot;" data-download-link="" data-download-label="Download Bash">
  <code class="language-bash">#!/usr/bin/env bash
#
# Universal Network Connectivity Script for RK3588 (Debian Bullseye)
# Version 8.1 - Refined Integration and Robustness
#
# Changelog from v8.0:
# - Refined debug_exec temp file handling (local management).
# - Enhanced cleanup function to handle temporary NetworkManager connections.
# - Improved nmcli scan parsing in scan_wifi_networks for better robustness.
# - Minor improvements to wpa_supplicant PID file usage.
# - Updated documentation.
#
# Features:
# - Interactive TUI using &#39;dialog&#39; for easier configuration
# - Automatic network configuration via Ethernet or Wi-Fi
# - Support for WPA/WPA2/WPA3, WEP, and open networks
# - Hidden SSID support
# - IPv4 and IPv6 configuration
# - Multiple DHCP client support (dhclient, dhcpcd, udhcpc)
# - Multiple Network Management tool support (NetworkManager, wpa_supplicant, iwd)
# - Connection profile management (passwords base64 encoded)
# - Comprehensive error handling, logging, and recovery (e.g., Wi-Fi driver reload)
# - Progress indicators and colored console output
# - Optional package dependency checking and installation
# - Non-interactive mode for automated setups
#
# Requirements:
# - Root privileges
# - &#39;dialog&#39; utility for interactive mode (will offer to install)
# - Basic utilities: ip, ping, awk, grep, sed, systemctl, mktemp, base64, pkill
# - At least one of: NetworkManager, wpa_supplicant, iwd
# - At least one of: dhclient, dhcpcd, udhcpc
#

# Strict mode
set -euo pipefail
IFS=$&#39;\n\t&#39;

# --- Constants and Configuration ---
readonly SCRIPT_VERSION=&quot;8.1&quot;
readonly SCRIPT_NAME=&quot;$(basename &quot;$0&quot;)&quot;
readonly CONFIG_DIR=&quot;/etc/netconnect&quot;
readonly PROFILE_DIR=&quot;${CONFIG_DIR}/profiles&quot;
readonly LOG_DIR=&quot;/var/log/netconnect&quot;
readonly MAIN_LOG_FILE=&quot;${LOG_DIR}/netconnect.log&quot;
readonly LOCK_FILE=&quot;/var/run/netconnect.lock&quot;

# Network testing parameters
readonly PING_IP_PRIMARY=&quot;8.8.8.8&quot;
readonly PING_IP_SECONDARY=&quot;1.1.1.1&quot;
readonly PING_HOSTNAME=&quot;google.com&quot;
readonly PING_COUNT=3
readonly PING_TIMEOUT=2 # seconds
readonly DHCP_TIMEOUT=30 # seconds
readonly WIFI_SCAN_TIMEOUT=10 # seconds for wpa_cli scan, nmcli/iw might be faster
readonly WIFI_CONNECT_TIMEOUT=30 # seconds

# Dialog UI settings
DIALOG_CMD=&quot;dialog&quot;
DIALOG_AVAILABLE=false
DIALOG_SUCCESS_CODE=0
DIALOG_CANCEL_CODE=1
DIALOG_HELP_CODE=2
DIALOG_EXTRA_CODE=3
DIALOG_ESC_CODE=255
DIALOG_DEFAULT_HEIGHT=15
DIALOG_DEFAULT_WIDTH=70
DIALOG_INPUT_WIDTH=50

# Color codes (disabled if not in terminal or if NON_INTERACTIVE)
if [[ -t 1 &amp;&amp; -t 2 ]]; then
    readonly COLOR_RED=&#39;\033[0;31m&#39;
    readonly COLOR_GREEN=&#39;\033[0;32m&#39;
    readonly COLOR_YELLOW=&#39;\033[0;33m&#39;
    readonly COLOR_BLUE=&#39;\033[0;34m&#39;
    readonly COLOR_PURPLE=&#39;\033[0;35m&#39;
    readonly COLOR_CYAN=&#39;\033[0;36m&#39;
    readonly COLOR_RESET=&#39;\033[0m&#39;
else
    readonly COLOR_RED=&#39;&#39;
    readonly COLOR_GREEN=&#39;&#39;
    readonly COLOR_YELLOW=&#39;&#39;
    readonly COLOR_BLUE=&#39;&#39;
    readonly COLOR_PURPLE=&#39;&#39;
    readonly COLOR_CYAN=&#39;&#39;
    readonly COLOR_RESET=&#39;&#39;
fi

# --- Global Variables ---
declare -a ETH_IFACES=()
declare -a WIFI_IFACES=()
declare -a TMP_FILES_TO_CLEAN=() # For files/items needing cleanup at script exit
declare SELECTED_IFACE=&quot;&quot;
declare NM_AVAILABLE=false
declare WPA_CLI_AVAILABLE=false
declare IWD_AVAILABLE=false
declare WPA_SUPPLICANT_SERVICE_ACTIVE=false
declare DHCP_CLIENT=&quot;&quot;

DBG=${DBG:-false}
DEBUG_LEVEL=${DEBUG_LEVEL:-1} # 1:basic, 2:verbose, 3:full
DEBUG_LOG_FILE=&quot;&quot;
VERBOSE_COMMANDS=${VERBOSE_COMMANDS:-true}
XTRACE_FD=6

NON_INTERACTIVE=false
CONNECTION_TYPE_ARG=&quot;&quot;
CHECK_ONLY_ARG=false

# --- Prerequisite Check &amp; Installation ---
check_command() {
    local cmd_to_check=&quot;$1&quot;
    if command -v &quot;$cmd_to_check&quot; &gt;/dev/null 2&gt;&amp;1; then
        return 0
    else
        return 1
    fi
}

install_packages_dialog() {
    local missing_packages_to_install=(&quot;$@&quot;)
    local choice

    if [[ ${#missing_packages_to_install[@]} -eq 0 ]]; then
        return 0 # Nothing to install
    fi

    warning_log &quot;Missing packages: ${missing_packages_to_install[*]}&quot;
    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local install_prompt_msg=&quot;The following essential packages are missing: ${missing_packages_to_install[*]}.\n\nDo you want to try and install them now?\n(Requires an existing temporary internet connection or cached packages)&quot;
        if $DIALOG_AVAILABLE ; then
            &quot;$DIALOG_CMD&quot; --title &quot;Missing Packages&quot; \
                   --yesno &quot;$install_prompt_msg&quot; \
                   12 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
            choice=$?
        else # Fallback for when dialog itself might be missing
            read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}$install_prompt_msg (y/N): ${COLOR_RESET}&quot;)&quot; response
            [[ &quot;$response&quot; =~ ^[yY]$ ]] &amp;&amp; choice=0 || choice=1
        fi
    else
        info_log &quot;Non-interactive mode: Attempting to install missing packages automatically.&quot;
        choice=0 # Auto-yes in non-interactive
    fi

    if [[ $choice -eq $DIALOG_SUCCESS_CODE ]]; then
        info_log &quot;User opted to install missing packages: ${missing_packages_to_install[*]}&quot;
        _show_progress_message &quot;Attempting to install: ${missing_packages_to_install[*]}...&quot; &quot;transient&quot;
        
        # Temporarily allow script to continue if apt-get update fails, but warn
        set +e
        apt-get update -qq
        local apt_update_ec=$?
        set -e
        if [[ $apt_update_ec -ne 0 ]]; then
             error_log &quot;&#39;apt-get update&#39; failed (EC: $apt_update_ec). Package installation might fail.&quot;
             _show_progress_message &quot;&#39;apt-get update&#39; failed. Please check your network connection and apt sources.&quot; &quot;error&quot;
             # Continue to try install, it might work with cached lists
        fi
        
        # shellcheck disable=SC2068 # We want word splitting for the array
        if apt-get install -y ${missing_packages_to_install[@]}; then
            _show_progress_message &quot;Successfully installed missing packages.&quot; &quot;persistent&quot;
            # Re-check for dialog if it was installed
            if [[ &quot; ${missing_packages_to_install[*]} &quot; =~ &quot; dialog &quot; ]] &amp;&amp; check_command dialog; then
                DIALOG_AVAILABLE=true
            fi
            return 0
        else
            error_log &quot;Failed to install packages: ${missing_packages_to_install[*]}.&quot;
            _show_progress_message &quot;Failed to install some packages. Please install them manually and re-run the script.\nPackages: ${missing_packages_to_install[*]}&quot; &quot;error&quot;
            return 1
        fi
    else
        error_log &quot;User declined package installation or cancelled.&quot;
        _show_progress_message &quot;Cannot proceed without essential packages: ${missing_packages_to_install[*]}. Exiting.&quot; &quot;error&quot;
        return 1
    fi
}

# --- Logging Functions ---
_log_to_file() {
    if $DBG &amp;&amp; [[ -n &quot;$DEBUG_LOG_FILE&quot; ]] &amp;&amp; [[ -w &quot;$DEBUG_LOG_FILE&quot; || -w &quot;$(dirname &quot;$DEBUG_LOG_FILE&quot;)&quot; ]]; then
        echo -e &quot;$1&quot; &gt;&gt; &quot;$DEBUG_LOG_FILE&quot;
    fi
}

_base_log() {
    local level=&quot;$1&quot;
    local color=&quot;$2&quot;
    shift 2
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local log_entry=&quot;[$timestamp] [$level] $message&quot;

    _log_to_file &quot;$log_entry&quot;

    if [[ &quot;$level&quot; != &quot;DEBUG&quot; &amp;&amp; &quot;$level&quot; != &quot;VERB&quot; &amp;&amp; &quot;$level&quot; != &quot;FULL&quot; ]] || $DBG; then
        if [[ &quot;$level&quot; == &quot;DEBUG&quot; &amp;&amp; &quot;$DEBUG_LEVEL&quot; -lt 1 ]]; then return; fi
        if [[ &quot;$level&quot; == &quot;VERB&quot; &amp;&amp; &quot;$DEBUG_LEVEL&quot; -lt 2 ]]; then return; fi
        if [[ &quot;$level&quot; == &quot;FULL&quot; &amp;&amp; &quot;$DEBUG_LEVEL&quot; -lt 3 ]]; then return; fi
        
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]] || ! $DIALOG_AVAILABLE || [[ &quot;$level&quot; == &quot;DEBUG&quot; || &quot;$level&quot; == &quot;VERB&quot; || &quot;$level&quot; == &quot;FULL&quot; ]]; then
             echo -e &quot;${color}[$level]${COLOR_RESET} $message&quot; &gt;&amp;2
        fi
    fi
}

debug_log()   { if $DBG &amp;&amp; [[ &quot;$DEBUG_LEVEL&quot; -ge 1 ]]; then local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;DEBUG&quot; &quot;$COLOR_BLUE&quot; &quot;[$caller_info] $*&quot;; fi; }
debug_verbose() { if $DBG &amp;&amp; [[ &quot;$DEBUG_LEVEL&quot; -ge 2 ]]; then local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;VERB&quot; &quot;$COLOR_CYAN&quot; &quot;[$caller_info] $*&quot;; fi; }
debug_full()    { if $DBG &amp;&amp; [[ &quot;$DEBUG_LEVEL&quot; -ge 3 ]]; then local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;FULL&quot; &quot;$COLOR_PURPLE&quot; &quot;[$caller_info] $*&quot;; fi; }
info_log()    { _base_log &quot;INFO&quot; &quot;$COLOR_GREEN&quot; &quot;$@&quot;; }
warning_log() { local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;WARN&quot; &quot;$COLOR_YELLOW&quot; &quot;[$caller_info] $*&quot;; }
error_log()   { local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;; _base_log &quot;ERROR&quot; &quot;$COLOR_RED&quot; &quot;[$caller_info] $*&quot;; }

debug_var() {
    if ! $DBG || [[ &quot;$DEBUG_LEVEL&quot; -lt 2 ]]; then return 0; fi
    local var_name=&quot;$1&quot;
    local var_value
    var_value=&quot;${!var_name}&quot; # Indirect expansion
    debug_verbose &quot;Variable $var_name = &#39;$var_value&#39; (length: ${#var_value})&quot;
    if [[ &quot;$var_value&quot; =~ [[:cntrl:]] ]]; then # Check for control characters
        debug_log &quot;WARNING: Variable $var_name contains control characters.&quot;
        debug_full &quot;Hex dump for $var_name:\n$(echo -n &quot;$var_value&quot; | hexdump -C)&quot;
    fi
}

# --- UI and Progress Functions ---
_show_dialog_message() {
    local type=&quot;$1&quot; title=&quot;$2&quot; message=&quot;$3&quot;
    local height=${4:-8} width=${5:-60}
    local dialog_exit_code=$DIALOG_CANCEL_CODE

    debug_verbose &quot;Showing dialog: type=$type, title=&#39;$title&#39;, message snippet=&#39;${message:0:50}...&#39;&quot;
    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;$title&quot; --&quot;$type&quot; &quot;$message&quot; &quot;$height&quot; &quot;$width&quot; 2&gt;/dev/tty
        dialog_exit_code=$?
        # Some dialog versions might not clear screen fully on exit
        # clear # Uncomment if needed, but can be disruptive
    else
        echo -e &quot;${COLOR_GREEN}$title:${COLOR_RESET}\n$message&quot; &gt;&amp;2
        if [[ &quot;$type&quot; == &quot;msgbox&quot; || &quot;$type&quot; == &quot;infobox&quot; ]]; then
            dialog_exit_code=$DIALOG_SUCCESS_CODE
        elif [[ &quot;$type&quot; == &quot;yesno&quot; ]]; then
             read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}$message (y/N): ${COLOR_RESET}&quot;)&quot; response
             [[ &quot;$response&quot; =~ ^[yY]$ ]] &amp;&amp; dialog_exit_code=$DIALOG_SUCCESS_CODE || dialog_exit_code=$DIALOG_CANCEL_CODE
        fi
    fi
    debug_verbose &quot;Dialog (&#39;$title&#39;) exit code: $dialog_exit_code&quot;
    return $dialog_exit_code
}

_show_progress_message() {
    local message=&quot;$1&quot;
    local type=&quot;${2:-info}&quot; # info, persistent, error, transient
    
    info_log &quot;$message&quot; # Always log it

    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then return; fi

    case &quot;$type&quot; in
        persistent) _show_dialog_message &quot;msgbox&quot; &quot;Information&quot; &quot;$message&quot; ;;
        error) _show_dialog_message &quot;msgbox&quot; &quot;Error&quot; &quot;$message&quot; 10 70 ;; # Slightly larger for errors
        transient) 
            if $DIALOG_AVAILABLE; then
                &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Information&quot; --infobox &quot;$message&quot; 6 60 2&gt;/dev/tty || true
                sleep 1
            else
                echo -e &quot;${COLOR_GREEN}INFO:${COLOR_RESET} $message&quot; &gt;&amp;2; sleep 1;
            fi ;;
        *) _show_dialog_message &quot;msgbox&quot; &quot;Information&quot; &quot;$message&quot; ;;
    esac
}

show_progress_spinner() {
    local message=&quot;$1&quot;
    local duration_s=&quot;${2:-0}&quot;

    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]] || ! $DIALOG_AVAILABLE; then
        echo -n -e &quot;${COLOR_GREEN}$message${COLOR_RESET}&quot; &gt;&amp;2
        if [[ &quot;$duration_s&quot; -gt 0 ]]; then
            local sleep_interval=0.2 spin_chars=&quot;/-\\|&quot;
            local num_steps=$(( (duration_s * 1000) / (sleep_interval * 1000) )) # Integer arithmetic
            for ((i=0; i&lt;num_steps; i++)); do
                echo -n -e &quot; ${spin_chars:i%${#spin_chars}:1}&quot; &gt;&amp;2; sleep &quot;$sleep_interval&quot;; echo -n -e &quot;\b\b&quot; &gt;&amp;2;
            done
            echo -e &quot;  done.&quot; &gt;&amp;2
        else echo -e &quot; done.&quot; &gt;&amp;2; fi
        return
    fi

    if [[ &quot;$duration_s&quot; -gt 0 ]]; then
        ( local percentage_per_step=$(( 100 / duration_s ));
          for ((i=0; i&lt;=duration_s; i++)); do echo &quot;$(( i * percentage_per_step ))&quot;; sleep 1; done; echo 100;
        ) | &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Progress&quot; --gauge &quot;$message&quot; 8 70 0 2&gt;/dev/tty
    else _show_progress_message &quot;$message ...done.&quot; &quot;transient&quot;; fi
}

# --- Utility Functions ---
debug_exec() {
    local cmd_string=&quot;$*&quot;
    debug_verbose &quot;Executing: $cmd_string&quot;
    local output exit_code
    local tmp_stdout_de tmp_stderr_de # Specific temp files for this function instance

    # Create temp files locally, do not add to global cleanup array
    tmp_stdout_de=$(mktemp &quot;/tmp/netconnect_cmd_stdout.XXXXXX&quot;)
    if [[ $? -ne 0 || -z &quot;$tmp_stdout_de&quot; ]]; then error_log &quot;debug_exec: Failed to create stdout temp file&quot;; return 1; fi
    tmp_stderr_de=$(mktemp &quot;/tmp/netconnect_cmd_stderr.XXXXXX&quot;)
    if [[ $? -ne 0 || -z &quot;$tmp_stderr_de&quot; ]]; then 
        error_log &quot;debug_exec: Failed to create stderr temp file&quot;; 
        rm -f &quot;$tmp_stdout_de&quot; 2&gt;/dev/null; # Clean up first temp file
        return 1; 
    fi

    # Execute command
    eval &quot;$cmd_string&quot; &gt; &quot;$tmp_stdout_de&quot; 2&gt; &quot;$tmp_stderr_de&quot;
    exit_code=$?
    
    local stdout_content stderr_content
    stdout_content=$(cat &quot;$tmp_stdout_de&quot;)
    stderr_content=$(cat &quot;$tmp_stderr_de&quot;)

    debug_verbose &quot;Exit code: $exit_code&quot;
    [[ -n &quot;$stdout_content&quot; ]] &amp;&amp; debug_full &quot;STDOUT:\n$stdout_content&quot;
    [[ -n &quot;$stderr_content&quot; ]] &amp;&amp; debug_full &quot;STDERR:\n$stderr_content&quot;
    
    if [[ $exit_code -ne 0 ]]; then
        debug_log &quot;FAILED command: $cmd_string (Exit Code: $exit_code)&quot;
        [[ -n &quot;$stderr_content&quot; ]] &amp;&amp; debug_log &quot;Stderr from failed command was logged in FULL debug.&quot;
    fi
    
    # Output the actual stdout of the command for capture by caller
    echo &quot;$stdout_content&quot;
    
    # Cleanup these specific temp files
    rm -f &quot;$tmp_stdout_de&quot; &quot;$tmp_stderr_de&quot; 2&gt;/dev/null || warning_log &quot;debug_exec: Failed to clean up its local temp files.&quot;

    return $exit_code
}

create_temp_file() {
    local prefix=&quot;${1:-netconnect}&quot; suffix_val=&quot;${2:-}&quot;
    local temp_file sane_prefix sane_suffix

    sane_prefix=$(echo &quot;$prefix&quot; | tr -cd &#39;[:alnum:]_-&#39;)
    sane_suffix=$(echo &quot;$suffix_val&quot; | tr -cs &#39;[:alnum:]_.-&#39; &#39;_&#39;)
    [[ -n &quot;$sane_suffix&quot; &amp;&amp; ! &quot;$sane_suffix&quot; =~ ^\. ]] &amp;&amp; sane_suffix=&quot;.$sane_suffix&quot;

    temp_file=$(mktemp &quot;/tmp/${sane_prefix}.XXXXXX${sane_suffix}&quot;)
    if [[ $? -ne 0 || -z &quot;$temp_file&quot; || ! -e &quot;$temp_file&quot; ]]; then
        error_log &quot;Failed to create temporary file (prefix &#39;$sane_prefix&#39;, suffix &#39;$sane_suffix&#39;)&quot;
        return 1
    fi
    debug_verbose &quot;Created global temporary file: &#39;$temp_file&#39;&quot;
    TMP_FILES_TO_CLEAN+=(&quot;$temp_file&quot;)
    echo &quot;$temp_file&quot;
    return 0
}

safe_rm() {
    local file_to_remove=&quot;$1&quot;
    debug_verbose &quot;safe_rm: Attempting to remove &#39;$file_to_remove&#39;&quot;
    if [[ -z &quot;$file_to_remove&quot; ]]; then warning_log &quot;safe_rm: Empty filename provided.&quot;; return 1; fi
    if [[ ! -e &quot;$file_to_remove&quot; ]]; then debug_verbose &quot;safe_rm: File &#39;$file_to_remove&#39; does not exist, skipping.&quot;; return 0; fi
    
    local critical_paths=(&quot;/&quot; &quot;/bin&quot; &quot;/etc&quot; &quot;/usr&quot; &quot;/var&quot; &quot;/tmp&quot; &quot;/sbin&quot; &quot;/lib&quot; &quot;/boot&quot; &quot;/home&quot; &quot;/root&quot;)
    for crit_path in &quot;${critical_paths[@]}&quot;; do
        if [[ &quot;$file_to_remove&quot; == &quot;$crit_path&quot; ]]; then
            error_log &quot;safe_rm: Critical path removal protection for &#39;$file_to_remove&#39;!&quot;
            return 1
        fi
    done
    if [[ &quot;$file_to_remove&quot; =~ (/|([[:alnum:]_-]+)/)\.\. ]]; then # Basic path traversal check
        error_log &quot;safe_rm: Path traversal attempt suspected in &#39;$file_to_remove&#39;!&quot;
        return 1
    fi

    if rm -f &quot;$file_to_remove&quot;; then
        debug_verbose &quot;safe_rm: Successfully removed &#39;$file_to_remove&#39;&quot;
        for i in &quot;${!TMP_FILES_TO_CLEAN[@]}&quot;; do
            if [[ &quot;${TMP_FILES_TO_CLEAN[i]}&quot; == &quot;$file_to_remove&quot; ]]; then
                unset &#39;TMP_FILES_TO_CLEAN[i]&#39;; break;
            fi
        done
        return 0
    else
        error_log &quot;safe_rm: Failed to remove &#39;$file_to_remove&#39; (Error: $?)&quot;; return 1;
    fi
}

cleanup() {
    local exit_code=$?
    debug_log &quot;Cleanup: Script exiting with code $exit_code&quot;
    local item_processed_flags=() # To avoid processing an item multiple times if it appears due to error

    # Process special cleanup items first (like nmcli connections)
    local remaining_items=()
    for item_idx in &quot;${!TMP_FILES_TO_CLEAN[@]}&quot;; do
        local item=&quot;${TMP_FILES_TO_CLEAN[$item_idx]}&quot;
        if [[ -z &quot;$item&quot; ]] || [[ &quot; ${item_processed_flags[*]} &quot; =~ &quot; ${item_idx} &quot; ]]; then continue; fi

        if [[ &quot;$item&quot; == nmcli_con_del_* ]]; then
            local con_name_to_del=&quot;${item#nmcli_con_del_}&quot;
            if [[ -n &quot;$con_name_to_del&quot; ]] &amp;&amp; $NM_AVAILABLE; then
                info_log &quot;Cleaning up temporary NetworkManager connection: $con_name_to_del&quot;
                nmcli connection delete id &quot;$con_name_to_del&quot; &gt;/dev/null 2&gt;&amp;1 || \
                    warning_log &quot;Failed to delete temporary NM connection &#39;$con_name_to_del&#39; during cleanup.&quot;
            fi
            item_processed_flags+=(&quot;$item_idx&quot;)
        else
            remaining_items+=(&quot;$item&quot;) # It&#39;s a file path for safe_rm
        fi
    done
    
    # Update TMP_FILES_TO_CLEAN with only file paths remaining
    TMP_FILES_TO_CLEAN=(&quot;${remaining_items[@]}&quot;)

    # Regular file cleanup
    if [[ ${#TMP_FILES_TO_CLEAN[@]} -gt 0 ]]; then
        debug_verbose &quot;Cleaning up ${#TMP_FILES_TO_CLEAN[@]} temporary file(s): ${TMP_FILES_TO_CLEAN[*]}&quot;
        for temp_file in &quot;${TMP_FILES_TO_CLEAN[@]}&quot;; do
            [[ -n &quot;$temp_file&quot; ]] &amp;&amp; safe_rm &quot;$temp_file&quot;
        done
    else
        debug_verbose &quot;No standard temporary files registered for cleanup.&quot;
    fi
    
    [[ -f &quot;$LOCK_FILE&quot; ]] &amp;&amp; safe_rm &quot;$LOCK_FILE&quot;
    
    if [[ -t 1 ]]; then
      stty sane 2&gt;/dev/null || debug_verbose &quot;stty sane failed&quot;
      tput cnorm 2&gt;/dev/null || debug_verbose &quot;tput cnorm failed&quot;
    fi
    
    if $DBG &amp;&amp; [[ -n &quot;$DEBUG_LOG_FILE&quot; ]]; then
        set +x
        eval &quot;exec $XTRACE_FD&gt;&amp;-&quot; 2&gt;/dev/null || debug_verbose &quot;Failed to close XTRACE_FD $XTRACE_FD&quot;
        info_log &quot;Script exited (Code: $exit_code). Debug log: $DEBUG_LOG_FILE&quot;
        [[ -t 2 ]] &amp;&amp; echo -e &quot;${COLOR_CYAN}Debug log available at: $DEBUG_LOG_FILE${COLOR_RESET}&quot; &gt;&amp;2
    else
        info_log &quot;Script exited (Code: $exit_code).&quot;
    fi
    exit &quot;$exit_code&quot;
}
trap cleanup EXIT
# SIGINT/SIGTERM are more complex; a simple message is fine, cleanup will run on EXIT.
trap &#39;error_log &quot;Script interrupted by SIGINT/SIGTERM.&quot;; exit 130&#39; SIGINT SIGTERM


check_root() {
    if [[ $EUID -ne 0 ]]; then
        error_log &quot;This script must be run as root&quot;
        _show_progress_message &quot;ERROR: This script must be run as root. Usage: sudo $SCRIPT_NAME [options]&quot; &quot;error&quot;
        exit 1
    fi
}

acquire_lock() {
    if [[ -f &quot;$LOCK_FILE&quot; ]]; then
        local pid; pid=$(cat &quot;$LOCK_FILE&quot; 2&gt;/dev/null)
        if [[ -n &quot;$pid&quot; ]] &amp;&amp; kill -0 &quot;$pid&quot; 2&gt;/dev/null; then
            error_log &quot;Another instance is already running (PID: $pid)&quot;; exit 1;
        fi
        safe_rm &quot;$LOCK_FILE&quot; # Stale lock file
    fi
    echo $$ &gt; &quot;$LOCK_FILE&quot; || { error_log &quot;Failed to create lock file: $LOCK_FILE&quot;; exit 1; }
}

init_directories() {
    local dirs=(&quot;$CONFIG_DIR&quot; &quot;$PROFILE_DIR&quot; &quot;$LOG_DIR&quot;)
    for dir in &quot;${dirs[@]}&quot;; do
        if [[ ! -d &quot;$dir&quot; ]]; then
            debug_log &quot;Creating directory: $dir&quot;
            mkdir -p &quot;$dir&quot; || warning_log &quot;Could not create directory: $dir.&quot;
        fi
    done
    touch &quot;$MAIN_LOG_FILE&quot; 2&gt;/dev/null || warning_log &quot;Main log file $MAIN_LOG_FILE is not writable.&quot;
}

sanitize_iface_name() {
    local val=&quot;$1&quot;; val=$(echo -n &quot;$val&quot; | tr -cd &#39;[:alnum:]_-&#39;); echo &quot;$val&quot;
}

sanitize_dialog_output() {
    local val=&quot;$1&quot;; val=$(echo -n &quot;$val&quot; | tr -cd &#39;[:print:]\n\r&#39;); val=$(echo -n &quot;$val&quot; | sed &#39;s/^[[:space:]]*//;s/[[:space:]]*$//&#39;); echo &quot;$val&quot;
}

# --- User Interaction Functions (Dialog-based with fallbacks) ---
prompt_user_input() {
    local prompt_text=&quot;$1&quot; default_value=&quot;${2:-}&quot; is_password=&quot;${3:-false}&quot;
    local input_value=&quot;&quot; dialog_exit_status

    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local dialog_option=&quot;--inputbox&quot;; [[ &quot;$is_password&quot; == &quot;true&quot; ]] &amp;&amp; dialog_option=&quot;--passwordbox&quot;
        local temp_out; temp_out=$(create_temp_file &quot;dialog_input&quot;) || return 1

        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Input Required&quot; &quot;$dialog_option&quot; &quot;$prompt_text&quot; \
            10 ${DIALOG_INPUT_WIDTH} &quot;$default_value&quot; 2&gt; &quot;$temp_out&quot;
        dialog_exit_status=$?
        
        input_value=$(sanitize_dialog_output &quot;$(cat &quot;$temp_out&quot;)&quot;)
        safe_rm &quot;$temp_out&quot;

        if [[ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]]; then
            info_log &quot;User cancelled input for: $prompt_text&quot;; return 1;
        fi
    else
        local read_options=&quot;&quot;; [[ &quot;$is_password&quot; == &quot;true&quot; ]] &amp;&amp; read_options=&quot;-s&quot;
        local prompt_full=&quot;$prompt_text&quot;; [[ -n &quot;$default_value&quot; ]] &amp;&amp; prompt_full+=&quot; [$default_value]&quot;
        prompt_full+=&quot;: &quot;
        
        read -r $read_options -p &quot;$(echo -e &quot;${COLOR_YELLOW}$prompt_full${COLOR_RESET}&quot;)&quot; input_value
        [[ &quot;$is_password&quot; == &quot;true&quot; ]] &amp;&amp; echo &gt;&amp;2
        [[ -z &quot;$input_value&quot; &amp;&amp; -n &quot;$default_value&quot; ]] &amp;&amp; input_value=&quot;$default_value&quot;
    fi
    echo &quot;$input_value&quot;; return 0
}

prompt_yes_no() {
    local prompt_text=&quot;$1&quot; default_choice=&quot;${2:-n}&quot;
    local response_code=$DIALOG_CANCEL_CODE

    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local default_opt=&quot;&quot;; [[ &quot;$default_choice&quot; == &quot;n&quot; ]] &amp;&amp; default_opt=&quot;--defaultno&quot;
        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Confirmation&quot; --yesno &quot;$prompt_text&quot; 8 ${DIALOG_DEFAULT_WIDTH} ${default_opt} 2&gt;/dev/tty
        response_code=$?
    else
        local yn_prompt=&quot;[y/N]&quot;; [[ &quot;$default_choice&quot; == &quot;y&quot; ]] &amp;&amp; yn_prompt=&quot;[Y/n]&quot;
        read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}$prompt_text $yn_prompt: ${COLOR_RESET}&quot;)&quot; response
        response=&quot;${response:-$default_choice}&quot;
        [[ &quot;$response&quot; =~ ^[yY]$ ]] &amp;&amp; response_code=$DIALOG_SUCCESS_CODE || response_code=$DIALOG_CANCEL_CODE
    fi
    [[ $response_code -eq $DIALOG_SUCCESS_CODE ]] &amp;&amp; return 0 || return 1
}

prompt_select_option() {
    local prompt_text=&quot;$1&quot;; shift
    local -a options_array=(&quot;$@&quot;) # Pairs: &quot;tag1&quot; &quot;description1&quot; ...
    local selected_tag=&quot;&quot; dialog_exit_status

    if [[ $((${#options_array[@]} % 2)) -ne 0 || ${#options_array[@]} -eq 0 ]]; then
        error_log &quot;prompt_select_option: Options array error.&quot;; return 1;
    fi
    if [[ ${#options_array[@]} -eq 2 &amp;&amp; &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        info_log &quot;Auto-selecting only option: ${options_array[1]}&quot;; echo &quot;${options_array[0]}&quot;; return 0;
    fi

    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then
        local temp_out; temp_out=$(create_temp_file &quot;dialog_menu&quot;) || return 1
        &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;Select Option&quot; --menu &quot;$prompt_text&quot; \
            ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} $((${#options_array[@]} / 2)) \
            &quot;${options_array[@]}&quot; 2&gt; &quot;$temp_out&quot;
        dialog_exit_status=$?
        selected_tag=$(sanitize_dialog_output &quot;$(cat &quot;$temp_out&quot;)&quot;)
        safe_rm &quot;$temp_out&quot;
        if [[ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]]; then info_log &quot;User cancelled selection.&quot;; return 1; fi
    else
        echo -e &quot;${COLOR_YELLOW}$prompt_text${COLOR_RESET}&quot; &gt;&amp;2
        local display_options_tags=()
        for ((i=0; i &lt; ${#options_array[@]}; i+=2)); do
            echo &quot;  $((i/2 + 1)). ${options_array[i+1]} (${options_array[i]})&quot; &gt;&amp;2
            display_options_tags+=(&quot;${options_array[i]}&quot;)
        done
        local choice_num
        while true; do
            read -r -p &quot;$(echo -e &quot;${COLOR_YELLOW}Enter choice (1-$((${#options_array[@]}/2))): ${COLOR_RESET}&quot;)&quot; choice_num
            if [[ &quot;$choice_num&quot; =~ ^[0-9]+$ &amp;&amp; &quot;$choice_num&quot; -ge 1 &amp;&amp; &quot;$choice_num&quot; -le $((${#options_array[@]}/2)) ]]; then
                selected_tag=&quot;${display_options_tags[$((choice_num-1))]}&quot;; break
            else echo -e &quot;${COLOR_RED}Invalid choice.${COLOR_RESET}&quot; &gt;&amp;2; fi
        done
    fi
    echo &quot;$selected_tag&quot;; return 0
}

# --- Network Detection Functions ---
# (detect_network_tools, detect_ethernet_interfaces, detect_wifi_interfaces from v8.0 are largely okay)
# Minor refinement to detect_wifi_interfaces to ensure unique entries robustly
detect_network_tools() {
    info_log &quot;Detecting available network management tools...&quot;
    NM_AVAILABLE=false; WPA_CLI_AVAILABLE=false; IWD_AVAILABLE=false; DHCP_CLIENT=&quot;&quot;

    if check_command nmcli &amp;&amp; systemctl is-active NetworkManager &gt;/dev/null 2&gt;&amp;1; then
        NM_AVAILABLE=true; info_log &quot;NetworkManager (nmcli) is available and active.&quot;
    else info_log &quot;NetworkManager (nmcli) is not active or not found.&quot;; fi
    
    if check_command wpa_cli; then
        WPA_CLI_AVAILABLE=true; info_log &quot;wpa_supplicant (wpa_cli command) is available.&quot;
    else info_log &quot;wpa_supplicant (wpa_cli command) not found.&quot;; fi
    
    if check_command iwctl &amp;&amp; systemctl is-active iwd &gt;/dev/null 2&gt;&amp;1; then
        IWD_AVAILABLE=true; info_log &quot;iwd (iwctl) is available and active.&quot;
    else info_log &quot;iwd (iwctl) is not active or not found.&quot;; fi
    
    for client in dhclient dhcpcd udhcpc; do
        if check_command &quot;$client&quot;; then DHCP_CLIENT=&quot;$client&quot;; info_log &quot;DHCP client found: $client&quot;; break; fi
    done
    if [[ -z &quot;$DHCP_CLIENT&quot; ]]; then warning_log &quot;No DHCP client found. DHCP may fail.&quot;; fi
}

detect_ethernet_interfaces() {
    debug_log &quot;Detecting Ethernet interfaces...&quot;
    ETH_IFACES=()
    local detected_output
    detected_output=$(debug_exec &quot;ip -o link show type ether 2&gt;/dev/null | awk -F&#39;: &#39; &#39;!/master|link\\/ether 00:00:00:00:00:00/{print \$2}&#39; | awk &#39;{print \$1}&#39; | grep -Ev &#39;^(lo|br|bond|dummy|veth|virbr|docker|tun|tap|vlan|vxlan|macvlan|macvtap|nlmon|gre|ipip|sit|ip6tnl|rename|wg)&#39; || true&quot;)
    if [[ -n &quot;$detected_output&quot; ]]; then
        while IFS= read -r iface; do
            local iface_clean; iface_clean=$(sanitize_iface_name &quot;$iface&quot;)
            if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; &amp;&amp; -e &quot;/sys/class/net/$iface_clean/device&quot; &amp;&amp; ! -e &quot;/sys/class/net/$iface_clean/virtual&quot; ]]; then
                ETH_IFACES+=(&quot;$iface_clean&quot;); debug_verbose &quot;Added Ethernet interface: &#39;$iface_clean&#39;&quot;
            elif [[ -n &quot;$iface&quot; ]]; then warning_log &quot;Skipped potentially invalid/virtual Ethernet interface: &#39;$iface&#39;&quot;; fi
        done &lt;&lt;&lt; &quot;$detected_output&quot;
    fi
    info_log &quot;Ethernet interfaces found: ${ETH_IFACES[*]:-(None)}&quot;
}

detect_wifi_interfaces() {
    debug_log &quot;Detecting Wi-Fi interfaces...&quot;
    WIFI_IFACES=()
    local detected_output=&quot;&quot; unique_wifi_ifaces_map # Use map for uniqueness

    declare -A unique_wifi_ifaces_map # Associative array for unique interface names

    # Try &#39;iw dev&#39; first
    if check_command iw; then
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;iw dev&#39;&quot;
        detected_output=$(debug_exec &quot;iw dev 2&gt;/dev/null | awk &#39;\$1==\&quot;Interface\&quot;{print \$2}&#39; || true&quot;)
        if [[ -n &quot;$detected_output&quot; ]]; then
            while IFS= read -r iface; do
                local iface_clean; iface_clean=$(sanitize_iface_name &quot;$iface&quot;)
                if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; &amp;&amp; -d &quot;/sys/class/net/${iface_clean}/wireless&quot; ]]; then
                    unique_wifi_ifaces_map[&quot;$iface_clean&quot;]=1
                fi
            done &lt;&lt;&lt; &quot;$detected_output&quot;
        fi
    fi
    
    # Fallback to &#39;ip link&#39; if &#39;iw dev&#39; found nothing or &#39;iw&#39; not present
    if [[ ${#unique_wifi_ifaces_map[@]} -eq 0 ]] &amp;&amp; check_command ip; then
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;ip link&#39; (fallback)&quot;
        detected_output=$(debug_exec &quot;ip -o link show 2&gt;/dev/null | awk -F&#39;: &#39; &#39;/wlan|wifi|wlp/{gsub(/@.*/, \&quot;\&quot;, \$2); print \$2}&#39; | awk &#39;{print \$1}&#39; | grep -E &#39;^(wlan|wlp|wifi)&#39; || true&quot;)
         if [[ -n &quot;$detected_output&quot; ]]; then
            while IFS= read -r iface; do
                local iface_clean; iface_clean=$(sanitize_iface_name &quot;$iface&quot;)
                if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; &amp;&amp; -d &quot;/sys/class/net/${iface_clean}/wireless&quot; ]]; then
                     unique_wifi_ifaces_map[&quot;$iface_clean&quot;]=1
                fi
            done &lt;&lt;&lt; &quot;$detected_output&quot;
        fi
    fi
    
    # Populate WIFI_IFACES array from the unique map keys
    for iface_key in &quot;${!unique_wifi_ifaces_map[@]}&quot;; do
        WIFI_IFACES+=(&quot;$iface_key&quot;)
        debug_verbose &quot;Added Wi-Fi interface: &#39;$iface_key&#39;&quot;
    done
    info_log &quot;Wi-Fi interfaces found: ${WIFI_IFACES[*]:-(None)}&quot;
}


# --- Interface Management Functions ---
# (ensure_interface_up from v8.0 is largely okay, minor logging tweaks if needed)
ensure_interface_up() {
    local iface=&quot;$1&quot; type=&quot;${2:-ethernet}&quot; max_attempts=3 attempt=1
    debug_log &quot;Ensuring interface $iface (type: $type) is up...&quot;
    if [[ &quot;$type&quot; == &quot;wifi&quot; ]] &amp;&amp; check_command rfkill; then
        if rfkill list wifi 2&gt;/dev/null | grep -i &quot;$iface&quot; -A2 | grep -q &quot;Hard blocked: yes&quot;; then error_log &quot;Wi-Fi $iface hard-blocked.&quot;; return 1; fi
        if rfkill list wifi 2&gt;/dev/null | grep -i &quot;$iface&quot; -A2 | grep -q &quot;Soft blocked: yes&quot;; then info_log &quot;Wi-Fi $iface soft-blocked. Unblocking...&quot;; debug_exec &quot;rfkill unblock wifi&quot;; sleep 1; fi
    fi
    if $NM_AVAILABLE; then
        local nm_state; nm_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_state&quot; == *&quot;unmanaged&quot;* ]]; then debug_log &quot;$iface unmanaged by NM. Setting managed...&quot;; nmcli device set &quot;$iface&quot; managed yes 2&gt;/dev/null || true; sleep 2; fi
    fi
    while [[ $attempt -le $max_attempts ]]; do
        debug_log &quot;Bringing up $iface (attempt $attempt/$max_attempts)...&quot;
        debug_exec &quot;ip link set \&quot;$iface\&quot; down&quot; 2&gt;/dev/null || true; sleep 0.5
        if debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then
            local wait_time=0 max_wait=5 current_state
            while [[ $wait_time -lt $max_wait ]]; do
                current_state=$(ip link show &quot;$iface&quot; 2&gt;/dev/null | grep -Po &#39;(?&lt;=state )\w+&#39; || echo &quot;UNKNOWN&quot;)
                debug_verbose &quot;$iface state: $current_state (wait: $wait_time)&quot;
                case &quot;$current_state&quot; in UP) debug_log &quot;$iface is UP.&quot;; return 0 ;;
                    DORMANT) if [[ &quot;$type&quot; == &quot;wifi&quot; ]]; then debug_log &quot;$iface DORMANT (OK for Wi-Fi).&quot;; return 0; fi ;;
                    UNKNOWN) debug_log &quot;$iface UNKNOWN (assuming OK).&quot;; return 0 ;; esac
                sleep 1; ((wait_time++)); done
            debug_log &quot;$iface up, but state $current_state after $max_wait s.&quot;; return 0;
        else warning_log &quot;&#39;ip link set $iface up&#39; failed (attempt $attempt).&quot;; fi
        if [[ &quot;$type&quot; == &quot;wifi&quot; &amp;&amp; $attempt -gt 1 ]]; then
            local driver; driver=$(basename &quot;$(readlink -f &quot;/sys/class/net/$iface/device/driver&quot; 2&gt;/dev/null)&quot; 2&gt;/dev/null || echo &quot;&quot;)
            if [[ -n &quot;$driver&quot; ]]; then _show_progress_message &quot;Reloading Wi-Fi driver $driver for $iface...&quot; &quot;transient&quot;; debug_exec &quot;pkill -f \&quot;wpa_supplicant.*$iface\&quot;&quot; || true;
                if debug_exec &quot;modprobe -r $driver&quot; 2&gt;/dev/null; then sleep 2; if debug_exec &quot;modprobe $driver&quot;; then sleep 3; info_log &quot;Driver $driver reloaded.&quot;; debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot; || true; else warning_log &quot;Failed to load $driver.&quot;; fi
                else warning_log &quot;Failed to remove $driver.&quot;; fi
            else debug_log &quot;No driver module found for $iface.&quot;; fi
        fi
        ((attempt++)); if [[ $attempt -le $max_attempts ]]; then sleep 2; fi; done
    error_log &quot;Failed to bring up $iface after $max_attempts attempts.&quot;; return 1
}

# --- Ethernet Configuration Functions ---
# (configure_dhcp, configure_static_ip, configure_ethernet from v8.0 are largely okay, will benefit from debug_exec fix)
# Example: configure_dhcp (core logic unchanged, benefits from fixed debug_exec)
configure_dhcp() {
    local iface=&quot;${1}&quot;
    info_log &quot;Configuring DHCP on $iface...&quot;
    ensure_interface_up &quot;$iface&quot; &quot;ethernet&quot; || return 1
    if $NM_AVAILABLE; then
        local nm_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_state&quot; != *&quot;unmanaged&quot;* ]]; then
            debug_log &quot;Attempting DHCP with NetworkManager for $iface.&quot;
            local profile_name=&quot;netconnect-dhcp-$iface-$$&quot;
            nmcli con delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true # Clean previous temp
            if nmcli connection add type ethernet con-name &quot;$profile_name&quot; ifname &quot;$iface&quot; ipv4.method auto ipv6.method auto connection.autoconnect no &gt;/dev/null 2&gt;&amp;1; then
                TMP_FILES_TO_CLEAN+=(&quot;nmcli_con_del_$profile_name&quot;)
                if nmcli connection up &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1; then
                    show_progress_spinner &quot;Obtaining IP via NetworkManager on $iface&quot; 5 &amp; local ppid=$!; disown $ppid 2&gt;/dev/null; wait $ppid 2&gt;/dev/null
                    sleep 2; if ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;DHCP OK via NM.&quot;; return 0;
                    else warning_log &quot;NM connected but no IP.&quot;; nmcli connection delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
                else warning_log &quot;NM &#39;con up $profile_name&#39; failed.&quot;; nmcli connection delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
            else warning_log &quot;NM &#39;con add&#39; for DHCP failed.&quot;; fi
        else debug_log &quot;NM reports $iface unmanaged, skipping NM for DHCP.&quot;; fi
    fi
    if [[ -z &quot;$DHCP_CLIENT&quot; ]]; then error_log &quot;No DHCP client for $iface.&quot;; return 1; fi
    debug_log &quot;Attempting DHCP with $DHCP_CLIENT for $iface&quot;
    case &quot;$DHCP_CLIENT&quot; in dhclient) debug_exec &quot;dhclient -r \&quot;$iface\&quot;&quot; || true ;; dhcpcd) debug_exec &quot;dhcpcd -k \&quot;$iface\&quot;&quot; || true ;; esac; sleep 1
    local dhcp_cmd_success=false
    show_progress_spinner &quot;Obtaining IP via $DHCP_CLIENT on $iface&quot; &quot;$DHCP_TIMEOUT&quot; &amp; local ppid2=$!; disown $ppid2 2&gt;/dev/null
    case &quot;$DHCP_CLIENT&quot; in
        dhclient) timeout &quot;$DHCP_TIMEOUT&quot; dhclient -v &quot;$iface&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; dhcp_cmd_success=true ;;
        dhcpcd)   timeout &quot;$DHCP_TIMEOUT&quot; dhcpcd -w &quot;$iface&quot; &gt;/dev/null 2&gt;&amp;1 &amp;&amp; dhcp_cmd_success=true ;;
        udhcpc)   timeout &quot;$DHCP_TIMEOUT&quot; udhcpc -i &quot;$iface&quot; -q -f -n &gt;/dev/null 2&gt;&amp;1 &amp;&amp; dhcp_cmd_success=true ;;
    esac; wait $ppid2 2&gt;/dev/null
    if $dhcp_cmd_success; then sleep 2; if ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;DHCP OK via $DHCP_CLIENT.&quot;; return 0;
        else error_log &quot;$DHCP_CLIENT OK, but no IP on $iface.&quot;; return 1; fi
    else error_log &quot;DHCP failed via $DHCP_CLIENT for $iface.&quot;; return 1; fi
}

configure_static_ip() {
    local iface=&quot;${1}&quot;
    info_log &quot;Configuring static IP on $iface...&quot;
    local ip_addr_cidr gateway dns_servers
    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then error_log &quot;Static IP not supported in non-interactive mode here.&quot;; return 1; fi
    ip_addr_cidr=$(prompt_user_input &quot;Enter IP address with CIDR (e.g., 192.168.1.100/24)&quot;) || return 1
    if [[ -z &quot;$ip_addr_cidr&quot; ]] || ! echo &quot;$ip_addr_cidr&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$&quot;; then error_log &quot;Invalid IP/CIDR: $ip_addr_cidr&quot;; return 1; fi
    gateway=$(prompt_user_input &quot;Enter gateway IP (e.g., 192.168.1.1)&quot;) || return 1
    if [[ -z &quot;$gateway&quot; ]] || ! echo &quot;$gateway&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$&quot;; then error_log &quot;Invalid Gateway: $gateway&quot;; return 1; fi
    dns_servers=$(prompt_user_input &quot;Enter DNS servers (comma-sep, optional)&quot; &quot;8.8.8.8,1.1.1.1&quot;) || dns_servers=&quot;8.8.8.8,1.1.1.1&quot;
    ensure_interface_up &quot;$iface&quot; &quot;ethernet&quot; || return 1
    if $NM_AVAILABLE; then
        local nm_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_state&quot; != *&quot;unmanaged&quot;* ]]; then
            debug_log &quot;Attempting static IP with NetworkManager for $iface.&quot;
            local profile_name=&quot;netconnect-static-$iface-$$&quot;; nmcli con delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true
            local nm_cmd_add=(nmcli con add type ethernet con-name &quot;$profile_name&quot; ifname &quot;$iface&quot; ipv4.method manual ipv4.addresses &quot;$ip_addr_cidr&quot; ipv4.gateway &quot;$gateway&quot;)
            [[ -n &quot;$dns_servers&quot; ]] &amp;&amp; nm_cmd_add+=(ipv4.dns &quot;$dns_servers&quot;); nm_cmd_add+=(ipv6.method auto connection.autoconnect no)
            if &quot;${nm_cmd_add[@]}&quot; &gt;/dev/null 2&gt;&amp;1; then TMP_FILES_TO_CLEAN+=(&quot;nmcli_con_del_$profile_name&quot;);
                if nmcli con up &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;Static IP OK via NM.&quot;; return 0;
                else warning_log &quot;NM &#39;con up $profile_name&#39; static failed.&quot;; nmcli con delete id &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
            else warning_log &quot;NM &#39;con add&#39; static failed.&quot;; fi
        else debug_log &quot;NM reports $iface unmanaged, skipping NM for static IP.&quot;; fi
    fi
    debug_log &quot;Configuring static IP manually for $iface using iproute2&quot;
    debug_exec &quot;ip addr flush dev \&quot;$iface\&quot;&quot; || true; debug_exec &quot;ip route flush dev \&quot;$iface\&quot;&quot; || true
    if ! debug_exec &quot;ip addr add \&quot;$ip_addr_cidr\&quot; dev \&quot;$iface\&quot;&quot;; then error_log &quot;Failed to add IP $ip_addr_cidr to $iface&quot;; return 1; fi
    debug_exec &quot;ip route del default&quot; 2&gt;/dev/null || true 
    if ! debug_exec &quot;ip route add default via \&quot;$gateway\&quot; dev \&quot;$iface\&quot;&quot;; then error_log &quot;Failed to add default route via $gateway&quot;; debug_exec &quot;ip addr del \&quot;$ip_addr_cidr\&quot; dev \&quot;$iface\&quot;&quot; || true; return 1; fi
    if [[ -n &quot;$dns_servers&quot; ]]; then if ! configure_dns &quot;$dns_servers&quot; &quot;$iface&quot;; then warning_log &quot;Manual DNS config failed, IP/GW set.&quot;; fi; else info_log &quot;No DNS servers for manual config.&quot;; fi
    info_log &quot;Static IP OK via iproute2.&quot;; return 0
}

configure_ethernet() {
    local iface_to_configure=&quot;${1:-}&quot;
    if [[ ${#ETH_IFACES[@]} -eq 0 ]]; then _show_progress_message &quot;No Ethernet interfaces available.&quot; &quot;warning&quot;; return 1; fi
    if [[ -z &quot;$iface_to_configure&quot; ]]; then
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then iface_to_configure=&quot;${ETH_IFACES[0]}&quot;; info_log &quot;Non-interactive: selected Ethernet $iface_to_configure&quot;;
        else local opts=(); for eth in &quot;${ETH_IFACES[@]}&quot;; do opts+=(&quot;$eth&quot; &quot;$eth&quot;); done; iface_to_configure=$(prompt_select_option &quot;Select Ethernet interface:&quot; &quot;${opts[@]}&quot;) || return 1; fi
        [[ -z &quot;$iface_to_configure&quot; ]] &amp;&amp; { info_log &quot;No Ethernet interface selected.&quot;; return 1; }
    elif ! [[ &quot; ${ETH_IFACES[*]} &quot; =~ &quot; ${iface_to_configure} &quot; ]]; then error_log &quot;Specified Ethernet &#39;$iface_to_configure&#39; not found.&quot;; return 1; fi
    SELECTED_IFACE=&quot;$iface_to_configure&quot;; info_log &quot;Configuring Ethernet: $SELECTED_IFACE&quot;
    local cfg_choice=&quot;dhcp&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then cfg_choice=$(prompt_select_option &quot;Method for $SELECTED_IFACE:&quot; &quot;dhcp&quot; &quot;DHCP (Auto)&quot; &quot;static&quot; &quot;Static IP (Manual)&quot;) || return 1; fi
    case &quot;$cfg_choice&quot; in
        dhcp) if configure_dhcp &quot;$SELECTED_IFACE&quot;; then return 0; else warning_log &quot;DHCP failed for $SELECTED_IFACE.&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]] &amp;&amp; prompt_yes_no &quot;DHCP failed. Try static IP?&quot; &quot;n&quot;; then return configure_static_ip &quot;$SELECTED_IFACE&quot;; fi; return 1; fi ;;
        static) if configure_static_ip &quot;$SELECTED_IFACE&quot;; then return 0; else warning_log &quot;Static IP failed for $SELECTED_IFACE.&quot;; return 1; fi ;;
        *) error_log &quot;Invalid Ethernet config choice.&quot;; return 1 ;;
    esac
}

configure_dns() {
    local dns_servers_csv=&quot;$1&quot; interface_context=&quot;${2:-}&quot;
    [[ -z &quot;$dns_servers_csv&quot; ]] &amp;&amp; { debug_log &quot;No DNS servers provided.&quot;; return 0; }
    info_log &quot;Configuring DNS: $dns_servers_csv&quot;
    if [[ -f /etc/resolv.conf &amp;&amp; ! -L /etc/resolv.conf ]]; then local bak=&quot;/etc/resolv.conf.bak.$(date +%s)&quot;; if cp /etc/resolv.conf &quot;$bak&quot; 2&gt;/dev/null; then debug_log &quot;Backed up /etc/resolv.conf to $bak&quot;; else warning_log &quot;Failed to backup /etc/resolv.conf&quot;; fi; fi
    local -a dns_arr; IFS=&#39;,&#39; read -r -a dns_arr &lt;&lt;&lt; &quot;$dns_servers_csv&quot;
    if systemctl is-active systemd-resolved &gt;/dev/null 2&gt;&amp;1 &amp;&amp; check_command resolvectl; then
        local eff_iface=&quot;global&quot;; if [[ -n &quot;$interface_context&quot; ]] &amp;&amp; ip link show &quot;$interface_context&quot; &gt;/dev/null 2&gt;&amp;1; then local idx; idx=$(cat &quot;/sys/class/net/$interface_context/ifindex&quot; 2&gt;/dev/null); [[ -n &quot;$idx&quot; ]] &amp;&amp; eff_iface=&quot;$idx&quot;; fi
        if debug_exec &quot;resolvectl dns \&quot;$eff_iface\&quot; ${dns_arr[*]}&quot;; then info_log &quot;DNS OK via systemd-resolved for $eff_iface.&quot;; debug_exec &quot;resolvectl flush-caches&quot;; return 0; else warning_log &quot;systemd-resolved failed.&quot;; fi
    fi
    if check_command resolvconf; then
        local res_iface=&quot;${interface_context:-netconnect_dns}&quot;; local res_input=&quot;&quot;; for dns in &quot;${dns_arr[@]}&quot;; do res_input+=&quot;nameserver $dns\n&quot;; done
        echo &quot;&quot; | resolvconf -d &quot;$res_iface&quot; 2&gt;/dev/null || true 
        if echo -e &quot;$res_input&quot; | resolvconf -a &quot;$res_iface&quot; 2&gt;/dev/null; then info_log &quot;DNS OK via resolvconf for $res_iface.&quot;; resolvconf -u 2&gt;/dev/null || true; return 0; else warning_log &quot;resolvconf failed.&quot;; fi
    fi
    if [[ -L /etc/resolv.conf ]]; then warning_log &quot;/etc/resolv.conf is symlink. Direct write risky.&quot;; if $NM_AVAILABLE; then warning_log &quot;NM active, should handle DNS.&quot;; fi; return 1; fi
    local res_content=&quot;# Generated by $SCRIPT_NAME at $(date)\n&quot;; for dns in &quot;${dns_arr[@]}&quot;; do res_content+=&quot;nameserver $dns\n&quot;; done
    if [[ -w /etc/resolv.conf ]] || ( [[ ! -e /etc/resolv.conf ]] &amp;&amp; [[ -w /etc ]] ); then
        if echo -e &quot;$res_content&quot; &gt; /etc/resolv.conf; then info_log &quot;DNS OK via direct write to /etc/resolv.conf.&quot;; warning_log &quot;Direct write may be overwritten.&quot;; return 0; else error_log &quot;Failed direct write to /etc/resolv.conf.&quot;; return 1; fi
    else error_log &quot;Cannot write /etc/resolv.conf (permissions).&quot;; return 1; fi
}

# --- Wi-Fi Configuration Functions ---
# (ensure_wpa_supplicant_running, scan_wifi_networks, connect_wifi, configure_wifi, save_network_profile from v8.0 are complex.
# Key changes for v8.1:
# - scan_wifi_networks: nmcli part uses -g or -t -f for robust parsing.
# - ensure_wpa_supplicant_running: use PID file for termination if available.
# )

ensure_wpa_supplicant_running() {
    local iface=&quot;$1&quot;
    debug_log &quot;Ensuring wpa_supplicant is running for $iface...&quot;
    if ! $WPA_CLI_AVAILABLE; then error_log &quot;wpa_cli not found.&quot;; install_packages_dialog &quot;wpa_cli,wpasupplicant&quot; || return 1; check_command wpa_cli &amp;&amp; WPA_CLI_AVAILABLE=true || { error_log &quot;wpa_cli still not available.&quot;; return 1; }; fi
    if $NM_AVAILABLE || $IWD_AVAILABLE; then debug_log &quot;NM or iwd active, assuming they handle supplicant needs.&quot;; if $WPA_CLI_AVAILABLE; then if debug_exec &quot;wpa_cli -i \&quot;$iface\&quot; status&quot;; then WPA_SUPPLICANT_SERVICE_ACTIVE=true; return 0; else WPA_SUPPLICANT_SERVICE_ACTIVE=false; return 0; fi; fi; return 0; fi
    
    local pid_file=&quot;/var/run/wpa_supplicant_${iface}.pid&quot;
    if [[ -f &quot;$pid_file&quot; ]]; then local pid_val; pid_val=$(cat &quot;$pid_file&quot; 2&gt;/dev/null); if [[ -n &quot;$pid_val&quot; ]] &amp;&amp; kill -0 &quot;$pid_val&quot; 2&gt;/dev/null; then if debug_exec &quot;wpa_cli -i \&quot;$iface\&quot; status&quot;; then debug_log &quot;wpa_supplicant running (PID $pid_val) and responsive.&quot;; WPA_SUPPLICANT_SERVICE_ACTIVE=true; return 0; else warning_log &quot;wpa_supplicant (PID $pid_val) running but unresponsive. Killing...&quot;; kill &quot;$pid_val&quot; 2&gt;/dev/null; sleep 1; fi; else debug_log &quot;Stale PID file $pid_file. Removing.&quot;; rm -f &quot;$pid_file&quot;; fi; fi
    debug_exec &quot;pkill -f \&quot;wpa_supplicant.*[[:space:]]-i[[:space:]]*$iface\&quot;&quot; || true; sleep 1

    local wpa_conf=&quot;/etc/wpa_supplicant/wpa_supplicant-${iface}.conf&quot; wpa_ctrl=&quot;/run/wpa_supplicant&quot;
    mkdir -p &quot;$(dirname &quot;$wpa_conf&quot;)&quot; &quot;$wpa_ctrl&quot;; if [[ ! -f &quot;$wpa_conf&quot; ]]; then echo -e &quot;ctrl_interface=DIR=${wpa_ctrl} GROUP=netdev\nupdate_config=1\nap_scan=1&quot; &gt; &quot;$wpa_conf&quot;; chmod 600 &quot;$wpa_conf&quot;; fi
    info_log &quot;Starting wpa_supplicant for $iface...&quot;; local drvs=(&quot;nl80211&quot; &quot;wext&quot;) started=false
    for drv in &quot;${drvs[@]}&quot;; do debug_log &quot;Trying wpa_supplicant for $iface with driver $drv&quot;
        if debug_exec &quot;wpa_supplicant -B -P \&quot;$pid_file\&quot; -i \&quot;$iface\&quot; -c \&quot;$wpa_conf\&quot; -D\&quot;$drv\&quot;&quot;; then sleep 2; if debug_exec &quot;wpa_cli -i \&quot;$iface\&quot; status&quot;; then info_log &quot;wpa_supplicant started (driver $drv).&quot;; started=true; break; else warning_log &quot;wpa_supplicant started (driver $drv) but wpa_cli cannot connect. Killing.&quot;; local kpid; kpid=$(cat &quot;$pid_file&quot; 2&gt;/dev/null); if [[ -n &quot;$kpid&quot; ]]; then kill &quot;$kpid&quot; 2&gt;/dev/null; else pkill -f &quot;wpa_supplicant.*[[:space:]]-i[[:space:]]*$iface.*-D$drv&quot;; fi; sleep 1; fi
        else warning_log &quot;Failed to start wpa_supplicant (driver $drv).&quot;; fi; done
    if ! $started; then error_log &quot;Failed to start wpa_supplicant for $iface.&quot;; WPA_SUPPLICANT_SERVICE_ACTIVE=false; return 1; fi
    WPA_SUPPLICANT_SERVICE_ACTIVE=true; return 0
}

scan_wifi_networks() {
    local iface=&quot;$1&quot;
    info_log &quot;Scanning for Wi-Fi networks on $iface...&quot;
    local temp_scan_file; temp_scan_file=$(create_temp_file &quot;wifi_scan_${iface}&quot;) || return 1
    ensure_interface_up &quot;$iface&quot; &quot;wifi&quot; || { safe_rm &quot;$temp_scan_file&quot;; return 1; }
    
    # This global associative array will be populated.
    # Bash functions don&#39;t easily return arrays, so this is a common pattern.
    # Caller (configure_wifi) must be aware of this.
    declare -gA unique_networks_scan_result=() # Ensure it&#39;s an assoc. array
    unique_networks_scan_result=() # Clear previous results

    # Method 1: NetworkManager (refined parsing)
    if $NM_AVAILABLE; then
        local nm_dev_state; nm_dev_state=$(nmcli -g GENERAL.STATE device show &quot;$iface&quot; 2&gt;/dev/null || echo &quot;unknown&quot;)
        if [[ &quot;$nm_dev_state&quot; != *&quot;unavailable&quot;* &amp;&amp; &quot;$nm_dev_state&quot; != *&quot;unmanaged&quot;* ]]; then
            debug_log &quot;Scanning with NetworkManager on $iface...&quot;
            nmcli device wifi rescan ifname &quot;$iface&quot; &gt;/dev/null 2&gt;&amp;1 || true; sleep &quot;$WIFI_SCAN_TIMEOUT&quot;
            # Use -g (generic) or -t -f for machine-readable output
            # nmcli -g SSID,SECURITY,SIGNAL,FREQ dev wifi list ifname &quot;$iface&quot; --rescan no
            local nm_scan_output; nm_scan_output=$(nmcli -t -f SSID,SECURITY,SIGNAL,FREQ dev wifi list ifname &quot;$iface&quot; --rescan no 2&gt;/dev/null || true)
            if [[ -n &quot;$nm_scan_output&quot; ]]; then
                debug_log &quot;Parsing NetworkManager scan results...&quot;
                while IFS=&#39;:&#39; read -r ssid security signal freq _; do
                    # nmcli -t -f might escape colons in SSID with \:
                    ssid=&quot;${ssid//\\:/ៈ}&quot; # Temp replace escaped colon
                    ssid=&quot;${ssid//:/ }&quot; # Replace non-escaped colons (should not happen in SSID field with -f)
                    ssid=&quot;${ssid//ៈ/:}&quot; # Restore escaped colon
                    [[ -z &quot;$ssid&quot; || &quot;$ssid&quot; == &quot;--&quot; ]] &amp;&amp; continue
                    local desc=&quot;Sig: ${signal}% | Sec: ${security:-Open} | Freq: ${freq}&quot;
                    unique_networks_scan_result[&quot;$ssid&quot;]=&quot;$desc&quot;
                done &lt;&lt;&lt; &quot;$nm_scan_output&quot;
                if [[ ${#unique_networks_scan_result[@]} -gt 0 ]]; then info_log &quot;Wi-Fi scan via NM OK.&quot;; cat &quot;$temp_scan_file&quot;; return 0; fi # temp_scan_file not used here
            else warning_log &quot;NM scan on $iface yielded no results.&quot;; fi
        else warning_log &quot;NM reports $iface $nm_dev_state, skipping NM scan.&quot;; fi
    fi

    # Method 2: wpa_cli (v8.0 logic was decent, ensure robust parsing)
    if $WPA_CLI_AVAILABLE &amp;&amp; [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then
        debug_log &quot;Scanning with wpa_cli on $iface...&quot;
        ensure_wpa_supplicant_running &quot;$iface&quot; || warning_log &quot;wpa_supplicant not running, wpa_cli scan might fail.&quot;
        if wpa_cli -i &quot;$iface&quot; scan &gt;/dev/null 2&gt;&amp;1; then sleep &quot;$WIFI_SCAN_TIMEOUT&quot;;
            local wpa_scan_raw; wpa_scan_raw=$(wpa_cli -i &quot;$iface&quot; scan_results 2&gt;/dev/null | tail -n +2)
            if [[ -n &quot;$wpa_scan_raw&quot; ]]; then debug_log &quot;Parsing wpa_cli scan results...&quot;
                echo &quot;$wpa_scan_raw&quot; | awk -F&#39;\t&#39; &#39;NF&gt;=5 {ssid_val=substr($0, index($0,$5)); flags=$4; sec=&quot;Open&quot;; if(flags ~ /WPA2-PSK/||flags ~ /RSN-PSK/)sec=&quot;WPA2-PSK&quot;; else if(flags ~ /WPA-PSK/)sec=&quot;WPA-PSK&quot;; else if(flags ~ /WEP/)sec=&quot;WEP&quot;; else if(flags ~ /SAE/)sec=&quot;WPA3-SAE&quot;; if(ssid_val!=&quot;&quot;&amp;&amp;ssid_val!=&quot;\\x00&quot;&amp;&amp;flags~/ESS/){gsub(/^&quot;|&quot;$/,&quot;&quot;,ssid_val);gsub(/[[:cntrl:]]/,&quot;&quot;,ssid_val);sig_val=$3;sq=sig_val;if(sig_val&lt;=-100)sq=0;else if(sig_val&gt;=-50)sq=100;else sq=2*(sig_val+100); printf &quot;%s|%s|%s|%s\n&quot;,ssid_val,sec,sq,$2;}}&#39; &gt; &quot;$temp_scan_file&quot;
                if [[ -s &quot;$temp_scan_file&quot; ]]; then 
                    while IFS=&#39;|&#39; read -r ssid security signal freq; do unique_networks_scan_result[&quot;$ssid&quot;]=&quot;Sig: ${signal}% | Sec: ${security} | Freq: ${freq}&quot;; done &lt; &quot;$temp_scan_file&quot;
                    if [[ ${#unique_networks_scan_result[@]} -gt 0 ]]; then info_log &quot;Wi-Fi scan via wpa_cli OK.&quot;; return 0; fi
                fi
            else warning_log &quot;wpa_cli scan yielded no results.&quot;; fi
        else warning_log &quot;wpa_cli scan command failed.&quot;; fi
    fi
    
    # Method 3: iw (fallback, parsing is simplified)
    if check_command iw &amp;&amp; [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then
        debug_log &quot;Scanning with iw on $iface...&quot;
        local iw_scan_raw; iw_scan_raw=$(iw dev &quot;$iface&quot; scan 2&gt;/dev/null || true)
        if [[ -n &quot;$iw_scan_raw&quot; ]]; then debug_log &quot;Parsing iw scan results...&quot;
            echo &quot;$iw_scan_raw&quot; | awk &#39;/^BSS / {if(cs!=&quot;&quot;)pn();cb=substr($2,1,17);cs=&quot;&quot;;csig=&quot;&quot;;cf=&quot;&quot;;csec=&quot;Open&quot;;} /\tSSID: / {cs=substr($0,index($0,$2));} /\tsignal: / {csig=sprintf(&quot;%.0f&quot;,$2);} /\tfreq: / {cf=$2;} /\tRSN:/ {csec=&quot;WPA2&quot;;} /\tWPA:/ {if(csec==&quot;Open&quot;)csec=&quot;WPA&quot;;} /\tPrivacy: / {if($2==&quot;on&quot;&amp;&amp;csec==&quot;Open&quot;)csec=&quot;WEP&quot;;} /\tcapability:.*ESS/{ie=1;} END{if(cs!=&quot;&quot;)pn();} function pn(){if(ie&amp;&amp;cs!~/^\\x00/){gsub(/[[:cntrl:]]/,&quot;&quot;,cs);sq=csig;if(csig&lt;=-100)sq=0;else if(csig&gt;=-50)sq=100;else sq=2*(csig+100);printf &quot;%s|%s|%s|%s\n&quot;,cs,csec,sq,cf;}ie=0;}&#39; &gt; &quot;$temp_scan_file&quot;
            if [[ -s &quot;$temp_scan_file&quot; ]]; then
                while IFS=&#39;|&#39; read -r ssid security signal freq; do unique_networks_scan_result[&quot;$ssid&quot;]=&quot;Sig: ${signal}% | Sec: ${security} | Freq: ${freq}&quot;; done &lt; &quot;$temp_scan_file&quot;
                if [[ ${#unique_networks_scan_result[@]} -gt 0 ]]; then info_log &quot;Wi-Fi scan via iw OK.&quot;; return 0; fi
            fi
        else warning_log &quot;iw scan yielded no results.&quot;; fi
    fi

    safe_rm &quot;$temp_scan_file&quot;
    if [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then error_log &quot;All Wi-Fi scanning methods failed or no networks found.&quot;; return 1; fi
    return 0 # unique_networks_scan_result is populated
}

connect_wifi() {
    local iface=&quot;$1&quot; ssid=&quot;$2&quot; password=&quot;${3:-}&quot; security_type=&quot;${4:-}&quot; is_hidden=&quot;${5:-false}&quot;
    info_log &quot;Attempting to connect to Wi-Fi: &#39;$ssid&#39; on $iface (Sec: ${security_type:-auto}, Hidden: $is_hidden)&quot;
    ensure_interface_up &quot;$iface&quot; &quot;wifi&quot; || return 1
    if $NM_AVAILABLE; then debug_log &quot;Trying NM for &#39;$ssid&#39;...&quot;
        local nm_cmd=(&quot;nmcli&quot; &quot;dev&quot; &quot;wifi&quot; &quot;connect&quot; &quot;$ssid&quot; &quot;ifname&quot; &quot;$iface&quot;); [[ -n &quot;$password&quot; ]] &amp;&amp; nm_cmd+=(&quot;password&quot; &quot;$password&quot;); [[ &quot;$is_hidden&quot; == &quot;true&quot; ]] &amp;&amp; nm_cmd+=(&quot;hidden&quot; &quot;yes&quot;)
        local nm_con=&quot;netconnect-$ssid-$$&quot;; nm_cmd+=(&quot;name&quot; &quot;$nm_con&quot;); nmcli con delete id &quot;$nm_con&quot; &gt;/dev/null 2&gt;&amp;1 || true
        show_progress_spinner &quot;Connecting &#39;$ssid&#39; via NM&quot; &quot;$WIFI_CONNECT_TIMEOUT&quot; &amp; local ppid=$!; disown $ppid 2&gt;/dev/null
        if &quot;${nm_cmd[@]}&quot; &gt;/dev/null 2&gt;&amp;1; then wait $ppid 2&gt;/dev/null; TMP_FILES_TO_CLEAN+=(&quot;nmcli_con_del_$nm_con&quot;); sleep 3; if nmcli -t -f GENERAL.STATE dev show &quot;$iface&quot; 2&gt;/dev/null | grep -q &quot;100 (connected)&quot; &amp;&amp; ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;NM connected to &#39;$ssid&#39;.&quot;; return 0; else warning_log &quot;NM connected to &#39;$ssid&#39; but no IP/full state.&quot;; nmcli con delete id &quot;$nm_con&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
        else wait $ppid 2&gt;/dev/null; warning_log &quot;NM failed to connect to &#39;$ssid&#39;.&quot;; nmcli con delete id &quot;$nm_con&quot; &gt;/dev/null 2&gt;&amp;1 || true; fi
    fi
    if $WPA_CLI_AVAILABLE; then debug_log &quot;Trying wpa_cli for &#39;$ssid&#39;...&quot;
        ensure_wpa_supplicant_running &quot;$iface&quot; || return 1
        wpa_cli -i &quot;$iface&quot; list_networks | grep &quot;$ssid&quot; | awk &#39;{print $1}&#39; | while read -r nid; do wpa_cli -i &quot;$iface&quot; remove_network &quot;$nid&quot; &gt;/dev/null 2&gt;&amp;1; done
        local net_id; net_id=$(wpa_cli -i &quot;$iface&quot; add_network | tail -1); if ! [[ &quot;$net_id&quot; =~ ^[0-9]+$ ]]; then error_log &quot;Failed to add net via wpa_cli for &#39;$ssid&#39;.&quot;; return 1; fi
        wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; ssid &quot;\&quot;$ssid\&quot;&quot; &gt;/dev/null; [[ &quot;$is_hidden&quot; == &quot;true&quot; ]] &amp;&amp; wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; scan_ssid 1 &gt;/dev/null
        local km_set=false; if [[ -n &quot;$security_type&quot; ]]; then case &quot;$security_type&quot; in Open)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt NONE &gt;/dev/null;km_set=true;; WEP)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt NONE &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; wep_key0 &quot;\&quot;$password\&quot;&quot; &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; wep_tx_keyidx 0 &gt;/dev/null;km_set=true;; *PSK)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt WPA-PSK &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; psk &quot;\&quot;$password\&quot;&quot; &gt;/dev/null;km_set=true;; *SAE)wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; key_mgmt SAE &gt;/dev/null;wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; sae_password &quot;\&quot;$password\&quot;&quot; &gt;/dev/null;km_set=true;; esac; fi
        if [[ -z &quot;$password&quot; &amp;&amp; &quot;$security_type&quot; != &quot;Open&quot; &amp;&amp; &quot;$km_set&quot; == &quot;false&quot; ]]; then warning_log &quot;No pass for secured &#39;$ssid&#39; ($security_type).&quot;; elif [[ -n &quot;$password&quot; &amp;&amp; &quot;$km_set&quot; == &quot;false&quot; ]]; then wpa_cli -i &quot;$iface&quot; set_network &quot;$net_id&quot; psk &quot;\&quot;$password\&quot;&quot; &gt;/dev/null; fi
        wpa_cli -i &quot;$iface&quot; enable_network &quot;$net_id&quot; &gt;/dev/null; wpa_cli -i &quot;$iface&quot; select_network &quot;$net_id&quot; &gt;/dev/null
        show_progress_spinner &quot;Connecting &#39;$ssid&#39; via wpa_cli&quot; &quot;$WIFI_CONNECT_TIMEOUT&quot; &amp; local ppid_wpa=$!; disown $ppid_wpa 2&gt;/dev/null
        local conn_wpa=false wpa_tries=$((WIFI_CONNECT_TIMEOUT/2)); for ((i=0;i&lt;wpa_tries;i++)); do local st; st=$(wpa_cli -i &quot;$iface&quot; status 2&gt;/dev/null); if echo &quot;$st&quot;|grep -q &quot;wpa_state=COMPLETED&quot;; then conn_wpa=true;break; fi; if echo &quot;$st&quot;|grep -q &quot;reason=WRONG_KEY&quot;; then error_log &quot;wpa_cli: WRONG KEY for &#39;$ssid&#39;.&quot;; break; fi; sleep 2; done; wait $ppid_wpa 2&gt;/dev/null
        if $conn_wpa; then info_log &quot;wpa_cli associated &#39;$ssid&#39;. DHCP...&quot;; wpa_cli -i &quot;$iface&quot; save_config &gt;/dev/null 2&gt;&amp;1 || warning_log &quot;Failed to save wpa_supplicant config.&quot;; if configure_dhcp &quot;$iface&quot;; then return 0; else error_log &quot;wpa_cli associated, DHCP failed.&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]] &amp;&amp; prompt_yes_no &quot;DHCP failed for &#39;$ssid&#39;. Static IP?&quot; &quot;n&quot;; then if configure_static_ip &quot;$iface&quot;; then return 0; fi; fi; fi
        else warning_log &quot;wpa_cli connect to &#39;$ssid&#39; failed.&quot;; fi; wpa_cli -i &quot;$iface&quot; remove_network &quot;$net_id&quot; &gt;/dev/null 2&gt;&amp;1
    fi
    if $IWD_AVAILABLE; then debug_log &quot;Trying iwd for &#39;$ssid&#39;...&quot;
        local iw_cmd=(&quot;iwctl&quot; &quot;--no-pager&quot; &quot;station&quot; &quot;$iface&quot; &quot;connect&quot; &quot;$ssid&quot;); [[ -n &quot;$password&quot; ]] &amp;&amp; iw_cmd+=(&quot;--passphrase&quot; &quot;$password&quot;)
        show_progress_spinner &quot;Connecting &#39;$ssid&#39; via iwd&quot; &quot;$WIFI_CONNECT_TIMEOUT&quot; &amp; local ppid_iwd=$!; disown $ppid_iwd 2&gt;/dev/null
        if debug_exec &quot;${iw_cmd[@]}&quot;; then wait $ppid_iwd 2&gt;/dev/null; sleep 3; if iwctl station &quot;$iface&quot; show 2&gt;/dev/null | grep -q &quot;State.*connected&quot; &amp;&amp; ip addr show dev &quot;$iface&quot; | grep -q &quot;inet &quot;; then info_log &quot;iwd connected to &#39;$ssid&#39;.&quot;; return 0; else warning_log &quot;iwd connected but no IP/full state.&quot;; fi
        else wait $ppid_iwd 2&gt;/dev/null; warning_log &quot;iwd failed to connect to &#39;$ssid&#39;.&quot;; fi
    fi
    error_log &quot;All Wi-Fi connection methods failed for &#39;$ssid&#39;.&quot;; return 1
}

# Global associative array for scan results, populated by scan_wifi_networks
declare -gA unique_networks_scan_result=()
configure_wifi() {
    local iface_to_configure=&quot;${1:-}&quot;
    unique_networks_scan_result=() # Clear previous
    if [[ ${#WIFI_IFACES[@]} -eq 0 ]]; then _show_progress_message &quot;No Wi-Fi interfaces.&quot; &quot;warning&quot;; return 1; fi
    if [[ -z &quot;$iface_to_configure&quot; ]]; then
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then iface_to_configure=&quot;${WIFI_IFACES[0]}&quot;; info_log &quot;Non-interactive: selected Wi-Fi $iface_to_configure&quot;;
        else local opts=(); for wf in &quot;${WIFI_IFACES[@]}&quot;; do opts+=(&quot;$wf&quot; &quot;$wf&quot;); done; iface_to_configure=$(prompt_select_option &quot;Select Wi-Fi interface:&quot; &quot;${opts[@]}&quot;) || return 1; fi
        [[ -z &quot;$iface_to_configure&quot; ]] &amp;&amp; { info_log &quot;No Wi-Fi interface selected.&quot;; return 1; }
    elif ! [[ &quot; ${WIFI_IFACES[*]} &quot; =~ &quot; ${iface_to_configure} &quot; ]]; then error_log &quot;Specified Wi-Fi &#39;$iface_to_configure&#39; not found.&quot;; return 1; fi
    SELECTED_IFACE=&quot;$iface_to_configure&quot;; info_log &quot;Configuring Wi-Fi: $SELECTED_IFACE&quot;
    _show_progress_message &quot;Scanning for networks on $SELECTED_IFACE...&quot; &quot;transient&quot;
    if ! scan_wifi_networks &quot;$SELECTED_IFACE&quot;; then # Populates global unique_networks_scan_result
        if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]] &amp;&amp; prompt_yes_no &quot;No networks found. Connect to hidden?&quot; &quot;n&quot;; then
            local h_ssid h_pass h_sec=&quot;WPA2-PSK&quot;; h_ssid=$(prompt_user_input &quot;Hidden SSID:&quot;) || return 1; [[ -z &quot;$h_ssid&quot; ]] &amp;&amp; { error_log &quot;Hidden SSID empty.&quot;; return 1; }
            h_pass=$(prompt_user_input &quot;Password for &#39;$h_ssid&#39; (empty for open):&quot; &quot;&quot; true); if [[ -z &quot;$h_pass&quot; ]]; then h_sec=&quot;Open&quot;; if ! prompt_yes_no &quot;Connect to &#39;$h_ssid&#39; as Open?&quot; &quot;y&quot;; then return 1; fi; fi
            return connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$h_ssid&quot; &quot;$h_pass&quot; &quot;$h_sec&quot; &quot;true&quot;
        fi; _show_progress_message &quot;No Wi-Fi networks found/selected for $SELECTED_IFACE.&quot; &quot;warning&quot;; return 1;
    fi
    if [[ ${#unique_networks_scan_result[@]} -eq 0 ]]; then _show_progress_message &quot;No Wi-Fi networks from scan.&quot; &quot;warning&quot;; return 1; fi
    local -a dlg_scan_opts=(); for skey in &quot;${!unique_networks_scan_result[@]}&quot;; do local s_trunc=&quot;$skey&quot;; [[ ${#s_trunc} -gt 30 ]] &amp;&amp; s_trunc=&quot;${s_trunc:0:27}...&quot;; dlg_scan_opts+=(&quot;$skey&quot; &quot;$s_trunc (${unique_networks_scan_result[$skey]})&quot;); done
    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then error_log &quot;Interactive Wi-Fi selection not supported here in non-interactive. Use profiles.&quot;; return 1; fi
    local sel_ssid_tag; sel_ssid_tag=$(prompt_select_option &quot;Select Wi-Fi network on $SELECTED_IFACE:&quot; &quot;${dlg_scan_opts[@]}&quot;) || return 1; [[ -z &quot;$sel_ssid_tag&quot; ]] &amp;&amp; { info_log &quot;No network selected.&quot;; return 1; }
    local sel_desc=&quot;${unique_networks_scan_result[$sel_ssid_tag]}&quot; sel_sec=&quot;WPA2-PSK&quot;; if [[ &quot;$sel_desc&quot; =~ Sec:[[:space:]]*([^[:space:]]+) ]]; then sel_sec=&quot;${BASH_REMATCH[1]}&quot;; elif [[ &quot;$sel_desc&quot; =~ Open ]]; then sel_sec=&quot;Open&quot;; fi
    local wf_pass=&quot;&quot;; if ! [[ &quot;$sel_sec&quot; =~ ^(Open|--)$ || -z &quot;$sel_sec&quot; ]]; then wf_pass=$(prompt_user_input &quot;Password for &#39;$sel_ssid_tag&#39;:&quot; &quot;&quot; true) || return 1; if [[ &quot;$sel_sec&quot; != &quot;WEP&quot; &amp;&amp; ${#wf_pass} -lt 8 &amp;&amp; -n &quot;$wf_pass&quot; ]]; then if ! prompt_yes_no &quot;Password for &#39;$sel_ssid_tag&#39; short. Continue?&quot; &quot;y&quot;; then return 1; fi; elif [[ -z &quot;$wf_pass&quot; ]]; then if ! prompt_yes_no &quot;Empty pass for secured &#39;$sel_ssid_tag&#39;. Treat as Open?&quot; &quot;n&quot;; then return 1; else sel_sec=&quot;Open&quot;; fi; fi; fi
    if connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$sel_ssid_tag&quot; &quot;$wf_pass&quot; &quot;$sel_sec&quot; &quot;false&quot;; then save_network_profile &quot;$SELECTED_IFACE&quot; &quot;$sel_ssid_tag&quot; &quot;$wf_pass&quot; &quot;$sel_sec&quot; &quot;false&quot;; return 0; fi
    return 1
}

save_network_profile() {
    local iface=&quot;$1&quot; ssid=&quot;$2&quot; password=&quot;$3&quot; security=&quot;$4&quot; hidden=&quot;$5&quot;
    local safe_fn=&quot;${ssid//[^a-zA-Z0-9._-]/_}&quot;; [[ -z &quot;$safe_fn&quot; ]] &amp;&amp; safe_fn=&quot;unnamed_ssid&quot;
    local pf=&quot;${PROFILE_DIR}/${iface}_${safe_fn}.conf&quot;; debug_log &quot;Saving profile: $pf&quot;
    mkdir -p &quot;$PROFILE_DIR&quot; 2&gt;/dev/null || warning_log &quot;Could not create $PROFILE_DIR&quot;
    (umask 077; cat &gt; &quot;$pf&quot; &lt;&lt;EOF
# Profile for SSID: $ssid on $iface by $SCRIPT_NAME v$SCRIPT_VERSION at $(date -Iseconds)
INTERFACE=&quot;$iface&quot;
SSID=&quot;$ssid&quot;
SECURITY=&quot;$security&quot;
HIDDEN=&quot;$hidden&quot;
$( [[ -n &quot;$password&quot; ]] &amp;&amp; echo &quot;PASSWORD_ENC=\&quot;$(echo -n &quot;$password&quot; | base64)\&quot;&quot; )
EOF
    ) &amp;&amp; info_log &quot;Profile saved: $pf&quot; || error_log &quot;Failed to save profile $pf&quot;
}

# --- Connectivity Check ---
# (check_connectivity from v8.0 is largely okay)
check_connectivity() {
    local test_type=&quot;${1:-full}&quot;
    _show_progress_message &quot;Checking network connectivity...&quot; &quot;transient&quot;
    local ping_tgt_ip=&quot;$PING_IP_PRIMARY&quot;; if ! ping -c 1 -W &quot;$PING_TIMEOUT&quot; &quot;$ping_tgt_ip&quot; &gt;/dev/null 2&gt;&amp;1; then ping_tgt_ip=&quot;$PING_IP_SECONDARY&quot;; fi
    if ping -c &quot;$PING_COUNT&quot; -W &quot;$PING_TIMEOUT&quot; &quot;$ping_tgt_ip&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;✓ IP connectivity to $ping_tgt_ip OK.&quot;; if [[ &quot;$test_type&quot; == &quot;basic&quot; ]]; then return 0; fi
        if ping -c &quot;$PING_COUNT&quot; -W &quot;$PING_TIMEOUT&quot; &quot;$PING_HOSTNAME&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;✓ DNS for $PING_HOSTNAME OK.&quot;; if check_command curl; then if curl -s --connect-timeout 5 -L &quot;http://$PING_HOSTNAME&quot; &gt;/dev/null 2&gt;&amp;1; then info_log &quot;✓ HTTP to $PING_HOSTNAME OK.&quot;; else warning_log &quot;HTTP to $PING_HOSTNAME failed (curl).&quot;; fi; fi; _show_progress_message &quot;Network UP (IP, DNS, HTTP tested).&quot; &quot;persistent&quot;; return 0;
        else warning_log &quot;DNS for $PING_HOSTNAME failed.&quot;; _show_progress_message &quot;Network PARTIAL (IP OK, DNS FAILED).&quot; &quot;warning&quot;; return 2; fi
    else warning_log &quot;No IP connectivity to $PING_IP_PRIMARY or $PING_IP_SECONDARY.&quot;; _show_progress_message &quot;Network DOWN (No IP connectivity).&quot; &quot;error&quot;; return 1; fi
}

# --- Main Script Functions ---
# (usage, parse_arguments, show_network_status, main from v8.0 are largely okay but need to use new prompt functions and integrate argument handling better)
usage() {
    local usage_text=&quot;Usage: sudo $SCRIPT_NAME [OPTIONS]

Universal Network Connectivity Script v$SCRIPT_VERSION

Configure Ethernet/Wi-Fi. Uses &#39;dialog&#39; for TUI if available.

OPTIONS:
  -h, --help             Show help and exit.
  -v, --version          Show version and exit.
  -d, --debug            Enable full debug (level 3).
  --debug-level LEVEL    Set debug level (1:basic, 2:verbose, 3:full).
  -V, --verbose          Alias for --debug-level 2.
  -n, --non-interactive  Run non-interactively (auto-config).
  -i, --interface IFACE  Specify interface to configure.
  -t, --type TYPE        Specify type (&#39;ethernet&#39;|&#39;wifi&#39;) for -i.
  -c, --check-only       Check connectivity, don&#39;t configure.
  --ssid SSID            (Wi-Fi) SSID to connect to (used with -i, -t wifi).
  --password PASS        (Wi-Fi) Password for SSID.
  --security SEC         (Wi-Fi) Security (WPA2-PSK, Open, WEP, WPA3-SAE).
  --hidden               (Wi-Fi) SSID is hidden.
  --install-deps         Check/install dependencies then exit.
  --status               Show network status and exit.

EXAMPLES:
  sudo $SCRIPT_NAME                     # Interactive mode
  sudo $SCRIPT_NAME -n                  # Non-interactive auto
  sudo $SCRIPT_NAME -i eth0 -t ethernet # Configure eth0
  sudo $SCRIPT_NAME -i wlan0 -t wifi --ssid \&quot;MyNet\&quot; --password \&quot;MyPass\&quot; 
&quot;
    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then _show_dialog_message &quot;msgbox&quot; &quot;Help - $SCRIPT_NAME v$SCRIPT_VERSION&quot; &quot;$usage_text&quot; 25 78; else echo -e &quot;$usage_text&quot;; fi
}

parse_arguments() {
    declare -g cli_ssid=&quot;&quot; cli_password=&quot;&quot; cli_security=&quot;&quot; cli_hidden=false # For direct Wi-Fi args
    # Reset flags that might be set if script is sourced/re-run in same shell
    DBG=false; DEBUG_LEVEL=1; NON_INTERACTIVE=false; SELECTED_IFACE=&quot;&quot;; CONNECTION_TYPE_ARG=&quot;&quot;; CHECK_ONLY_ARG=false
    INSTALL_DEPS_ARG=false; SHOW_STATUS_ARG=false

    while [[ $# -gt 0 ]]; do
        case &quot;$1&quot; in -h|--help) usage; exit 0 ;; -v|--version) echo &quot;$SCRIPT_NAME v$SCRIPT_VERSION&quot;; exit 0 ;;
            -d|--debug) DBG=true; DEBUG_LEVEL=3; shift ;;
            --debug-level) DBG=true; if [[ &quot;$2&quot; =~ ^[1-3]$ ]]; then DEBUG_LEVEL=&quot;$2&quot;; else echo &quot;Invalid debug level: $2&quot; &gt;&amp;2; exit 1; fi; shift 2 ;;
            -V|--verbose) DBG=true; DEBUG_LEVEL=2; shift ;;
            -n|--non-interactive) NON_INTERACTIVE=true; shift ;;
            -i|--interface) SELECTED_IFACE=&quot;$2&quot;; shift 2 ;;
            -t|--type) CONNECTION_TYPE_ARG=$(echo &quot;$2&quot;|tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;); shift 2 ;;
            -c|--check-only) CHECK_ONLY_ARG=true; shift ;;
            --ssid) cli_ssid=&quot;$2&quot;; shift 2 ;; --password) cli_password=&quot;$2&quot;; shift 2 ;;
            --security) cli_security=&quot;$2&quot;; shift 2 ;; --hidden) cli_hidden=true; shift ;;
            --install-deps) INSTALL_DEPS_ARG=true; shift ;; --status) SHOW_STATUS_ARG=true; shift ;;
            *) _base_log &quot;ERROR&quot; &quot;$COLOR_RED&quot; &quot;Unknown option: $1&quot;; usage; exit 1 ;;
        esac; done
    if [[ -n &quot;$cli_ssid&quot; ]]; then if [[ -z &quot;$SELECTED_IFACE&quot; || &quot;$CONNECTION_TYPE_ARG&quot; != &quot;wifi&quot; ]]; then _base_log &quot;ERROR&quot; &quot;$COLOR_RED&quot; &quot;--ssid requires -i &lt;wifi-iface&gt; and -t wifi.&quot;; usage; exit 1; fi; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then info_log &quot;Direct Wi-Fi params for non-interactive: $SELECTED_IFACE, SSID:$cli_ssid&quot;; declare -g DIRECT_WIFI_SSID=&quot;$cli_ssid&quot;; declare -g DIRECT_WIFI_PASS=&quot;$cli_password&quot;; declare -g DIRECT_WIFI_SEC=&quot;$cli_security&quot;; declare -g DIRECT_WIFI_HIDDEN=&quot;$cli_hidden&quot;; else warning_log &quot;--ssid etc. for non-interactive use primarily.&quot;; fi; fi
}

show_network_status() {
    _show_progress_message &quot;Gathering network status...&quot; &quot;transient&quot;
    local status_text=&quot;&quot;
    status_text+=&quot;\n=== Network Status ===\n&quot;
    status_text+=&quot;\n--- Network Interfaces (ip -br addr) ---\n$(ip -br addr show 2&gt;/dev/null || echo &quot;Failed to get interface addresses.&quot;)\n&quot;
    status_text+=&quot;\n--- Routing Table (ip route) ---\n$(ip route show 2&gt;/dev/null || echo &quot;Failed to get routing table.&quot;)\n&quot;
    status_text+=&quot;\n--- DNS Configuration (/etc/resolv.conf) ---\n&quot;
    if [[ -f /etc/resolv.conf ]]; then status_text+=&quot;$(grep -v &#39;^#&#39; /etc/resolv.conf | grep &#39;nameserver&#39; || echo &quot;No nameservers in /etc/resolv.conf.&quot;)&quot;; else status_text+=&quot;/etc/resolv.conf not found.&quot;; fi
    status_text+=&quot;\n&quot;
    if systemctl is-active systemd-resolved &gt;/dev/null 2&gt;&amp;1 &amp;&amp; check_command resolvectl; then status_text+=&quot;\n--- Systemd-Resolved Status ---\n$(resolvectl status 2&gt;/dev/null || echo &quot;Failed to get resolvectl status.&quot;)\n&quot;; fi
    status_text+=&quot;\n--- Connectivity Test ---\n&quot; # check_connectivity will print its own messages
    if $DIALOG_AVAILABLE &amp;&amp; [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then _show_dialog_message &quot;msgbox&quot; &quot;Network Status&quot; &quot;$status_text&quot; 20 75; else echo -e &quot;$status_text&quot;; fi
    check_connectivity &quot;full&quot;
}

main() {
    # Global flags that parse_arguments will set.
    declare -g INSTALL_DEPS_ARG=false SHOW_STATUS_ARG=false
    parse_arguments &quot;$@&quot;
    if $DBG; then mkdir -p &quot;$LOG_DIR&quot; 2&gt;/dev/null; DEBUG_LOG_FILE=&quot;${LOG_DIR}/netconnect_debug_$(date +%Y%m%d_%H%M%S)_$$.log&quot;; if ! touch &quot;$DEBUG_LOG_FILE&quot; 2&gt;/dev/null; then echo &quot;WARN: Cannot write debug log $DEBUG_LOG_FILE&quot; &gt;&amp;2; DEBUG_LOG_FILE=&quot;&quot;; else _base_log &quot;INFO&quot; &quot;$COLOR_GREEN&quot; &quot;Debug mode L$DEBUG_LEVEL. Log: $DEBUG_LOG_FILE&quot;; eval &quot;exec $XTRACE_FD&gt;&gt;\&quot;\$DEBUG_LOG_FILE\&quot;&quot;; export BASH_XTRACEFD=&quot;$XTRACE_FD&quot;; set -x; fi; fi
    debug_log &quot;Script $SCRIPT_NAME v$SCRIPT_VERSION started (PID $$)&quot;; debug_var_array=(&quot;NON_INTERACTIVE&quot; &quot;SELECTED_IFACE&quot; &quot;CONNECTION_TYPE_ARG&quot; &quot;CHECK_ONLY_ARG&quot;); for v in &quot;${debug_var_array[@]}&quot;; do debug_var &quot;$v&quot;; done
    check_root; acquire_lock; init_directories
    if check_command dialog; then DIALOG_AVAILABLE=true; debug_log &quot;Dialog available.&quot;; else DIALOG_AVAILABLE=false; info_log &quot;Dialog not found. Basic prompts.&quot;; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then install_packages_dialog &quot;dialog,dialog&quot; || info_log &quot;Proceeding without dialog.&quot;; fi; fi
    if ! $DIALOG_AVAILABLE || [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then echo -e &quot;${COLOR_GREEN}=== $SCRIPT_NAME v$SCRIPT_VERSION ===${COLOR_RESET}\n&quot; &gt;&amp;2; else &quot;$DIALOG_CMD&quot; --cr-wrap --title &quot;$SCRIPT_NAME&quot; --msgbox &quot;Welcome to Universal Network Connectivity Script v$SCRIPT_VERSION&quot; 8 60 2&gt;/dev/tty; fi
    if $INSTALL_DEPS_ARG; then info_log &quot;Checking/installing dependencies...&quot;; local deps=(&quot;dialog,dialog&quot; &quot;ip,iproute2&quot; &quot;ping,iputils-ping&quot; &quot;curl,curl&quot; &quot;nmcli,network-manager&quot; &quot;wpa_cli,wpasupplicant&quot; &quot;iw,iw&quot;); install_packages_dialog &quot;${deps[@]}&quot;; exit 0; fi
    detect_network_tools; detect_ethernet_interfaces; detect_wifi_interfaces
    if $SHOW_STATUS_ARG; then show_network_status; exit 0; fi
    if check_connectivity &quot;basic&quot;; then info_log &quot;✓ Internet connection active.&quot;; if $CHECK_ONLY_ARG; then exit 0; fi; if [[ &quot;$NON_INTERACTIVE&quot; == &quot;false&quot; ]]; then if ! prompt_yes_no &quot;Connection active. Reconfigure?&quot; &quot;n&quot;; then exit 0; fi; else info_log &quot;Non-interactive: Exiting, connection active.&quot;; exit 0; fi; else info_log &quot;No active connection. Proceeding...&quot;; if $CHECK_ONLY_ARG; then exit 1; fi; fi

    if [[ &quot;$NON_INTERACTIVE&quot; == &quot;true&quot; ]]; then info_log &quot;Non-interactive mode...&quot;; local connected=false
        if [[ -n &quot;$SELECTED_IFACE&quot; &amp;&amp; -n &quot;$CONNECTION_TYPE_ARG&quot; ]]; then info_log &quot;Configuring specified $SELECTED_IFACE ($CONNECTION_TYPE_ARG)...&quot;
            if [[ &quot;$CONNECTION_TYPE_ARG&quot; == &quot;ethernet&quot; ]]; then if configure_ethernet &quot;$SELECTED_IFACE&quot;; then check_connectivity &amp;&amp; connected=true; fi
            elif [[ &quot;$CONNECTION_TYPE_ARG&quot; == &quot;wifi&quot; ]]; then if [[ -n &quot;${DIRECT_WIFI_SSID:-}&quot; ]]; then if connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$DIRECT_WIFI_SSID&quot; &quot;${DIRECT_WIFI_PASS:-}&quot; &quot;${DIRECT_WIFI_SEC:-}&quot; &quot;${DIRECT_WIFI_HIDDEN:-false}&quot;; then check_connectivity &amp;&amp; connected=true; fi; else info_log &quot;No direct SSID for $SELECTED_IFACE. Trying profiles...&quot;; for pf in &quot;${PROFILE_DIR}/${SELECTED_IFACE}_&quot;*.conf; do if [[ -f &quot;$pf&quot; ]]; then debug_log &quot;Profile: $pf&quot;; local PI PS PSEC PPASSENC PHID; source &quot;$pf&quot;; PI=&quot;${INTERFACE:-}&quot;; PS=&quot;${SSID:-}&quot;; PSEC=&quot;${SECURITY:-}&quot;; PPASSENC=&quot;${PASSWORD_ENC:-}&quot;; PHID=&quot;${HIDDEN:-false}&quot;; if [[ &quot;$PI&quot; == &quot;$SELECTED_IFACE&quot; &amp;&amp; -n &quot;$PS&quot; ]]; then local pp; [[ -n &quot;$PPASSENC&quot; ]] &amp;&amp; pp=$(echo &quot;$PPASSENC&quot;|base64 -d); if connect_wifi &quot;$SELECTED_IFACE&quot; &quot;$PS&quot; &quot;$pp&quot; &quot;$PSEC&quot; &quot;$PHID&quot;; then if check_connectivity; then connected=true; break; fi; fi; fi; fi; done; fi; fi
        fi
        if ! $connected; then info_log &quot;Specified config failed or no specific args. Trying auto...&quot;; for eth_if in &quot;${ETH_IFACES[@]}&quot;; do if configure_dhcp &quot;$eth_if&quot;; then if check_connectivity; then connected=true; break; fi; fi; done
            if ! $connected &amp;&amp; [[ ${#WIFI_IFACES[@]} -gt 0 ]]; then for wifi_if in &quot;${WIFI_IFACES[@]}&quot;; do for pf in &quot;${PROFILE_DIR}/${wifi_if}_&quot;*.conf; do if [[ -f &quot;$pf&quot; ]]; then debug_log &quot;Profile: $pf for $wifi_if&quot;; local PI PS PSEC PPASSENC PHID; source &quot;$pf&quot;; PI=&quot;${INTERFACE:-}&quot;; PS=&quot;${SSID:-}&quot;; PSEC=&quot;${SECURITY:-}&quot;; PPASSENC=&quot;${PASSWORD_ENC:-}&quot;; PHID=&quot;${HIDDEN:-false}&quot;; if [[ &quot;$PI&quot; == &quot;$wifi_if&quot; &amp;&amp; -n &quot;$PS&quot; ]]; then local pp; [[ -n &quot;$PPASSENC&quot; ]] &amp;&amp; pp=$(echo &quot;$PPASSENC&quot;|base64 -d); if connect_wifi &quot;$wifi_if&quot; &quot;$PS&quot; &quot;$pp&quot; &quot;$PSEC&quot; &quot;$PHID&quot;; then if check_connectivity; then connected=true; break 2; fi; fi; fi; fi; done; done; fi
        fi
        if $connected; then info_log &quot;✓ Non-interactive connection OK.&quot;; exit 0; else error_log &quot;Non-interactive connection FAILED.&quot;; exit 1; fi
    fi

    while true; do echo; local menu_opts=(); if [[ ${#ETH_IFACES[@]} -gt 0 ]]; then menu_opts+=(&quot;ETH&quot; &quot;Ethernet (${#ETH_IFACES[@]})&quot;); fi; if [[ ${#WIFI_IFACES[@]} -gt 0 ]]; then menu_opts+=(&quot;WIFI&quot; &quot;Wi-Fi (${#WIFI_IFACES[@]})&quot;); fi; menu_opts+=(&quot;STATUS&quot; &quot;Network Status&quot; &quot;CHECK&quot; &quot;Re-check Connectivity&quot; &quot;EXIT&quot; &quot;Exit&quot;);
        local choice; choice=$(prompt_select_option &quot;Select action:&quot; &quot;${menu_opts[@]}&quot;) || { info_log &quot;Exiting (cancel).&quot;; exit 0; }
        case &quot;$choice&quot; in
            ETH) if [[ ${#ETH_IFACES[@]} -gt 0 ]]; then if configure_ethernet &quot;$SELECTED_IFACE&quot;; then check_connectivity &amp;&amp; _show_progress_message &quot;Ethernet OK!&quot; &quot;persistent&quot; &amp;&amp; exit 0; fi; else _show_progress_message &quot;No Ethernet.&quot; &quot;warning&quot;; fi; SELECTED_IFACE=&quot;&quot;;;
            WIFI) if [[ ${#WIFI_IFACES[@]} -gt 0 ]]; then if configure_wifi &quot;$SELECTED_IFACE&quot;; then check_connectivity &amp;&amp; _show_progress_message &quot;Wi-Fi OK!&quot; &quot;persistent&quot; &amp;&amp; exit 0; fi; else _show_progress_message &quot;No Wi-Fi.&quot; &quot;warning&quot;; fi; SELECTED_IFACE=&quot;&quot;;;
            STATUS) show_network_status ;; CHECK) check_connectivity ;; EXIT) info_log &quot;User Exit.&quot;; exit 0 ;; *) error_log &quot;Invalid choice: $choice&quot; ;;
        esac
        if ! check_connectivity &quot;basic&quot;; then if ! prompt_yes_no &quot;Connection failed/none. Try again?&quot; &quot;y&quot;; then error_log &quot;Exiting (failed attempts).&quot;; exit 1; fi; fi
    done
    exit 1 # Should not reach
}

# Run main function
main &quot;$@&quot;</code>
</section>

        </div>
        
          URL: https://ib.bsb.br/internet4linux
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/infinite-tool-use/" title="Infinite tool use" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/network-diag/" title="network diag" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts>bash"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts-bash" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/network-diag/" title="network diag" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-06-20 01:56:32
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scripts-bash">
                  scripts>bash
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/internet4linux/"
        },
        "headline": "Internet Connectivity Solution for linux",
        "description": "",
        "datePublished": "2025-05-26T00:00:00+00:00",
        "dateModified": "2025-05-28T00:07:28+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
