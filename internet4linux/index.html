<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Internet Connectivity Solution for linux - infoBAG
      
    </title>
    <meta name="title" content="Internet Connectivity Solution for linux - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/internet4linux/">
    <meta property="og:title" content="Internet Connectivity Solution for linux - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/internet4linux/">
    <meta name="twitter:title" content="Internet Connectivity Solution for linux - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/internet4linux/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scripts&gt;bash">
      
        <meta property="article:tag" content="scripts&gt;bash">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Internet Connectivity Solution for linux
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-05-26T00:00:00+00:00" class="post-date">
          26 May 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-05-27T00:38:51+00:00">
              27 May 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/internet4linux" class="tag">internet4linux</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scripts-bash" class="tag">scripts>bash</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        72909 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        6884 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-05-26-internet4linux.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-05-26-internet4linux.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#sudo-apt-install">sudo apt install</a></li><li><a href="#bash-wifish">bash wifi.sh</a></li></ul>
          <h1 id="sudo-apt-install">
    
    
     <a href="#sudo-apt-install">#</a><a href="#" aria-label="Back to top">sudo apt install</a>
        
    
  </h1>
      
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>sudo apt install -y dialog network-manager wpasupplicant isc-dhcp-client iproute2 iw iputils-ping wireless-tools procps mawk
</code></section></div></div>
  <h1 id="bash-wifish">
    
    
     <a href="#bash-wifish">#</a><a href="#" aria-label="Back to top">bash wifi.sh</a>
        
    
  </h1>
      

<section class="code-block-container" role="group" aria-label="Bash Code Block" data-filename="bash_code_block.sh" data-code="#!/usr/bin/env bash
#
# Universal Network Connectivity Script for RK3588 VPC-3588 (Debian Bullseye)
#
# This script attempts to establish an internet connection via Ethernet or Wi-Fi,
# interactively prompting the user for necessary information.
# It must be run with root privileges.
#
# Version 3.2: Corrected premature &#39;fi&#39; tokens in scan_wifi_networks.

# --- Script Setup ---
set -e
set -o pipefail

# --- Debug Configuration ---
DEBUG_LEVEL=${DEBUG_LEVEL:-1} # 0=off, 1=basic, 2=verbose, 3=full (used if DBG is true)
DBG=${DBG:-false}             # Global debug flag, can be set by --debug argument
DEBUG_LOG_FILE=&quot;&quot;             # Initialized globally, set in main if DBG is true
VERBOSE_COMMANDS=${VERBOSE_COMMANDS:-true} # Set to false to disable command verbosity in debug_exec if DBG is true
XTRACE_FD=6                   # File descriptor for xtrace output

# --- Global Variables ---
ETH_IFACES=()
WIFI_IFACES=()
SELECTED_ETH_IFACE=&quot;&quot;
SELECTED_WIFI_IFACE=&quot;&quot;
NM_IS_ACTIVE=false
DIALOG_SUCCESS_CODE=0
DIALOG_CANCEL_CODE=1
DIALOG_HELP_CODE=2 # Not explicitly used by this script&#39;s dialog calls
DIALOG_EXTRA_CODE=3 # Not explicitly used
DIALOG_ESC_CODE=255 # Standard for Esc key
DIALOG_DEFAULT_HEIGHT=15
DIALOG_DEFAULT_WIDTH=70
DIALOG_INPUT_WIDTH=50

PING_IP_TARGET=&quot;8.8.8.8&quot;
PING_HOSTNAME_TARGET=&quot;google.com&quot;
PING_COUNT=3
PING_TIMEOUT=2

TMP_FILES_TO_CLEAN=()

# --- Logging Functions ---
_log_to_file() {
    if $DBG &amp;&amp; [ -n &quot;$DEBUG_LOG_FILE&quot; ]; then
        echo -e &quot;$1&quot; &gt;&gt; &quot;$DEBUG_LOG_FILE&quot;
    fi
}

debug_log() {
    if ! $DBG; then return 0; fi

    local level_tag=&quot;$1&quot;; shift
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;
    local log_entry=&quot;[$timestamp] [$level_tag] [$caller_info] $message&quot;

    echo -e &quot;$log_entry&quot; &gt;&amp;2 # Debug logs always go to stderr
    _log_to_file &quot;$log_entry&quot; # And to file if DBG and DEBUG_LOG_FILE is set
}

debug_basic() { if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 1 ]; then debug_log &quot;DEBUG&quot; &quot;$@&quot;; fi; }
debug_verbose() { if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 2 ]; then debug_log &quot;VERB&quot; &quot;$@&quot;; fi; }
debug_full() { if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 3 ]; then debug_log &quot;FULL&quot; &quot;$@&quot;; fi; }

info_log() {
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local log_entry=&quot;[$timestamp] [INFO] $message&quot;
    echo -e &quot;$log_entry&quot; &gt;&amp;2
    _log_to_file &quot;$log_entry&quot;
}

error_log() {
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;
    local log_entry=&quot;[$timestamp] [ERROR] [$caller_info] $message&quot;
    echo -e &quot;$log_entry&quot; &gt;&amp;2
    _log_to_file &quot;$log_entry&quot;
}

warning_log() {
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;
    local log_entry=&quot;[$timestamp] [WARN] [$caller_info] $message&quot;
    echo -e &quot;$log_entry&quot; &gt;&amp;2
    _log_to_file &quot;$log_entry&quot;
}

debug_exec() {
    local cmd_string=&quot;$*&quot;
    debug_verbose &quot;Executing: $cmd_string&quot;

    if $DBG &amp;&amp; $VERBOSE_COMMANDS &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 2 ]; then
        local output exit_code
        # Using a subshell to capture output and exit code reliably
        output=$( (eval &quot;$cmd_string&quot;) 2&gt;&amp;1)
        exit_code=$?
        
        debug_verbose &quot;Exit code: $exit_code&quot;
        [ -n &quot;$output&quot; ] &amp;&amp; debug_full &quot;Output:\n$output&quot;
        
        if [ $exit_code -ne 0 ]; then
            debug_basic &quot;FAILED command: $cmd_string (Exit Code: $exit_code)&quot;
        fi
        echo &quot;$output&quot; 
        return $exit_code
    else
        eval &quot;$cmd_string&quot;
        return $?
    fi
}

debug_var() {
    if ! $DBG || [ &quot;$DEBUG_LEVEL&quot; -lt 2 ]; then return 0; fi
    local var_name=&quot;$1&quot;
    local var_value=&quot;${!var_name}&quot;
    debug_verbose &quot;Variable $var_name = &#39;$var_value&#39; (length: ${#var_value})&quot;

    if [[ &quot;$var_value&quot; =~ [[:cntrl:]] ]]; then
        debug_basic &quot;WARNING: Variable $var_name contains control characters.&quot;
        debug_full &quot;Hex dump for $var_name:\n$(echo -n &quot;$var_value&quot; | hexdump -C)&quot;
    fi
}

# --- Safe File Operations ---
create_temp_file() {
    local prefix=&quot;${1:-tmpfile}&quot;
    local suffix_val=&quot;${2:-}&quot; # e.g., &quot;.log&quot; or &quot;list&quot;
    local temp_file
    
    local sane_prefix
    sane_prefix=$(echo &quot;$prefix&quot; | tr -cs &#39;[:alnum:]_-&#39; &#39;_&#39;)
    local sane_suffix
    sane_suffix=$(echo &quot;$suffix_val&quot; | tr -cs &#39;[:alnum:]_.-&#39; &#39;_&#39;)

    # mktemp requires XXXXXX at end of template. Suffix is appended by mktemp if specified.
    # Ensure suffix starts with a dot if it&#39;s meant as an extension and not empty.
    if [[ -n &quot;$sane_suffix&quot; &amp;&amp; ! &quot;$sane_suffix&quot; =~ ^\. ]]; then
        sane_suffix=&quot;.$sane_suffix&quot;
    fi
    
    temp_file=$(mktemp &quot;/tmp/${sane_prefix}.XXXXXX${sane_suffix}&quot;)

    if [ -z &quot;$temp_file&quot; ] || [ ! -f &quot;$temp_file&quot; ] &amp;&amp; [ ! -d &quot;$temp_file&quot; ]; then
        error_log &quot;Failed to create temporary file with prefix &#39;$sane_prefix&#39; and suffix &#39;$sane_suffix&#39;&quot;
        return 1
    fi

    debug_verbose &quot;Created temporary file: &#39;$temp_file&#39;&quot;
    TMP_FILES_TO_CLEAN+=(&quot;$temp_file&quot;)
    echo &quot;$temp_file&quot;
    return 0
}

safe_rm() {
    local file_to_remove=&quot;$1&quot;
    debug_verbose &quot;Attempting to remove: &#39;$file_to_remove&#39;&quot;

    if [ -z &quot;$file_to_remove&quot; ]; then
        warning_log &quot;safe_rm: Empty filename provided.&quot;
        return 1
    fi
    if [ ! -e &quot;$file_to_remove&quot; ]; then
         debug_verbose &quot;File does not exist, skipping removal: &#39;$file_to_remove&#39;&quot;
         return 0
    fi

    if [ ${#file_to_remove} -gt 255 ]; then
        error_log &quot;safe_rm: Filename too long to remove: &#39;$file_to_remove&#39;&quot;
        return 1
    fi
    if [[ &quot;$file_to_remove&quot; =~ (\.\./|/\.\.) ]]; then
        error_log &quot;safe_rm: Path traversal attempt suspected: &#39;$file_to_remove&#39;&quot;
        return 1
    fi
    if [[ &quot;$file_to_remove&quot; == &quot;/&quot; ]] || [[ &quot;$file_to_remove&quot; == &quot;/bin&quot; ]] || [[ &quot;$file_to_remove&quot; == &quot;/etc&quot; ]] ; then
        error_log &quot;safe_rm: Critical path removal protection: &#39;$file_to_remove&#39;&quot;
        return 1
    fi

    if rm -f &quot;$file_to_remove&quot;; then
        debug_verbose &quot;Successfully removed: &#39;$file_to_remove&#39;&quot;
        return 0
    else
        error_log &quot;Failed to remove: &#39;$file_to_remove&#39; (Error: $?)&quot;
        return 1
    fi
}

# --- Cleanup Function ---
cleanup() {
    local exit_code=$?
    debug_basic &quot;Cleanup: Script exiting with code $exit_code&quot;
    
    if [ ${#TMP_FILES_TO_CLEAN[@]} -gt 0 ]; then
        debug_verbose &quot;Cleaning up ${#TMP_FILES_TO_CLEAN[@]} temporary file(s): ${TMP_FILES_TO_CLEAN[*]}&quot;
        for temp_file in &quot;${TMP_FILES_TO_CLEAN[@]}&quot;; do
            safe_rm &quot;$temp_file&quot;
        done
    else
        debug_verbose &quot;No temporary files registered for cleanup.&quot;
    fi

    if command -v stty &gt;/dev/null 2&gt;&amp;1; then
        stty sane 2&gt;/dev/null || debug_verbose &quot;stty sane failed (expected on some exits)&quot;
    fi
    if command -v tput &gt;/dev/null 2&gt;&amp;1; then
        tput cnorm 2&gt;/dev/null || debug_verbose &quot;tput cnorm failed (expected on some exits)&quot;
    fi
    
    # Stop xtrace and close its FD if it was used
    if $DBG &amp;&amp; [ -n &quot;$DEBUG_LOG_FILE&quot; ]; then
        set +x # Turn off xtrace
        # Close the xtrace file descriptor
        eval &quot;exec $XTRACE_FD&gt;&amp;-&quot; 2&gt;/dev/null || debug_verbose &quot;Failed to close XTRACE_FD $XTRACE_FD&quot;
        info_log &quot;Script exited (Code: $exit_code). Debug log available at: $DEBUG_LOG_FILE&quot;
        echo &quot;Debug log available at: $DEBUG_LOG_FILE&quot; &gt;&amp;2
    else
        info_log &quot;Script exited (Code: $exit_code). Cleanup performed.&quot;
    fi

    if [ $exit_code -ne 0 ] &amp;&amp; [ $exit_code -ne 130 ]; then # 130 is SIGINT/SIGTERM
        # Only prompt if running in an interactive terminal
        if [ -t 0 ] &amp;&amp; [ -t 1 ]; then # Check if stdin and stdout are terminals
            read -rp &quot;Press Enter to close terminal...&quot; &lt;/dev/tty
        fi
    fi
    exit $exit_code
}
trap cleanup EXIT
trap &#39;error_log &quot;Script interrupted by user (SIGINT/SIGTERM).&quot;; exit 130&#39; SIGINT SIGTERM

# --- Dialog UI Functions ---
_show_dialog_message() {
    local type=&quot;$1&quot;
    local title=&quot;$2&quot;
    local message=&quot;$3&quot;
    local height=${4:-8}
    local width=${5:-60}
    
    debug_verbose &quot;Showing dialog: type=$type, title=&#39;$title&#39;, message snippet=&#39;${message:0:50}...&#39;&quot;
    dialog --title &quot;$title&quot; --&quot;$type&quot; &quot;$message&quot; &quot;$height&quot; &quot;$width&quot; 2&gt;/dev/tty
    local dialog_exit_code=$?
    debug_verbose &quot;Dialog (&#39;$title&#39;) exit code: $dialog_exit_code&quot;
    return $dialog_exit_code
}

log_info_persistent() { info_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Information&quot; &quot;$1&quot;; }
log_info_transient() { info_log &quot;$1&quot;; dialog --title &quot;Information&quot; --infobox &quot;$1&quot; 6 60 2&gt;/dev/tty || true; sleep 1; } # Allow infobox to fail gracefully
log_msg() { info_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Message&quot; &quot;$1&quot;; }
log_error() { error_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Error&quot; &quot;$1&quot;; }
log_warning() { warning_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Warning&quot; &quot;$1&quot;; }

# --- Prerequisite Checks ---
check_command() {
    local cmd_to_check=&quot;$1&quot;
    debug_verbose &quot;Checking for command: $cmd_to_check&quot;
    if command -v &quot;$cmd_to_check&quot; &gt;/dev/null 2&gt;&amp;1; then
        debug_verbose &quot;Command &#39;$cmd_to_check&#39; found.&quot;
        return 0
    else
        debug_basic &quot;Command &#39;$cmd_to_check&#39; not found.&quot;
        return 1
    fi
}

install_packages() {
    local missing_packages_to_install=()
    local pkg_info cmd pkg_name choice
    
    debug_basic &quot;Checking required packages: $@&quot;
    for pkg_info in &quot;$@&quot;; do
        IFS=&#39;,&#39; read -r cmd pkg_name &lt;&lt;&lt; &quot;$pkg_info&quot;
        debug_verbose &quot;Checking for command &#39;$cmd&#39; (package &#39;$pkg_name&#39;)&quot;
        if ! check_command &quot;$cmd&quot;; then
            debug_basic &quot;Missing command &#39;$cmd&#39; for package &#39;$pkg_name&#39;&quot;
            missing_packages_to_install+=(&quot;$pkg_name&quot;)
        fi
    done

    if [ ${#missing_packages_to_install[@]} -gt 0 ]; then
        warning_log &quot;Missing packages: ${missing_packages_to_install[*]}&quot;
        dialog --title &quot;Missing Packages&quot; \
               --yesno &quot;The following essential packages are missing: ${missing_packages_to_install[*]}.\\n\\nDo you want to try and install them now?\\n(Requires an existing temporary internet connection or cached packages)&quot; \
               12 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
        choice=$?
        debug_basic &quot;Install prompt choice code: $choice&quot;

        if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
            info_log &quot;User opted to install missing packages: ${missing_packages_to_install[*]}&quot;
            log_info_transient &quot;Attempting to install: ${missing_packages_to_install[*]}...&quot;
            
            if debug_exec &quot;apt-get update -qq&quot;; then
                if debug_exec &quot;apt-get install -y ${missing_packages_to_install[@]}&quot;; then
                    log_info_persistent &quot;Successfully installed missing packages.&quot;
                else
                    error_log &quot;Failed to install packages: ${missing_packages_to_install[*]} after apt-get update.&quot;
                    log_error &quot;Failed to install some packages. Please install them manually and re-run the script.\\nPackages: ${missing_packages_to_install[*]}&quot;
                    exit 1
                fi
            else
                error_log &quot;&#39;apt-get update&#39; failed. Cannot install packages.&quot;
                log_error &quot;&#39;apt-get update&#39; failed. Please check your network connection and apt sources, then re-run the script.&quot;
                exit 1
            fi
        else
            error_log &quot;User declined package installation or cancelled.&quot;
            log_error &quot;Cannot proceed without essential packages: ${missing_packages_to_install[*]}. Exiting.&quot;
            exit 1
        fi
    else
        debug_basic &quot;All required packages are present.&quot;
    fi
}

# --- Network Interface and Manager Detection ---
detect_ethernet_interfaces() {
    debug_basic &quot;Detecting Ethernet interfaces...&quot;
    ETH_IFACES=()
    local detected_output
    # Improved detection: exclude virtual interfaces more reliably, handle interfaces without carrier initially
    detected_output=$(debug_exec &quot;ip -o link show type ether 2&gt;/dev/null | awk -F&#39;: &#39; &#39;!/master|link\\/ether 00:00:00:00:00:00/{print \$2}&#39; | awk &#39;{print \$1}&#39; | grep -Ev &#39;^(lo|br|bond|dummy|veth|virbr|docker|tun|tap|vlan|vxlan|macvlan|macvtap|nlmon|gre|ipip|sit|ip6tnl)&#39; || true&quot;)
    
    debug_full &quot;Raw detected ethernet interfaces output: &#39;$detected_output&#39;&quot;
    if [ -n &quot;$detected_output&quot; ]; then
        while IFS= read -r iface; do
            iface_clean=$(echo &quot;$iface&quot; | tr -cd &#39;[:alnum:]_-&#39;) # Allow hyphens and underscores
            if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; ]]; then
                ETH_IFACES+=(&quot;$iface_clean&quot;)
                debug_verbose &quot;Added Ethernet interface: &#39;$iface_clean&#39;&quot;
            elif [ -n &quot;$iface&quot; ]; then
                 warning_log &quot;Skipped potentially invalid Ethernet interface name: &#39;$iface&#39;&quot;
            fi
        done &lt;&lt;&lt; &quot;$detected_output&quot;
    fi
    log_info_transient &quot;Detected Ethernet interfaces: ${ETH_IFACES[*]:-(None)}&quot;
}

detect_wifi_interfaces() {
    debug_basic &quot;Detecting Wi-Fi interfaces...&quot;
    WIFI_IFACES=()
    local detected_output=&quot;&quot;

    if check_command iw; then
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;iw dev&#39;&quot;
        detected_output=$(debug_exec &quot;iw dev 2&gt;/dev/null | awk &#39;\$1==\&quot;Interface\&quot;{print \$2}&#39; || true&quot;)
        debug_full &quot;Raw detected Wi-Fi interfaces output (iw): &#39;$detected_output&#39;&quot;
    fi
    
    if [ -z &quot;$detected_output&quot; ] &amp;&amp; check_command ip; then # Fallback if &#39;iw&#39; fails or not present
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;ip link&#39; (fallback)&quot;
        # &#39;type wlan&#39; is more specific for Wi-Fi than just &#39;type ether&#39;
        detected_output=$(debug_exec &quot;ip -o link show type wlan 2&gt;/dev/null | awk -F&#39;: &#39; &#39;{print \$2}&#39; | awk &#39;{print \$1}&#39; || true&quot;)
        debug_full &quot;Raw detected Wi-Fi interfaces output (ip): &#39;$detected_output&#39;&quot;
    fi

    if [ -n &quot;$detected_output&quot; ]; then
        while IFS= read -r iface; do
            iface_clean=$(echo &quot;$iface&quot; | tr -cd &#39;[:alnum:]_-&#39;) # Allow hyphens and underscores
            if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; ]]; then
                WIFI_IFACES+=(&quot;$iface_clean&quot;)
                debug_verbose &quot;Added Wi-Fi interface: &#39;$iface_clean&#39;&quot;
            elif [ -n &quot;$iface&quot; ]; then
                warning_log &quot;Skipped potentially invalid Wi-Fi interface name: &#39;$iface&#39;&quot;
            fi
        done &lt;&lt;&lt; &quot;$detected_output&quot;
    fi
    log_info_transient &quot;Detected Wi-Fi interfaces: ${WIFI_IFACES[*]:-(None)}&quot;
}

check_network_manager_active() {
    debug_basic &quot;Checking NetworkManager service status...&quot;
    if check_command systemctl &amp;&amp; systemctl is-active --quiet NetworkManager; then
        NM_IS_ACTIVE=true
        info_log &quot;NetworkManager service is active.&quot;
        log_info_transient &quot;NetworkManager service is active.&quot;
    else
        NM_IS_ACTIVE=false
        info_log &quot;NetworkManager service is not active or not found.&quot;
        log_info_transient &quot;NetworkManager service is not active or not found.&quot;
    fi
    debug_var &quot;NM_IS_ACTIVE&quot;
}

# --- User Interaction and Selection (Robust Dialog Handling) ---
prompt_select_interface() {
    local type=&quot;$1&quot;; shift
    local interfaces_array=(&quot;$@&quot;)
    local dialog_options=() choice_tag i=1 selected_interface=&quot;&quot;

    debug_basic &quot;Prompting user to select $type interface. Available: ${interfaces_array[*]}&quot;
    debug_var &quot;type&quot;

    if [ ${#interfaces_array[@]} -eq 0 ]; then
        log_warning &quot;No $type interfaces found to select.&quot;; return 1
    elif [ ${#interfaces_array[@]} -eq 1 ]; then
        selected_interface=&quot;${interfaces_array[0]}&quot;
        log_info_persistent &quot;Auto-selecting $type interface: $selected_interface&quot;
        echo &quot;$selected_interface&quot;; return 0
    fi

    for iface_item in &quot;${interfaces_array[@]}&quot;; do dialog_options+=(&quot;$i&quot; &quot;$iface_item&quot;); i=$((i + 1)); done
    debug_verbose &quot;Dialog options for $type selection: ${dialog_options[*]}&quot;

    exec 3&gt;&amp;1 
    choice_tag=$(dialog --title &quot;Select $type Interface&quot; \
        --menu &quot;Choose the $type interface to configure:&quot; \
        ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} $((${#dialog_options[@]} / 2)) \
        &quot;${dialog_options[@]}&quot; 2&gt;&amp;1 1&gt;&amp;3) 
    local dialog_exit_status=$?
    exec 3&gt;&amp;- 

    debug_basic &quot;$type interface selection: dialog exit status: $dialog_exit_status, captured tag: &#39;$choice_tag&#39;&quot;

    if [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]; then
        log_info_persistent &quot;$type interface selection cancelled by user.&quot;; return 1
    fi
    
    local choice_tag_cleaned
    choice_tag_cleaned=$(echo &quot;$choice_tag&quot; | tr -cd &#39;0-9&#39;) # Ensure only digits
    if [ -z &quot;$choice_tag_cleaned&quot; ] || ! [[ &quot;$choice_tag_cleaned&quot; =~ ^[0-9]+$ ]] || \
       [ &quot;$choice_tag_cleaned&quot; -lt 1 ] || [ &quot;$choice_tag_cleaned&quot; -gt $((${#dialog_options[@]} / 2)) ]; then
        error_log &quot;Invalid or empty selection tag received from $type interface menu: &#39;$choice_tag&#39;&quot;
        log_warning &quot;Invalid selection from $type interface menu.&quot;; return 1
    fi
    
    selected_interface=&quot;${interfaces_array[$((choice_tag_cleaned - 1))]}&quot;
    debug_basic &quot;User selected $type interface: &#39;$selected_interface&#39;&quot;
    echo &quot;$selected_interface&quot;; return 0
}

prompt_static_config() {
    local interface_type=&quot;$1&quot; 
    local static_ip=&quot;&quot; static_gateway=&quot;&quot; static_dns=&quot;&quot;
    local dialog_exit_status

    debug_basic &quot;Prompting for static IP configuration for $interface_type&quot;

    exec 3&gt;&amp;1
    static_ip=$(dialog --title &quot;Static IP Configuration ($interface_type)&quot; \
        --inputbox &quot;Enter Static IP Address with CIDR (e.g., 192.168.1.100/24):&quot; \
        10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
    dialog_exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;Static IP dialog exit: $dialog_exit_status, value: &#39;$static_ip&#39;&quot;
    [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ] &amp;&amp; { log_info_persistent &quot;Static IP entry cancelled.&quot;; return 1; }

    exec 3&gt;&amp;1
    static_gateway=$(dialog --title &quot;Static IP Configuration ($interface_type)&quot; \
        --inputbox &quot;Enter Gateway IP Address (e.g., 192.168.1.1):&quot; \
        10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
    dialog_exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;Gateway dialog exit: $dialog_exit_status, value: &#39;$static_gateway&#39;&quot;
    [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ] &amp;&amp; { log_info_persistent &quot;Gateway entry cancelled.&quot;; return 1; }

    exec 3&gt;&amp;1
    static_dns=$(dialog --title &quot;Static IP Configuration ($interface_type)&quot; \
        --inputbox &quot;Enter DNS Server(s) (comma-separated, e.g., 8.8.8.8,1.1.1.1, optional):&quot; \
        10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
    dialog_exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;DNS dialog exit: $dialog_exit_status, value: &#39;$static_dns&#39;&quot;
    # If DNS entry is cancelled (ESC or Cancel button), dialog_exit_status will be non-zero.
    # In this case, static_dns (captured from dialog&#39;s stdout) will be empty.
    # So, we just proceed, and if static_dns is empty, no DNS will be configured.
    if [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]; then
        log_info_persistent &quot;DNS entry cancelled or skipped, DNS will not be set.&quot;
        static_dns=&quot;&quot; # Ensure it&#39;s empty if cancelled
    fi

    if [[ -z &quot;$static_ip&quot; || -z &quot;$static_gateway&quot; ]]; then
        log_error &quot;Static IP and Gateway cannot be empty.&quot;; return 1;
    fi
    if ! echo &quot;$static_ip&quot; | grep -qE &quot;/[0-9]{1,2}$&quot;; then
        log_error &quot;Static IP must be in CIDR notation (e.g., 192.168.1.100/24).&quot;; return 1;
    fi
    if ! echo &quot;$static_gateway&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$&quot;; then
        log_error &quot;Gateway IP Address format is invalid (e.g., 192.168.1.1).&quot;; return 1;
    fi
    if [ -n &quot;$static_dns&quot; ]; then
        IFS=&#39;,&#39; read -ra dns_array &lt;&lt;&lt; &quot;$static_dns&quot;
        for dns_entry in &quot;${dns_array[@]}&quot;; do
            # Trim whitespace from dns_entry
            dns_entry_trimmed=$(echo &quot;$dns_entry&quot; | awk &#39;{$1=$1};1&#39;)
            if ! echo &quot;$dns_entry_trimmed&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$&quot;; then
                log_error &quot;DNS Server IP Address format is invalid: &#39;$dns_entry_trimmed&#39;.&quot;; return 1;
            fi
        done
    fi
    
    debug_verbose &quot;Static config collected: IP=&#39;$static_ip&#39;, GW=&#39;$static_gateway&#39;, DNS=&#39;$static_dns&#39;&quot;
    echo &quot;$static_ip:$static_gateway:$static_dns&quot;; return 0
}

# --- Connectivity Check ---
check_internet_connectivity() {
    log_info_transient &quot;Checking internet connectivity...&quot;
    debug_basic &quot;Pinging IP: $PING_IP_TARGET, Host: $PING_HOSTNAME_TARGET&quot;

    if debug_exec &quot;ping -c ${PING_COUNT} -W ${PING_TIMEOUT} \&quot;${PING_IP_TARGET}\&quot;&quot; &gt;/dev/null 2&gt;&amp;1; then
        info_log &quot;Successfully pinged IP address (${PING_IP_TARGET}). Basic connectivity OK.&quot;
        log_info_transient &quot;Ping to IP ${PING_IP_TARGET} successful.&quot;
        if debug_exec &quot;ping -c ${PING_COUNT} -W ${PING_TIMEOUT} \&quot;${PING_HOSTNAME_TARGET}\&quot;&quot; &gt;/dev/null 2&gt;&amp;1; then
            log_msg &quot;Internet connection established and DNS resolution working (pinged ${PING_HOSTNAME_TARGET}).&quot;
            return 0
        else
            warning_log &quot;DNS resolution failed (cannot ping ${PING_HOSTNAME_TARGET}). Check DNS settings.&quot;
            log_warning &quot;Successfully pinged IP, but DNS resolution failed for ${PING_HOSTNAME_TARGET}. Check DNS settings.&quot;; return 2 # Special code for DNS failure
        fi
    else
        warning_log &quot;Failed to ping IP address (${PING_IP_TARGET}). No basic network connectivity.&quot;
        log_warning &quot;Failed to ping IP address (${PING_IP_TARGET}). No basic network connectivity.&quot;; return 1
    fi
}

# --- Ethernet Configuration ---
attempt_ethernet_dhcp() {
    local iface=&quot;$1&quot;
    debug_basic &quot;Attempting DHCP on Ethernet interface: $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;
    log_info_transient &quot;Attempting DHCP on Ethernet interface: $iface&quot;

    if $NM_IS_ACTIVE; then
        local profile_name
        # Try to find an active connection for the device first
        profile_name=$(nmcli -g NAME,DEVICE connection show --active 2&gt;/dev/null | grep -E &quot;:$iface$&quot; | cut -d&#39;:&#39; -f1 | head -n1 || true)
        [ -z &quot;$profile_name&quot; ] &amp;&amp; profile_name=$(nmcli -g NAME,DEVICE connection show 2&gt;/dev/null | grep -E &quot;:$iface$&quot; | cut -d&#39;:&#39; -f1 | head -n1 || true)
        debug_verbose &quot;NM existing profile for $iface: &#39;$profile_name&#39;&quot;

        if [ -n &quot;$profile_name&quot; ]; then
            log_info_transient &quot;Found existing NM profile &#39;$profile_name&#39; for $iface. Ensuring DHCP and activating...&quot;
            # Modify to DHCP and then activate
            if debug_exec &quot;nmcli connection modify \&quot;$profile_name\&quot; ipv4.method auto ipv6.method auto&quot; &amp;&amp; \
               debug_exec &quot;nmcli connection up \&quot;$profile_name\&quot; ifname \&quot;$iface\&quot;&quot;; then
                log_info_transient &quot;NetworkManager activated DHCP profile &#39;$profile_name&#39; for $iface.&quot;; sleep 5; return 0
            else
                warning_log &quot;Failed to activate existing DHCP profile &#39;$profile_name&#39; for $iface via NM. Trying to add a new one.&quot;
            fi
        fi
        
        log_info_transient &quot;Attempting to add and activate a new DHCP Ethernet connection for $iface via NetworkManager...&quot;
        local new_profile_name=&quot;Eth-DHCP-$iface-$(date +%s)&quot; # Make profile name more unique
        nmcli connection delete &quot;$new_profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true # Clean up if it somehow exists
        if debug_exec &quot;nmcli connection add type ethernet con-name \&quot;$new_profile_name\&quot; ifname \&quot;$iface\&quot; ipv4.method auto ipv6.method auto&quot; &amp;&amp; \
           debug_exec &quot;nmcli connection up \&quot;$new_profile_name\&quot;&quot;; then
            log_info_transient &quot;NetworkManager added and activated DHCP connection for $iface.&quot;; sleep 5; return 0
        else
            warning_log &quot;Failed to configure Ethernet DHCP for $iface via NetworkManager. Will try dhclient.&quot;
            nmcli connection delete &quot;$new_profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true # Cleanup failed attempt
        fi
    fi

    log_info_transient &quot;Bringing interface $iface up...&quot;
    if ! debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then log_warning &quot;Failed to bring interface $iface up.&quot;; return 1; fi
    # Release any old lease for the interface
    debug_exec &quot;dhclient -r \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true 
    
    local dhclient_log
    dhclient_log=$(create_temp_file &quot;dhclient_eth_${iface}&quot; &quot;log&quot;)
    [ $? -ne 0 ] &amp;&amp; { error_log &quot;Failed to create dhclient log file.&quot;; dhclient_log=&quot;/dev/null&quot;; } # Proceed even if log creation fails

    log_info_transient &quot;Attempting DHCP with dhclient on $iface...&quot;
    if debug_exec &quot;timeout 30 dhclient -v \&quot;$iface\&quot;&quot; &gt;&quot;$dhclient_log&quot; 2&gt;&amp;1; then
        log_info_transient &quot;dhclient successfully obtained lease on $iface.&quot;
        debug_full &quot;dhclient log for $iface:\n$(cat &quot;$dhclient_log&quot;)&quot;; sleep 2; return 0
    else
        error_log &quot;dhclient failed or timed out for $iface. Log: $dhclient_log&quot;
        log_error &quot;dhclient failed or timed out for $iface. Check log: $dhclient_log&quot;
        debug_full &quot;dhclient log for $iface on failure:\n$(cat &quot;$dhclient_log&quot;)&quot;; return 1
    fi
}

configure_ethernet_static() {
    local iface=&quot;$1&quot; config_str prompt_exit_status static_ip_cidr gateway dns_servers
    debug_basic &quot;Configuring static Ethernet for $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;
    
    config_str=$(prompt_static_config &quot;Ethernet ($iface)&quot;)
    prompt_exit_status=$?
    [ $prompt_exit_status -ne 0 ] &amp;&amp; return 1
    debug_verbose &quot;Static config string from prompt: &#39;$config_str&#39;&quot;

    IFS=&#39;:&#39; read -r static_ip_cidr gateway dns_servers &lt;&lt;&lt; &quot;$config_str&quot;
    log_info_transient &quot;Configuring static IP for Ethernet $iface: IP=$static_ip_cidr, GW=$gateway, DNS=${dns_servers:-Not set}&quot;

    if $NM_IS_ACTIVE; then
        local profile_name=&quot;Static-Eth-$iface-$(date +%s)&quot; nm_cmd_parts=() # Make profile name more unique
        nmcli connection delete &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true 
        
        log_info_transient &quot;Attempting to add/activate static Ethernet connection via NetworkManager...&quot;
        nm_cmd_parts=(&quot;nmcli&quot; &quot;connection&quot; &quot;add&quot; &quot;type&quot; &quot;ethernet&quot; &quot;con-name&quot; &quot;$profile_name&quot; &quot;ifname&quot; &quot;$iface&quot; &quot;ipv4.method&quot; &quot;manual&quot; &quot;ipv4.addresses&quot; &quot;$static_ip_cidr&quot; &quot;ipv4.gateway&quot; &quot;$gateway&quot;)
        [ -n &quot;$dns_servers&quot; ] &amp;&amp; nm_cmd_parts+=(&quot;ipv4.dns&quot; &quot;$dns_servers&quot;)
        nm_cmd_parts+=(&quot;ipv6.method&quot; &quot;ignore&quot;) # Typically ignore IPv6 for simple static setups

        if debug_exec &quot;${nm_cmd_parts[@]}&quot; &amp;&amp; debug_exec &quot;nmcli connection up \&quot;$profile_name\&quot;&quot;; then
            log_info_transient &quot;NetworkManager configured and activated static IP on $iface.&quot;; sleep 3; return 0
        else
            error_log &quot;Failed to configure static IP on $iface via NetworkManager.&quot;
            log_error &quot;NM static IP configuration failed for $iface.&quot;
            nmcli connection delete &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; return 1 # Cleanup failed attempt
        fi
    fi

    # Fallback to iproute2 if NM is not active or failed
    log_info_transient &quot;Configuring static IP on $iface using iproute2...&quot;
    debug_exec &quot;ip addr flush dev \&quot;$iface\&quot;&quot; || true # Clear existing IPs
    debug_exec &quot;ip link set \&quot;$iface\&quot; down&quot; || true # Take interface down before reconfiguring
    if ! debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then log_warning &quot;Failed to bring interface $iface up for static config.&quot;; return 1; fi
    
    if debug_exec &quot;ip addr add \&quot;$static_ip_cidr\&quot; dev \&quot;$iface\&quot;&quot;; then
        log_info_transient &quot;IP address $static_ip_cidr added to $iface.&quot;; sleep 2
        # Remove existing default routes for this interface before adding a new one
        debug_exec &quot;ip route del default dev \&quot;$iface\&quot;&quot; 2&gt;/dev/null || true
        if debug_exec &quot;ip route add default via \&quot;$gateway\&quot; dev \&quot;$iface\&quot;&quot;; then
            log_info_transient &quot;Default route via $gateway added for $iface.&quot;
            if [ -n &quot;$dns_servers&quot; ]; then
                local resolv_conf_content=&quot;&quot;
                IFS=&#39;,&#39; read -ra dns_array &lt;&lt;&lt; &quot;$dns_servers&quot;
                for dns in &quot;${dns_array[@]}&quot;; do 
                    dns_trimmed=$(echo &quot;$dns&quot; | awk &#39;{$1=$1};1&#39;) # Trim whitespace
                    resolv_conf_content+=&quot;nameserver $dns_trimmed\n&quot;
                done
                
                if [ -L /etc/resolv.conf ] &amp;&amp; ! command -v resolvconf &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ! command -v systemd-resolve &gt;/dev/null 2&gt;&amp;1; then
                    warning_log &quot;/etc/resolv.conf is a symlink. Overwriting it for DNS might be overridden if not managed by resolvconf or systemd-resolved.&quot;
                    log_warning &quot;/etc/resolv.conf is a symlink. DNS might not be set correctly by overwriting it.&quot;
                fi
                # This is a direct overwrite, might be temporary if NetworkManager or systemd-resolved is running
                echo -e &quot;$resolv_conf_content&quot; &gt; /etc/resolv.conf
                info_log &quot;Configured DNS servers in /etc/resolv.conf: $dns_servers (manual iproute2 mode)&quot;
                log_info_transient &quot;DNS servers set in /etc/resolv.conf: $dns_servers&quot;
            fi
            sleep 3; return 0
        else
            error_log &quot;Failed to add default route via $gateway for $iface.&quot;
            log_error &quot;Failed to add default route for $iface.&quot;; return 1
        fi
    else
        error_log &quot;Failed to add IP address $static_ip_cidr to $iface.&quot;
        log_error &quot;Failed to add IP address to $iface.&quot;; return 1
    fi
}

handle_ethernet_connection() {
    local select_exit_status choice
    debug_basic &quot;Handling Ethernet connection. Detected interfaces: ${#ETH_IFACES[@]}&quot;
    if [ ${#ETH_IFACES[@]} -eq 0 ]; then
        log_warning &quot;No Ethernet interfaces detected. Skipping Ethernet setup.&quot;; return 1
    fi

    SELECTED_ETH_IFACE=$(prompt_select_interface &quot;Ethernet&quot; &quot;${ETH_IFACES[@]}&quot;)
    select_exit_status=$?
    debug_basic &quot;Ethernet interface selection: exit_status=$select_exit_status, SELECTED_ETH_IFACE=&#39;$SELECTED_ETH_IFACE&#39;&quot;
    [ $select_exit_status -ne 0 ] &amp;&amp; return 1
    [ -z &quot;$SELECTED_ETH_IFACE&quot; ] &amp;&amp; { log_warning &quot;No Ethernet interface was actually selected.&quot;; return 1; }

    dialog --title &quot;Ethernet Configuration: $SELECTED_ETH_IFACE&quot; \
           --yesno &quot;Attempt to configure &#39;$SELECTED_ETH_IFACE&#39; using DHCP (automatic IP)?&quot; \
           ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
    choice=$?
    if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
        if attempt_ethernet_dhcp &quot;$SELECTED_ETH_IFACE&quot;; then return 0; fi
        log_warning &quot;DHCP on $SELECTED_ETH_IFACE failed. Offering static IP.&quot;
    elif [ $choice -eq $DIALOG_CANCEL_CODE ]; then # User selected &quot;No&quot; for DHCP
        log_info_persistent &quot;DHCP for $SELECTED_ETH_IFACE skipped by user.&quot;
    else # ESC or other dialog error
        log_info_persistent &quot;Ethernet DHCP choice cancelled or dialog error.&quot;; return 1
    fi

    # Offer static IP if DHCP failed or was skipped
    dialog --title &quot;Ethernet Configuration: $SELECTED_ETH_IFACE&quot; \
           --yesno &quot;Do you want to configure a static IP for &#39;$SELECTED_ETH_IFACE&#39;?&quot; \
           ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
    choice=$?
    if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
        if configure_ethernet_static &quot;$SELECTED_ETH_IFACE&quot;; then return 0; fi
        log_warning &quot;Static IP configuration on $SELECTED_ETH_IFACE failed.&quot;
    elif [ $choice -eq $DIALOG_CANCEL_CODE ]; then # User selected &quot;No&quot; for Static IP
        log_info_persistent &quot;Static IP configuration for $SELECTED_ETH_IFACE skipped by user.&quot;
    else # ESC or other dialog error
        log_info_persistent &quot;Ethernet Static IP choice cancelled or dialog error.&quot;; return 1
    fi
    
    debug_basic &quot;Ethernet configuration for $SELECTED_ETH_IFACE did not succeed.&quot;; return 1
}

# --- Wi-Fi Configuration (Robust Scanning) ---
scan_wifi_networks() {
    local iface=&quot;$1&quot;
    local networks_list=() 
    local tmp_scan_file
    
    debug_basic &quot;Scanning Wi-Fi networks on interface: $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;
    log_info_transient &quot;Scanning for Wi-Fi networks on $iface (this may take a few seconds)...&quot;

    tmp_scan_file=$(create_temp_file &quot;wifi_scan_${iface}&quot; &quot;list&quot;)
    if [ $? -ne 0 ] || [ -z &quot;$tmp_scan_file&quot; ]; then
        error_log &quot;Failed to create temporary file for Wi-Fi scan on $iface.&quot;; return 1
    fi

    # Ensure interface is up for scanning, but don&#39;t fail if it errors (might be already up or managed)
    debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot; 2&gt;/dev/null || warning_log &quot;Could not bring $iface up for scanning, scan might be incomplete.&quot;

    if $NM_IS_ACTIVE &amp;&amp; check_command nmcli; then
        debug_verbose &quot;Using nmcli for Wi-Fi scan on $iface.&quot;
        # Request a rescan if possible
        debug_exec &quot;nmcli device wifi rescan ifname \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true 
        sleep 3 # Give some time for the rescan to populate

        # nmcli output: IN-USE:SSID:BARS:SECURITY (BARS is signal strength as string like &#39;▂▄▆_&#39;)
        # Awk processes this to: SSID\0Description\n
        # Robustly parse nmcli terse output, handling colons in SSIDs.
        # The strategy is to identify fixed position fields from the right (SECURITY, BARS)
        # and assume the middle part is the SSID.
        debug_exec &quot;nmcli -t -f IN-USE,SSID,BARS,SECURITY device wifi list ifname \&quot;$iface\&quot; --rescan no&quot; 2&gt;/dev/null | \
        awk -F: &#39;
            # awk script for nmcli output processing
            # Input format: IN-USE:SSID:BARS:SECURITY (SSID can contain colons)
            # Output format for mapfile: SSID\0Description\n
            BEGIN { OFS=&quot;\0&quot;; ORS=&quot;\n&quot; }
            {
                if (NF &lt; 4) { # Expect at least 4 fields (e.g. *:OpenSSID:strength:Open)
                    # Handle cases with empty SSID or unexpected format if necessary
                    # print &quot;AWK_NMCLI_PARSE_WARN: Skipping line due to insufficient fields: &quot; $0 &gt; &quot;/dev/stderr&quot;;
                    next;
                }

                in_use_field = $1;
                # Reconstruct SSID: from $2 up to $(NF-2)
                ssid_field = $2;
                for (i = 3; i &lt;= NF - 2; i++) {
                    ssid_field = ssid_field &quot;:&quot; $i;
                }
                
                # Remove potential escaping if nmcli added any (unlikely with -t)
                # gsub(/\\:/, &quot;:&quot;, ssid_field); # Example if nmcli escaped colons in SSID

                bars_field = $(NF-1); # Second to last field
                security_field = $NF;   # Last field

                if (ssid_field == &quot;&quot;) next; # Skip if SSID is empty after reconstruction

                # Create display SSID (truncated)
                display_ssid = substr(ssid_field, 1, 25);
                if (length(ssid_field) &gt; 25) display_ssid = display_ssid &quot;..&quot;;

                # Format security display string
                sec_display = (security_field == &quot;&quot; ? &quot;Open&quot; : security_field);
                # Prepend *Connected* if IN-USE is &#39;*&#39;
                if (in_use_field == &quot;*&quot;) sec_display = &quot;*Connected* &quot; sec_display;

                # Construct description string
                description = &quot;Sig: &quot; bars_field &quot; | Sec: &quot; sec_display &quot; | &quot; display_ssid;
                
                # Output SSID and Description, null-separated, newline-terminated
                print ssid_field, description;
            }
        &#39; &gt; &quot;$tmp_scan_file&quot;
        # CORRECTED: Check command status without premature &#39;fi&#39;
        [ $? -ne 0 ] &amp;&amp; error_log &quot;nmcli scan or awk processing failed for $iface.&quot;

    elif check_command iwlist; then
        debug_verbose &quot;Using iwlist for Wi-Fi scan on $iface.&quot;
        # Try to kill any existing wpa_supplicant for this interface to ensure iwlist can scan
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill &gt;/dev/null 2&gt;&amp;1 || true; sleep 0.5
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill -9 &gt;/dev/null 2&gt;&amp;1 || true; sleep 1

        debug_exec &quot;iwlist \&quot;$iface\&quot; scan&quot; 2&gt;/dev/null | \
        awk -v RS=&quot;Cell &quot; &#39;
            # awk script for iwlist output processing
            # Input: iwlist scan output, record separated by &quot;Cell &quot;
            # Output format for mapfile: SSID\0Description\n
            NR &gt; 1 { # Skip first record as it is not a cell
                essid=&quot;&quot;; signal=&quot;N/A&quot;; security=&quot;Open&quot;;
                # Extract ESSID
                if (match($0, /ESSID:&quot;([^&quot;]+)&quot;/, arr_essid)) { essid=arr_essid[1] }
                # Clean control characters from ESSID
                gsub(/[[:cntrl:]]/, &quot;&quot;, essid);
                if (essid == &quot;&quot;) next; # Skip if no ESSID

                # Extract Signal Quality/Level
                if (match($0, /Quality=([0-9]+\/[0-9]+).*Signal level=(-?[0-9]+ dBm)/, arr_sig)) { signal=arr_sig[1] &quot; (&quot; arr_sig[2] &quot;)&quot; }
                else if (match($0, /Signal level=(-?[0-9]+ dBm)/, arr_sig)) { signal=arr_sig[1] }
                else if (match($0, /Quality=([0-9]+\/[0-9]+)/, arr_sig)) { signal=arr_sig[1] }

                # Determine Security Type
                if (match($0, /Encryption key:on/)) {
                    security=&quot;Protected&quot;; # Generic
                    # More specific checks for WPA/WPA2/WEP
                    # This logic is a bit simplistic; WPA/WPA2 is usually in IEs
                    if (!match($0, /IE: IEEE 802.11i\/WPA2/) &amp;&amp; !match($0, /IE: WPA Version 1/)) {
                         security=&quot;WEP&quot;; 
                    }
                }
                # Prioritize WPA2/WPA detection from IEs
                if (match($0, /IE: IEEE 802.11i\/WPA2 Version 1/)) { security=&quot;WPA2/PSK&quot; } 
                else if (match($0, /IE: WPA Version 1/)) { security=&quot;WPA/PSK&quot; } 
                # Note: WPA3/SAE detection from iwlist is less reliable, may need &quot;IE:.*SAE&quot;

                # Create display ESSID (truncated)
                display_essid = substr(essid, 1, 25);
                if (length(essid) &gt; 25) display_essid = display_essid &quot;..&quot;;
                
                # Construct description string
                description = &quot;Sig: &quot; signal &quot; | Sec: &quot; security &quot; | &quot; display_essid;
                
                # Output SSID and Description, null-separated, newline-terminated
                printf &quot;%s\0%s\n&quot;, essid, description;
            }&#39; &gt; &quot;$tmp_scan_file&quot;
        # CORRECTED: Check command status without premature &#39;fi&#39;
        [ $? -ne 0 ] &amp;&amp; error_log &quot;iwlist scan or awk processing failed for $iface.&quot;
    else
        error_log &quot;No suitable tool (nmcli or iwlist) found for Wi-Fi scanning on $iface.&quot;
        safe_rm &quot;$tmp_scan_file&quot;; TMP_FILES_TO_CLEAN=(&quot;${TMP_FILES_TO_CLEAN[@]/$tmp_scan_file}&quot;); return 1
    fi # This &#39;fi&#39; now correctly closes the entire if/elif/else structure.
    
    # Read into array using null delimiter, expecting pairs (SSID, Description)
    mapfile -t -d $&#39;\0&#39; networks_list &lt; &quot;$tmp_scan_file&quot;
    local mapfile_status=$?
    debug_full &quot;mapfile status: $mapfile_status. Networks list size: ${#networks_list[@]}&quot;
    
    # Remove the temporary file from the global cleanup list as it&#39;s processed here
    safe_rm &quot;$tmp_scan_file&quot;
    TMP_FILES_TO_CLEAN=(&quot;${TMP_FILES_TO_CLEAN[@]/$tmp_scan_file}&quot;) # Remove from global list

    if [ ${#networks_list[@]} -eq 0 ]; then
        log_warning &quot;No Wi-Fi networks found on $iface after scan, or error reading scan data.&quot;
        return 1
    fi

    debug_basic &quot;Wi-Fi scan on $iface found $((${#networks_list[@]}/2)) networks.&quot;
    if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 3 ]; then
        for ((i=0; i &lt; ${#networks_list[@]}; i+=2)); do
            debug_full &quot;Scan result: SSID=&#39;${networks_list[i]}&#39;, DESC=&#39;${networks_list[i+1]}&#39;&quot;
        done
    fi
    
    # Print the flat array (SSID\nDescription\nSSID\nDescription...) for connect_wifi to mapfile again
    printf &quot;%s\n&quot; &quot;${networks_list[@]}&quot;; return 0
}

connect_wifi() {
    local iface=&quot;$1&quot; networks_flat_array_str networks_flat_array=()
    local scan_status selected_ssid security_type full_description wifi_password exit_status choice
    local wpa_conf_temp connect_tries static_config_str static_ip_cidr gw dns_val
    local resolv_conf_content_wifi dns_array_wifi active_wifi_conn nm_modify_cmd

    debug_basic &quot;Attempting to connect Wi-Fi on interface: $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;

    networks_flat_array_str=$(scan_wifi_networks &quot;$iface&quot;)
    scan_status=$? 
    
    if [ $scan_status -ne 0 ] || [ -z &quot;$networks_flat_array_str&quot; ]; then
        log_warning &quot;Failed to retrieve Wi-Fi networks or no networks found for $iface.&quot;; return 1
    fi
    # networks_flat_array_str is already newline separated from printf in scan_wifi_networks
    mapfile -t networks_flat_array &lt;&lt;&lt; &quot;$networks_flat_array_str&quot;
    debug_verbose &quot;Retrieved ${#networks_flat_array[@]} items for Wi-Fi selection dialog.&quot;

    # Ensure we have pairs for the dialog menu (SSID, Description)
    if [ $((${#networks_flat_array[@]} % 2)) -ne 0 ]; then
        error_log &quot;Wi-Fi scan data is malformed (not in pairs). Cannot proceed.&quot;
        return 1
    fi

    exec 3&gt;&amp;1
    selected_ssid=$(dialog --title &quot;Select Wi-Fi Network ($iface)&quot; \
        --menu &quot;Choose the Wi-Fi network (SSID) to connect to:&quot; \
        $((DIALOG_DEFAULT_HEIGHT + 5)) ${DIALOG_DEFAULT_WIDTH} $((${#networks_flat_array[@]} / 2)) \
        &quot;${networks_flat_array[@]}&quot; 2&gt;&amp;1 1&gt;&amp;3)
    exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;Wi-Fi selection dialog: exit_status=$exit_status, selected_ssid_tag=&#39;$selected_ssid&#39;&quot;

    if [ $exit_status -ne $DIALOG_SUCCESS_CODE ] || [ -z &quot;$selected_ssid&quot; ]; then
        log_info_persistent &quot;Wi-Fi network selection cancelled or empty.&quot;; return 1
    fi

    # Determine security type based on the description string from the scan
    security_type=&quot;Unknown&quot; # Default
    for ((i=0; i&lt;${#networks_flat_array[@]}; i+=2)); do
        if [ &quot;${networks_flat_array[i]}&quot; == &quot;$selected_ssid&quot; ]; then
            full_description=&quot;${networks_flat_array[i+1]}&quot;
            debug_verbose &quot;Full description for &#39;$selected_ssid&#39;: &#39;$full_description&#39;&quot;
            # More specific security type detection based on common patterns
            if [[ &quot;$full_description&quot; == *&quot;Sec: Open&quot;* ]]; then security_type=&quot;Open&quot;
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WEP&quot;* ]]; then security_type=&quot;WEP&quot;
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WPA2/PSK&quot;* || &quot;$full_description&quot; == *&quot;Sec: WPA2&quot;* ]]; then security_type=&quot;PSK&quot; # WPA2 implies PSK for consumer
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WPA/PSK&quot;* || &quot;$full_description&quot; == *&quot;Sec: WPA&quot;* ]]; then security_type=&quot;PSK&quot; # WPA implies PSK
            elif [[ &quot;$full_description&quot; == *&quot;Sec: PSK&quot;* ]]; then security_type=&quot;PSK&quot;
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WPA3&quot;* || &quot;$full_description&quot; == *&quot;Sec: SAE&quot;* ]]; then security_type=&quot;PSK&quot; # WPA3/SAE often needs PSK input method
            elif [[ &quot;$full_description&quot; == *&quot;Sec: Protected&quot;* &amp;&amp; &quot;$security_type&quot; == &quot;Unknown&quot; ]]; then security_type=&quot;PSK&quot; # Generic fallback
            fi; break
        fi
    done
    debug_basic &quot;Determined security type for &#39;$selected_ssid&#39;: $security_type&quot;

    wifi_password=&quot;&quot;
    if [ &quot;$security_type&quot; == &quot;PSK&quot; ] || [ &quot;$security_type&quot; == &quot;WEP&quot; ]; then
        exec 3&gt;&amp;1
        wifi_password=$(dialog --title &quot;Wi-Fi Password&quot; \
            --passwordbox &quot;Enter password for SSID &#39;$selected_ssid&#39; ($security_type):&quot; \
            10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
        exit_status=$?
        exec 3&gt;&amp;-
        debug_basic &quot;Password dialog exit: $exit_status&quot;
        if [ $exit_status -ne $DIALOG_SUCCESS_CODE ]; then
            log_warning &quot;Password entry cancelled. Cannot connect to $security_type network.&quot;; return 1
        fi
        # Allow empty password for WEP if user insists, though unlikely to work
        if [ &quot;$security_type&quot; == &quot;PSK&quot; ] &amp;&amp; [ -z &quot;$wifi_password&quot; ]; then
             log_warning &quot;Password cannot be empty for $security_type. Cannot connect.&quot;; return 1
        fi
    elif [ &quot;$security_type&quot; == &quot;Unknown&quot; ]; then # If security is still unknown, prompt
        dialog --title &quot;Unknown Security for $selected_ssid&quot; \
               --yesno &quot;Security type is Unknown. Attempt to provide a password (for WPA/WEP/PSK types) or connect as Open network?&quot; \
               12 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
        choice=$?
        if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then # User wants to provide password
            exec 3&gt;&amp;1
            wifi_password=$(dialog --title &quot;Wi-Fi Password&quot; \
                --passwordbox &quot;Enter password/key for SSID &#39;$selected_ssid&#39;:&quot; \
                10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
            exit_status=$?
            exec 3&gt;&amp;-
            [ $exit_status -ne $DIALOG_SUCCESS_CODE ] &amp;&amp; { log_warning &quot;Password entry cancelled.&quot;; return 1; }
            [ -n &quot;$wifi_password&quot; ] &amp;&amp; security_type=&quot;PSK&quot; || security_type=&quot;Open&quot; # Assume PSK if password provided
        else # User wants to try as Open, or cancelled
            security_type=&quot;Open&quot;
        fi
        debug_basic &quot;Security for &#39;Unknown&#39; network, after prompt: $security_type&quot;
    fi
    debug_var &quot;wifi_password&quot; # Be careful logging passwords, even to debug logs

    log_info_transient &quot;Attempting to connect to Wi-Fi: $selected_ssid on $iface (Security: $security_type)&quot;
    if $NM_IS_ACTIVE; then
        debug_verbose &quot;Using NetworkManager to connect to Wi-Fi.&quot;
        debug_exec &quot;nmcli device disconnect \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true; sleep 1 # Disconnect first
        
        # Delete existing connections for this SSID to avoid conflicts or using old passwords
        local old_profile_uuids
        old_profile_uuids=$(nmcli -g UUID,TYPE,NAME connection show 2&gt;/dev/null | grep -E &quot;wireless|802-11-wireless&quot; | grep &quot;:$selected_ssid$&quot; | cut -d&#39;:&#39; -f1 || true)
        if [ -n &quot;$old_profile_uuids&quot; ]; then
            echo &quot;$old_profile_uuids&quot; | while read -r uuid_to_delete; do
                info_log &quot;Deleting existing NM profile UUID $uuid_to_delete for SSID &#39;$selected_ssid&#39;.&quot;
                debug_exec &quot;nmcli connection delete uuid \&quot;$uuid_to_delete\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true
            done
        fi

        local connect_cmd_nmcli=(&quot;nmcli&quot; &quot;device&quot; &quot;wifi&quot; &quot;connect&quot; &quot;$selected_ssid&quot; &quot;ifname&quot; &quot;$iface&quot;)
        # Only add password if security type suggests it or if password is not empty (for &quot;Open&quot; with password attempts)
        if { [ &quot;$security_type&quot; != &quot;Open&quot; ] &amp;&amp; [ -n &quot;$wifi_password&quot; ]; } || \
           { [ &quot;$security_type&quot; == &quot;Open&quot; ] &amp;&amp; [ -n &quot;$wifi_password&quot; ]; }; then # Handles case where user forces password for &quot;Open&quot;
            connect_cmd_nmcli+=(&quot;password&quot; &quot;$wifi_password&quot;)
        fi
        # For WEP, nmcli might need specific syntax if &#39;password&#39; isn&#39;t enough.
        # if [ &quot;$security_type&quot; == &quot;WEP&quot; ]; then connect_cmd_nmcli+=(&quot;wep-key-type&quot; &quot;passphrase&quot;); fi # Example

        if debug_exec &quot;${connect_cmd_nmcli[@]}&quot;; then
            log_info_transient &quot;Successfully initiated Wi-Fi connection to $selected_ssid via NetworkManager.&quot;; sleep 5; return 0 
        else
            error_log &quot;Failed to connect to Wi-Fi $selected_ssid via NetworkManager.&quot;
            log_error &quot;NM Wi-Fi connection failed for &#39;$selected_ssid&#39;. Check password/security.&quot;; return 1
        fi
    else 
        # Manual connection using wpa_supplicant
        debug_verbose &quot;Using wpa_supplicant to connect to Wi-Fi.&quot;
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill &gt;/dev/null 2&gt;&amp;1 || true; sleep 0.5
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill -9 &gt;/dev/null 2&gt;&amp;1 || true; sleep 1
        
        wpa_conf_temp=$(create_temp_file &quot;wpa_temp_${iface}&quot; &quot;conf&quot;)
        if [ $? -ne 0 ] || [ -z &quot;$wpa_conf_temp&quot; ]; then error_log &quot;Failed to create wpa_supplicant temp conf file.&quot;; return 1; fi

        # Basic wpa_supplicant configuration
        echo &quot;ctrl_interface=DIR=/run/wpa_supplicant GROUP=netdev&quot; &gt; &quot;$wpa_conf_temp&quot;
        echo &quot;update_config=1&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        echo -e &quot;\nnetwork={&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        echo &quot;    ssid=\&quot;$selected_ssid\&quot;&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        
        if [ &quot;$security_type&quot; == &quot;Open&quot; ] &amp;&amp; [ -z &quot;$wifi_password&quot; ]; then
            echo &quot;    key_mgmt=NONE&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        elif [ &quot;$security_type&quot; == &quot;WEP&quot; ]; then
            echo &quot;    key_mgmt=NONE&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            # Handle WEP key (hex or passphrase)
            if [[ &quot;$wifi_password&quot; =~ ^[0-9A-Fa-f]{10}$ || &quot;$wifi_password&quot; =~ ^[0-9A-Fa-f]{26}$ ]]; then # Hex key
                echo &quot;    wep_key0=$wifi_password&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            elif [[ &quot;${#wifi_password}&quot; -eq 5 || &quot;${#wifi_password}&quot; -eq 13 ]]; then # ASCII passphrase
                echo &quot;    wep_key0=\&quot;$wifi_password\&quot;&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            else
                error_log &quot;Invalid WEP key format for &#39;$selected_ssid&#39;. Expected 5/13 ASCII or 10/26 HEX chars.&quot;; 
                log_error &quot;Invalid WEP key format.&quot;; return 1
            fi
            echo &quot;    wep_tx_keyidx=0&quot; &gt;&gt; &quot;$wpa_conf_temp&quot; # Default WEP key index
        else # Assume PSK (WPA/WPA2/WPA3-SAE)
            echo &quot;    psk=\&quot;$wifi_password\&quot;&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            # For WPA3-SAE, you might need: key_mgmt=SAE or WPA-PSK SAE
            # if [[ &quot;$security_type_from_scan&quot; == &quot;WPA3&quot; ]]; then echo &quot;    key_mgmt=SAE&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;; fi
        fi
        echo &quot;}&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        chmod 600 &quot;$wpa_conf_temp&quot; # wpa_supplicant requires restricted permissions
        debug_full &quot;wpa_supplicant config file $wpa_conf_temp content:\n$(cat &quot;$wpa_conf_temp&quot;)&quot;

        # Start wpa_supplicant in background
        # -Dnl80211,wext are common drivers, nl80211 is preferred
        if ! debug_exec &quot;wpa_supplicant -B -i \&quot;$iface\&quot; -c \&quot;$wpa_conf_temp\&quot; -Dnl80211,wext&quot;; then
            error_log &quot;Failed to start wpa_supplicant for $iface.&quot;; return 1
        fi
        log_info_transient &quot;wpa_supplicant started. Waiting for association with $selected_ssid...&quot;
        connect_tries=20 # Wait up to 20 seconds for association
        while [ $connect_tries -gt 0 ]; do
            if wpa_cli -i &quot;$iface&quot; status 2&gt;/dev/null | grep -q &quot;wpa_state=COMPLETED&quot;; then
                log_info_transient &quot;Associated with $selected_ssid via wpa_supplicant.&quot;; break
            fi
            sleep 1; connect_tries=$((connect_tries - 1))
            debug_verbose &quot;wpa_supplicant association tries left for $selected_ssid: $connect_tries&quot;
        done
        if [ $connect_tries -eq 0 ]; then
            error_log &quot;Failed to associate with $selected_ssid via wpa_supplicant (timeout).&quot;
            log_error &quot;wpa_supplicant association timed out for &#39;$selected_ssid&#39;.&quot;
            # Kill the lingering wpa_supplicant process
            pgrep -af &quot;wpa_supplicant -B -i $iface -c $wpa_conf_temp&quot; | awk &#39;{print $1}&#39; | xargs -r kill -9 &gt;/dev/null 2&gt;&amp;1 || true
            return 1
        fi
    fi 

    # If not using NetworkManager (which handles DHCP itself), run dhclient
    if ! $NM_IS_ACTIVE; then
        log_info_transient &quot;Wi-Fi associated ($selected_ssid). Attempting DHCP on $iface...&quot;
        debug_exec &quot;dhclient -r \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true # Release old lease
        
        local dhclient_wifi_log
        dhclient_wifi_log=$(create_temp_file &quot;dhclient_wifi_${iface}&quot; &quot;log&quot;)
        [ $? -ne 0 ] &amp;&amp; { error_log &quot;Failed to create dhclient log file.&quot;; dhclient_wifi_log=&quot;/dev/null&quot;; }

        if debug_exec &quot;timeout 30 dhclient -v \&quot;$iface\&quot;&quot; &gt;&quot;$dhclient_wifi_log&quot; 2&gt;&amp;1; then
            log_info_transient &quot;dhclient successfully obtained lease on $iface for $selected_ssid.&quot;
            debug_full &quot;dhclient log for $iface (Wi-Fi):\n$(cat &quot;$dhclient_wifi_log&quot;)&quot;; sleep 2; return 0
        else 
            warning_log &quot;dhclient failed or timed out for &#39;$selected_ssid&#39; on $iface. Log: $dhclient_wifi_log&quot;
            debug_full &quot;dhclient log for $iface (Wi-Fi) on failure:\n$(cat &quot;$dhclient_wifi_log&quot;)&quot;
            
            # Offer static IP configuration if DHCP fails
            dialog --title &quot;Wi-Fi IP Configuration: $selected_ssid&quot; \
                   --yesno &quot;DHCP failed for &#39;$selected_ssid&#39; on $iface.\\nDo you want to configure a static IP for this Wi-Fi connection?&quot; \
                   ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
            choice=$?
            if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
                static_config_str=$(prompt_static_config &quot;Wi-Fi ($selected_ssid)&quot;)
                exit_status=$?
                [ $exit_status -ne 0 ] &amp;&amp; return 1 # User cancelled static config

                IFS=&#39;:&#39; read -r static_ip_cidr gw dns_val &lt;&lt;&lt; &quot;$static_config_str&quot;
                log_info_transient &quot;Configuring static IP for Wi-Fi $iface ($selected_ssid): IP=$static_ip_cidr, GW=$gw, DNS=${dns_val:-Not set}&quot;
                
                debug_exec &quot;ip addr flush dev \&quot;$iface\&quot;&quot; || true
                if ! debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then log_warning &quot;Failed to bring $iface up for static Wi-Fi.&quot;; return 1; fi
                if debug_exec &quot;ip addr add \&quot;$static_ip_cidr\&quot; dev \&quot;$iface\&quot;&quot;; then
                    sleep 2 
                    debug_exec &quot;ip route del default dev \&quot;$iface\&quot;&quot; 2&gt;/dev/null || true
                    if debug_exec &quot;ip route add default via \&quot;$gw\&quot; dev \&quot;$iface\&quot;&quot;; then
                        log_info_transient &quot;iproute2 configured static IP for Wi-Fi $iface ($selected_ssid).&quot;
                        if [ -n &quot;$dns_val&quot; ]; then
                            resolv_conf_content_wifi=&quot;&quot;
                            IFS=&#39;,&#39; read -ra dns_array_wifi &lt;&lt;&lt; &quot;$dns_val&quot;
                            for dns_entry in &quot;${dns_array_wifi[@]}&quot;; do 
                                dns_entry_trimmed=$(echo &quot;$dns_entry&quot; | awk &#39;{$1=$1};1&#39;)
                                resolv_conf_content_wifi+=&quot;nameserver $dns_entry_trimmed\n&quot;
                            done
                            if [ -L /etc/resolv.conf ] &amp;&amp; ! command -v resolvconf &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ! command -v systemd-resolve &gt;/dev/null 2&gt;&amp;1; then
                                 warning_log &quot;/etc/resolv.conf is a symlink. Overwriting for DNS may be temporary.&quot;
                                 log_warning &quot;/etc/resolv.conf is a symlink. DNS set via script might be overridden.&quot;
                            fi
                            echo -e &quot;$resolv_conf_content_wifi&quot; &gt; /etc/resolv.conf
                            info_log &quot;Configured DNS servers for Wi-Fi $iface in /etc/resolv.conf: $dns_val&quot;
                        fi
                        return 0
                    else error_log &quot;Failed to add default route for static Wi-Fi on $iface.&quot;; return 1; fi
                else error_log &quot;Failed to add IP address for static Wi-Fi on $iface.&quot;; return 1; fi
            else 
                log_info_persistent &quot;Static IP configuration for Wi-Fi &#39;$selected_ssid&#39; skipped by user.&quot;; return 1;
            fi 
        fi 
    fi 
    debug_basic &quot;Wi-Fi connection attempt for &#39;$selected_ssid&#39; on $iface concluded.&quot;; return 1 # Fallthrough if NM handled DHCP or other cases
}

handle_wifi_connection() {
    local select_exit_status rfkill_idx rfkill_output
    debug_basic &quot;Handling Wi-Fi connection. Detected interfaces: ${#WIFI_IFACES[@]}&quot;
    if [ ${#WIFI_IFACES[@]} -eq 0 ]; then
        log_warning &quot;No Wi-Fi interfaces detected. Skipping Wi-Fi setup.&quot;; return 1
    fi

    SELECTED_WIFI_IFACE=$(prompt_select_interface &quot;Wi-Fi&quot; &quot;${WIFI_IFACES[@]}&quot;)
    select_exit_status=$?
    debug_basic &quot;Wi-Fi interface selection: exit_status=$select_exit_status, SELECTED_WIFI_IFACE=&#39;$SELECTED_WIFI_IFACE&#39;&quot;
    [ $select_exit_status -ne 0 ] &amp;&amp; return 1
    [ -z &quot;$SELECTED_WIFI_IFACE&quot; ] &amp;&amp; { log_warning &quot;No Wi-Fi interface was actually selected.&quot;; return 1; }

    # Check rfkill status
    if check_command rfkill; then
        # Get rfkill output: ID DEVICE TYPE SOFT HARD
        rfkill_output=$(debug_exec &quot;rfkill list wifi -n -o ID,DEVICE,SOFT,HARD&quot;)
        # Find the ID for the selected interface
        rfkill_idx=$(echo &quot;$rfkill_output&quot; | grep -w &quot;$SELECTED_WIFI_IFACE&quot; | awk &#39;{print $1}&#39; || true)
        debug_verbose &quot;rfkill_idx for $SELECTED_WIFI_IFACE: &#39;$rfkill_idx&#39;&quot;

        if [ -n &quot;$rfkill_idx&quot; ]; then 
            # Check soft block: field 3 (SOFT) for the given ID
            if echo &quot;$rfkill_output&quot; | awk -v id=&quot;$rfkill_idx&quot; &#39;$1 == id &amp;&amp; $3 == &quot;blocked&quot; {print &quot;softblocked&quot;}&#39; | grep -q &quot;softblocked&quot;; then 
                dialog --title &quot;Wi-Fi Soft Blocked&quot; \
                       --yesno &quot;$SELECTED_WIFI_IFACE (rfkill ID $rfkill_idx) is soft-blocked. Attempt to unblock?&quot; \
                       10 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
                if [ $? -eq $DIALOG_SUCCESS_CODE ]; then
                    if debug_exec &quot;rfkill unblock $rfkill_idx&quot;; then
                        log_info_persistent &quot;$SELECTED_WIFI_IFACE (ID $rfkill_idx) unblocked.&quot;; sleep 1
                    else log_warning &quot;Failed to unblock $SELECTED_WIFI_IFACE (ID $rfkill_idx).&quot;; fi
                fi
            fi
            # Check hard block: field 4 (HARD) for the given ID
            if echo &quot;$rfkill_output&quot; | awk -v id=&quot;$rfkill_idx&quot; &#39;$1 == id &amp;&amp; $4 == &quot;blocked&quot; {print &quot;hardblocked&quot;}&#39; | grep -q &quot;hardblocked&quot; ; then 
                error_log &quot;$SELECTED_WIFI_IFACE (ID $rfkill_idx) is hard-blocked (hardware switch).&quot;
                log_error &quot;$SELECTED_WIFI_IFACE (ID $rfkill_idx) is hard-blocked by a physical switch. Cannot proceed with this interface.&quot;; return 1
            fi
        fi
    fi

    if connect_wifi &quot;$SELECTED_WIFI_IFACE&quot;; then return 0; fi 
    
    log_warning &quot;Wi-Fi connection on $SELECTED_WIFI_IFACE failed or was cancelled.&quot;; return 1
}

# --- Main Script Logic ---
main() {
    # Handle --debug argument first
    if [[ &quot;$1&quot; == &quot;--debug&quot; ]]; then
        DBG=true
        DEBUG_LEVEL=3 
        DEBUG_LOG_FILE=&quot;/tmp/universal_net_connect_$(date +%Y%m%d_%H%M%S)_$$.log&quot;
        # Initialize xtrace logging to file descriptor $XTRACE_FD
        # This must be done before `set -x`
        # Ensure the FD is available and not used by dialog&#39;s redirections later
        # Using a temporary file for xtrace and then appending to main log might be safer
        # For now, direct redirection. Ensure $XTRACE_FD is high enough (e.g., 6, 7, 8, 9).
        eval &quot;exec $XTRACE_FD&gt;&gt;\&quot;\$DEBUG_LOG_FILE\&quot;&quot;
        export BASH_XTRACEFD=&quot;$XTRACE_FD&quot; # Tell Bash to use this FD for xtrace
        set -x # Start xtrace
        info_log &quot;Debug mode activated. Log file: $DEBUG_LOG_FILE. DEBUG_LEVEL=$DEBUG_LEVEL. Xtrace on FD $XTRACE_FD.&quot;
        shift # Consume the --debug argument
    elif [ -n &quot;$DEBUG_LOG_FILE_ENV&quot; ]; then # Allow setting log file via environment
        DEBUG_LOG_FILE=&quot;$DEBUG_LOG_FILE_ENV&quot;; DBG=true 
        info_log &quot;Logging to ENV specified file: $DEBUG_LOG_FILE. DEBUG_LEVEL=$DEBUG_LEVEL.&quot;
    fi

    info_log &quot;Universal Network Connectivity Script v3.1 started. UID: $(id -u)&quot;
    if [ &quot;$(id -u)&quot; -ne 0 ]; then
        error_log &quot;Script not run as root.&quot;
        # Avoid dialog here as it might not be installed yet
        echo &quot;This script must be run as root. Please use &#39;sudo $0&#39;&quot; &gt;&amp;2; exit 1
    fi
    debug_basic &quot;Running as root.&quot;

    # Install dialog first as it&#39;s crucial for user interaction
    install_packages &quot;dialog,dialog&quot; 
    # Then other packages
    install_packages &quot;ip,iproute2&quot; &quot;ping,iputils-ping&quot; &quot;nmcli,network-manager&quot; \
                     &quot;wpa_cli,wpasupplicant&quot; &quot;wpa_supplicant,wpasupplicant&quot; \
                     &quot;dhclient,isc-dhcp-client&quot; &quot;iw,iw&quot; &quot;iwlist,wireless-tools&quot; \
                     &quot;rfkill,rfkill&quot; &quot;timeout,coreutils&quot; &quot;awk,gawk&quot; 

    detect_ethernet_interfaces
    detect_wifi_interfaces
    check_network_manager_active 

    if check_internet_connectivity; then
        info_log &quot;Internet connection already active. Exiting.&quot;; exit 0 
    fi
    log_info_persistent &quot;No active internet connection detected. Starting configuration process...&quot;

    local options=() main_choice main_dialog_exit_status
    while true; do
        options=() 
        [ ${#ETH_IFACES[@]} -gt 0 ] &amp;&amp; options+=(&quot;ETH&quot; &quot;Configure Ethernet Connection&quot;)
        [ ${#WIFI_IFACES[@]} -gt 0 ] &amp;&amp; options+=(&quot;WIFI&quot; &quot;Configure Wi-Fi Connection&quot;)
        
        if [ $((${#ETH_IFACES[@]} + ${#WIFI_IFACES[@]})) -eq 0 ]; then
            log_error &quot;No usable network interfaces (Ethernet or Wi-Fi) were detected. Cannot proceed.&quot;; exit 1
        fi
        
        options+=(&quot;CHECK&quot; &quot;Re-check Internet Connectivity&quot;)
        debug_verbose &quot;Main menu options: ${options[*]}&quot;

        exec 3&gt;&amp;1
        main_choice=$(dialog --title &quot;Main Menu - Universal Network Connector&quot; \
            --cancel-label &quot;Exit Script&quot; \
            --menu &quot;Select an action:&quot; ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} $((${#options[@]}/2)) \
            &quot;${options[@]}&quot; 2&gt;&amp;1 1&gt;&amp;3)
        main_dialog_exit_status=$?
        exec 3&gt;&amp;-
        debug_basic &quot;Main menu dialog: exit_status=$main_dialog_exit_status, choice_tag=&#39;$main_choice&#39;&quot;
        
        if [ $main_dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]; then 
            log_info_persistent &quot;Exiting script as per user request from main menu.&quot;; break 
        fi
        [ -z &quot;$main_choice&quot; ] &amp;&amp; { log_warning &quot;No option selected from main menu. Please try again.&quot;; continue; }

        case &quot;$main_choice&quot; in
            ETH)
                if [ ${#ETH_IFACES[@]} -eq 0 ]; then log_warning &quot;No Ethernet interfaces available.&quot;; continue; fi
                if handle_ethernet_connection; then 
                    if check_internet_connectivity; then exit 0; fi 
                else log_info_persistent &quot;Ethernet configuration did not result in a connection or was cancelled.&quot;; fi
                ;;
            WIFI)
                if [ ${#WIFI_IFACES[@]} -eq 0 ]; then log_warning &quot;No Wi-Fi interfaces available.&quot;; continue; fi
                if handle_wifi_connection; then 
                    if check_internet_connectivity; then exit 0; fi
                else log_info_persistent &quot;Wi-Fi configuration did not result in a connection or was cancelled.&quot;; fi
                ;;
            CHECK) if check_internet_connectivity; then exit 0; fi ;;
            *) log_warning &quot;Invalid choice &#39;$main_choice&#39; from main menu. This should not happen.&quot; ;;
        esac
    done
    info_log &quot;Exited main loop. Script finished.&quot;
    exit 1 # Exit with 1 if loop is broken without successful connection
}

# Pass all script arguments to main
main &quot;$@&quot;" data-download-link="" data-download-label="Download Bash">
  <code class="language-bash">#!/usr/bin/env bash
#
# Universal Network Connectivity Script for RK3588 VPC-3588 (Debian Bullseye)
#
# This script attempts to establish an internet connection via Ethernet or Wi-Fi,
# interactively prompting the user for necessary information.
# It must be run with root privileges.
#
# Version 3.2: Corrected premature &#39;fi&#39; tokens in scan_wifi_networks.

# --- Script Setup ---
set -e
set -o pipefail

# --- Debug Configuration ---
DEBUG_LEVEL=${DEBUG_LEVEL:-1} # 0=off, 1=basic, 2=verbose, 3=full (used if DBG is true)
DBG=${DBG:-false}             # Global debug flag, can be set by --debug argument
DEBUG_LOG_FILE=&quot;&quot;             # Initialized globally, set in main if DBG is true
VERBOSE_COMMANDS=${VERBOSE_COMMANDS:-true} # Set to false to disable command verbosity in debug_exec if DBG is true
XTRACE_FD=6                   # File descriptor for xtrace output

# --- Global Variables ---
ETH_IFACES=()
WIFI_IFACES=()
SELECTED_ETH_IFACE=&quot;&quot;
SELECTED_WIFI_IFACE=&quot;&quot;
NM_IS_ACTIVE=false
DIALOG_SUCCESS_CODE=0
DIALOG_CANCEL_CODE=1
DIALOG_HELP_CODE=2 # Not explicitly used by this script&#39;s dialog calls
DIALOG_EXTRA_CODE=3 # Not explicitly used
DIALOG_ESC_CODE=255 # Standard for Esc key
DIALOG_DEFAULT_HEIGHT=15
DIALOG_DEFAULT_WIDTH=70
DIALOG_INPUT_WIDTH=50

PING_IP_TARGET=&quot;8.8.8.8&quot;
PING_HOSTNAME_TARGET=&quot;google.com&quot;
PING_COUNT=3
PING_TIMEOUT=2

TMP_FILES_TO_CLEAN=()

# --- Logging Functions ---
_log_to_file() {
    if $DBG &amp;&amp; [ -n &quot;$DEBUG_LOG_FILE&quot; ]; then
        echo -e &quot;$1&quot; &gt;&gt; &quot;$DEBUG_LOG_FILE&quot;
    fi
}

debug_log() {
    if ! $DBG; then return 0; fi

    local level_tag=&quot;$1&quot;; shift
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;
    local log_entry=&quot;[$timestamp] [$level_tag] [$caller_info] $message&quot;

    echo -e &quot;$log_entry&quot; &gt;&amp;2 # Debug logs always go to stderr
    _log_to_file &quot;$log_entry&quot; # And to file if DBG and DEBUG_LOG_FILE is set
}

debug_basic() { if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 1 ]; then debug_log &quot;DEBUG&quot; &quot;$@&quot;; fi; }
debug_verbose() { if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 2 ]; then debug_log &quot;VERB&quot; &quot;$@&quot;; fi; }
debug_full() { if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 3 ]; then debug_log &quot;FULL&quot; &quot;$@&quot;; fi; }

info_log() {
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local log_entry=&quot;[$timestamp] [INFO] $message&quot;
    echo -e &quot;$log_entry&quot; &gt;&amp;2
    _log_to_file &quot;$log_entry&quot;
}

error_log() {
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;
    local log_entry=&quot;[$timestamp] [ERROR] [$caller_info] $message&quot;
    echo -e &quot;$log_entry&quot; &gt;&amp;2
    _log_to_file &quot;$log_entry&quot;
}

warning_log() {
    local message=&quot;$*&quot;
    local timestamp
    timestamp=$(date &#39;+%Y-%m-%d %H:%M:%S&#39;)
    local caller_info=&quot;${BASH_SOURCE[1]##*/}:${FUNCNAME[1]}:${BASH_LINENO[0]}&quot;
    local log_entry=&quot;[$timestamp] [WARN] [$caller_info] $message&quot;
    echo -e &quot;$log_entry&quot; &gt;&amp;2
    _log_to_file &quot;$log_entry&quot;
}

debug_exec() {
    local cmd_string=&quot;$*&quot;
    debug_verbose &quot;Executing: $cmd_string&quot;

    if $DBG &amp;&amp; $VERBOSE_COMMANDS &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 2 ]; then
        local output exit_code
        # Using a subshell to capture output and exit code reliably
        output=$( (eval &quot;$cmd_string&quot;) 2&gt;&amp;1)
        exit_code=$?
        
        debug_verbose &quot;Exit code: $exit_code&quot;
        [ -n &quot;$output&quot; ] &amp;&amp; debug_full &quot;Output:\n$output&quot;
        
        if [ $exit_code -ne 0 ]; then
            debug_basic &quot;FAILED command: $cmd_string (Exit Code: $exit_code)&quot;
        fi
        echo &quot;$output&quot; 
        return $exit_code
    else
        eval &quot;$cmd_string&quot;
        return $?
    fi
}

debug_var() {
    if ! $DBG || [ &quot;$DEBUG_LEVEL&quot; -lt 2 ]; then return 0; fi
    local var_name=&quot;$1&quot;
    local var_value=&quot;${!var_name}&quot;
    debug_verbose &quot;Variable $var_name = &#39;$var_value&#39; (length: ${#var_value})&quot;

    if [[ &quot;$var_value&quot; =~ [[:cntrl:]] ]]; then
        debug_basic &quot;WARNING: Variable $var_name contains control characters.&quot;
        debug_full &quot;Hex dump for $var_name:\n$(echo -n &quot;$var_value&quot; | hexdump -C)&quot;
    fi
}

# --- Safe File Operations ---
create_temp_file() {
    local prefix=&quot;${1:-tmpfile}&quot;
    local suffix_val=&quot;${2:-}&quot; # e.g., &quot;.log&quot; or &quot;list&quot;
    local temp_file
    
    local sane_prefix
    sane_prefix=$(echo &quot;$prefix&quot; | tr -cs &#39;[:alnum:]_-&#39; &#39;_&#39;)
    local sane_suffix
    sane_suffix=$(echo &quot;$suffix_val&quot; | tr -cs &#39;[:alnum:]_.-&#39; &#39;_&#39;)

    # mktemp requires XXXXXX at end of template. Suffix is appended by mktemp if specified.
    # Ensure suffix starts with a dot if it&#39;s meant as an extension and not empty.
    if [[ -n &quot;$sane_suffix&quot; &amp;&amp; ! &quot;$sane_suffix&quot; =~ ^\. ]]; then
        sane_suffix=&quot;.$sane_suffix&quot;
    fi
    
    temp_file=$(mktemp &quot;/tmp/${sane_prefix}.XXXXXX${sane_suffix}&quot;)

    if [ -z &quot;$temp_file&quot; ] || [ ! -f &quot;$temp_file&quot; ] &amp;&amp; [ ! -d &quot;$temp_file&quot; ]; then
        error_log &quot;Failed to create temporary file with prefix &#39;$sane_prefix&#39; and suffix &#39;$sane_suffix&#39;&quot;
        return 1
    fi

    debug_verbose &quot;Created temporary file: &#39;$temp_file&#39;&quot;
    TMP_FILES_TO_CLEAN+=(&quot;$temp_file&quot;)
    echo &quot;$temp_file&quot;
    return 0
}

safe_rm() {
    local file_to_remove=&quot;$1&quot;
    debug_verbose &quot;Attempting to remove: &#39;$file_to_remove&#39;&quot;

    if [ -z &quot;$file_to_remove&quot; ]; then
        warning_log &quot;safe_rm: Empty filename provided.&quot;
        return 1
    fi
    if [ ! -e &quot;$file_to_remove&quot; ]; then
         debug_verbose &quot;File does not exist, skipping removal: &#39;$file_to_remove&#39;&quot;
         return 0
    fi

    if [ ${#file_to_remove} -gt 255 ]; then
        error_log &quot;safe_rm: Filename too long to remove: &#39;$file_to_remove&#39;&quot;
        return 1
    fi
    if [[ &quot;$file_to_remove&quot; =~ (\.\./|/\.\.) ]]; then
        error_log &quot;safe_rm: Path traversal attempt suspected: &#39;$file_to_remove&#39;&quot;
        return 1
    fi
    if [[ &quot;$file_to_remove&quot; == &quot;/&quot; ]] || [[ &quot;$file_to_remove&quot; == &quot;/bin&quot; ]] || [[ &quot;$file_to_remove&quot; == &quot;/etc&quot; ]] ; then
        error_log &quot;safe_rm: Critical path removal protection: &#39;$file_to_remove&#39;&quot;
        return 1
    fi

    if rm -f &quot;$file_to_remove&quot;; then
        debug_verbose &quot;Successfully removed: &#39;$file_to_remove&#39;&quot;
        return 0
    else
        error_log &quot;Failed to remove: &#39;$file_to_remove&#39; (Error: $?)&quot;
        return 1
    fi
}

# --- Cleanup Function ---
cleanup() {
    local exit_code=$?
    debug_basic &quot;Cleanup: Script exiting with code $exit_code&quot;
    
    if [ ${#TMP_FILES_TO_CLEAN[@]} -gt 0 ]; then
        debug_verbose &quot;Cleaning up ${#TMP_FILES_TO_CLEAN[@]} temporary file(s): ${TMP_FILES_TO_CLEAN[*]}&quot;
        for temp_file in &quot;${TMP_FILES_TO_CLEAN[@]}&quot;; do
            safe_rm &quot;$temp_file&quot;
        done
    else
        debug_verbose &quot;No temporary files registered for cleanup.&quot;
    fi

    if command -v stty &gt;/dev/null 2&gt;&amp;1; then
        stty sane 2&gt;/dev/null || debug_verbose &quot;stty sane failed (expected on some exits)&quot;
    fi
    if command -v tput &gt;/dev/null 2&gt;&amp;1; then
        tput cnorm 2&gt;/dev/null || debug_verbose &quot;tput cnorm failed (expected on some exits)&quot;
    fi
    
    # Stop xtrace and close its FD if it was used
    if $DBG &amp;&amp; [ -n &quot;$DEBUG_LOG_FILE&quot; ]; then
        set +x # Turn off xtrace
        # Close the xtrace file descriptor
        eval &quot;exec $XTRACE_FD&gt;&amp;-&quot; 2&gt;/dev/null || debug_verbose &quot;Failed to close XTRACE_FD $XTRACE_FD&quot;
        info_log &quot;Script exited (Code: $exit_code). Debug log available at: $DEBUG_LOG_FILE&quot;
        echo &quot;Debug log available at: $DEBUG_LOG_FILE&quot; &gt;&amp;2
    else
        info_log &quot;Script exited (Code: $exit_code). Cleanup performed.&quot;
    fi

    if [ $exit_code -ne 0 ] &amp;&amp; [ $exit_code -ne 130 ]; then # 130 is SIGINT/SIGTERM
        # Only prompt if running in an interactive terminal
        if [ -t 0 ] &amp;&amp; [ -t 1 ]; then # Check if stdin and stdout are terminals
            read -rp &quot;Press Enter to close terminal...&quot; &lt;/dev/tty
        fi
    fi
    exit $exit_code
}
trap cleanup EXIT
trap &#39;error_log &quot;Script interrupted by user (SIGINT/SIGTERM).&quot;; exit 130&#39; SIGINT SIGTERM

# --- Dialog UI Functions ---
_show_dialog_message() {
    local type=&quot;$1&quot;
    local title=&quot;$2&quot;
    local message=&quot;$3&quot;
    local height=${4:-8}
    local width=${5:-60}
    
    debug_verbose &quot;Showing dialog: type=$type, title=&#39;$title&#39;, message snippet=&#39;${message:0:50}...&#39;&quot;
    dialog --title &quot;$title&quot; --&quot;$type&quot; &quot;$message&quot; &quot;$height&quot; &quot;$width&quot; 2&gt;/dev/tty
    local dialog_exit_code=$?
    debug_verbose &quot;Dialog (&#39;$title&#39;) exit code: $dialog_exit_code&quot;
    return $dialog_exit_code
}

log_info_persistent() { info_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Information&quot; &quot;$1&quot;; }
log_info_transient() { info_log &quot;$1&quot;; dialog --title &quot;Information&quot; --infobox &quot;$1&quot; 6 60 2&gt;/dev/tty || true; sleep 1; } # Allow infobox to fail gracefully
log_msg() { info_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Message&quot; &quot;$1&quot;; }
log_error() { error_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Error&quot; &quot;$1&quot;; }
log_warning() { warning_log &quot;$1&quot;; _show_dialog_message &quot;msgbox&quot; &quot;Warning&quot; &quot;$1&quot;; }

# --- Prerequisite Checks ---
check_command() {
    local cmd_to_check=&quot;$1&quot;
    debug_verbose &quot;Checking for command: $cmd_to_check&quot;
    if command -v &quot;$cmd_to_check&quot; &gt;/dev/null 2&gt;&amp;1; then
        debug_verbose &quot;Command &#39;$cmd_to_check&#39; found.&quot;
        return 0
    else
        debug_basic &quot;Command &#39;$cmd_to_check&#39; not found.&quot;
        return 1
    fi
}

install_packages() {
    local missing_packages_to_install=()
    local pkg_info cmd pkg_name choice
    
    debug_basic &quot;Checking required packages: $@&quot;
    for pkg_info in &quot;$@&quot;; do
        IFS=&#39;,&#39; read -r cmd pkg_name &lt;&lt;&lt; &quot;$pkg_info&quot;
        debug_verbose &quot;Checking for command &#39;$cmd&#39; (package &#39;$pkg_name&#39;)&quot;
        if ! check_command &quot;$cmd&quot;; then
            debug_basic &quot;Missing command &#39;$cmd&#39; for package &#39;$pkg_name&#39;&quot;
            missing_packages_to_install+=(&quot;$pkg_name&quot;)
        fi
    done

    if [ ${#missing_packages_to_install[@]} -gt 0 ]; then
        warning_log &quot;Missing packages: ${missing_packages_to_install[*]}&quot;
        dialog --title &quot;Missing Packages&quot; \
               --yesno &quot;The following essential packages are missing: ${missing_packages_to_install[*]}.\\n\\nDo you want to try and install them now?\\n(Requires an existing temporary internet connection or cached packages)&quot; \
               12 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
        choice=$?
        debug_basic &quot;Install prompt choice code: $choice&quot;

        if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
            info_log &quot;User opted to install missing packages: ${missing_packages_to_install[*]}&quot;
            log_info_transient &quot;Attempting to install: ${missing_packages_to_install[*]}...&quot;
            
            if debug_exec &quot;apt-get update -qq&quot;; then
                if debug_exec &quot;apt-get install -y ${missing_packages_to_install[@]}&quot;; then
                    log_info_persistent &quot;Successfully installed missing packages.&quot;
                else
                    error_log &quot;Failed to install packages: ${missing_packages_to_install[*]} after apt-get update.&quot;
                    log_error &quot;Failed to install some packages. Please install them manually and re-run the script.\\nPackages: ${missing_packages_to_install[*]}&quot;
                    exit 1
                fi
            else
                error_log &quot;&#39;apt-get update&#39; failed. Cannot install packages.&quot;
                log_error &quot;&#39;apt-get update&#39; failed. Please check your network connection and apt sources, then re-run the script.&quot;
                exit 1
            fi
        else
            error_log &quot;User declined package installation or cancelled.&quot;
            log_error &quot;Cannot proceed without essential packages: ${missing_packages_to_install[*]}. Exiting.&quot;
            exit 1
        fi
    else
        debug_basic &quot;All required packages are present.&quot;
    fi
}

# --- Network Interface and Manager Detection ---
detect_ethernet_interfaces() {
    debug_basic &quot;Detecting Ethernet interfaces...&quot;
    ETH_IFACES=()
    local detected_output
    # Improved detection: exclude virtual interfaces more reliably, handle interfaces without carrier initially
    detected_output=$(debug_exec &quot;ip -o link show type ether 2&gt;/dev/null | awk -F&#39;: &#39; &#39;!/master|link\\/ether 00:00:00:00:00:00/{print \$2}&#39; | awk &#39;{print \$1}&#39; | grep -Ev &#39;^(lo|br|bond|dummy|veth|virbr|docker|tun|tap|vlan|vxlan|macvlan|macvtap|nlmon|gre|ipip|sit|ip6tnl)&#39; || true&quot;)
    
    debug_full &quot;Raw detected ethernet interfaces output: &#39;$detected_output&#39;&quot;
    if [ -n &quot;$detected_output&quot; ]; then
        while IFS= read -r iface; do
            iface_clean=$(echo &quot;$iface&quot; | tr -cd &#39;[:alnum:]_-&#39;) # Allow hyphens and underscores
            if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; ]]; then
                ETH_IFACES+=(&quot;$iface_clean&quot;)
                debug_verbose &quot;Added Ethernet interface: &#39;$iface_clean&#39;&quot;
            elif [ -n &quot;$iface&quot; ]; then
                 warning_log &quot;Skipped potentially invalid Ethernet interface name: &#39;$iface&#39;&quot;
            fi
        done &lt;&lt;&lt; &quot;$detected_output&quot;
    fi
    log_info_transient &quot;Detected Ethernet interfaces: ${ETH_IFACES[*]:-(None)}&quot;
}

detect_wifi_interfaces() {
    debug_basic &quot;Detecting Wi-Fi interfaces...&quot;
    WIFI_IFACES=()
    local detected_output=&quot;&quot;

    if check_command iw; then
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;iw dev&#39;&quot;
        detected_output=$(debug_exec &quot;iw dev 2&gt;/dev/null | awk &#39;\$1==\&quot;Interface\&quot;{print \$2}&#39; || true&quot;)
        debug_full &quot;Raw detected Wi-Fi interfaces output (iw): &#39;$detected_output&#39;&quot;
    fi
    
    if [ -z &quot;$detected_output&quot; ] &amp;&amp; check_command ip; then # Fallback if &#39;iw&#39; fails or not present
        debug_verbose &quot;Attempting Wi-Fi detection with &#39;ip link&#39; (fallback)&quot;
        # &#39;type wlan&#39; is more specific for Wi-Fi than just &#39;type ether&#39;
        detected_output=$(debug_exec &quot;ip -o link show type wlan 2&gt;/dev/null | awk -F&#39;: &#39; &#39;{print \$2}&#39; | awk &#39;{print \$1}&#39; || true&quot;)
        debug_full &quot;Raw detected Wi-Fi interfaces output (ip): &#39;$detected_output&#39;&quot;
    fi

    if [ -n &quot;$detected_output&quot; ]; then
        while IFS= read -r iface; do
            iface_clean=$(echo &quot;$iface&quot; | tr -cd &#39;[:alnum:]_-&#39;) # Allow hyphens and underscores
            if [[ -n &quot;$iface_clean&quot; &amp;&amp; &quot;$iface_clean&quot; == &quot;$iface&quot; ]]; then
                WIFI_IFACES+=(&quot;$iface_clean&quot;)
                debug_verbose &quot;Added Wi-Fi interface: &#39;$iface_clean&#39;&quot;
            elif [ -n &quot;$iface&quot; ]; then
                warning_log &quot;Skipped potentially invalid Wi-Fi interface name: &#39;$iface&#39;&quot;
            fi
        done &lt;&lt;&lt; &quot;$detected_output&quot;
    fi
    log_info_transient &quot;Detected Wi-Fi interfaces: ${WIFI_IFACES[*]:-(None)}&quot;
}

check_network_manager_active() {
    debug_basic &quot;Checking NetworkManager service status...&quot;
    if check_command systemctl &amp;&amp; systemctl is-active --quiet NetworkManager; then
        NM_IS_ACTIVE=true
        info_log &quot;NetworkManager service is active.&quot;
        log_info_transient &quot;NetworkManager service is active.&quot;
    else
        NM_IS_ACTIVE=false
        info_log &quot;NetworkManager service is not active or not found.&quot;
        log_info_transient &quot;NetworkManager service is not active or not found.&quot;
    fi
    debug_var &quot;NM_IS_ACTIVE&quot;
}

# --- User Interaction and Selection (Robust Dialog Handling) ---
prompt_select_interface() {
    local type=&quot;$1&quot;; shift
    local interfaces_array=(&quot;$@&quot;)
    local dialog_options=() choice_tag i=1 selected_interface=&quot;&quot;

    debug_basic &quot;Prompting user to select $type interface. Available: ${interfaces_array[*]}&quot;
    debug_var &quot;type&quot;

    if [ ${#interfaces_array[@]} -eq 0 ]; then
        log_warning &quot;No $type interfaces found to select.&quot;; return 1
    elif [ ${#interfaces_array[@]} -eq 1 ]; then
        selected_interface=&quot;${interfaces_array[0]}&quot;
        log_info_persistent &quot;Auto-selecting $type interface: $selected_interface&quot;
        echo &quot;$selected_interface&quot;; return 0
    fi

    for iface_item in &quot;${interfaces_array[@]}&quot;; do dialog_options+=(&quot;$i&quot; &quot;$iface_item&quot;); i=$((i + 1)); done
    debug_verbose &quot;Dialog options for $type selection: ${dialog_options[*]}&quot;

    exec 3&gt;&amp;1 
    choice_tag=$(dialog --title &quot;Select $type Interface&quot; \
        --menu &quot;Choose the $type interface to configure:&quot; \
        ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} $((${#dialog_options[@]} / 2)) \
        &quot;${dialog_options[@]}&quot; 2&gt;&amp;1 1&gt;&amp;3) 
    local dialog_exit_status=$?
    exec 3&gt;&amp;- 

    debug_basic &quot;$type interface selection: dialog exit status: $dialog_exit_status, captured tag: &#39;$choice_tag&#39;&quot;

    if [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]; then
        log_info_persistent &quot;$type interface selection cancelled by user.&quot;; return 1
    fi
    
    local choice_tag_cleaned
    choice_tag_cleaned=$(echo &quot;$choice_tag&quot; | tr -cd &#39;0-9&#39;) # Ensure only digits
    if [ -z &quot;$choice_tag_cleaned&quot; ] || ! [[ &quot;$choice_tag_cleaned&quot; =~ ^[0-9]+$ ]] || \
       [ &quot;$choice_tag_cleaned&quot; -lt 1 ] || [ &quot;$choice_tag_cleaned&quot; -gt $((${#dialog_options[@]} / 2)) ]; then
        error_log &quot;Invalid or empty selection tag received from $type interface menu: &#39;$choice_tag&#39;&quot;
        log_warning &quot;Invalid selection from $type interface menu.&quot;; return 1
    fi
    
    selected_interface=&quot;${interfaces_array[$((choice_tag_cleaned - 1))]}&quot;
    debug_basic &quot;User selected $type interface: &#39;$selected_interface&#39;&quot;
    echo &quot;$selected_interface&quot;; return 0
}

prompt_static_config() {
    local interface_type=&quot;$1&quot; 
    local static_ip=&quot;&quot; static_gateway=&quot;&quot; static_dns=&quot;&quot;
    local dialog_exit_status

    debug_basic &quot;Prompting for static IP configuration for $interface_type&quot;

    exec 3&gt;&amp;1
    static_ip=$(dialog --title &quot;Static IP Configuration ($interface_type)&quot; \
        --inputbox &quot;Enter Static IP Address with CIDR (e.g., 192.168.1.100/24):&quot; \
        10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
    dialog_exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;Static IP dialog exit: $dialog_exit_status, value: &#39;$static_ip&#39;&quot;
    [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ] &amp;&amp; { log_info_persistent &quot;Static IP entry cancelled.&quot;; return 1; }

    exec 3&gt;&amp;1
    static_gateway=$(dialog --title &quot;Static IP Configuration ($interface_type)&quot; \
        --inputbox &quot;Enter Gateway IP Address (e.g., 192.168.1.1):&quot; \
        10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
    dialog_exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;Gateway dialog exit: $dialog_exit_status, value: &#39;$static_gateway&#39;&quot;
    [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ] &amp;&amp; { log_info_persistent &quot;Gateway entry cancelled.&quot;; return 1; }

    exec 3&gt;&amp;1
    static_dns=$(dialog --title &quot;Static IP Configuration ($interface_type)&quot; \
        --inputbox &quot;Enter DNS Server(s) (comma-separated, e.g., 8.8.8.8,1.1.1.1, optional):&quot; \
        10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
    dialog_exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;DNS dialog exit: $dialog_exit_status, value: &#39;$static_dns&#39;&quot;
    # If DNS entry is cancelled (ESC or Cancel button), dialog_exit_status will be non-zero.
    # In this case, static_dns (captured from dialog&#39;s stdout) will be empty.
    # So, we just proceed, and if static_dns is empty, no DNS will be configured.
    if [ $dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]; then
        log_info_persistent &quot;DNS entry cancelled or skipped, DNS will not be set.&quot;
        static_dns=&quot;&quot; # Ensure it&#39;s empty if cancelled
    fi

    if [[ -z &quot;$static_ip&quot; || -z &quot;$static_gateway&quot; ]]; then
        log_error &quot;Static IP and Gateway cannot be empty.&quot;; return 1;
    fi
    if ! echo &quot;$static_ip&quot; | grep -qE &quot;/[0-9]{1,2}$&quot;; then
        log_error &quot;Static IP must be in CIDR notation (e.g., 192.168.1.100/24).&quot;; return 1;
    fi
    if ! echo &quot;$static_gateway&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$&quot;; then
        log_error &quot;Gateway IP Address format is invalid (e.g., 192.168.1.1).&quot;; return 1;
    fi
    if [ -n &quot;$static_dns&quot; ]; then
        IFS=&#39;,&#39; read -ra dns_array &lt;&lt;&lt; &quot;$static_dns&quot;
        for dns_entry in &quot;${dns_array[@]}&quot;; do
            # Trim whitespace from dns_entry
            dns_entry_trimmed=$(echo &quot;$dns_entry&quot; | awk &#39;{$1=$1};1&#39;)
            if ! echo &quot;$dns_entry_trimmed&quot; | grep -qE &quot;^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$&quot;; then
                log_error &quot;DNS Server IP Address format is invalid: &#39;$dns_entry_trimmed&#39;.&quot;; return 1;
            fi
        done
    fi
    
    debug_verbose &quot;Static config collected: IP=&#39;$static_ip&#39;, GW=&#39;$static_gateway&#39;, DNS=&#39;$static_dns&#39;&quot;
    echo &quot;$static_ip:$static_gateway:$static_dns&quot;; return 0
}

# --- Connectivity Check ---
check_internet_connectivity() {
    log_info_transient &quot;Checking internet connectivity...&quot;
    debug_basic &quot;Pinging IP: $PING_IP_TARGET, Host: $PING_HOSTNAME_TARGET&quot;

    if debug_exec &quot;ping -c ${PING_COUNT} -W ${PING_TIMEOUT} \&quot;${PING_IP_TARGET}\&quot;&quot; &gt;/dev/null 2&gt;&amp;1; then
        info_log &quot;Successfully pinged IP address (${PING_IP_TARGET}). Basic connectivity OK.&quot;
        log_info_transient &quot;Ping to IP ${PING_IP_TARGET} successful.&quot;
        if debug_exec &quot;ping -c ${PING_COUNT} -W ${PING_TIMEOUT} \&quot;${PING_HOSTNAME_TARGET}\&quot;&quot; &gt;/dev/null 2&gt;&amp;1; then
            log_msg &quot;Internet connection established and DNS resolution working (pinged ${PING_HOSTNAME_TARGET}).&quot;
            return 0
        else
            warning_log &quot;DNS resolution failed (cannot ping ${PING_HOSTNAME_TARGET}). Check DNS settings.&quot;
            log_warning &quot;Successfully pinged IP, but DNS resolution failed for ${PING_HOSTNAME_TARGET}. Check DNS settings.&quot;; return 2 # Special code for DNS failure
        fi
    else
        warning_log &quot;Failed to ping IP address (${PING_IP_TARGET}). No basic network connectivity.&quot;
        log_warning &quot;Failed to ping IP address (${PING_IP_TARGET}). No basic network connectivity.&quot;; return 1
    fi
}

# --- Ethernet Configuration ---
attempt_ethernet_dhcp() {
    local iface=&quot;$1&quot;
    debug_basic &quot;Attempting DHCP on Ethernet interface: $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;
    log_info_transient &quot;Attempting DHCP on Ethernet interface: $iface&quot;

    if $NM_IS_ACTIVE; then
        local profile_name
        # Try to find an active connection for the device first
        profile_name=$(nmcli -g NAME,DEVICE connection show --active 2&gt;/dev/null | grep -E &quot;:$iface$&quot; | cut -d&#39;:&#39; -f1 | head -n1 || true)
        [ -z &quot;$profile_name&quot; ] &amp;&amp; profile_name=$(nmcli -g NAME,DEVICE connection show 2&gt;/dev/null | grep -E &quot;:$iface$&quot; | cut -d&#39;:&#39; -f1 | head -n1 || true)
        debug_verbose &quot;NM existing profile for $iface: &#39;$profile_name&#39;&quot;

        if [ -n &quot;$profile_name&quot; ]; then
            log_info_transient &quot;Found existing NM profile &#39;$profile_name&#39; for $iface. Ensuring DHCP and activating...&quot;
            # Modify to DHCP and then activate
            if debug_exec &quot;nmcli connection modify \&quot;$profile_name\&quot; ipv4.method auto ipv6.method auto&quot; &amp;&amp; \
               debug_exec &quot;nmcli connection up \&quot;$profile_name\&quot; ifname \&quot;$iface\&quot;&quot;; then
                log_info_transient &quot;NetworkManager activated DHCP profile &#39;$profile_name&#39; for $iface.&quot;; sleep 5; return 0
            else
                warning_log &quot;Failed to activate existing DHCP profile &#39;$profile_name&#39; for $iface via NM. Trying to add a new one.&quot;
            fi
        fi
        
        log_info_transient &quot;Attempting to add and activate a new DHCP Ethernet connection for $iface via NetworkManager...&quot;
        local new_profile_name=&quot;Eth-DHCP-$iface-$(date +%s)&quot; # Make profile name more unique
        nmcli connection delete &quot;$new_profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true # Clean up if it somehow exists
        if debug_exec &quot;nmcli connection add type ethernet con-name \&quot;$new_profile_name\&quot; ifname \&quot;$iface\&quot; ipv4.method auto ipv6.method auto&quot; &amp;&amp; \
           debug_exec &quot;nmcli connection up \&quot;$new_profile_name\&quot;&quot;; then
            log_info_transient &quot;NetworkManager added and activated DHCP connection for $iface.&quot;; sleep 5; return 0
        else
            warning_log &quot;Failed to configure Ethernet DHCP for $iface via NetworkManager. Will try dhclient.&quot;
            nmcli connection delete &quot;$new_profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true # Cleanup failed attempt
        fi
    fi

    log_info_transient &quot;Bringing interface $iface up...&quot;
    if ! debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then log_warning &quot;Failed to bring interface $iface up.&quot;; return 1; fi
    # Release any old lease for the interface
    debug_exec &quot;dhclient -r \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true 
    
    local dhclient_log
    dhclient_log=$(create_temp_file &quot;dhclient_eth_${iface}&quot; &quot;log&quot;)
    [ $? -ne 0 ] &amp;&amp; { error_log &quot;Failed to create dhclient log file.&quot;; dhclient_log=&quot;/dev/null&quot;; } # Proceed even if log creation fails

    log_info_transient &quot;Attempting DHCP with dhclient on $iface...&quot;
    if debug_exec &quot;timeout 30 dhclient -v \&quot;$iface\&quot;&quot; &gt;&quot;$dhclient_log&quot; 2&gt;&amp;1; then
        log_info_transient &quot;dhclient successfully obtained lease on $iface.&quot;
        debug_full &quot;dhclient log for $iface:\n$(cat &quot;$dhclient_log&quot;)&quot;; sleep 2; return 0
    else
        error_log &quot;dhclient failed or timed out for $iface. Log: $dhclient_log&quot;
        log_error &quot;dhclient failed or timed out for $iface. Check log: $dhclient_log&quot;
        debug_full &quot;dhclient log for $iface on failure:\n$(cat &quot;$dhclient_log&quot;)&quot;; return 1
    fi
}

configure_ethernet_static() {
    local iface=&quot;$1&quot; config_str prompt_exit_status static_ip_cidr gateway dns_servers
    debug_basic &quot;Configuring static Ethernet for $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;
    
    config_str=$(prompt_static_config &quot;Ethernet ($iface)&quot;)
    prompt_exit_status=$?
    [ $prompt_exit_status -ne 0 ] &amp;&amp; return 1
    debug_verbose &quot;Static config string from prompt: &#39;$config_str&#39;&quot;

    IFS=&#39;:&#39; read -r static_ip_cidr gateway dns_servers &lt;&lt;&lt; &quot;$config_str&quot;
    log_info_transient &quot;Configuring static IP for Ethernet $iface: IP=$static_ip_cidr, GW=$gateway, DNS=${dns_servers:-Not set}&quot;

    if $NM_IS_ACTIVE; then
        local profile_name=&quot;Static-Eth-$iface-$(date +%s)&quot; nm_cmd_parts=() # Make profile name more unique
        nmcli connection delete &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true 
        
        log_info_transient &quot;Attempting to add/activate static Ethernet connection via NetworkManager...&quot;
        nm_cmd_parts=(&quot;nmcli&quot; &quot;connection&quot; &quot;add&quot; &quot;type&quot; &quot;ethernet&quot; &quot;con-name&quot; &quot;$profile_name&quot; &quot;ifname&quot; &quot;$iface&quot; &quot;ipv4.method&quot; &quot;manual&quot; &quot;ipv4.addresses&quot; &quot;$static_ip_cidr&quot; &quot;ipv4.gateway&quot; &quot;$gateway&quot;)
        [ -n &quot;$dns_servers&quot; ] &amp;&amp; nm_cmd_parts+=(&quot;ipv4.dns&quot; &quot;$dns_servers&quot;)
        nm_cmd_parts+=(&quot;ipv6.method&quot; &quot;ignore&quot;) # Typically ignore IPv6 for simple static setups

        if debug_exec &quot;${nm_cmd_parts[@]}&quot; &amp;&amp; debug_exec &quot;nmcli connection up \&quot;$profile_name\&quot;&quot;; then
            log_info_transient &quot;NetworkManager configured and activated static IP on $iface.&quot;; sleep 3; return 0
        else
            error_log &quot;Failed to configure static IP on $iface via NetworkManager.&quot;
            log_error &quot;NM static IP configuration failed for $iface.&quot;
            nmcli connection delete &quot;$profile_name&quot; &gt;/dev/null 2&gt;&amp;1 || true; return 1 # Cleanup failed attempt
        fi
    fi

    # Fallback to iproute2 if NM is not active or failed
    log_info_transient &quot;Configuring static IP on $iface using iproute2...&quot;
    debug_exec &quot;ip addr flush dev \&quot;$iface\&quot;&quot; || true # Clear existing IPs
    debug_exec &quot;ip link set \&quot;$iface\&quot; down&quot; || true # Take interface down before reconfiguring
    if ! debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then log_warning &quot;Failed to bring interface $iface up for static config.&quot;; return 1; fi
    
    if debug_exec &quot;ip addr add \&quot;$static_ip_cidr\&quot; dev \&quot;$iface\&quot;&quot;; then
        log_info_transient &quot;IP address $static_ip_cidr added to $iface.&quot;; sleep 2
        # Remove existing default routes for this interface before adding a new one
        debug_exec &quot;ip route del default dev \&quot;$iface\&quot;&quot; 2&gt;/dev/null || true
        if debug_exec &quot;ip route add default via \&quot;$gateway\&quot; dev \&quot;$iface\&quot;&quot;; then
            log_info_transient &quot;Default route via $gateway added for $iface.&quot;
            if [ -n &quot;$dns_servers&quot; ]; then
                local resolv_conf_content=&quot;&quot;
                IFS=&#39;,&#39; read -ra dns_array &lt;&lt;&lt; &quot;$dns_servers&quot;
                for dns in &quot;${dns_array[@]}&quot;; do 
                    dns_trimmed=$(echo &quot;$dns&quot; | awk &#39;{$1=$1};1&#39;) # Trim whitespace
                    resolv_conf_content+=&quot;nameserver $dns_trimmed\n&quot;
                done
                
                if [ -L /etc/resolv.conf ] &amp;&amp; ! command -v resolvconf &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ! command -v systemd-resolve &gt;/dev/null 2&gt;&amp;1; then
                    warning_log &quot;/etc/resolv.conf is a symlink. Overwriting it for DNS might be overridden if not managed by resolvconf or systemd-resolved.&quot;
                    log_warning &quot;/etc/resolv.conf is a symlink. DNS might not be set correctly by overwriting it.&quot;
                fi
                # This is a direct overwrite, might be temporary if NetworkManager or systemd-resolved is running
                echo -e &quot;$resolv_conf_content&quot; &gt; /etc/resolv.conf
                info_log &quot;Configured DNS servers in /etc/resolv.conf: $dns_servers (manual iproute2 mode)&quot;
                log_info_transient &quot;DNS servers set in /etc/resolv.conf: $dns_servers&quot;
            fi
            sleep 3; return 0
        else
            error_log &quot;Failed to add default route via $gateway for $iface.&quot;
            log_error &quot;Failed to add default route for $iface.&quot;; return 1
        fi
    else
        error_log &quot;Failed to add IP address $static_ip_cidr to $iface.&quot;
        log_error &quot;Failed to add IP address to $iface.&quot;; return 1
    fi
}

handle_ethernet_connection() {
    local select_exit_status choice
    debug_basic &quot;Handling Ethernet connection. Detected interfaces: ${#ETH_IFACES[@]}&quot;
    if [ ${#ETH_IFACES[@]} -eq 0 ]; then
        log_warning &quot;No Ethernet interfaces detected. Skipping Ethernet setup.&quot;; return 1
    fi

    SELECTED_ETH_IFACE=$(prompt_select_interface &quot;Ethernet&quot; &quot;${ETH_IFACES[@]}&quot;)
    select_exit_status=$?
    debug_basic &quot;Ethernet interface selection: exit_status=$select_exit_status, SELECTED_ETH_IFACE=&#39;$SELECTED_ETH_IFACE&#39;&quot;
    [ $select_exit_status -ne 0 ] &amp;&amp; return 1
    [ -z &quot;$SELECTED_ETH_IFACE&quot; ] &amp;&amp; { log_warning &quot;No Ethernet interface was actually selected.&quot;; return 1; }

    dialog --title &quot;Ethernet Configuration: $SELECTED_ETH_IFACE&quot; \
           --yesno &quot;Attempt to configure &#39;$SELECTED_ETH_IFACE&#39; using DHCP (automatic IP)?&quot; \
           ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
    choice=$?
    if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
        if attempt_ethernet_dhcp &quot;$SELECTED_ETH_IFACE&quot;; then return 0; fi
        log_warning &quot;DHCP on $SELECTED_ETH_IFACE failed. Offering static IP.&quot;
    elif [ $choice -eq $DIALOG_CANCEL_CODE ]; then # User selected &quot;No&quot; for DHCP
        log_info_persistent &quot;DHCP for $SELECTED_ETH_IFACE skipped by user.&quot;
    else # ESC or other dialog error
        log_info_persistent &quot;Ethernet DHCP choice cancelled or dialog error.&quot;; return 1
    fi

    # Offer static IP if DHCP failed or was skipped
    dialog --title &quot;Ethernet Configuration: $SELECTED_ETH_IFACE&quot; \
           --yesno &quot;Do you want to configure a static IP for &#39;$SELECTED_ETH_IFACE&#39;?&quot; \
           ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
    choice=$?
    if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
        if configure_ethernet_static &quot;$SELECTED_ETH_IFACE&quot;; then return 0; fi
        log_warning &quot;Static IP configuration on $SELECTED_ETH_IFACE failed.&quot;
    elif [ $choice -eq $DIALOG_CANCEL_CODE ]; then # User selected &quot;No&quot; for Static IP
        log_info_persistent &quot;Static IP configuration for $SELECTED_ETH_IFACE skipped by user.&quot;
    else # ESC or other dialog error
        log_info_persistent &quot;Ethernet Static IP choice cancelled or dialog error.&quot;; return 1
    fi
    
    debug_basic &quot;Ethernet configuration for $SELECTED_ETH_IFACE did not succeed.&quot;; return 1
}

# --- Wi-Fi Configuration (Robust Scanning) ---
scan_wifi_networks() {
    local iface=&quot;$1&quot;
    local networks_list=() 
    local tmp_scan_file
    
    debug_basic &quot;Scanning Wi-Fi networks on interface: $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;
    log_info_transient &quot;Scanning for Wi-Fi networks on $iface (this may take a few seconds)...&quot;

    tmp_scan_file=$(create_temp_file &quot;wifi_scan_${iface}&quot; &quot;list&quot;)
    if [ $? -ne 0 ] || [ -z &quot;$tmp_scan_file&quot; ]; then
        error_log &quot;Failed to create temporary file for Wi-Fi scan on $iface.&quot;; return 1
    fi

    # Ensure interface is up for scanning, but don&#39;t fail if it errors (might be already up or managed)
    debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot; 2&gt;/dev/null || warning_log &quot;Could not bring $iface up for scanning, scan might be incomplete.&quot;

    if $NM_IS_ACTIVE &amp;&amp; check_command nmcli; then
        debug_verbose &quot;Using nmcli for Wi-Fi scan on $iface.&quot;
        # Request a rescan if possible
        debug_exec &quot;nmcli device wifi rescan ifname \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true 
        sleep 3 # Give some time for the rescan to populate

        # nmcli output: IN-USE:SSID:BARS:SECURITY (BARS is signal strength as string like &#39;▂▄▆_&#39;)
        # Awk processes this to: SSID\0Description\n
        # Robustly parse nmcli terse output, handling colons in SSIDs.
        # The strategy is to identify fixed position fields from the right (SECURITY, BARS)
        # and assume the middle part is the SSID.
        debug_exec &quot;nmcli -t -f IN-USE,SSID,BARS,SECURITY device wifi list ifname \&quot;$iface\&quot; --rescan no&quot; 2&gt;/dev/null | \
        awk -F: &#39;
            # awk script for nmcli output processing
            # Input format: IN-USE:SSID:BARS:SECURITY (SSID can contain colons)
            # Output format for mapfile: SSID\0Description\n
            BEGIN { OFS=&quot;\0&quot;; ORS=&quot;\n&quot; }
            {
                if (NF &lt; 4) { # Expect at least 4 fields (e.g. *:OpenSSID:strength:Open)
                    # Handle cases with empty SSID or unexpected format if necessary
                    # print &quot;AWK_NMCLI_PARSE_WARN: Skipping line due to insufficient fields: &quot; $0 &gt; &quot;/dev/stderr&quot;;
                    next;
                }

                in_use_field = $1;
                # Reconstruct SSID: from $2 up to $(NF-2)
                ssid_field = $2;
                for (i = 3; i &lt;= NF - 2; i++) {
                    ssid_field = ssid_field &quot;:&quot; $i;
                }
                
                # Remove potential escaping if nmcli added any (unlikely with -t)
                # gsub(/\\:/, &quot;:&quot;, ssid_field); # Example if nmcli escaped colons in SSID

                bars_field = $(NF-1); # Second to last field
                security_field = $NF;   # Last field

                if (ssid_field == &quot;&quot;) next; # Skip if SSID is empty after reconstruction

                # Create display SSID (truncated)
                display_ssid = substr(ssid_field, 1, 25);
                if (length(ssid_field) &gt; 25) display_ssid = display_ssid &quot;..&quot;;

                # Format security display string
                sec_display = (security_field == &quot;&quot; ? &quot;Open&quot; : security_field);
                # Prepend *Connected* if IN-USE is &#39;*&#39;
                if (in_use_field == &quot;*&quot;) sec_display = &quot;*Connected* &quot; sec_display;

                # Construct description string
                description = &quot;Sig: &quot; bars_field &quot; | Sec: &quot; sec_display &quot; | &quot; display_ssid;
                
                # Output SSID and Description, null-separated, newline-terminated
                print ssid_field, description;
            }
        &#39; &gt; &quot;$tmp_scan_file&quot;
        # CORRECTED: Check command status without premature &#39;fi&#39;
        [ $? -ne 0 ] &amp;&amp; error_log &quot;nmcli scan or awk processing failed for $iface.&quot;

    elif check_command iwlist; then
        debug_verbose &quot;Using iwlist for Wi-Fi scan on $iface.&quot;
        # Try to kill any existing wpa_supplicant for this interface to ensure iwlist can scan
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill &gt;/dev/null 2&gt;&amp;1 || true; sleep 0.5
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill -9 &gt;/dev/null 2&gt;&amp;1 || true; sleep 1

        debug_exec &quot;iwlist \&quot;$iface\&quot; scan&quot; 2&gt;/dev/null | \
        awk -v RS=&quot;Cell &quot; &#39;
            # awk script for iwlist output processing
            # Input: iwlist scan output, record separated by &quot;Cell &quot;
            # Output format for mapfile: SSID\0Description\n
            NR &gt; 1 { # Skip first record as it is not a cell
                essid=&quot;&quot;; signal=&quot;N/A&quot;; security=&quot;Open&quot;;
                # Extract ESSID
                if (match($0, /ESSID:&quot;([^&quot;]+)&quot;/, arr_essid)) { essid=arr_essid[1] }
                # Clean control characters from ESSID
                gsub(/[[:cntrl:]]/, &quot;&quot;, essid);
                if (essid == &quot;&quot;) next; # Skip if no ESSID

                # Extract Signal Quality/Level
                if (match($0, /Quality=([0-9]+\/[0-9]+).*Signal level=(-?[0-9]+ dBm)/, arr_sig)) { signal=arr_sig[1] &quot; (&quot; arr_sig[2] &quot;)&quot; }
                else if (match($0, /Signal level=(-?[0-9]+ dBm)/, arr_sig)) { signal=arr_sig[1] }
                else if (match($0, /Quality=([0-9]+\/[0-9]+)/, arr_sig)) { signal=arr_sig[1] }

                # Determine Security Type
                if (match($0, /Encryption key:on/)) {
                    security=&quot;Protected&quot;; # Generic
                    # More specific checks for WPA/WPA2/WEP
                    # This logic is a bit simplistic; WPA/WPA2 is usually in IEs
                    if (!match($0, /IE: IEEE 802.11i\/WPA2/) &amp;&amp; !match($0, /IE: WPA Version 1/)) {
                         security=&quot;WEP&quot;; 
                    }
                }
                # Prioritize WPA2/WPA detection from IEs
                if (match($0, /IE: IEEE 802.11i\/WPA2 Version 1/)) { security=&quot;WPA2/PSK&quot; } 
                else if (match($0, /IE: WPA Version 1/)) { security=&quot;WPA/PSK&quot; } 
                # Note: WPA3/SAE detection from iwlist is less reliable, may need &quot;IE:.*SAE&quot;

                # Create display ESSID (truncated)
                display_essid = substr(essid, 1, 25);
                if (length(essid) &gt; 25) display_essid = display_essid &quot;..&quot;;
                
                # Construct description string
                description = &quot;Sig: &quot; signal &quot; | Sec: &quot; security &quot; | &quot; display_essid;
                
                # Output SSID and Description, null-separated, newline-terminated
                printf &quot;%s\0%s\n&quot;, essid, description;
            }&#39; &gt; &quot;$tmp_scan_file&quot;
        # CORRECTED: Check command status without premature &#39;fi&#39;
        [ $? -ne 0 ] &amp;&amp; error_log &quot;iwlist scan or awk processing failed for $iface.&quot;
    else
        error_log &quot;No suitable tool (nmcli or iwlist) found for Wi-Fi scanning on $iface.&quot;
        safe_rm &quot;$tmp_scan_file&quot;; TMP_FILES_TO_CLEAN=(&quot;${TMP_FILES_TO_CLEAN[@]/$tmp_scan_file}&quot;); return 1
    fi # This &#39;fi&#39; now correctly closes the entire if/elif/else structure.
    
    # Read into array using null delimiter, expecting pairs (SSID, Description)
    mapfile -t -d $&#39;\0&#39; networks_list &lt; &quot;$tmp_scan_file&quot;
    local mapfile_status=$?
    debug_full &quot;mapfile status: $mapfile_status. Networks list size: ${#networks_list[@]}&quot;
    
    # Remove the temporary file from the global cleanup list as it&#39;s processed here
    safe_rm &quot;$tmp_scan_file&quot;
    TMP_FILES_TO_CLEAN=(&quot;${TMP_FILES_TO_CLEAN[@]/$tmp_scan_file}&quot;) # Remove from global list

    if [ ${#networks_list[@]} -eq 0 ]; then
        log_warning &quot;No Wi-Fi networks found on $iface after scan, or error reading scan data.&quot;
        return 1
    fi

    debug_basic &quot;Wi-Fi scan on $iface found $((${#networks_list[@]}/2)) networks.&quot;
    if $DBG &amp;&amp; [ &quot;$DEBUG_LEVEL&quot; -ge 3 ]; then
        for ((i=0; i &lt; ${#networks_list[@]}; i+=2)); do
            debug_full &quot;Scan result: SSID=&#39;${networks_list[i]}&#39;, DESC=&#39;${networks_list[i+1]}&#39;&quot;
        done
    fi
    
    # Print the flat array (SSID\nDescription\nSSID\nDescription...) for connect_wifi to mapfile again
    printf &quot;%s\n&quot; &quot;${networks_list[@]}&quot;; return 0
}

connect_wifi() {
    local iface=&quot;$1&quot; networks_flat_array_str networks_flat_array=()
    local scan_status selected_ssid security_type full_description wifi_password exit_status choice
    local wpa_conf_temp connect_tries static_config_str static_ip_cidr gw dns_val
    local resolv_conf_content_wifi dns_array_wifi active_wifi_conn nm_modify_cmd

    debug_basic &quot;Attempting to connect Wi-Fi on interface: $iface. NM_IS_ACTIVE=$NM_IS_ACTIVE&quot;

    networks_flat_array_str=$(scan_wifi_networks &quot;$iface&quot;)
    scan_status=$? 
    
    if [ $scan_status -ne 0 ] || [ -z &quot;$networks_flat_array_str&quot; ]; then
        log_warning &quot;Failed to retrieve Wi-Fi networks or no networks found for $iface.&quot;; return 1
    fi
    # networks_flat_array_str is already newline separated from printf in scan_wifi_networks
    mapfile -t networks_flat_array &lt;&lt;&lt; &quot;$networks_flat_array_str&quot;
    debug_verbose &quot;Retrieved ${#networks_flat_array[@]} items for Wi-Fi selection dialog.&quot;

    # Ensure we have pairs for the dialog menu (SSID, Description)
    if [ $((${#networks_flat_array[@]} % 2)) -ne 0 ]; then
        error_log &quot;Wi-Fi scan data is malformed (not in pairs). Cannot proceed.&quot;
        return 1
    fi

    exec 3&gt;&amp;1
    selected_ssid=$(dialog --title &quot;Select Wi-Fi Network ($iface)&quot; \
        --menu &quot;Choose the Wi-Fi network (SSID) to connect to:&quot; \
        $((DIALOG_DEFAULT_HEIGHT + 5)) ${DIALOG_DEFAULT_WIDTH} $((${#networks_flat_array[@]} / 2)) \
        &quot;${networks_flat_array[@]}&quot; 2&gt;&amp;1 1&gt;&amp;3)
    exit_status=$?
    exec 3&gt;&amp;-
    debug_basic &quot;Wi-Fi selection dialog: exit_status=$exit_status, selected_ssid_tag=&#39;$selected_ssid&#39;&quot;

    if [ $exit_status -ne $DIALOG_SUCCESS_CODE ] || [ -z &quot;$selected_ssid&quot; ]; then
        log_info_persistent &quot;Wi-Fi network selection cancelled or empty.&quot;; return 1
    fi

    # Determine security type based on the description string from the scan
    security_type=&quot;Unknown&quot; # Default
    for ((i=0; i&lt;${#networks_flat_array[@]}; i+=2)); do
        if [ &quot;${networks_flat_array[i]}&quot; == &quot;$selected_ssid&quot; ]; then
            full_description=&quot;${networks_flat_array[i+1]}&quot;
            debug_verbose &quot;Full description for &#39;$selected_ssid&#39;: &#39;$full_description&#39;&quot;
            # More specific security type detection based on common patterns
            if [[ &quot;$full_description&quot; == *&quot;Sec: Open&quot;* ]]; then security_type=&quot;Open&quot;
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WEP&quot;* ]]; then security_type=&quot;WEP&quot;
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WPA2/PSK&quot;* || &quot;$full_description&quot; == *&quot;Sec: WPA2&quot;* ]]; then security_type=&quot;PSK&quot; # WPA2 implies PSK for consumer
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WPA/PSK&quot;* || &quot;$full_description&quot; == *&quot;Sec: WPA&quot;* ]]; then security_type=&quot;PSK&quot; # WPA implies PSK
            elif [[ &quot;$full_description&quot; == *&quot;Sec: PSK&quot;* ]]; then security_type=&quot;PSK&quot;
            elif [[ &quot;$full_description&quot; == *&quot;Sec: WPA3&quot;* || &quot;$full_description&quot; == *&quot;Sec: SAE&quot;* ]]; then security_type=&quot;PSK&quot; # WPA3/SAE often needs PSK input method
            elif [[ &quot;$full_description&quot; == *&quot;Sec: Protected&quot;* &amp;&amp; &quot;$security_type&quot; == &quot;Unknown&quot; ]]; then security_type=&quot;PSK&quot; # Generic fallback
            fi; break
        fi
    done
    debug_basic &quot;Determined security type for &#39;$selected_ssid&#39;: $security_type&quot;

    wifi_password=&quot;&quot;
    if [ &quot;$security_type&quot; == &quot;PSK&quot; ] || [ &quot;$security_type&quot; == &quot;WEP&quot; ]; then
        exec 3&gt;&amp;1
        wifi_password=$(dialog --title &quot;Wi-Fi Password&quot; \
            --passwordbox &quot;Enter password for SSID &#39;$selected_ssid&#39; ($security_type):&quot; \
            10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
        exit_status=$?
        exec 3&gt;&amp;-
        debug_basic &quot;Password dialog exit: $exit_status&quot;
        if [ $exit_status -ne $DIALOG_SUCCESS_CODE ]; then
            log_warning &quot;Password entry cancelled. Cannot connect to $security_type network.&quot;; return 1
        fi
        # Allow empty password for WEP if user insists, though unlikely to work
        if [ &quot;$security_type&quot; == &quot;PSK&quot; ] &amp;&amp; [ -z &quot;$wifi_password&quot; ]; then
             log_warning &quot;Password cannot be empty for $security_type. Cannot connect.&quot;; return 1
        fi
    elif [ &quot;$security_type&quot; == &quot;Unknown&quot; ]; then # If security is still unknown, prompt
        dialog --title &quot;Unknown Security for $selected_ssid&quot; \
               --yesno &quot;Security type is Unknown. Attempt to provide a password (for WPA/WEP/PSK types) or connect as Open network?&quot; \
               12 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
        choice=$?
        if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then # User wants to provide password
            exec 3&gt;&amp;1
            wifi_password=$(dialog --title &quot;Wi-Fi Password&quot; \
                --passwordbox &quot;Enter password/key for SSID &#39;$selected_ssid&#39;:&quot; \
                10 ${DIALOG_INPUT_WIDTH} &quot;&quot; 2&gt;&amp;1 1&gt;&amp;3)
            exit_status=$?
            exec 3&gt;&amp;-
            [ $exit_status -ne $DIALOG_SUCCESS_CODE ] &amp;&amp; { log_warning &quot;Password entry cancelled.&quot;; return 1; }
            [ -n &quot;$wifi_password&quot; ] &amp;&amp; security_type=&quot;PSK&quot; || security_type=&quot;Open&quot; # Assume PSK if password provided
        else # User wants to try as Open, or cancelled
            security_type=&quot;Open&quot;
        fi
        debug_basic &quot;Security for &#39;Unknown&#39; network, after prompt: $security_type&quot;
    fi
    debug_var &quot;wifi_password&quot; # Be careful logging passwords, even to debug logs

    log_info_transient &quot;Attempting to connect to Wi-Fi: $selected_ssid on $iface (Security: $security_type)&quot;
    if $NM_IS_ACTIVE; then
        debug_verbose &quot;Using NetworkManager to connect to Wi-Fi.&quot;
        debug_exec &quot;nmcli device disconnect \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true; sleep 1 # Disconnect first
        
        # Delete existing connections for this SSID to avoid conflicts or using old passwords
        local old_profile_uuids
        old_profile_uuids=$(nmcli -g UUID,TYPE,NAME connection show 2&gt;/dev/null | grep -E &quot;wireless|802-11-wireless&quot; | grep &quot;:$selected_ssid$&quot; | cut -d&#39;:&#39; -f1 || true)
        if [ -n &quot;$old_profile_uuids&quot; ]; then
            echo &quot;$old_profile_uuids&quot; | while read -r uuid_to_delete; do
                info_log &quot;Deleting existing NM profile UUID $uuid_to_delete for SSID &#39;$selected_ssid&#39;.&quot;
                debug_exec &quot;nmcli connection delete uuid \&quot;$uuid_to_delete\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true
            done
        fi

        local connect_cmd_nmcli=(&quot;nmcli&quot; &quot;device&quot; &quot;wifi&quot; &quot;connect&quot; &quot;$selected_ssid&quot; &quot;ifname&quot; &quot;$iface&quot;)
        # Only add password if security type suggests it or if password is not empty (for &quot;Open&quot; with password attempts)
        if { [ &quot;$security_type&quot; != &quot;Open&quot; ] &amp;&amp; [ -n &quot;$wifi_password&quot; ]; } || \
           { [ &quot;$security_type&quot; == &quot;Open&quot; ] &amp;&amp; [ -n &quot;$wifi_password&quot; ]; }; then # Handles case where user forces password for &quot;Open&quot;
            connect_cmd_nmcli+=(&quot;password&quot; &quot;$wifi_password&quot;)
        fi
        # For WEP, nmcli might need specific syntax if &#39;password&#39; isn&#39;t enough.
        # if [ &quot;$security_type&quot; == &quot;WEP&quot; ]; then connect_cmd_nmcli+=(&quot;wep-key-type&quot; &quot;passphrase&quot;); fi # Example

        if debug_exec &quot;${connect_cmd_nmcli[@]}&quot;; then
            log_info_transient &quot;Successfully initiated Wi-Fi connection to $selected_ssid via NetworkManager.&quot;; sleep 5; return 0 
        else
            error_log &quot;Failed to connect to Wi-Fi $selected_ssid via NetworkManager.&quot;
            log_error &quot;NM Wi-Fi connection failed for &#39;$selected_ssid&#39;. Check password/security.&quot;; return 1
        fi
    else 
        # Manual connection using wpa_supplicant
        debug_verbose &quot;Using wpa_supplicant to connect to Wi-Fi.&quot;
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill &gt;/dev/null 2&gt;&amp;1 || true; sleep 0.5
        pgrep -af &quot;wpa_supplicant.*${iface}&quot; | awk &#39;{print $1}&#39; | xargs -r kill -9 &gt;/dev/null 2&gt;&amp;1 || true; sleep 1
        
        wpa_conf_temp=$(create_temp_file &quot;wpa_temp_${iface}&quot; &quot;conf&quot;)
        if [ $? -ne 0 ] || [ -z &quot;$wpa_conf_temp&quot; ]; then error_log &quot;Failed to create wpa_supplicant temp conf file.&quot;; return 1; fi

        # Basic wpa_supplicant configuration
        echo &quot;ctrl_interface=DIR=/run/wpa_supplicant GROUP=netdev&quot; &gt; &quot;$wpa_conf_temp&quot;
        echo &quot;update_config=1&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        echo -e &quot;\nnetwork={&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        echo &quot;    ssid=\&quot;$selected_ssid\&quot;&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        
        if [ &quot;$security_type&quot; == &quot;Open&quot; ] &amp;&amp; [ -z &quot;$wifi_password&quot; ]; then
            echo &quot;    key_mgmt=NONE&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        elif [ &quot;$security_type&quot; == &quot;WEP&quot; ]; then
            echo &quot;    key_mgmt=NONE&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            # Handle WEP key (hex or passphrase)
            if [[ &quot;$wifi_password&quot; =~ ^[0-9A-Fa-f]{10}$ || &quot;$wifi_password&quot; =~ ^[0-9A-Fa-f]{26}$ ]]; then # Hex key
                echo &quot;    wep_key0=$wifi_password&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            elif [[ &quot;${#wifi_password}&quot; -eq 5 || &quot;${#wifi_password}&quot; -eq 13 ]]; then # ASCII passphrase
                echo &quot;    wep_key0=\&quot;$wifi_password\&quot;&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            else
                error_log &quot;Invalid WEP key format for &#39;$selected_ssid&#39;. Expected 5/13 ASCII or 10/26 HEX chars.&quot;; 
                log_error &quot;Invalid WEP key format.&quot;; return 1
            fi
            echo &quot;    wep_tx_keyidx=0&quot; &gt;&gt; &quot;$wpa_conf_temp&quot; # Default WEP key index
        else # Assume PSK (WPA/WPA2/WPA3-SAE)
            echo &quot;    psk=\&quot;$wifi_password\&quot;&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
            # For WPA3-SAE, you might need: key_mgmt=SAE or WPA-PSK SAE
            # if [[ &quot;$security_type_from_scan&quot; == &quot;WPA3&quot; ]]; then echo &quot;    key_mgmt=SAE&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;; fi
        fi
        echo &quot;}&quot; &gt;&gt; &quot;$wpa_conf_temp&quot;
        chmod 600 &quot;$wpa_conf_temp&quot; # wpa_supplicant requires restricted permissions
        debug_full &quot;wpa_supplicant config file $wpa_conf_temp content:\n$(cat &quot;$wpa_conf_temp&quot;)&quot;

        # Start wpa_supplicant in background
        # -Dnl80211,wext are common drivers, nl80211 is preferred
        if ! debug_exec &quot;wpa_supplicant -B -i \&quot;$iface\&quot; -c \&quot;$wpa_conf_temp\&quot; -Dnl80211,wext&quot;; then
            error_log &quot;Failed to start wpa_supplicant for $iface.&quot;; return 1
        fi
        log_info_transient &quot;wpa_supplicant started. Waiting for association with $selected_ssid...&quot;
        connect_tries=20 # Wait up to 20 seconds for association
        while [ $connect_tries -gt 0 ]; do
            if wpa_cli -i &quot;$iface&quot; status 2&gt;/dev/null | grep -q &quot;wpa_state=COMPLETED&quot;; then
                log_info_transient &quot;Associated with $selected_ssid via wpa_supplicant.&quot;; break
            fi
            sleep 1; connect_tries=$((connect_tries - 1))
            debug_verbose &quot;wpa_supplicant association tries left for $selected_ssid: $connect_tries&quot;
        done
        if [ $connect_tries -eq 0 ]; then
            error_log &quot;Failed to associate with $selected_ssid via wpa_supplicant (timeout).&quot;
            log_error &quot;wpa_supplicant association timed out for &#39;$selected_ssid&#39;.&quot;
            # Kill the lingering wpa_supplicant process
            pgrep -af &quot;wpa_supplicant -B -i $iface -c $wpa_conf_temp&quot; | awk &#39;{print $1}&#39; | xargs -r kill -9 &gt;/dev/null 2&gt;&amp;1 || true
            return 1
        fi
    fi 

    # If not using NetworkManager (which handles DHCP itself), run dhclient
    if ! $NM_IS_ACTIVE; then
        log_info_transient &quot;Wi-Fi associated ($selected_ssid). Attempting DHCP on $iface...&quot;
        debug_exec &quot;dhclient -r \&quot;$iface\&quot;&quot; &gt;/dev/null 2&gt;&amp;1 || true # Release old lease
        
        local dhclient_wifi_log
        dhclient_wifi_log=$(create_temp_file &quot;dhclient_wifi_${iface}&quot; &quot;log&quot;)
        [ $? -ne 0 ] &amp;&amp; { error_log &quot;Failed to create dhclient log file.&quot;; dhclient_wifi_log=&quot;/dev/null&quot;; }

        if debug_exec &quot;timeout 30 dhclient -v \&quot;$iface\&quot;&quot; &gt;&quot;$dhclient_wifi_log&quot; 2&gt;&amp;1; then
            log_info_transient &quot;dhclient successfully obtained lease on $iface for $selected_ssid.&quot;
            debug_full &quot;dhclient log for $iface (Wi-Fi):\n$(cat &quot;$dhclient_wifi_log&quot;)&quot;; sleep 2; return 0
        else 
            warning_log &quot;dhclient failed or timed out for &#39;$selected_ssid&#39; on $iface. Log: $dhclient_wifi_log&quot;
            debug_full &quot;dhclient log for $iface (Wi-Fi) on failure:\n$(cat &quot;$dhclient_wifi_log&quot;)&quot;
            
            # Offer static IP configuration if DHCP fails
            dialog --title &quot;Wi-Fi IP Configuration: $selected_ssid&quot; \
                   --yesno &quot;DHCP failed for &#39;$selected_ssid&#39; on $iface.\\nDo you want to configure a static IP for this Wi-Fi connection?&quot; \
                   ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
            choice=$?
            if [ $choice -eq $DIALOG_SUCCESS_CODE ]; then
                static_config_str=$(prompt_static_config &quot;Wi-Fi ($selected_ssid)&quot;)
                exit_status=$?
                [ $exit_status -ne 0 ] &amp;&amp; return 1 # User cancelled static config

                IFS=&#39;:&#39; read -r static_ip_cidr gw dns_val &lt;&lt;&lt; &quot;$static_config_str&quot;
                log_info_transient &quot;Configuring static IP for Wi-Fi $iface ($selected_ssid): IP=$static_ip_cidr, GW=$gw, DNS=${dns_val:-Not set}&quot;
                
                debug_exec &quot;ip addr flush dev \&quot;$iface\&quot;&quot; || true
                if ! debug_exec &quot;ip link set \&quot;$iface\&quot; up&quot;; then log_warning &quot;Failed to bring $iface up for static Wi-Fi.&quot;; return 1; fi
                if debug_exec &quot;ip addr add \&quot;$static_ip_cidr\&quot; dev \&quot;$iface\&quot;&quot;; then
                    sleep 2 
                    debug_exec &quot;ip route del default dev \&quot;$iface\&quot;&quot; 2&gt;/dev/null || true
                    if debug_exec &quot;ip route add default via \&quot;$gw\&quot; dev \&quot;$iface\&quot;&quot;; then
                        log_info_transient &quot;iproute2 configured static IP for Wi-Fi $iface ($selected_ssid).&quot;
                        if [ -n &quot;$dns_val&quot; ]; then
                            resolv_conf_content_wifi=&quot;&quot;
                            IFS=&#39;,&#39; read -ra dns_array_wifi &lt;&lt;&lt; &quot;$dns_val&quot;
                            for dns_entry in &quot;${dns_array_wifi[@]}&quot;; do 
                                dns_entry_trimmed=$(echo &quot;$dns_entry&quot; | awk &#39;{$1=$1};1&#39;)
                                resolv_conf_content_wifi+=&quot;nameserver $dns_entry_trimmed\n&quot;
                            done
                            if [ -L /etc/resolv.conf ] &amp;&amp; ! command -v resolvconf &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ! command -v systemd-resolve &gt;/dev/null 2&gt;&amp;1; then
                                 warning_log &quot;/etc/resolv.conf is a symlink. Overwriting for DNS may be temporary.&quot;
                                 log_warning &quot;/etc/resolv.conf is a symlink. DNS set via script might be overridden.&quot;
                            fi
                            echo -e &quot;$resolv_conf_content_wifi&quot; &gt; /etc/resolv.conf
                            info_log &quot;Configured DNS servers for Wi-Fi $iface in /etc/resolv.conf: $dns_val&quot;
                        fi
                        return 0
                    else error_log &quot;Failed to add default route for static Wi-Fi on $iface.&quot;; return 1; fi
                else error_log &quot;Failed to add IP address for static Wi-Fi on $iface.&quot;; return 1; fi
            else 
                log_info_persistent &quot;Static IP configuration for Wi-Fi &#39;$selected_ssid&#39; skipped by user.&quot;; return 1;
            fi 
        fi 
    fi 
    debug_basic &quot;Wi-Fi connection attempt for &#39;$selected_ssid&#39; on $iface concluded.&quot;; return 1 # Fallthrough if NM handled DHCP or other cases
}

handle_wifi_connection() {
    local select_exit_status rfkill_idx rfkill_output
    debug_basic &quot;Handling Wi-Fi connection. Detected interfaces: ${#WIFI_IFACES[@]}&quot;
    if [ ${#WIFI_IFACES[@]} -eq 0 ]; then
        log_warning &quot;No Wi-Fi interfaces detected. Skipping Wi-Fi setup.&quot;; return 1
    fi

    SELECTED_WIFI_IFACE=$(prompt_select_interface &quot;Wi-Fi&quot; &quot;${WIFI_IFACES[@]}&quot;)
    select_exit_status=$?
    debug_basic &quot;Wi-Fi interface selection: exit_status=$select_exit_status, SELECTED_WIFI_IFACE=&#39;$SELECTED_WIFI_IFACE&#39;&quot;
    [ $select_exit_status -ne 0 ] &amp;&amp; return 1
    [ -z &quot;$SELECTED_WIFI_IFACE&quot; ] &amp;&amp; { log_warning &quot;No Wi-Fi interface was actually selected.&quot;; return 1; }

    # Check rfkill status
    if check_command rfkill; then
        # Get rfkill output: ID DEVICE TYPE SOFT HARD
        rfkill_output=$(debug_exec &quot;rfkill list wifi -n -o ID,DEVICE,SOFT,HARD&quot;)
        # Find the ID for the selected interface
        rfkill_idx=$(echo &quot;$rfkill_output&quot; | grep -w &quot;$SELECTED_WIFI_IFACE&quot; | awk &#39;{print $1}&#39; || true)
        debug_verbose &quot;rfkill_idx for $SELECTED_WIFI_IFACE: &#39;$rfkill_idx&#39;&quot;

        if [ -n &quot;$rfkill_idx&quot; ]; then 
            # Check soft block: field 3 (SOFT) for the given ID
            if echo &quot;$rfkill_output&quot; | awk -v id=&quot;$rfkill_idx&quot; &#39;$1 == id &amp;&amp; $3 == &quot;blocked&quot; {print &quot;softblocked&quot;}&#39; | grep -q &quot;softblocked&quot;; then 
                dialog --title &quot;Wi-Fi Soft Blocked&quot; \
                       --yesno &quot;$SELECTED_WIFI_IFACE (rfkill ID $rfkill_idx) is soft-blocked. Attempt to unblock?&quot; \
                       10 ${DIALOG_DEFAULT_WIDTH} 2&gt;/dev/tty
                if [ $? -eq $DIALOG_SUCCESS_CODE ]; then
                    if debug_exec &quot;rfkill unblock $rfkill_idx&quot;; then
                        log_info_persistent &quot;$SELECTED_WIFI_IFACE (ID $rfkill_idx) unblocked.&quot;; sleep 1
                    else log_warning &quot;Failed to unblock $SELECTED_WIFI_IFACE (ID $rfkill_idx).&quot;; fi
                fi
            fi
            # Check hard block: field 4 (HARD) for the given ID
            if echo &quot;$rfkill_output&quot; | awk -v id=&quot;$rfkill_idx&quot; &#39;$1 == id &amp;&amp; $4 == &quot;blocked&quot; {print &quot;hardblocked&quot;}&#39; | grep -q &quot;hardblocked&quot; ; then 
                error_log &quot;$SELECTED_WIFI_IFACE (ID $rfkill_idx) is hard-blocked (hardware switch).&quot;
                log_error &quot;$SELECTED_WIFI_IFACE (ID $rfkill_idx) is hard-blocked by a physical switch. Cannot proceed with this interface.&quot;; return 1
            fi
        fi
    fi

    if connect_wifi &quot;$SELECTED_WIFI_IFACE&quot;; then return 0; fi 
    
    log_warning &quot;Wi-Fi connection on $SELECTED_WIFI_IFACE failed or was cancelled.&quot;; return 1
}

# --- Main Script Logic ---
main() {
    # Handle --debug argument first
    if [[ &quot;$1&quot; == &quot;--debug&quot; ]]; then
        DBG=true
        DEBUG_LEVEL=3 
        DEBUG_LOG_FILE=&quot;/tmp/universal_net_connect_$(date +%Y%m%d_%H%M%S)_$$.log&quot;
        # Initialize xtrace logging to file descriptor $XTRACE_FD
        # This must be done before `set -x`
        # Ensure the FD is available and not used by dialog&#39;s redirections later
        # Using a temporary file for xtrace and then appending to main log might be safer
        # For now, direct redirection. Ensure $XTRACE_FD is high enough (e.g., 6, 7, 8, 9).
        eval &quot;exec $XTRACE_FD&gt;&gt;\&quot;\$DEBUG_LOG_FILE\&quot;&quot;
        export BASH_XTRACEFD=&quot;$XTRACE_FD&quot; # Tell Bash to use this FD for xtrace
        set -x # Start xtrace
        info_log &quot;Debug mode activated. Log file: $DEBUG_LOG_FILE. DEBUG_LEVEL=$DEBUG_LEVEL. Xtrace on FD $XTRACE_FD.&quot;
        shift # Consume the --debug argument
    elif [ -n &quot;$DEBUG_LOG_FILE_ENV&quot; ]; then # Allow setting log file via environment
        DEBUG_LOG_FILE=&quot;$DEBUG_LOG_FILE_ENV&quot;; DBG=true 
        info_log &quot;Logging to ENV specified file: $DEBUG_LOG_FILE. DEBUG_LEVEL=$DEBUG_LEVEL.&quot;
    fi

    info_log &quot;Universal Network Connectivity Script v3.1 started. UID: $(id -u)&quot;
    if [ &quot;$(id -u)&quot; -ne 0 ]; then
        error_log &quot;Script not run as root.&quot;
        # Avoid dialog here as it might not be installed yet
        echo &quot;This script must be run as root. Please use &#39;sudo $0&#39;&quot; &gt;&amp;2; exit 1
    fi
    debug_basic &quot;Running as root.&quot;

    # Install dialog first as it&#39;s crucial for user interaction
    install_packages &quot;dialog,dialog&quot; 
    # Then other packages
    install_packages &quot;ip,iproute2&quot; &quot;ping,iputils-ping&quot; &quot;nmcli,network-manager&quot; \
                     &quot;wpa_cli,wpasupplicant&quot; &quot;wpa_supplicant,wpasupplicant&quot; \
                     &quot;dhclient,isc-dhcp-client&quot; &quot;iw,iw&quot; &quot;iwlist,wireless-tools&quot; \
                     &quot;rfkill,rfkill&quot; &quot;timeout,coreutils&quot; &quot;awk,gawk&quot; 

    detect_ethernet_interfaces
    detect_wifi_interfaces
    check_network_manager_active 

    if check_internet_connectivity; then
        info_log &quot;Internet connection already active. Exiting.&quot;; exit 0 
    fi
    log_info_persistent &quot;No active internet connection detected. Starting configuration process...&quot;

    local options=() main_choice main_dialog_exit_status
    while true; do
        options=() 
        [ ${#ETH_IFACES[@]} -gt 0 ] &amp;&amp; options+=(&quot;ETH&quot; &quot;Configure Ethernet Connection&quot;)
        [ ${#WIFI_IFACES[@]} -gt 0 ] &amp;&amp; options+=(&quot;WIFI&quot; &quot;Configure Wi-Fi Connection&quot;)
        
        if [ $((${#ETH_IFACES[@]} + ${#WIFI_IFACES[@]})) -eq 0 ]; then
            log_error &quot;No usable network interfaces (Ethernet or Wi-Fi) were detected. Cannot proceed.&quot;; exit 1
        fi
        
        options+=(&quot;CHECK&quot; &quot;Re-check Internet Connectivity&quot;)
        debug_verbose &quot;Main menu options: ${options[*]}&quot;

        exec 3&gt;&amp;1
        main_choice=$(dialog --title &quot;Main Menu - Universal Network Connector&quot; \
            --cancel-label &quot;Exit Script&quot; \
            --menu &quot;Select an action:&quot; ${DIALOG_DEFAULT_HEIGHT} ${DIALOG_DEFAULT_WIDTH} $((${#options[@]}/2)) \
            &quot;${options[@]}&quot; 2&gt;&amp;1 1&gt;&amp;3)
        main_dialog_exit_status=$?
        exec 3&gt;&amp;-
        debug_basic &quot;Main menu dialog: exit_status=$main_dialog_exit_status, choice_tag=&#39;$main_choice&#39;&quot;
        
        if [ $main_dialog_exit_status -ne $DIALOG_SUCCESS_CODE ]; then 
            log_info_persistent &quot;Exiting script as per user request from main menu.&quot;; break 
        fi
        [ -z &quot;$main_choice&quot; ] &amp;&amp; { log_warning &quot;No option selected from main menu. Please try again.&quot;; continue; }

        case &quot;$main_choice&quot; in
            ETH)
                if [ ${#ETH_IFACES[@]} -eq 0 ]; then log_warning &quot;No Ethernet interfaces available.&quot;; continue; fi
                if handle_ethernet_connection; then 
                    if check_internet_connectivity; then exit 0; fi 
                else log_info_persistent &quot;Ethernet configuration did not result in a connection or was cancelled.&quot;; fi
                ;;
            WIFI)
                if [ ${#WIFI_IFACES[@]} -eq 0 ]; then log_warning &quot;No Wi-Fi interfaces available.&quot;; continue; fi
                if handle_wifi_connection; then 
                    if check_internet_connectivity; then exit 0; fi
                else log_info_persistent &quot;Wi-Fi configuration did not result in a connection or was cancelled.&quot;; fi
                ;;
            CHECK) if check_internet_connectivity; then exit 0; fi ;;
            *) log_warning &quot;Invalid choice &#39;$main_choice&#39; from main menu. This should not happen.&quot; ;;
        esac
    done
    info_log &quot;Exited main loop. Script finished.&quot;
    exit 1 # Exit with 1 if loop is broken without successful connection
}

# Pass all script arguments to main
main &quot;$@&quot;</code>
</section>

        </div>
        
          URL: https://ib.bsb.br/internet4linux
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/infinite-tool-use/" title="Infinite tool use" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/network-diag/" title="network diag" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts>bash"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts-bash" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/network-diag/" title="network diag" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-05-26 23:45:14
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scripts-bash">
                  scripts>bash
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/internet4linux/"
        },
        "headline": "Internet Connectivity Solution for linux",
        "description": "",
        "datePublished": "2025-05-26T00:00:00+00:00",
        "dateModified": "2025-05-27T00:38:51+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
