<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Portable linux via Sbnb distro with persistence - infoBAG
      
    </title>
    <meta name="title" content="Portable linux via Sbnb distro with persistence - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/sbnb/">
    <meta property="og:title" content="Portable linux via Sbnb distro with persistence - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/sbnb/">
    <meta name="twitter:title" content="Portable linux via Sbnb distro with persistence - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/sbnb/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="linux&gt;software&gt;dotfile">
      
        <meta property="article:tag" content="linux&gt;software&gt;dotfile">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Portable linux via Sbnb distro with persistence
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-04-07T00:00:00+00:00" class="post-date">
          07 Apr 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-05-01T19:49:12+00:00">
              01 May 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/sbnb" class="tag">sbnb</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#linux-software-dotfile" class="tag">linux>software>dotfile</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        83581 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        10036 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-04-07-sbnb.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-04-07-sbnb.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#-extreme-caution-irreversible-data-destruction-imminent-"><strong>***** EXTREME CAUTION: IRREVERSIBLE DATA DESTRUCTION IMMINENT! *****</strong></a></li></ul>
          <p>This guide provides comprehensive, step-by-step instructions for configuring a single USB flash drive (or potentially an external USB hard drive) to perform two distinct functions simultaneously:</p>

<ol>
  <li><strong>Booting the Sbnb Linux Operating System:</strong> The drive will be prepared with a standard UEFI-compatible structure, specifically an EFI System Partition (ESP) containing the Sbnb EFI bootloader (<code class="language-plaintext highlighter-rouge">sbnb.efi</code>) and necessary configuration files. This allows the server’s firmware to locate and start the Sbnb boot process. The <code class="language-plaintext highlighter-rouge">sbnb.efi</code> file itself is typically a Unified Kernel Image (UKI), bundling the Linux kernel, initramfs, and kernel command line into a single executable file.</li>
  <li><strong>Providing Simple Persistent Storage:</strong> Utilizing a separate partition on the same physical USB drive, formatted with a standard Linux filesystem (<code class="language-plaintext highlighter-rouge">ext4</code> is used in this guide). This partition is intended to be automatically mounted at the <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> directory path within the running Sbnb Linux system via a custom boot script (<code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>). This provides a space where data (like container volumes, application data, logs, user files) can persist across reboots of the otherwise ephemeral, RAM-based Sbnb OS.</li>
</ol>

<p><strong>Why <code class="language-plaintext highlighter-rouge">ext4</code> instead of LVM:</strong> Initial analysis suggested LVM might be suitable, but further review of the default Sbnb Linux build configuration indicates the necessary <code class="language-plaintext highlighter-rouge">lvm2</code> user-space tools are likely missing from the base runtime environment. Without these tools, managing LVM volumes during boot via standard scripts is infeasible unless you create a custom Sbnb build that includes the <code class="language-plaintext highlighter-rouge">lvm2</code> package. This revised guide therefore uses a standard <code class="language-plaintext highlighter-rouge">ext4</code> filesystem partition, relying only on basic tools expected to be present in Sbnb.</p>

<p><strong>Contrasting with Standard Sbnb Workflow:</strong> It’s crucial to understand that this guide describes a highly non-standard setup. The intended Sbnb workflow prioritizes resilience, performance, and statelessness:</p>

<ul>
  <li>Boot the minimal Sbnb OS from simple USB/network.</li>
  <li>Use automation (Ansible) or manual scripts (<code class="language-plaintext highlighter-rouge">sbnb-configure-storage.sh</code>) post-boot to configure LVM on internal server drives.</li>
  <li>Run workloads utilizing this fast, reliable internal storage. This guide’s method compromises these benefits for single-drive convenience under specific constraints.</li>
</ul><hr />

<blockquote>
  <h5 id="-extreme-caution-irreversible-data-destruction-imminent-">
    
    
     <a href="#-extreme-caution-irreversible-data-destruction-imminent-">#</a><a href="#" aria-label="Back to top"><strong>***** EXTREME CAUTION: IRREVERSIBLE DATA DESTRUCTION IMMINENT! *****</strong></a>
        
    
  </h5>
      

  <p>This procedure involves low-level disk operations (partitioning, formatting) that will completely and <strong>PERMANENTLY ERASE ALL DATA</strong> currently residing on the USB drive you select. There is <strong>NO UNDO</strong> function. Data recovery after accidental formatting is often impossible.</p>

  <p>The most critical risk is selecting the <strong>wrong target device</strong>. Mistakenly choosing your computer’s internal hard drive (e.g., <code class="language-plaintext highlighter-rouge">/dev/sda</code>, <code class="language-plaintext highlighter-rouge">/dev/nvme0n1</code>) instead of the intended USB drive (e.g., <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, <code class="language-plaintext highlighter-rouge">/dev/sdc</code>) <strong>WILL RESULT IN CATASTROPHIC AND LIKELY IRRECOVERABLE LOSS OF YOUR OPERATING SYSTEM, APPLICATIONS, AND PERSONAL FILES.</strong></p>

  <p>You <strong>MUST</strong> verify the target device name multiple times using different commands (like <code class="language-plaintext highlighter-rouge">lsblk</code>, <code class="language-plaintext highlighter-rouge">fdisk</code>, <code class="language-plaintext highlighter-rouge">parted</code>) and cross-reference with expected drive sizes and models before executing any partitioning or formatting commands. Proceed with extreme vigilance, double-checking each step, entirely at your own sole risk!</p>
</blockquote><hr />
  <h2 id="primary-drawbacks--warnings-reiterated--expanded">
    
    
     <a href="#primary-drawbacks--warnings-reiterated--expanded">#</a><a href="#" aria-label="Back to top">Primary Drawbacks &amp; Warnings (Reiterated &amp; Expanded):</a>
        
    
  </h2>
      

<ul>
  <li><strong>Highly Non-Standard &amp; Complex:</strong> Deviates significantly from Sbnb’s design. Setup is intricate, runtime behavior depends on precise script execution and timing. Future Sbnb updates might break this.</li>
  <li><strong>Severe Performance Penalty:</strong> USB storage is inherently slow (latency, throughput, IOPS) compared to internal NVMe/SATA drives. Disk I/O to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> will be a major bottleneck.</li>
  <li><strong>Drastically Reduced Lifespan &amp; Reliability:</strong> USB flash drives will wear out quickly under persistent write load due to limited write cycles, write amplification, and lack of TRIM support. Unsuitable for write-intensive workloads or high reliability needs. Expect eventual failure and data loss without robust backups.</li>
  <li><strong>Potential Instability &amp; Boot Issues:</strong> Relies on correct partition detection, udev node creation, filesystem integrity, and <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> execution timing. Failures can leave persistent storage unavailable.</li>
</ul>
  <h3 id="when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">
    
    
     <a href="#when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">#</a><a href="#" aria-label="Back to top">When Might This Be Considered? (Limited Scenarios with Full Risk Acceptance)</a>
        
    
  </h3>
      

<ul>
  <li><strong>Temporary Testing/Experimentation ONLY:</strong> Brief evaluations on hardware lacking internal drives.</li>
  <li><strong>Specific, Very Low-Intensity, Read-Mostly Use Cases:</strong> Infrequent writes, performance irrelevant (e.g., static config kiosk).</li>
  <li><strong>Absolute Hardware Constraints:</strong> Sealed systems where internal drives are impossible, and risks are fully accepted.</li>
</ul>

<p><em>Even in these limited scenarios, regular, automated, and verified backups are non-negotiable.</em></p>
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<ul>
  <li><strong>A Suitable USB Flash Drive:</strong>
    <ul>
      <li><strong>Capacity:</strong> Min ~1GB ESP + desired data size (32GB+ recommended).</li>
      <li><strong>Quality &amp; Speed:</strong> Reputable brand, USB 3.0+ advised for marginal speed benefit. Endurance matters more than peak speed.</li>
    </ul>
  </li>
  <li><strong>A Working Linux System (Preparation Environment):</strong>
    <ul>
      <li><strong>Necessity:</strong> Required for partitioning/formatting the target USB safely. openSUSE Tumbleweed assumed.</li>
      <li><strong>Live Environment Benefit:</strong> Using a Live USB/CD (e.g., openSUSE Tumbleweed Live) is highly recommended as it provides a non-destructive environment.</li>
    </ul>
  </li>
  <li><strong>Sbnb Linux Boot File (<code class="language-plaintext highlighter-rouge">sbnb.efi</code>):</strong>
    <ul>
      <li><strong>Method 1 (Easier):</strong> Run official Sbnb install script on a temporary USB, then copy <code class="language-plaintext highlighter-rouge">/EFI/BOOT/BOOTX64.EFI</code> from its ESP.</li>
      <li><strong>Method 2 (Advanced):</strong> Build Sbnb from source, find <code class="language-plaintext highlighter-rouge">sbnb.efi</code> in <code class="language-plaintext highlighter-rouge">output/images/</code>.</li>
    </ul>
  </li>
  <li><strong>Root/Sudo Privileges:</strong> Needed on the openSUSE prep system for disk commands.</li>
  <li><strong>Internet Connection:</strong> May be needed for <code class="language-plaintext highlighter-rouge">zypper</code>.</li>
</ul>
  <h2 id="step-by-step-instructions">
    
    
     <a href="#step-by-step-instructions">#</a><a href="#" aria-label="Back to top">Step-by-Step Instructions</a>
        
    
  </h2>
      

<p><em>(Reminder: TRIPLE-CHECK your target device name, e.g., <code class="language-plaintext highlighter-rouge">/dev/sdX</code>, before every destructive command!)</em></p>
  <h3 id="phase-1-prepare-the-linux-environment-opensuse-tumbleweed">
    
    
     <a href="#phase-1-prepare-the-linux-environment-opensuse-tumbleweed">#</a><a href="#" aria-label="Back to top">Phase 1: Prepare the Linux Environment (openSUSE Tumbleweed)</a>
        
    
  </h3>
      

<ol>
  <li><strong>Boot into openSUSE:</strong> Start your preparation environment.</li>
  <li><strong>Install Necessary Tools:</strong> Open a terminal. <code class="language-plaintext highlighter-rouge">zypper refresh</code> updates package lists. <code class="language-plaintext highlighter-rouge">zypper install</code> installs tools.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">sudo </span>zypper refresh
<span class="nb">sudo </span>zypper <span class="nb">install</span> <span class="nt">-y</span> parted lvm2 dosfstools e2fsprogs
</code></section></div>    </div>
  </li>
  <li><strong>Identify Target USB Drive:</strong> <strong>CRITICAL SAFETY STEP!</strong> Unplug other USB storage.
    <ul>
      <li>Insert the target USB drive.</li>
      <li>Use multiple commands. Compare SIZE and MODEL. Check <code class="language-plaintext highlighter-rouge">dmesg | tail</code> after plugging in for kernel messages like <code class="language-plaintext highlighter-rouge">sd 2:0:0:0: [sdc] Attached SCSI removable disk</code>.
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>lsblk <span class="nt">-d</span> <span class="nt">-o</span> NAME,SIZE,MODEL,VENDOR,TYPE | <span class="nb">grep</span> <span class="s1">'disk'</span>
<span class="nb">sudo </span>fdisk <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s1">'^Disk /dev/'</span>
<span class="nb">sudo </span>parted <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s1">'^Disk /dev/'</span>
<span class="c"># Example: If consistently identified as /dev/sdc, use /dev/sdc below.</span>
</code></section></div>        </div>
      </li>
      <li>Visually confirm with YaST Partitioner (<code class="language-plaintext highlighter-rouge">sudo yast2 partitioner</code>) or GParted (<code class="language-plaintext highlighter-rouge">sudo zypper install -y gparted &amp;&amp; sudo gparted</code>) if preferred. Look for the drive matching the expected size and vendor/model.</li>
      <li>Assume <code class="language-plaintext highlighter-rouge">/dev/sdX</code> is your verified target drive. <strong>Replace it carefully!</strong></li>
    </ul>
  </li>
</ol>
  <h3 id="phase-2-partition-the-usb-drive">
    
    
     <a href="#phase-2-partition-the-usb-drive">#</a><a href="#" aria-label="Back to top">Phase 2: Partition the USB Drive</a>
        
    
  </h3>
      

<p><strong>(Warning: The following <code class="language-plaintext highlighter-rouge">parted</code> commands are DESTRUCTIVE to <code class="language-plaintext highlighter-rouge">/dev/sdX</code>. Double-check the device name!)</strong></p>

<p>This script automates the partitioning and formatting process. Save it as <code class="language-plaintext highlighter-rouge">prepare_usb.sh</code>, make it executable (<code class="language-plaintext highlighter-rouge">chmod +x prepare_usb.sh</code>), and run it with <code class="language-plaintext highlighter-rouge">sudo ./prepare_usb.sh /dev/sdX</code> (replacing <code class="language-plaintext highlighter-rouge">/dev/sdX</code> with your verified target device).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/bash</span>

<span class="c"># --- Configuration ---</span>
<span class="c"># Exit immediately if a command exits with a non-zero status.</span>
<span class="c"># Treat unset variables as an error when substituting.</span>
<span class="c"># Pipelines return the exit status of the last command to exit non-zero.</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="c"># --- Variables ---</span>
<span class="c"># EFI System Partition (ESP) Label (CRITICAL - must match bootloader config)</span>
<span class="nv">ESP_LABEL</span><span class="o">=</span><span class="s2">"sbnb"</span>
<span class="c"># Data Partition Label (Recommended for identification)</span>
<span class="nv">DATA_LABEL</span><span class="o">=</span><span class="s2">"SBNB_DATA"</span>
<span class="c"># ESP Size (Adjust if needed, ~1GB is usually sufficient)</span>
<span class="nv">ESP_SIZE</span><span class="o">=</span><span class="s2">"1025MiB"</span>
<span class="c"># List of required commands for the script to function</span>
<span class="nv">REQUIRED_CMDS</span><span class="o">=(</span>
  <span class="s2">"parted"</span> <span class="s2">"mkfs.vfat"</span> <span class="s2">"mkfs.ext4"</span> <span class="s2">"wipefs"</span> <span class="s2">"findmnt"</span> <span class="s2">"lsblk"</span>
  <span class="s2">"blkid"</span> <span class="s2">"fsck.vfat"</span> <span class="s2">"e2fsck"</span> <span class="s2">"sync"</span> <span class="s2">"id"</span> <span class="s2">"grep"</span> <span class="s2">"read"</span>
  <span class="s2">"sleep"</span> <span class="s2">"xargs"</span> <span class="s2">"umount"</span> <span class="s2">"partprobe"</span> <span class="s2">"realpath"</span>
<span class="o">)</span>

<span class="c"># --- Functions ---</span>
<span class="c"># Function to check for required commands</span>
check_dependencies<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">"--- Checking for required commands ---"</span>
  <span class="nb">local </span><span class="nv">missing_cmds</span><span class="o">=()</span>
  <span class="k">for </span>cmd <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">REQUIRED_CMDS</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span> &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
      </span>missing_cmds+<span class="o">=(</span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span><span class="o">)</span>
    <span class="k">fi
  done

  if</span> <span class="o">[</span> <span class="k">${#</span><span class="nv">missing_cmds</span><span class="p">[@]</span><span class="k">}</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ERROR: The following required commands are not found:"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">printf</span> <span class="s2">" - %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">missing_cmds</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"Please install them and try again."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
  <span class="k">fi
  </span><span class="nb">echo</span> <span class="s2">"All required commands found."</span>
<span class="o">}</span>

<span class="c"># Function to get the base block device for a given path (handles partitions, links, etc.)</span>
get_base_device<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="nb">local </span>resolved_path
  <span class="nv">resolved_path</span><span class="o">=</span><span class="si">$(</span><span class="nb">realpath</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">"ERROR: Cannot resolve path '</span><span class="nv">$path</span><span class="s2">'"</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
  <span class="c"># lsblk -no pkname gets the parent kernel name (base device)</span>
  lsblk <span class="nt">-no</span> pkname <span class="s2">"</span><span class="nv">$resolved_path</span><span class="s2">"</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">"ERROR: Cannot find base device for '</span><span class="nv">$resolved_path</span><span class="s2">' using lsblk."</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c"># --- Script Start ---</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">"--- USB Drive Partitioning and Formatting Script ---"</span>
<span class="nb">echo</span> <span class="s2">"---  (Version 2 - Enhanced Safety)      ---"</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"WARNING: This script is DESTRUCTIVE and will ERASE"</span>
<span class="nb">echo</span> <span class="s2">" ALL DATA on the target device."</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="c"># --- Check for Root Privileges ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span><span class="s2">"</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: This script must be run as root (e.g., using sudo)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># --- Check Dependencies ---</span>
check_dependencies

<span class="c"># --- Check for Device Argument ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="k">:-}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$0</span><span class="s2"> /dev/sdX"</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: Please provide the target block device (e.g., /dev/sda, /dev/sdb)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">""</span>
  <span class="nb">echo</span> <span class="s2">"Available block devices (excluding ROM, loop, and RAM devices):"</span>
  lsblk <span class="nt">-d</span> <span class="nt">-o</span> NAME,SIZE,TYPE,MODEL | <span class="nb">grep</span> <span class="nt">-vE</span> <span class="s1">'rom|loop|ram'</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">DEVICE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>

<span class="c"># --- Validate Device ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: '</span><span class="nv">$DEVICE</span><span class="s2">' is not a valid block device."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># --- CRITICAL SAFETY CHECK: Prevent targeting the root filesystem device ---</span>
<span class="nb">echo</span> <span class="s2">"--- Performing safety checks ---"</span>
<span class="nv">ROOT_DEV_PATH</span><span class="o">=</span><span class="si">$(</span>findmnt <span class="nt">-n</span> <span class="nt">-o</span> SOURCE /<span class="si">)</span>
<span class="nv">ROOT_BASE_DEV_NAME</span><span class="o">=</span><span class="si">$(</span>get_base_device <span class="s2">"</span><span class="nv">$ROOT_DEV_PATH</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit </span>1 <span class="c"># Exit if function fails</span>
<span class="nv">TARGET_BASE_DEV_NAME</span><span class="o">=</span><span class="si">$(</span>get_base_device <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit </span>1

<span class="c"># Construct full device paths for comparison</span>
<span class="nv">ROOT_BASE_DEV</span><span class="o">=</span><span class="s2">"/dev/</span><span class="k">${</span><span class="nv">ROOT_BASE_DEV_NAME</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">TARGET_BASE_DEV</span><span class="o">=</span><span class="s2">"/dev/</span><span class="k">${</span><span class="nv">TARGET_BASE_DEV_NAME</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Assumes the input $DEVICE is the base device</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$TARGET_BASE_DEV</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"FATAL ERROR: Target device '</span><span class="nv">$DEVICE</span><span class="s2">' appears to be the same"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">" device ('</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">') as the running root"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">" filesystem ('</span><span class="nv">$ROOT_DEV_PATH</span><span class="s2">')."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">" Aborting to prevent data loss."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi
</span><span class="nb">echo</span> <span class="s2">"Safety check passed: Target device '</span><span class="nv">$DEVICE</span><span class="s2">' is not the root filesystem device ('</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">')."</span>

<span class="c"># Check if the device looks like an SD card reader often used for the OS drive</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">==</span> /dev/mmcblk<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"WARNING: '</span><span class="nv">$DEVICE</span><span class="s2">' looks like an SD card (e.g., /dev/mmcblk0)."</span>
  <span class="nb">echo</span> <span class="s2">" Double-check this is not your primary OS drive!"</span>
<span class="k">fi</span>


<span class="c"># --- Confirmation ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Target Device: </span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Partitions to be created:"</span>
<span class="nb">echo</span> <span class="s2">"  1: EFI System Partition (ESP), FAT32, Label: '</span><span class="nv">$ESP_LABEL</span><span class="s2">', Size: </span><span class="nv">$ESP_SIZE</span><span class="s2">, Flags: boot, esp"</span>
<span class="nb">echo</span> <span class="s2">"  2: Linux Data Partition, ext4, Label: '</span><span class="nv">$DATA_LABEL</span><span class="s2">', Size: Remaining space"</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"ARE YOU ABSOLUTELY SURE you want to erase '</span><span class="nv">$DEVICE</span><span class="s2">' and proceed? (yes/NO): "</span> CONFIRMATION
<span class="nv">CONFIRMATION</span><span class="o">=</span><span class="k">${</span><span class="nv">CONFIRMATION</span><span class="k">:-</span><span class="nv">NO</span><span class="k">}</span> <span class="c"># Default to NO if user just presses Enter</span>

<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$CONFIRMATION</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"yes"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Operation cancelled by user."</span>
  <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Proceeding with operations on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>

<span class="c"># --- Phase 2: Partition the USB Drive ---</span>

<span class="c"># 1. Unmount Existing Partitions</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Unmounting any existing partitions on </span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}</span><span class="s2">* ---"</span>
<span class="c"># Use findmnt to get mount points and umount them safely</span>
<span class="c"># Also try to unmount the base device itself in case it's loop-mounted etc.</span>
findmnt <span class="nt">-n</span> <span class="nt">-o</span> TARGET <span class="nt">--source</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}</span><span class="s2">*"</span> | xargs <span class="nt">--no-run-if-empty</span> umount <span class="nt">-v</span> <span class="nt">-l</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Info: No partitions were mounted or umount failed (might be okay)."</span>
umount <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> &amp;&gt;/dev/null <span class="o">||</span> <span class="nb">true</span> <span class="c"># Attempt to unmount base device, ignore errors</span>
<span class="nb">sleep </span>1 <span class="c"># Give time for umount to settle</span>
lsblk <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>

<span class="c"># 2. Wipe Existing Signatures (Recommended)</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Wiping filesystem/partition signatures from </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
wipefs <span class="nt">--all</span> <span class="nt">--force</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk to ensure changes are physically written</span>

<span class="c"># 3. Create New GPT Partition Table</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating new GPT partition table on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mklabel gpt
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># 4. Create EFI System Partition (ESP)</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating ESP partition (1) on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mkpart <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">"</span> fat32 1MiB <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> <span class="nb">set </span>1 boot on
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> <span class="nb">set </span>1 esp on
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># 5. Create Linux Data Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating Linux data partition (2) on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
<span class="c"># Use the end of the ESP as the start for the data partition</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mkpart <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> ext4 <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">"</span> 100%
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>
<span class="nb">echo</span> <span class="s2">"Waiting briefly for kernel to recognize new partitions..."</span>
<span class="nb">sleep </span>2

<span class="c"># Define partition variables (assuming standard naming, e.g., /dev/sda1, /dev/sda2)</span>
<span class="c"># Adding 'p' for NVMe devices (e.g., /dev/nvme0n1p1) - check if base device name contains 'nvme'</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">==</span> <span class="k">*</span>nvme<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nv">PART_PREFIX</span><span class="o">=</span><span class="s2">"p"</span>
<span class="k">else
  </span><span class="nv">PART_PREFIX</span><span class="o">=</span><span class="s2">""</span>
<span class="k">fi
</span><span class="nv">ESP_PARTITION</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}${</span><span class="nv">PART_PREFIX</span><span class="k">}</span><span class="s2">1"</span>
<span class="nv">DATA_PARTITION</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}${</span><span class="nv">PART_PREFIX</span><span class="k">}</span><span class="s2">2"</span>

<span class="c"># Check if partition devices exist, retry with partprobe if needed</span>
<span class="nb">echo</span> <span class="s2">"--- Checking for partition device nodes (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">, </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">) ---"</span>
<span class="nv">PARTITIONS_FOUND</span><span class="o">=</span><span class="nb">false
</span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do
  if</span> <span class="o">[</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$ESP_PARTITION</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$DATA_PARTITION</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Partition nodes found."</span>
    <span class="nv">PARTITIONS_FOUND</span><span class="o">=</span><span class="nb">true
    break
  </span><span class="k">fi
  </span><span class="nb">echo</span> <span class="s2">"Partition nodes not yet found. Retrying probe (Attempt </span><span class="nv">$i</span><span class="s2">/5)..."</span>
  partprobe <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Warning: partprobe command failed, continuing check..."</span>
  <span class="nb">sleep </span>1
<span class="k">done

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$PARTITIONS_FOUND</span><span class="s2">"</span> <span class="o">=</span> <span class="nb">false</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: Partition devices (</span><span class="nv">$ESP_PARTITION</span><span class="s2">, </span><span class="nv">$DATA_PARTITION</span><span class="s2">) not found after partitioning and retries."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"    Please check manually ('lsblk </span><span class="nv">$DEVICE</span><span class="s2">', 'parted </span><span class="nv">$DEVICE</span><span class="s2"> print')."</span> <span class="o">&gt;</span>&amp;2
  lsblk <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 6. Verify Partitioning</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying partitions on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> print
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Block device view: ---"</span>
lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,PARTLABEL,MOUNTPOINT,PARTFLAGS <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"----------------------------"</span>
<span class="nb">echo</span> <span class="s2">"Expected: </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2"> (~</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">), Type EFI System, Flags: boot, esp"</span>
<span class="nb">echo</span> <span class="s2">"Expected: </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2"> (Remaining size), Type Linux filesystem"</span>
<span class="nb">echo</span> <span class="s2">"----------------------------"</span>
<span class="nb">sleep </span>2 <span class="c"># Pause for user to review</span>


<span class="c"># --- Phase 3: Format Filesystems ---</span>

<span class="c"># 1. Format EFI Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Formatting ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">) as FAT32 with label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' ---"</span>
mkfs.vfat <span class="nt">-F</span> 32 <span class="nt">-n</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># Check filesystem integrity</span>
<span class="nb">echo</span> <span class="s2">"--- Checking ESP filesystem (fsck.vfat) ---"</span>
<span class="nv">FSCK_VFAT_EXIT_CODE</span><span class="o">=</span>0
fsck.vfat <span class="nt">-a</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nv">FSCK_VFAT_EXIT_CODE</span><span class="o">=</span><span class="nv">$?</span> <span class="c"># Run fsck, capture exit code on failure</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$FSCK_VFAT_EXIT_CODE</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ESP filesystem check passed (or no check performed)."</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$FSCK_VFAT_EXIT_CODE</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Exit code 1 usually means errors were found AND corrected.</span>
  <span class="nb">echo</span> <span class="s2">"WARNING: fsck.vfat found and corrected errors on ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">). Check output above."</span>
<span class="k">else</span>
  <span class="c"># Exit codes &gt; 1 typically indicate uncorrected errors.</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: fsck.vfat reported uncorrectable errors (Exit Code: </span><span class="nv">$FSCK_VFAT_EXIT_CODE</span><span class="s2">) on ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"    Cannot proceed safely. Please investigate manually."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Verify label using blkid</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying ESP label ---"</span>
<span class="k">if </span>blkid <span class="nt">-s</span> LABEL <span class="nt">-o</span> value <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">$"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ESP Label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' verified successfully on </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">."</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to verify ESP Label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' on </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span>&amp;2
  blkid <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Show full blkid output for debugging</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 2. Format Data Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Formatting Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">) as ext4 with label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' ---"</span>
mkfs.ext4 <span class="nt">-m</span> 0 <span class="nt">-L</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># Check the new ext4 filesystem integrity</span>
<span class="nb">echo</span> <span class="s2">"--- Checking Data partition filesystem (e2fsck) ---"</span>
<span class="c"># -f forces check even if clean, -y assumes yes to all prompts (use with caution)</span>
<span class="nv">E2FSCK_EXIT_CODE</span><span class="o">=</span>0
e2fsck <span class="nt">-f</span> <span class="nt">-y</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nv">E2FSCK_EXIT_CODE</span><span class="o">=</span><span class="nv">$?</span> <span class="c"># Capture exit code on failure</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$E2FSCK_EXIT_CODE</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Data partition filesystem check passed."</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$E2FSCK_EXIT_CODE</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Exit code 1 means errors were corrected.</span>
  <span class="nb">echo</span> <span class="s2">"WARNING: e2fsck found and corrected errors on Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">). Check output above."</span>
<span class="k">else</span>
  <span class="c"># Exit codes &gt; 1 indicate uncorrected errors.</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: e2fsck reported uncorrectable errors (Exit Code: </span><span class="nv">$E2FSCK_EXIT_CODE</span><span class="s2">) on Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"    Cannot proceed safely. Please investigate manually."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Verify the label using blkid</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying Data partition label ---"</span>
<span class="k">if </span>blkid <span class="nt">-s</span> LABEL <span class="nt">-o</span> value <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">$"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Data Label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' verified successfully on </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">."</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to verify Data Label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' on </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span>&amp;2
  blkid <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Show full blkid output for debugging</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">"--- Script finished successfully! ---"</span>
<span class="nb">echo</span> <span class="s2">"Device: </span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Partitions created and formatted:"</span>
lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,LABEL,PARTLABEL,MOUNTPOINT <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>

<span class="nb">exit </span>0
</code></section></div></div>
  <h3 id="phase-3-install-sbnb-boot-files-and-configuration">
    
    
     <a href="#phase-3-install-sbnb-boot-files-and-configuration">#</a><a href="#" aria-label="Back to top">Phase 3: Install Sbnb Boot Files and Configuration</a>
        
    
  </h3>
      

<ol>
  <li><strong>Mount EFI Partition:</strong> Access the ESP filesystem. Replace <code class="language-plaintext highlighter-rouge">/dev/sdX1</code> with the actual ESP partition device name identified earlier.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Mounting ESP partition ---"</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /mnt/sbnb-mount
<span class="nb">sudo </span>mount /dev/sdX1 /mnt/sbnb-mount
</code></section></div>    </div>
  </li>
  <li><strong>Create EFI Boot Directory:</strong> Standard UEFI fallback path.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Creating EFI boot directories ---"</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /mnt/sbnb-mount/EFI/BOOT
</code></section></div>    </div>
  </li>
  <li><strong>Copy Sbnb EFI Boot File:</strong> Place the bootloader (<code class="language-plaintext highlighter-rouge">sbnb.efi</code> as <code class="language-plaintext highlighter-rouge">BOOTX64.EFI</code>). Replace <code class="language-plaintext highlighter-rouge">/path/to/your/sbnb.efi</code> with the actual path to the file you obtained.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Copying Sbnb EFI boot file ---"</span>
<span class="nb">sudo cp</span> /path/to/your/sbnb.efi /mnt/sbnb-mount/EFI/BOOT/BOOTX64.EFI
</code></section></div>    </div>
  </li>
  <li><strong>Run Sbnb Configuration python script:</strong> Mount <code class="language-plaintext highlighter-rouge">/dev/sdX1</code> to <code class="language-plaintext highlighter-rouge">/mnt/sbnb</code> and <code class="language-plaintext highlighter-rouge">/dev/sdX2</code> to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>. Replace <code class="language-plaintext highlighter-rouge">tskey-auth-...</code> with your actual Tailscale auth key on this python script:</li>
</ol>

<p>{% codeblock python %}
#!/usr/bin/env python3
“””
Unified SBNB Configuration Deployment Script (Version 2.1 - BusyBox cp focus).</p>

<p>Generates configuration files and scripts to:</p>
<ul>
  <li>Mount a persistent data partition.</li>
  <li>Configure Docker to use a persistent data-root on that partition.</li>
  <li>Optionally migrate existing Docker data from /var/lib/docker robustly using busybox cp.</li>
  <li>Set up backup/purge routines for the persistent Docker data.</li>
  <li>Set up health and volume monitoring for Docker (with safer defaults).</li>
  <li>Deploy a Tailscale authentication key.</li>
  <li>Deploy an optional development environment script.</li>
</ul>

<p>Core components generated:</p>
<ul>
  <li>/mnt/sbnb/sbnb-cmds.sh: Main boot script executed by the system.</li>
  <li>/mnt/sbnb/sbnb-tskey.txt: Tailscale authentication key.</li>
  <li>/mnt/sbnb-data/scripts/*: Helper scripts for backup, purge, health checks.</li>
  <li>/mnt/sbnb-data/systemd/*: Systemd units to automate helper scripts.</li>
</ul>

<p>Prerequisites:</p>
<ul>
  <li>Run as root.</li>
  <li>ESP partition mounted at /mnt/sbnb (writable).</li>
  <li>Data partition mounted at /mnt/sbnb-data (writable).</li>
  <li>Required: Standard Linux utilities (coreutils including ‘cp’, systemd, grep, sed, etc.).</li>
  <li>Recommended: <code class="language-plaintext highlighter-rouge">jq</code> installed on the target system for robust JSON handling.
“””</li>
</ul>

<p>import os
import stat
import sys
import pathlib
import json
import shutil
from datetime import datetime</p>
  <h1 id="-configuration-file-paths-">
    
    
     <a href="#-configuration-file-paths-">#</a><a href="#" aria-label="Back to top">— Configuration: File Paths —</a>
        
    
  </h1>
      
  <h1 id="base-mount-points---script-will-check-if-these-exist-and-are-writable">
    
    
     <a href="#base-mount-points---script-will-check-if-these-exist-and-are-writable">#</a><a href="#" aria-label="Back to top">Base mount points - Script will check if these exist and are writable</a>
        
    
  </h1>
      
<p>ESP_MOUNT = “/mnt/sbnb”
DATA_MOUNT = “/mnt/sbnb-data”</p>
  <h1 id="docker-configuration">
    
    
     <a href="#docker-configuration">#</a><a href="#" aria-label="Back to top">Docker configuration</a>
        
    
  </h1>
      
<p>PERSISTENT_DOCKER_ROOT = f”{DATA_MOUNT}/docker-root”
DOCKER_CONFIG_DIR = “/etc/docker”
DOCKER_CONFIG_FILE = f”{DOCKER_CONFIG_DIR}/daemon.json”
DOCKER_CONFIG_BACKUP_SUFFIX = “.sbnb-orig-backup” # Suffix for one-time backup
DOCKER_DATA_EPHEMERAL = “/var/lib/docker” # Default path for migration check</p>
  <h1 id="permissions-for-docker-root-dir-rwxxx-ownergroup-should-be-rootroot">
    
    
     <a href="#permissions-for-docker-root-dir-rwxxx-ownergroup-should-be-rootroot">#</a><a href="#" aria-label="Back to top">Permissions for Docker root dir (rwx–x–x). Owner/Group should be root:root.</a>
        
    
  </h1>
      
  <h1 id="use-standard-integer-representation-for-octal-in-python">
    
    
     <a href="#use-standard-integer-representation-for-octal-in-python">#</a><a href="#" aria-label="Back to top">Use standard integer representation for octal in Python</a>
        
    
  </h1>
      
<p>DOCKER_ROOT_PERMISSIONS = 0o711</p>
  <h1 id="permissions-for-daemonjson-rw-rr">
    
    
     <a href="#permissions-for-daemonjson-rw-rr">#</a><a href="#" aria-label="Back to top">Permissions for daemon.json (rw-r–r–)</a>
        
    
  </h1>
      
<p>DOCKER_CONFIG_PERMISSIONS = 0o644</p>
  <h1 id="backup-configuration">
    
    
     <a href="#backup-configuration">#</a><a href="#" aria-label="Back to top">Backup configuration</a>
        
    
  </h1>
      
<p>BACKUP_BASE_DIR = f”{DATA_MOUNT}/backups/docker”
BACKUP_KEEP_COUNT = 3 # Number of backups to retain
STOP_DOCKER_FOR_BACKUP = 1 # 1 = Stop Docker during backup (safer), 0 = Attempt live backup</p>
  <h1 id="permissions-for-backup-base-directory-rwxr-x">
    
    
     <a href="#permissions-for-backup-base-directory-rwxr-x">#</a><a href="#" aria-label="Back to top">Permissions for backup base directory (rwxr-x—)</a>
        
    
  </h1>
      
<p>BACKUP_DIR_PERMISSIONS = 0o750</p>
  <h1 id="health-check-configuration">
    
    
     <a href="#health-check-configuration">#</a><a href="#" aria-label="Back to top">Health Check configuration</a>
        
    
  </h1>
      
<p>VOLUME_CHECK_THRESHOLD_PERCENT = 10 # Warn if free space drops below this %</p>
  <h1 id="pruning-level-in-volume-check-0none-1containersdangling-images-2all-unused-imagescontainers-volumes-still-excluded">
    
    
     <a href="#pruning-level-in-volume-check-0none-1containersdangling-images-2all-unused-imagescontainers-volumes-still-excluded">#</a><a href="#" aria-label="Back to top">Pruning level in volume check: 0=None, 1=Containers/Dangling Images, 2=All Unused Images+Containers (–volumes still excluded)</a>
        
    
  </h1>
      
<p>VOLUME_CHECK_PRUNE_LEVEL = 1</p>
  <h1 id="-content-definitions-">
    
    
     <a href="#-content-definitions-">#</a><a href="#" aria-label="Back to top">— Content Definitions —</a>
        
    
  </h1>
      
  <h1 id="-sbnb-cmdssh-content-">
    
    
     <a href="#-sbnb-cmdssh-content-">#</a><a href="#" aria-label="Back to top">— sbnb-cmds.sh Content —</a>
        
    
  </h1>
      
  <h1 id="refactor-removed-rsync-checks-and-usage-standardized-on-cp--a--u-for-migration">
    
    
     <a href="#refactor-removed-rsync-checks-and-usage-standardized-on-cp--a--u-for-migration">#</a><a href="#" aria-label="Back to top">REFACTOR: Removed rsync checks and usage, standardized on cp -a -u for migration.</a>
        
    
  </h1>
      
  <h1 id="refactor-use-correct-octal-format-specifier-o-for-mkdir--m-and-chmod">
    
    
     <a href="#refactor-use-correct-octal-format-specifier-o-for-mkdir--m-and-chmod">#</a><a href="#" aria-label="Back to top">REFACTOR: Use correct octal format specifier (:o) for mkdir -m and chmod.</a>
        
    
  </h1>
      
<p>SBNB_CMDS_SH_CONTENT = f”””#!/bin/sh</p>
  <h1 id="sbnb-custom-commands-script-unified-persistent-docker-root--features---v21---busybox-cp">
    
    
     <a href="#sbnb-custom-commands-script-unified-persistent-docker-root--features---v21---busybox-cp">#</a><a href="#" aria-label="Back to top">Sbnb Custom Commands Script (Unified Persistent Docker Root + Features - v2.1 - BusyBox cp)</a>
        
    
  </h1>
      
  <h1 id="mounts-persistent-data-configures-docker-data-root-migrates-data-if-needed-using-cp">
    
    
     <a href="#mounts-persistent-data-configures-docker-data-root-migrates-data-if-needed-using-cp">#</a><a href="#" aria-label="Back to top">Mounts persistent data, configures Docker data-root, migrates data (if needed using cp),</a>
        
    
  </h1>
      
  <h1 id="updates-optional-scripts-enables-systemd-units-for-backup--monitoring">
    
    
     <a href="#updates-optional-scripts-enables-systemd-units-for-backup--monitoring">#</a><a href="#" aria-label="Back to top">updates optional scripts, enables systemd units for backup &amp; monitoring.</a>
        
    
  </h1>
      
  <h1 id="strict-error-handling">
    
    
     <a href="#strict-error-handling">#</a><a href="#" aria-label="Back to top">Strict error handling</a>
        
    
  </h1>
      
<p>set -e -o pipefail -u</p>
  <h1 id="-logging-function-">
    
    
     <a href="#-logging-function-">#</a><a href="#" aria-label="Back to top">— Logging Function —</a>
        
    
  </h1>
      
<p>log() {{
    # Log to kernel message buffer
    echo “[sbnb-cmds.sh] $1” &gt; /dev/kmsg
}}</p>

<p>log “Starting custom boot commands (Unified Persistent Docker Root v2.1 - BusyBox cp)…”</p>
  <h1 id="-check-core-commands-">
    
    
     <a href="#-check-core-commands-">#</a><a href="#" aria-label="Back to top">— Check Core Commands —</a>
        
    
  </h1>
      
  <h1 id="ensure-essential-commands-for-this-script-are-present">
    
    
     <a href="#ensure-essential-commands-for-this-script-are-present">#</a><a href="#" aria-label="Back to top">Ensure essential commands for this script are present</a>
        
    
  </h1>
      
<p>check_cmds() {{
    local missing_cmd=0
    log “Checking required commands…”
    for cmd in “$@”; do
        if ! command -v “$cmd” &gt;/dev/null 2&gt;&amp;1; then
            log “ERROR: Required command ‘$cmd’ not found.”
            missing_cmd=1
        fi
    done
    if [ $missing_cmd -eq 1 ]; then
        log “ERROR: Missing one or more required commands. Cannot proceed.”
        exit 1
    fi
    log “Required commands found.”
    # Check optional but recommended commands
    if ! command -v jq &gt;/dev/null 2&gt;&amp;1; then
        log “WARNING: ‘jq’ command not found. JSON handling for daemon.json will be less robust and may fail on complex existing files.”
    else
        log “OK: ‘jq’ command found (recommended).”
    fi
    # Note: rsync check removed as cp -a -u is now the standard method
}}</p>
  <h1 id="define-all-commands-potentially-used-in-this-script">
    
    
     <a href="#define-all-commands-potentially-used-in-this-script">#</a><a href="#" aria-label="Back to top">Define all commands potentially used in this script</a>
        
    
  </h1>
      
  <h1 id="removed-rsync-from-the-list">
    
    
     <a href="#removed-rsync-from-the-list">#</a><a href="#" aria-label="Back to top">Removed ‘rsync’ from the list.</a>
        
    
  </h1>
      
<p>check_cmds mountpoint readlink mkdir mount echo sleep rm find ln systemctl mktemp cp mv chmod chown dirname basename jq grep cat cmp date sed ls</p>
  <h1 id="-mount-persistent-data-partition-">
    
    
     <a href="#-mount-persistent-data-partition-">#</a><a href="#" aria-label="Back to top">— Mount Persistent Data Partition —</a>
        
    
  </h1>
      
<p>DATA_LABEL=”SBNB_DATA”
DATA_DEVICE_SYMLINK=”/dev/disk/by-label/${{DATA_LABEL}}”
DATA_MOUNT_POINT=”{DATA_MOUNT}”
MAX_WAIT_SECONDS=15
WAIT_INTERVAL=1
elapsed_time=0</p>

<p>log “Waiting up to ${{MAX_WAIT_SECONDS}}s for data device (Label: ${{DATA_LABEL}})…”
while [ ! -e “${{DATA_DEVICE_SYMLINK}}” ]; do
    if [ ${{elapsed_time}} -ge ${{MAX_WAIT_SECONDS}} ]; then
        log “ERROR: Timeout waiting for device ${{DATA_DEVICE_SYMLINK}}. Persistent data cannot be mounted.”
        exit 1
    fi
    sleep ${{WAIT_INTERVAL}}
    elapsed_time=$((elapsed_time + WAIT_INTERVAL))
done
DATA_DEVICE=$(readlink -f “${{DATA_DEVICE_SYMLINK}}”)
log “Data partition device resolved to ${{DATA_DEVICE}} after ${{elapsed_time}}s.”</p>
  <h1 id="ensure-mount-point-directory-exists">
    
    
     <a href="#ensure-mount-point-directory-exists">#</a><a href="#" aria-label="Back to top">Ensure mount point directory exists</a>
        
    
  </h1>
      
<p>mkdir -p “${{DATA_MOUNT_POINT}}”</p>

<p>log “Attempting to mount ${{DATA_DEVICE}} at ${{DATA_MOUNT_POINT}}…”
if ! mountpoint -q “${{DATA_MOUNT_POINT}}”; then
    # Attempt to mount read-write, noatime, nodiratime
    if mount -o rw,noatime,nodiratime “${{DATA_DEVICE}}” “${{DATA_MOUNT_POINT}}”; then
        log “Successfully mounted persistent partition at ${{DATA_MOUNT_POINT}}.”
    else
        log “ERROR: Failed to mount ${{DATA_DEVICE}} at ${{DATA_MOUNT_POINT}}! Check filesystem and device.”
        exit 1
    fi
else
    log “Persistent partition already mounted at ${{DATA_MOUNT_POINT}}. Ensuring read-write…”
    # Ensure partition is mounted read-write
    mount -o remount,rw “${{DATA_MOUNT_POINT}}” || {{
        log “ERROR: Failed to remount ${{DATA_MOUNT_POINT}} as read-write! Docker requires write access.”
        exit 1
    }}
fi</p>
  <h1 id="-configure-docker-to-use-persistent-data-directory-">
    
    
     <a href="#-configure-docker-to-use-persistent-data-directory-">#</a><a href="#" aria-label="Back to top">— Configure Docker to use Persistent Data Directory —</a>
        
    
  </h1>
      
<p>log “Setting up Docker to use persistent data-root…”</p>

<p>PERSISTENT_DOCKER_ROOT=”{PERSISTENT_DOCKER_ROOT}”
DOCKER_CONFIG_DIR=”{DOCKER_CONFIG_DIR}”
DOCKER_CONFIG_FILE=”{DOCKER_CONFIG_FILE}”
DOCKER_CONFIG_BACKUP=”{DOCKER_CONFIG_FILE}{DOCKER_CONFIG_BACKUP_SUFFIX}”
DOCKER_DATA_EPHEMERAL=”{DOCKER_DATA_EPHEMERAL}” # For migration check
CONFIG_CHANGED=0 # Flag to track if we need to restart docker</p>
  <h1 id="1-ensure-the-persistent-docker-data-root-directory-exists-with-correct-ownerpermissions">
    
    
     <a href="#1-ensure-the-persistent-docker-data-root-directory-exists-with-correct-ownerpermissions">#</a><a href="#" aria-label="Back to top">1. Ensure the persistent Docker data-root directory exists with correct owner/permissions</a>
        
    
  </h1>
      
<p>log “Ensuring persistent Docker data directory exists: ${{PERSISTENT_DOCKER_ROOT}}”</p>
  <h1 id="create-with-specific-permissions-rwxxx-using-correct-octal-format-for-command-line">
    
    
     <a href="#create-with-specific-permissions-rwxxx-using-correct-octal-format-for-command-line">#</a><a href="#" aria-label="Back to top">Create with specific permissions (rwx–x–x) using correct octal format for command line</a>
        
    
  </h1>
      
<p>mkdir -p -m {DOCKER_ROOT_PERMISSIONS:o} “${{PERSISTENT_DOCKER_ROOT}}”
if [ ! -d “${{PERSISTENT_DOCKER_ROOT}}” ]; then
    log “ERROR: Failed to create persistent Docker data directory ${{PERSISTENT_DOCKER_ROOT}}!”
    exit 1
fi</p>
  <h1 id="ensure-ownership-is-rootroot-critical-for-docker">
    
    
     <a href="#ensure-ownership-is-rootroot-critical-for-docker">#</a><a href="#" aria-label="Back to top">Ensure ownership is root:root (critical for Docker)</a>
        
    
  </h1>
      
<p>log “Ensuring ownership of ${{PERSISTENT_DOCKER_ROOT}} is root:root…”
chown root:root “${{PERSISTENT_DOCKER_ROOT}}” || log “WARNING: Failed to set ownership on ${{PERSISTENT_DOCKER_ROOT}}. Docker might have issues.”</p>
  <h1 id="ensure-permissions-are-correct-mkdir--p-doesnt-always-set-mode-on-existing-dirs-using-correct-octal-format-for-command-line">
    
    
     <a href="#ensure-permissions-are-correct-mkdir--p-doesnt-always-set-mode-on-existing-dirs-using-correct-octal-format-for-command-line">#</a><a href="#" aria-label="Back to top">Ensure permissions are correct (mkdir -p doesn’t always set mode on existing dirs) using correct octal format for command line</a>
        
    
  </h1>
      
<p>log “Ensuring permissions of ${{PERSISTENT_DOCKER_ROOT}} are {DOCKER_ROOT_PERMISSIONS:o}…”
chmod {DOCKER_ROOT_PERMISSIONS:o} “${{PERSISTENT_DOCKER_ROOT}}” || log “WARNING: Failed to set permissions on ${{PERSISTENT_DOCKER_ROOT}}.”</p>

<p>log “Persistent Docker data directory ensured.”</p>
  <h1 id="2-createupdate-docker-daemon-configuration-etcdockerdaemonjson">
    
    
     <a href="#2-createupdate-docker-daemon-configuration-etcdockerdaemonjson">#</a><a href="#" aria-label="Back to top">2. Create/Update Docker daemon configuration (/etc/docker/daemon.json)</a>
        
    
  </h1>
      
<p>log “Configuring Docker daemon (${{DOCKER_CONFIG_FILE}}) to use data-root: ${{PERSISTENT_DOCKER_ROOT}}”
mkdir -p “${{DOCKER_CONFIG_DIR}}” # Ensure config directory exists</p>
  <h1 id="backup-original-config-once-if-it-exists-and-backup-doesnt">
    
    
     <a href="#backup-original-config-once-if-it-exists-and-backup-doesnt">#</a><a href="#" aria-label="Back to top">Backup original config ONCE if it exists and backup doesn’t</a>
        
    
  </h1>
      
<p>if [ -f “${{DOCKER_CONFIG_FILE}}” ] &amp;&amp; [ ! -f “${{DOCKER_CONFIG_BACKUP}}” ]; then
    log “Backing up original Docker config to ${{DOCKER_CONFIG_BACKUP}}…”
    cp -a “${{DOCKER_CONFIG_FILE}}” “${{DOCKER_CONFIG_BACKUP}}” || <br />
        log “WARNING: Failed to create backup of ${{DOCKER_CONFIG_FILE}}.”
fi</p>
  <h1 id="-safely-update-daemonjson-">
    
    
     <a href="#-safely-update-daemonjson-">#</a><a href="#" aria-label="Back to top">— Safely update daemon.json —</a>
        
    
  </h1>
      
<p>NEEDS_UPDATE=0</p>
  <h1 id="use-jq-if-available-preferred-method">
    
    
     <a href="#use-jq-if-available-preferred-method">#</a><a href="#" aria-label="Back to top">Use jq if available (preferred method)</a>
        
    
  </h1>
      
<p>if command -v jq &gt;/dev/null 2&gt;&amp;1; then
    log “Using jq to manage daemon.json.”
    # Ensure file exists with at least {{}} for jq processing
    [ -f “${{DOCKER_CONFIG_FILE}}” ] || echo “{{}}” &gt; “${{DOCKER_CONFIG_FILE}}”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># Read current value safely, defaulting to empty string if null or missing
current_data_root=$(jq -r '.["data-root"] // ""' "${{DOCKER_CONFIG_FILE}}")

if [ "$current_data_root" != "${{PERSISTENT_DOCKER_ROOT}}" ]; then
    log "Data-root needs update (jq check). Preparing changes..."
    NEEDS_UPDATE=1
else
    log "Docker data-root already correctly set in daemon.json (jq check)."
fi

if [ $NEEDS_UPDATE -eq 1 ]; then
    TMP_JSON=$(mktemp "${{DOCKER_CONFIG_DIR}}/daemon.json.tmp.XXXXXX")
    log "Attempting to merge data-root setting using jq..."
    # Merge the new data-root value, preserving other keys
    if jq --arg path "${{PERSISTENT_DOCKER_ROOT}}" '. + {{"data-root": $path}}' "${{DOCKER_CONFIG_FILE}}" &gt; "${{TMP_JSON}}"; then
        # Check if jq produced valid JSON
        if jq -e . "${{TMP_JSON}}" &gt; /dev/null; then
            # Check if content actually changed before moving
            if ! cmp -s "${{TMP_JSON}}" "${{DOCKER_CONFIG_FILE}}"; then
                mv "${{TMP_JSON}}" "${{DOCKER_CONFIG_FILE}}"
                chmod {DOCKER_CONFIG_PERMISSIONS:o} "${{DOCKER_CONFIG_FILE}}" # Use correct format here too for consistency, though 644 doesn't need '0o' prefix
                log "Successfully updated daemon.json using jq."
                CONFIG_CHANGED=1
            else
                log "daemon.json content unchanged after jq merge, removing temp file."
                rm -f "${{TMP_JSON}}"
            fi
        else
            log "ERROR: jq produced invalid JSON output. Config not updated."
            rm -f "${{TMP_JSON}}" # Clean up temp file
        fi
    else
        jq_exit_code=$?
        log "ERROR: jq command failed (exit code $jq_exit_code) while updating config. Config not updated."
        # Optionally capture and log jq stderr here if needed
        rm -f "${{TMP_JSON}}" # Clean up temp file
    fi
fi # Fallback logic if jq is NOT available else
log "WARNING: jq not found. Using less robust fallback for daemon.json."
# Define the minimal target content
TARGET_JSON_CONTENT=$(printf '{{%s\\n  "data-root": "%s"%s\\n}}%s\\n' "" "${{PERSISTENT_DOCKER_ROOT}}" "" "")

if [ ! -f "${{DOCKER_CONFIG_FILE}}" ]; then
    log "daemon.json does not exist. Creating new file with data-root."
    NEEDS_UPDATE=1
else
    # Check if data-root key exists at all
    if ! grep -q '"data-root"\\s*:' "${{DOCKER_CONFIG_FILE}}"; then
         log "Existing daemon.json lacks 'data-root' key."
        # Check if the file is simple (e.g., just {{}} or empty/whitespace)
        if ! grep -q '[a-zA-Z0-9]' "${{DOCKER_CONFIG_FILE}}" || grep -q '^\\s*{{\\s*}}\\s*$' "${{DOCKER_CONFIG_FILE}}"; then
            log "Existing file is simple, overwriting with data-root."
            NEEDS_UPDATE=1
        else
            log "ERROR: Existing daemon.json is complex and lacks 'data-root'. Cannot safely update without jq. Install jq or manually edit."
            # Do not proceed with overwrite
            NEEDS_UPDATE=0 # Explicitly prevent update
        fi
    # Key exists, check if the value is correct (basic check)
    elif ! grep -q '"data-root"\\s*:\\s*"${{PERSISTENT_DOCKER_ROOT}}"' "${{DOCKER_CONFIG_FILE}}"; then
        log "ERROR: Existing daemon.json has 'data-root' but points elsewhere. Cannot safely update without jq. Install jq or manually edit."
        # Do not proceed with overwrite
        NEEDS_UPDATE=0 # Explicitly prevent update
    else
        log "daemon.json exists and data-root seems correct (grep check)."
        NEEDS_UPDATE=0
    fi
fi

# Perform write only if deemed safe and necessary by the logic above
if [ $NEEDS_UPDATE -eq 1 ]; then
    log "Writing daemon.json (simple method)..."
    TMP_JSON=$(mktemp "${{DOCKER_CONFIG_DIR}}/daemon.json.tmp.XXXXXX")
    echo "$TARGET_JSON_CONTENT" &gt; "${{TMP_JSON}}"
    if [ $? -eq 0 ]; then
        mv "${{TMP_JSON}}" "${{DOCKER_CONFIG_FILE}}"
        chmod {DOCKER_CONFIG_PERMISSIONS:o} "${{DOCKER_CONFIG_FILE}}" # Use correct format here too
        log "Successfully wrote simple daemon.json."
        CONFIG_CHANGED=1
    else
        log "ERROR: Failed to write temporary simple daemon.json! Config not updated."
        rm -f "${{TMP_JSON}}"
    fi
fi fi log "Docker daemon configuration check finished."
</code></section></div></div>
  <h1 id="3-data-migration-optional-migrate-data-from-ephemeral-location-if-needed">
    
    
     <a href="#3-data-migration-optional-migrate-data-from-ephemeral-location-if-needed">#</a><a href="#" aria-label="Back to top">3. Data Migration (Optional): Migrate data from ephemeral location if needed</a>
        
    
  </h1>
      
<p>log “Checking for existing Docker data in ephemeral location (${{DOCKER_DATA_EPHEMERAL}})…”</p>
  <h1 id="check-if-the-directory-exists-and-contains-anything-other-than-lostfound-or-potential-marker-files">
    
    
     <a href="#check-if-the-directory-exists-and-contains-anything-other-than-lostfound-or-potential-marker-files">#</a><a href="#" aria-label="Back to top">Check if the directory exists and contains anything other than ‘lost+found’ or potential marker files</a>
        
    
  </h1>
      
<p>if [ -d “${{DOCKER_DATA_EPHEMERAL}}” ] &amp;&amp; [ -n “$(ls -A “${{DOCKER_DATA_EPHEMERAL}}” | grep -v -e ‘^lost+found$’ -e ‘^\.sbnb_persistent_redirect$’ -e ‘^README_DO_NOT_USE\.txt$’ 2&gt;/dev/null)” ]; then
    log “Found potentially significant data in ${{DOCKER_DATA_EPHEMERAL}}.”
    # Check if persistent location is effectively empty (allowing only lost+found)
    persistent_is_empty=0
    if [ ! “$(ls -A “${{PERSISTENT_DOCKER_ROOT}}” | grep -v ‘^lost+found$’ 2&gt;/dev/null)” ]; then
        persistent_is_empty=1
    fi</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>if [ $persistent_is_empty -eq 1 ]; then
    log "Persistent location ${{PERSISTENT_DOCKER_ROOT}} is empty. Migrating data..."

    # Ensure Docker is stopped before migration
    if systemctl is-active --quiet docker; then
        log "Stopping Docker service for migration..."
        systemctl stop docker || log "WARNING: Failed to stop Docker. Migration proceeding, but data might be inconsistent!"
        sleep 3 # Give it time to release files
    fi

    log "Starting migration using cp -a -u..."
    MIGRATION_SUCCESS=0
    # Use cp -a -u: archive mode (preserve attrs), update mode (copy only if newer/missing).
    # Source ends with /. to copy contents including hidden files.
    # This is the recommended busybox alternative to rsync for local mirroring.
    if cp -a -u "${{DOCKER_DATA_EPHEMERAL}}/." "${{PERSISTENT_DOCKER_ROOT}}/"; then
         MIGRATION_SUCCESS=1
    else
         log "ERROR: cp -a -u migration failed with exit code $? !"
    fi

    # Handle migration outcome
    if [ $MIGRATION_SUCCESS -eq 1 ]; then
        log "Migration completed successfully."
        # Rename old data directory as backup
        OLD_DATA_BACKUP="${{DOCKER_DATA_EPHEMERAL}}.migrated.$(date +%Y%m%d_%H%M%S).bak"
        log "Attempting to rename old data directory to ${{OLD_DATA_BACKUP}}..."
        # Use mv -T to handle if ephemeral is somehow a symlink
        if mv -T "${{DOCKER_DATA_EPHEMERAL}}" "${{OLD_DATA_BACKUP}}"; then
            log "Successfully renamed old data directory."
        else
            log "WARNING: Could not rename old data directory ${{DOCKER_DATA_EPHEMERAL}}. It may still contain data."
            # Consider rm -rf here ONLY if migration verification was very thorough, otherwise leave it.
        fi
        # Mark that Docker needs restart due to migration
        CONFIG_CHANGED=1
    else
        log "ERROR: Data migration failed! Docker data may be incomplete or inconsistent in ${{PERSISTENT_DOCKER_ROOT}}."
        # Exiting is likely the safest option here to force manual review.
        exit 1
    fi
else
    log "Persistent location ${{PERSISTENT_DOCKER_ROOT}} already contains data. Skipping migration."
    # Optionally rename the ephemeral data if it still exists and is unwanted
    OLD_DATA_BACKUP="${{DOCKER_DATA_EPHEMERAL}}.ignored.$(date +%Y%m%d_%H%M%S).bak"
    log "Attempting to rename unused ephemeral data directory to ${{OLD_DATA_BACKUP}}..."
    mv -T "${{DOCKER_DATA_EPHEMERAL}}" "${{OLD_DATA_BACKUP}}" || \\
        log "WARNING: Could not rename ephemeral data directory ${{DOCKER_DATA_EPHEMERAL}}."
fi else
log "No significant data found in ephemeral location ${{DOCKER_DATA_EPHEMERAL}}. No migration needed." fi # Ensure the original ephemeral directory path exists but is empty, with a marker log "Ensuring ephemeral path ${{DOCKER_DATA_EPHEMERAL}} exists and is marked as unused." # Remove original path if it still exists (e.g., if rename failed but we continued) if [ -d "${{DOCKER_DATA_EPHEMERAL}}" ]; then
rm -rf "${{DOCKER_DATA_EPHEMERAL}}" || log "WARNING: Failed to remove original ephemeral directory after processing." fi mkdir -p "${{DOCKER_DATA_EPHEMERAL}}" touch "${{DOCKER_DATA_EPHEMERAL}}/.sbnb_persistent_redirect" echo "Docker data is managed at ${{PERSISTENT_DOCKER_ROOT}}. This directory should remain empty." &gt; "${{DOCKER_DATA_EPHEMERAL}}/README_DO_NOT_USE.txt" chmod 644 "${{DOCKER_DATA_EPHEMERAL}}/README_DO_NOT_USE.txt" # 644 doesn't need :o format chmod 600 "${{DOCKER_DATA_EPHEMERAL}}/.sbnb_persistent_redirect" # 600 doesn't need :o format log "Data migration check finished."
</code></section></div></div>
  <h1 id="4-restart-docker-service-if-configuration-was-changed-or-migration-occurred">
    
    
     <a href="#4-restart-docker-service-if-configuration-was-changed-or-migration-occurred">#</a><a href="#" aria-label="Back to top">4. Restart Docker Service <em>if</em> configuration was changed OR migration occurred</a>
        
    
  </h1>
      
<p>if [ $CONFIG_CHANGED -eq 1 ]; then
    log “Configuration or data migration requires Docker restart. Reloading daemon and restarting service…”
    if ! systemctl daemon-reload; then
        log “ERROR: Failed to reload systemd daemon! Docker restart might fail or use old config.”
        exit 1 # Critical failure if daemon cannot reload
    fi
    log “Attempting to restart docker.service…”
    if systemctl restart docker.service; then
        log “Docker service restarted successfully.”
    else
        log “ERROR: Failed to restart Docker service! Check ‘journalctl -u docker.service’.”
        exit 1 # Critical failure if Docker doesn’t restart after config change/migration
    fi
else
    log “No configuration changes or migration. Docker restart not required by this script.”
    # Optional: Ensure Docker is running even if no changes occurred
    # log “Ensuring Docker service is active…”
    # if ! systemctl is-active –quiet docker.service; then
    #     log “Docker service is not active. Attempting to start…”
    #     systemctl start docker.service || log “WARNING: Failed to start inactive Docker service.”
    # fi
fi
log “Docker setup finished.”</p>
  <h1 id="-update-optional-development-environment-script-">
    
    
     <a href="#-update-optional-development-environment-script-">#</a><a href="#" aria-label="Back to top">— Update Optional Development Environment Script —</a>
        
    
  </h1>
      
  <h1 id="using-the-robust-atomic-update-logic">
    
    
     <a href="#using-the-robust-atomic-update-logic">#</a><a href="#" aria-label="Back to top">(Using the robust atomic update logic)</a>
        
    
  </h1>
      
<p>TARGET_DEV_ENV_SCRIPT=”/usr/sbin/sbnb-dev-env.sh”
SOURCE_DEV_ENV_SCRIPT=”${{DATA_MOUNT_POINT}}/scripts/sbnb-dev-env.sh” # Assuming it’s stored persistently</p>

<p>log “Checking for optional development script update: ${{SOURCE_DEV_ENV_SCRIPT}}”
if [ -f “${{SOURCE_DEV_ENV_SCRIPT}}” ] &amp;&amp; [ -r “${{SOURCE_DEV_ENV_SCRIPT}}” ]; then
    log “Source script found. Attempting atomic update of ${{TARGET_DEV_ENV_SCRIPT}}…”
    TARGET_DIR=$(dirname “${{TARGET_DEV_ENV_SCRIPT}}”)
    TMP_SCRIPT=””</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># Setup trap for cleanup
trap 'sbnb_dev_cleanup' EXIT HUP INT QUIT TERM
sbnb_dev_cleanup() {{
    if [ -n "${{TMP_SCRIPT:-}}" ] &amp;&amp; [ -f "${{TMP_SCRIPT}}" ]; then
        rm -f "${{TMP_SCRIPT}}"
        log "Cleaned up temporary file ${{TMP_SCRIPT}}"
    fi
    trap - EXIT HUP INT QUIT TERM # Reset trap
}}

if [ ! -d "${{TARGET_DIR}}" ] || [ ! -w "${{TARGET_DIR}}" ]; then
    log "WARNING: Target directory ${{TARGET_DIR}} does not exist or is not writable. Cannot update script."
# Check required commands exist (already done by check_cmds, but good practice here too)
elif ! command -v mktemp &gt;/dev/null 2&gt;&amp;1 || ! command -v cp &gt;/dev/null 2&gt;&amp;1 || ! command -v chmod &gt;/dev/null 2&gt;&amp;1 || ! command -v mv &gt;/dev/null 2&gt;&amp;1; then
    log "WARNING: Required command (mktemp/cp/chmod/mv) not found. Skipping update."
else
    TMP_SCRIPT=$(mktemp "${{TARGET_DIR}}/sbnb-dev-env.sh.XXXXXX")
    if [ -z "${{TMP_SCRIPT}}" ] || [ ! -f "${{TMP_SCRIPT}}" ]; then
        log "WARNING: Failed to create temporary file in ${{TARGET_DIR}}. Skipping update."
        TMP_SCRIPT="" # Prevent trap from trying to remove nothing
    else
        # Proceed with copy, chmod, move
        if cp "${{SOURCE_DEV_ENV_SCRIPT}}" "${{TMP_SCRIPT}}"; then
            if chmod +x "${{TMP_SCRIPT}}"; then
                # Use mv -T to handle target being a symlink correctly
                if mv -T "${{TMP_SCRIPT}}" "${{TARGET_DEV_ENV_SCRIPT}}"; then
                    log "Successfully updated ${{TARGET_DEV_ENV_SCRIPT}}."
                    TMP_SCRIPT="" # Clear var so trap doesn't remove the final script
                else log "WARNING: Failed to move temporary file ${{TMP_SCRIPT}} to ${{TARGET_DEV_ENV_SCRIPT}}. Update failed."; fi
            else log "WARNING: Failed to set execute permissions on temporary file ${{TMP_SCRIPT}}. Update failed."; fi
        else log "WARNING: Failed to copy content from ${{SOURCE_DEV_ENV_SCRIPT}} to ${{TMP_SCRIPT}}. Update failed."; fi
    fi
    # Clean up temp file if it still exists (e.g., on mv failure) and TMP_SCRIPT is set
    if [ -n "${{TMP_SCRIPT:-}}" ] &amp;&amp; [ -f "${{TMP_SCRIPT}}" ]; then rm -f "${{TMP_SCRIPT}}"; fi
    TMP_SCRIPT="" # Ensure trap doesn't run again for this
fi
trap - EXIT HUP INT QUIT TERM # Clear trap explicitly else
log "NOTE: Source script ${{SOURCE_DEV_ENV_SCRIPT}} not found or not readable. Skipping update." fi log "Update of optional script finished."
</code></section></div></div>
  <h1 id="-enable-systemd-units-backuppurge--healthvolume-checks-">
    
    
     <a href="#-enable-systemd-units-backuppurge--healthvolume-checks-">#</a><a href="#" aria-label="Back to top">— Enable Systemd Units (Backup/Purge + Health/Volume Checks) —</a>
        
    
  </h1>
      
<p>SYSTEMD_SOURCE_DIR=”${{DATA_MOUNT_POINT}}/systemd”
SYSTEMD_TARGET_DIR=”/etc/systemd/system”
TIMERS_WANTS_DIR=”${{SYSTEMD_TARGET_DIR}}/timers.target.wants”</p>

<p>log “Enabling custom systemd units (Source: ${{SYSTEMD_SOURCE_DIR}})…”
if [ -d “${{SYSTEMD_SOURCE_DIR}}” ] &amp;&amp; [ -r “${{SYSTEMD_SOURCE_DIR}}” ]; then
    mkdir -p “${{SYSTEMD_TARGET_DIR}}”
    mkdir -p “${{TIMERS_WANTS_DIR}}”
    # Check ln and systemctl exist (already done in check_cmds)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>linked_any=0
log "Linking systemd unit files..."
# Use find with -print0 and read -d '' for safe filename handling
find "${{SYSTEMD_SOURCE_DIR}}" -maxdepth 1 -type f \\( -name '*.service' -o -name '*.timer' \\) -print0 | while IFS= read -r -d '' source_unit; do
    unit_name=$(basename "${{source_unit}}")
    target_link="${{SYSTEMD_TARGET_DIR}}/${{unit_name}}"
    log "  Linking ${{unit_name}}..."
    # Use ln -sf: symbolic, force overwrite if link exists
    if ln -sf "${{source_unit}}" "${{target_link}}"; then
        linked_any=1
    else
        log "  WARNING: Failed to link ${{unit_name}}."
    fi
done

if [ $linked_any -eq 0 ]; then
    log "No unit files found in ${{SYSTEMD_SOURCE_DIR}} to link."
else
    log "Reloading systemd daemon after linking units..."
    # Reload daemon again (might be redundant if Docker restart already did it, but safe)
    systemctl daemon-reload || log "WARNING: systemctl daemon-reload failed after linking units."

    log "Enabling systemd timers/services..."
    enabled_any=0
    # Define ALL units expected to be enabled by this script
    UNITS_TO_ENABLE="docker-backup.timer docker-purge.timer docker-shutdown-backup.service docker-health-check.timer docker-volume-check.timer"
    final_enabled_list=""
    # Use 'for unit in $UNITS_TO_ENABLE' which relies on word splitting
    # shellcheck disable=SC2086
    for unit in $UNITS_TO_ENABLE; do
        # Check if the link exists and points to a file before enabling
        if [ -L "${{SYSTEMD_TARGET_DIR}}/${{unit}}" ] &amp;&amp; [ -f "${{SYSTEMD_TARGET_DIR}}/${{unit}}" ]; then
            log "  Enabling ${{unit}}..."
            # Use --now to also start timers immediately if desired, otherwise just enable
            if systemctl enable "${{unit}}"; then
                enabled_any=1
                final_enabled_list="${{final_enabled_list}} ${{unit}}"
            else
                log "  WARNING: Failed to enable ${{unit}}."
            fi
        else
            log "  Skipping enable for ${{unit}} (link missing or broken)."
        fi
    done

    if [ $enabled_any -eq 1 ]; then
        final_enabled_list=$(echo "${{final_enabled_list}}" | sed 's/^ *//') # Remove leading space
        log "Systemd units enabled successfully: ${{final_enabled_list}}"
    else
        log "No relevant systemd units were successfully enabled."
    fi
fi # end if linked_any else
log "WARNING: Systemd source directory ${{SYSTEMD_SOURCE_DIR}} not found or not readable. Cannot enable units." fi log "Systemd unit setup finished."
</code></section></div></div>
  <h1 id="-script-finish-logging-">
    
    
     <a href="#-script-finish-logging-">#</a><a href="#" aria-label="Back to top">— Script Finish Logging —</a>
        
    
  </h1>
      
<p>log “Finished custom boot commands successfully.”</p>
  <h1 id="clear-trap-explicitly">
    
    
     <a href="#clear-trap-explicitly">#</a><a href="#" aria-label="Back to top">Clear trap explicitly</a>
        
    
  </h1>
      
<p>trap - EXIT HUP INT QUIT TERM
exit 0
“””</p>
  <h1 id="-tailscale-key-">
    
    
     <a href="#-tailscale-key-">#</a><a href="#" aria-label="Back to top">— Tailscale Key —</a>
        
    
  </h1>
      
  <h1 id="-replace-this-with-your-actual-key-">
    
    
     <a href="#-replace-this-with-your-actual-key-">#</a><a href="#" aria-label="Back to top">!!! REPLACE THIS WITH YOUR ACTUAL KEY !!!</a>
        
    
  </h1>
      
<p>SBNB_TSKEY_TXT_CONTENT = “tskey-auth-…” # Placeholder</p>
  <h1 id="-backup-script-">
    
    
     <a href="#-backup-script-">#</a><a href="#" aria-label="Back to top">— Backup Script —</a>
        
    
  </h1>
      
<p>BACKUP_DOCKER_SH_CONTENT = f”””#!/bin/sh</p>
  <h1 id="file-data_mountscriptsbackup-dockersh">
    
    
     <a href="#file-data_mountscriptsbackup-dockersh">#</a><a href="#" aria-label="Back to top">File: {DATA_MOUNT}/scripts/backup-docker.sh</a>
        
    
  </h1>
      
  <h1 id="backs-up-the-persistent-docker-data-root-directory">
    
    
     <a href="#backs-up-the-persistent-docker-data-root-directory">#</a><a href="#" aria-label="Back to top">Backs up the persistent Docker data-root directory.</a>
        
    
  </h1>
      

<p>set -e -u</p>
  <h1 id="-configuration-">
    
    
     <a href="#-configuration-">#</a><a href="#" aria-label="Back to top">— Configuration —</a>
        
    
  </h1>
      
<p>DOCKER_DATA_DIR=”{PERSISTENT_DOCKER_ROOT}” # Source is PERSISTENT root
BACKUP_DIR=”{BACKUP_BASE_DIR}”
TIMESTAMP=$(date +”%Y%m%d_%H%M%S”)
BACKUP_FILE=”${{BACKUP_DIR}}/docker_backup_${{TIMESTAMP}}.tar.gz”
LATEST_LINK=”${{BACKUP_DIR}}/docker_latest.tar.gz”
STOP_DOCKER={STOP_DOCKER_FOR_BACKUP} # 1=Stop Docker (safer), 0=Live backup</p>

<p>log() {{ echo “[backup-docker.sh] $1” &gt; /dev/kmsg; }}</p>
  <h1 id="-check-commands-">
    
    
     <a href="#-check-commands-">#</a><a href="#" aria-label="Back to top">— Check Commands —</a>
        
    
  </h1>
      
<p>log “Checking required commands…”
check_cmds() {{
    local missing_cmd=0
    for cmd in “$@”; do
        if ! command -v “$cmd” &gt;/dev/null 2&gt;&amp;1; then log “ERROR: Command ‘$cmd’ not found.”; missing_cmd=1; fi
    done
    # Exit if any command is missing
    [ $missing_cmd -eq 1 ] &amp;&amp; exit 1
}}</p>
  <h1 id="core-commands-needed">
    
    
     <a href="#core-commands-needed">#</a><a href="#" aria-label="Back to top">Core commands needed</a>
        
    
  </h1>
      
<p>check_cmds date mkdir tar gzip ln mv sleep dirname basename</p>
  <h1 id="check-systemctl-only-if-stopping-docker-is-enabled">
    
    
     <a href="#check-systemctl-only-if-stopping-docker-is-enabled">#</a><a href="#" aria-label="Back to top">Check systemctl only if stopping docker is enabled</a>
        
    
  </h1>
      
<p>[ $STOP_DOCKER -eq 1 ] &amp;&amp; check_cmds systemctl</p>
  <h1 id="check-for-optional-nice-command">
    
    
     <a href="#check-for-optional-nice-command">#</a><a href="#" aria-label="Back to top">Check for optional ‘nice’ command</a>
        
    
  </h1>
      
<p>NICE_CMD=””
if command -v nice &gt;/dev/null 2&gt;&amp;1; then NICE_CMD=”nice -n 19”; log “Using nice for lower tar priority.”; fi</p>
  <h1 id="-main-logic-">
    
    
     <a href="#-main-logic-">#</a><a href="#" aria-label="Back to top">— Main Logic —</a>
        
    
  </h1>
      
<p>log “Starting Docker backup process…”
log “Source:         ${{DOCKER_DATA_DIR}}”
log “Destination:    ${{BACKUP_FILE}}”</p>
  <h1 id="ensure-backup-directory-exists-and-is-writable">
    
    
     <a href="#ensure-backup-directory-exists-and-is-writable">#</a><a href="#" aria-label="Back to top">Ensure backup directory exists and is writable</a>
        
    
  </h1>
      
<p>log “Ensuring backup directory exists: ${{BACKUP_DIR}}”
mkdir -p “${{BACKUP_DIR}}”</p>
  <h1 id="check-write-permissions-specifically">
    
    
     <a href="#check-write-permissions-specifically">#</a><a href="#" aria-label="Back to top">Check write permissions specifically</a>
        
    
  </h1>
      
<p>if [ ! -w “${{BACKUP_DIR}}” ]; then log “ERROR: Backup directory not writable: ${{BACKUP_DIR}}”; exit 1; fi</p>
  <h1 id="stop-docker-if-configured">
    
    
     <a href="#stop-docker-if-configured">#</a><a href="#" aria-label="Back to top">Stop Docker if configured</a>
        
    
  </h1>
      
<p>DOCKER_WAS_RUNNING=0
if [ $STOP_DOCKER -eq 1 ]; then
    log “Attempting to stop Docker service…”
    if systemctl is-active –quiet docker.service; then
        DOCKER_WAS_RUNNING=1
        log “Docker service is active, stopping…”
        if systemctl stop docker.service; then
            log “Docker service stopped. Waiting 5s for files to release…”; sleep 5
        else
            # If stop fails, warn but maybe proceed? Or exit? Exiting might be safer.
            log “ERROR: Failed to stop Docker service gracefully! Backup might be inconsistent or fail. Aborting.”
            exit 1 # Exit if stop fails, as backup consistency is compromised
        fi
    else
        log “Docker service already stopped.”
    fi
fi</p>
  <h1 id="create-backup">
    
    
     <a href="#create-backup">#</a><a href="#" aria-label="Back to top">Create backup</a>
        
    
  </h1>
      
<p>log “Creating backup archive…”
if [ -d “${{DOCKER_DATA_DIR}}” ] &amp;&amp; [ -r “${{DOCKER_DATA_DIR}}” ]; then
    PARENT_DIR=$(dirname “${{DOCKER_DATA_DIR}}”)
    SOURCE_BASENAME=$(basename “${{DOCKER_DATA_DIR}}”)
    log “Archiving ‘${{SOURCE_BASENAME}}’ from parent ‘${{PARENT_DIR}}’…”
    # Use -C to change directory, archive relative path ‘docker-root/…’
    # Add –warning=no-file-changed to suppress warnings about files changing during read
    # shellcheck disable=SC2086 # Allow word splitting for $NICE_CMD
    if ${{NICE_CMD}} tar –warning=no-file-changed -czf “${{BACKUP_FILE}}” -C “${{PARENT_DIR}}” “${{SOURCE_BASENAME}}”; then
        log “Backup archive created successfully.”
        # Verify backup file exists and is not empty
        if [ -s “${{BACKUP_FILE}}” ]; then
            log “Updating latest backup link…”
            # Atomic symlink update: create temp link, then rename over old one
            ln -sfT “${{BACKUP_FILE}}” “${{LATEST_LINK}}.tmp” &amp;&amp; mv -Tf “${{LATEST_LINK}}.tmp” “${{LATEST_LINK}}”
            if [ $? -eq 0 ]; then
                log “Updated latest link to point to ${{BACKUP_FILE}}.”
            else
                log “WARNING: Failed to update latest backup link.”
                rm -f “${{LATEST_LINK}}.tmp” # Clean up temp link if mv failed
            fi
        else
            log “WARNING: Backup file seems invalid (empty/missing): ${{BACKUP_FILE}}. Removing.”
            rm -f “${{BACKUP_FILE}}”
        fi
    else
        tar_exit_code=$?
        log “ERROR: tar command failed with exit code ${{tar_exit_code}}! Backup failed.”
        rm -f “${{BACKUP_FILE}}” # Clean up partial archive if tar failed
    fi
else
    log “WARNING: Docker data directory not found or not readable: ${{DOCKER_DATA_DIR}}. Skipping backup.”
fi</p>
  <h1 id="restart-docker-if-it-was-running-and-we-stopped-it-successfully">
    
    
     <a href="#restart-docker-if-it-was-running-and-we-stopped-it-successfully">#</a><a href="#" aria-label="Back to top">Restart Docker if it was running and we stopped it successfully</a>
        
    
  </h1>
      
<p>if [ $DOCKER_WAS_RUNNING -eq 1 ]; then
    log “Restarting Docker service…”
    if ! systemctl start docker.service; then
        log “WARNING: Failed to restart Docker service after backup.”
    else
        log “Docker service restarted.”
    fi
fi</p>

<p>log “Docker backup process finished.”
exit 0
“””</p>
  <h1 id="-purge-script-">
    
    
     <a href="#-purge-script-">#</a><a href="#" aria-label="Back to top">— Purge Script —</a>
        
    
  </h1>
      
<p>PURGE_DOCKER_BACKUPS_SH_CONTENT = f”””#!/bin/sh</p>
  <h1 id="file-data_mountscriptspurge-docker-backupssh">
    
    
     <a href="#file-data_mountscriptspurge-docker-backupssh">#</a><a href="#" aria-label="Back to top">File: {DATA_MOUNT}/scripts/purge-docker-backups.sh</a>
        
    
  </h1>
      
  <h1 id="removes-old-docker-backups-keeping-the-last-n">
    
    
     <a href="#removes-old-docker-backups-keeping-the-last-n">#</a><a href="#" aria-label="Back to top">Removes old Docker backups, keeping the last N.</a>
        
    
  </h1>
      

<p>set -e -u</p>

<p>BACKUP_DIR=”{BACKUP_BASE_DIR}”
KEEP_COUNT={BACKUP_KEEP_COUNT}</p>

<p>log() {{ echo “[purge-docker-backups.sh] $1” &gt; /dev/kmsg; }}</p>
  <h1 id="check-commands">
    
    
     <a href="#check-commands">#</a><a href="#" aria-label="Back to top">Check commands</a>
        
    
  </h1>
      
<p>check_cmds() {{
    local missing_cmd=0
    for cmd in “$@”; do if ! command -v “$cmd” &gt;/dev/null 2&gt;&amp;1; then log “ERROR: Command ‘$cmd’ not found.”; missing_cmd=1; fi; done
    [ $missing_cmd -eq 1 ] &amp;&amp; exit 1
}}
check_cmds find wc sort head cut xargs rm mkdir date</p>

<p>log “Purging old Docker backups in ${{BACKUP_DIR}}, keeping ${{KEEP_COUNT}}…”</p>
  <h1 id="validate-keep_count">
    
    
     <a href="#validate-keep_count">#</a><a href="#" aria-label="Back to top">Validate KEEP_COUNT</a>
        
    
  </h1>
      
<p>if ! [ “$KEEP_COUNT” -ge 0 ] 2&gt;/dev/null; then log “ERROR: KEEP_COUNT (${{KEEP_COUNT}}) is invalid.”; exit 1; fi</p>
  <h1 id="ensure-backup-directory-exists-and-is-accessible">
    
    
     <a href="#ensure-backup-directory-exists-and-is-accessible">#</a><a href="#" aria-label="Back to top">Ensure backup directory exists and is accessible</a>
        
    
  </h1>
      
<p>if ! mkdir -p “${{BACKUP_DIR}}”; then log “ERROR: Failed to create backup directory ${{BACKUP_DIR}}!”; exit 1; fi
if [ ! -d “${{BACKUP_DIR}}” ] || [ ! -r “${{BACKUP_DIR}}” ] || [ ! -w “${{BACKUP_DIR}}” ]; then log “ERROR: Cannot access backup directory ${{BACKUP_DIR}}!”; exit 1; fi</p>
  <h1 id="count-existing-backups-safely">
    
    
     <a href="#count-existing-backups-safely">#</a><a href="#" aria-label="Back to top">Count existing backups safely</a>
        
    
  </h1>
      
<p>log “Counting existing backup files…”
backup_count=$(find “${{BACKUP_DIR}}” -maxdepth 1 -name ‘docker_backup_*.tar.gz’ -type f -print 2&gt;/dev/null | wc -l)
find_exit_code=$?</p>

<p>if [ $find_exit_code -ne 0 ]; then log “WARNING: find command failed (${{find_exit_code}}) while counting backups. Skipping purge.”; exit 0; fi
log “Found ${{backup_count}} backup files.”</p>

<p>if [ “$backup_count” -gt “$KEEP_COUNT” ]; then
    to_delete_count=$(( backup_count - KEEP_COUNT ))
    log “Need to delete ${{to_delete_count}} oldest backup(s).”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># Use find -printf with null terminators for safe filename handling
log "Identifying oldest backups to delete..."
delete_output=$(find "${{BACKUP_DIR}}" -maxdepth 1 -name 'docker_backup_*.tar.gz' -type f -printf '%T@ %p\\0' 2&gt;/dev/null | \\
    sort -zn | \\
    head -zn "${{to_delete_count}}" | \\
    cut -z -d' ' -f2- | \\
    xargs -0 -r rm -v -- 2&gt;&amp;1) # Capture rm output (stdout+stderr)
rm_exit_code=$?

if [ $rm_exit_code -eq 0 ]; then
    log "Purge completed successfully."
    if [ -n "$delete_output" ]; then
        log "Deleted files:"
        # Log multi-line output safely
        echo "$delete_output" | while IFS= read -r line || [ -n "$line" ]; do log "  $line"; done
    fi
else
    log "WARNING: Purge command (rm) failed (exit code ${{rm_exit_code}}). Check output below."
    log "rm output:"
    echo "$delete_output" | while IFS= read -r line || [ -n "$line" ]; do log "  $line"; done
fi else
log "${{backup_count}} backups found &lt;= ${{KEEP_COUNT}}. No backups purged." fi
</code></section></div></div>

<p>log “Backup purge process finished.”
exit 0
“””</p>
  <h1 id="-health-check-script-">
    
    
     <a href="#-health-check-script-">#</a><a href="#" aria-label="Back to top">— Health Check Script —</a>
        
    
  </h1>
      
<p>DOCKER_HEALTH_CHECK_SH_CONTENT = f”””#!/bin/sh</p>
  <h1 id="file-data_mountscriptsdocker-health-checksh">
    
    
     <a href="#file-data_mountscriptsdocker-health-checksh">#</a><a href="#" aria-label="Back to top">File: {DATA_MOUNT}/scripts/docker-health-check.sh</a>
        
    
  </h1>
      
  <h1 id="checks-docker-daemon-health-responsiveness-and-data-root-configuration">
    
    
     <a href="#checks-docker-daemon-health-responsiveness-and-data-root-configuration">#</a><a href="#" aria-label="Back to top">Checks Docker daemon health, responsiveness, and data-root configuration.</a>
        
    
  </h1>
      

<p>set -e -u</p>

<p>PERSISTENT_ROOT=”{PERSISTENT_DOCKER_ROOT}”
DOCKER_CONFIG_FILE=”{DOCKER_CONFIG_FILE}”</p>

<table>
  <tbody>
    <tr>
      <td>log() {{ echo “[docker-health-check] $1”</td>
      <td>tee /dev/kmsg; }} # Log to kmsg and stdout/stderr</td>
    </tr>
  </tbody>
</table>

<p>log “Starting Docker health check…”</p>
  <h1 id="check-required-commands">
    
    
     <a href="#check-required-commands">#</a><a href="#" aria-label="Back to top">Check required commands</a>
        
    
  </h1>
      
<p>check_cmds() {{ for cmd in “$@”; do if ! command -v “$cmd” &gt;/dev/null 2&gt;&amp;1; then log “ERROR: Command ‘$cmd’ not found.”; exit 1; fi; done }}
check_cmds systemctl docker</p>
  <h1 id="check-if-docker-daemon-service-is-running">
    
    
     <a href="#check-if-docker-daemon-service-is-running">#</a><a href="#" aria-label="Back to top">Check if Docker daemon service is running</a>
        
    
  </h1>
      
<p>log “Checking if docker.service is active…”
if ! systemctl is-active –quiet docker.service; then
    log “WARNING: Docker service is not running. Attempting restart…”
    if systemctl restart docker.service; then
        log “Docker service restarted successfully.”
        sleep 5 # Give it time to fully start
    else
        log “ERROR: Failed to restart inactive Docker service!”
        exit 1 # Critical failure if it should be running but can’t be started
    fi
fi</p>
  <h1 id="verify-docker-daemon-is-responding-to-commands">
    
    
     <a href="#verify-docker-daemon-is-responding-to-commands">#</a><a href="#" aria-label="Back to top">Verify Docker daemon is responding to commands</a>
        
    
  </h1>
      
<p>log “Checking Docker daemon responsiveness via ‘docker info’…”
if ! docker info &gt; /dev/null 2&gt;&amp;1; then
    log “WARNING: Docker service is running but ‘docker info’ command failed. Attempting restart…”
    if systemctl restart docker.service; then
        log “Docker service restarted successfully.”
        sleep 5 # Give it time
        # Re-check responsiveness after restart
        if ! docker info &gt; /dev/null 2&gt;&amp;1; then
            log “ERROR: Docker daemon still not responding after restart! Requires manual investigation.”
            exit 1 # Critical failure
        else
            log “Docker daemon is now responsive after restart.”
        fi
    else
        log “ERROR: Failed to restart unresponsive Docker service!”
        exit 1 # Critical failure
    fi
else
    log “Docker daemon is responsive.”
fi</p>
  <h1 id="check-if-docker-is-using-the-correct-data-root-directory">
    
    
     <a href="#check-if-docker-is-using-the-correct-data-root-directory">#</a><a href="#" aria-label="Back to top">Check if Docker is using the correct data-root directory</a>
        
    
  </h1>
      
<p>log “Checking configured Docker data-root directory…”</p>
  <h1 id="use-docker-info-with-go-template-for-precise-extraction">
    
    
     <a href="#use-docker-info-with-go-template-for-precise-extraction">#</a><a href="#" aria-label="Back to top">Use docker info with Go template for precise extraction</a>
        
    
  </h1>
      
<p>CURRENT_ROOT=$(docker info –format ‘{{{{.DockerRootDir}}}}’ 2&gt;/dev/null || echo “ERROR_GETTING_INFO”)</p>

<p>if [ “$CURRENT_ROOT” = “ERROR_GETTING_INFO” ]; then
    log “ERROR: Could not determine Docker’s current data-root using ‘docker info’. Health check incomplete.”
    exit 1 # Exit as this is a significant issue
elif [ “$CURRENT_ROOT” != “$PERSISTENT_ROOT” ]; then
    log “CRITICAL ERROR: Docker is using incorrect data-root!”
    log “  Expected: $PERSISTENT_ROOT”
    log “  Actual:   $CURRENT_ROOT”
    log “This indicates a configuration problem in $DOCKER_CONFIG_FILE or Docker failed to apply it. Manual intervention required.”
    exit 1 # Critical configuration error
else
    log “Docker is correctly using the persistent data-root: $PERSISTENT_ROOT”
fi</p>

<p>log “Docker health check completed successfully.”
exit 0
“””</p>
  <h1 id="-volume-check-script-">
    
    
     <a href="#-volume-check-script-">#</a><a href="#" aria-label="Back to top">— Volume Check Script —</a>
        
    
  </h1>
      
  <h1 id="define-prune-command-based-on-configuration">
    
    
     <a href="#define-prune-command-based-on-configuration">#</a><a href="#" aria-label="Back to top">Define prune command based on configuration</a>
        
    
  </h1>
      
<p>if VOLUME_CHECK_PRUNE_LEVEL == 0:
    PRUNE_COMMAND = “echo ‘Automatic pruning disabled.’” # No-op
elif VOLUME_CHECK_PRUNE_LEVEL == 1:
    # Prune stopped containers and dangling images only
    PRUNE_COMMAND = “docker container prune -f &amp;&amp; docker image prune -f”
elif VOLUME_CHECK_PRUNE_LEVEL &gt;= 2:
    # Prune stopped containers and <em>all</em> unused images (more aggressive)
    PRUNE_COMMAND = “docker container prune -f &amp;&amp; docker image prune -a -f”
else: # Default to level 1 if invalid config
    PRUNE_COMMAND = “docker container prune -f &amp;&amp; docker image prune -f”</p>

<p>DOCKER_VOLUME_CHECK_SH_CONTENT = f”””#!/bin/sh</p>
  <h1 id="file-data_mountscriptsdocker-volume-checksh">
    
    
     <a href="#file-data_mountscriptsdocker-volume-checksh">#</a><a href="#" aria-label="Back to top">File: {DATA_MOUNT}/scripts/docker-volume-check.sh</a>
        
    
  </h1>
      
  <h1 id="checks-free-space-on-the-docker-persistent-volume-and-optionally-prunes-resources">
    
    
     <a href="#checks-free-space-on-the-docker-persistent-volume-and-optionally-prunes-resources">#</a><a href="#" aria-label="Back to top">Checks free space on the Docker persistent volume and optionally prunes resources.</a>
        
    
  </h1>
      

<p>set -e -u</p>

<p>DOCKER_ROOT=”{PERSISTENT_DOCKER_ROOT}”
MIN_FREE_PERCENT={VOLUME_CHECK_THRESHOLD_PERCENT}</p>
  <h1 id="prune-command-determined-by-python-script-configuration-level-volume_check_prune_level">
    
    
     <a href="#prune-command-determined-by-python-script-configuration-level-volume_check_prune_level">#</a><a href="#" aria-label="Back to top">Prune command determined by Python script configuration (Level: {VOLUME_CHECK_PRUNE_LEVEL})</a>
        
    
  </h1>
      
<p>PRUNE_CMD=”{PRUNE_COMMAND}”</p>

<table>
  <tbody>
    <tr>
      <td>log() {{ echo “[docker-volume-check] $1”</td>
      <td>tee /dev/kmsg; }}</td>
    </tr>
  </tbody>
</table>

<p>log “Checking Docker volume free space: ${{DOCKER_ROOT}}”</p>
  <h1 id="check-required-commands-1">
    
    
     <a href="#check-required-commands-1">#</a><a href="#" aria-label="Back to top">Check required commands</a>
        
    
  </h1>
      
<p>check_cmds() {{ for cmd in “$@”; do if ! command -v “$cmd” &gt;/dev/null 2&gt;&amp;1; then log “ERROR: Command ‘$cmd’ not found.”; exit 1; fi; done }}
check_cmds df awk sed docker # Need docker if pruning is enabled</p>
  <h1 id="check-if-the-docker-root-directory-exists">
    
    
     <a href="#check-if-the-docker-root-directory-exists">#</a><a href="#" aria-label="Back to top">Check if the Docker root directory exists</a>
        
    
  </h1>
      
<p>if [ ! -d “$DOCKER_ROOT” ]; then log “ERROR: Docker root directory not found: $DOCKER_ROOT”; exit 1; fi</p>
  <h1 id="get-free-space-percentage-using-df--p-for-posix-compatibility">
    
    
     <a href="#get-free-space-percentage-using-df--p-for-posix-compatibility">#</a><a href="#" aria-label="Back to top">Get free space percentage using df -P for POSIX compatibility</a>
        
    
  </h1>
      
<p>log “Calculating free space…”</p>
  <h1 id="get-available-and-total-blocks-in-1k-blocks-usually">
    
    
     <a href="#get-available-and-total-blocks-in-1k-blocks-usually">#</a><a href="#" aria-label="Back to top">Get Available and Total blocks (in 1K blocks usually)</a>
        
    
  </h1>
      
<p>df_output=$(df -P “$DOCKER_ROOT” | awk ‘NR==2 {{print $4, $2}}’ 2&gt;/dev/null)
if [ -z “$df_output” ]; then log “ERROR: Failed to get disk usage using df for $DOCKER_ROOT”; exit 1; fi</p>

<table>
  <tbody>
    <tr>
      <td>avail_kb=$(echo “$df_output”</td>
      <td>awk ‘{{print $1}}’)</td>
    </tr>
    <tr>
      <td>total_kb=$(echo “$df_output”</td>
      <td>awk ‘{{print $2}}’)</td>
    </tr>
  </tbody>
</table>
  <h1 id="handle-edge-case-where-total-size-is-0-or-df-failed-weirdly">
    
    
     <a href="#handle-edge-case-where-total-size-is-0-or-df-failed-weirdly">#</a><a href="#" aria-label="Back to top">Handle edge case where total size is 0 or df failed weirdly</a>
        
    
  </h1>
      
<p>if [ -z “$total_kb” ] || [ “$total_kb” -le 0 ]; then
    log “WARNING: Total disk size reported as zero or invalid for $DOCKER_ROOT. Cannot calculate percentage.”
    exit 0
fi</p>
  <h1 id="calculate-free-percentage-using-integer-arithmetic">
    
    
     <a href="#calculate-free-percentage-using-integer-arithmetic">#</a><a href="#" aria-label="Back to top">Calculate free percentage using integer arithmetic</a>
        
    
  </h1>
      
<p>free_percent=$(( (avail_kb * 100) / total_kb ))</p>
  <h1 id="get-human-readable-sizes-for-logging">
    
    
     <a href="#get-human-readable-sizes-for-logging">#</a><a href="#" aria-label="Back to top">Get human-readable sizes for logging</a>
        
    
  </h1>
      
<p>total_size_hr=$(df -h “$DOCKER_ROOT” | awk ‘NR==2 {{print $2}}’)
avail_size_hr=$(df -h “$DOCKER_ROOT” | awk ‘NR==2 {{print $4}}’)</p>

<p>log “Volume Stats: Total=${{total_size_hr}}, Available=${{avail_size_hr}}, Free=${{free_percent}}%”</p>
  <h1 id="check-against-threshold">
    
    
     <a href="#check-against-threshold">#</a><a href="#" aria-label="Back to top">Check against threshold</a>
        
    
  </h1>
      
<p>if [ “$free_percent” -lt “$MIN_FREE_PERCENT” ]; then
    log “WARNING: Low disk space! Free: ${{free_percent}}% (Threshold: ${{MIN_FREE_PERCENT}}%)”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># Attempt to prune based on configured level
if [ {VOLUME_CHECK_PRUNE_LEVEL} -gt 0 ]; then
    log "Attempting automatic prune (Level: {VOLUME_CHECK_PRUNE_LEVEL})..."
    prune_output=$({PRUNE_COMMAND} 2&gt;&amp;1) || prune_exit_code=$?
    # Check exit code, prune can return non-zero even if it works partially
    if [ "${{prune_exit_code:-0}}" -eq 0 ]; then
        log "Docker prune command executed successfully."
    else
        log "WARNING: Docker prune command finished with exit code ${{prune_exit_code}}."
    fi
    log "Prune output:"
    echo "$prune_output" | while IFS= read -r line || [ -n "$line" ]; do log "  $line"; done

    # Recalculate free space after pruning
    log "Recalculating space after cleanup..."
    df_output=$(df -P "$DOCKER_ROOT" | awk 'NR==2 {{print $4, $2}}' 2&gt;/dev/null)
    avail_kb=$(echo "$df_output" | awk '{{print $1}}')
    total_kb=$(echo "$df_output" | awk '{{print $2}}')
    if [ "$total_kb" -gt 0 ]; then free_percent=$(( (avail_kb * 100) / total_kb )); else free_percent=0; fi
    avail_size_hr=$(df -h "$DOCKER_ROOT" | awk 'NR==2 {{print $4}}')

    log "Space after cleanup: Available=${{avail_size_hr}}, Free=${{free_percent}}%"
    if [ "$free_percent" -lt "$MIN_FREE_PERCENT" ]; then
        log "ERROR: Space still critically low after cleanup! Manual intervention likely required."
    else
        log "Space is now above threshold after cleanup."
    fi
else
     log "Automatic pruning is disabled (Level 0). Manual cleanup needed."
fi else
log "Sufficient free space available (${{free_percent}}%)." fi
</code></section></div></div>

<p>log “Docker volume check completed.”
exit 0
“””</p>
  <h1 id="-systemd-units-content-definitions-remain-the-same-as-previous-version-">
    
    
     <a href="#-systemd-units-content-definitions-remain-the-same-as-previous-version-">#</a><a href="#" aria-label="Back to top">— Systemd Units (Content definitions remain the same as previous version) —</a>
        
    
  </h1>
      
  <h1 id="backup-service">
    
    
     <a href="#backup-service">#</a><a href="#" aria-label="Back to top">Backup Service</a>
        
    
  </h1>
      
<p>DOCKER_BACKUP_SERVICE_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-backup.service
[Unit]
Description=Backup Docker Data ({PERSISTENT_DOCKER_ROOT})
Documentation=file://{DATA_MOUNT}/scripts/backup-docker.sh
Requires=mnt-sbnb-data.mount
After=mnt-sbnb-data.mount docker.service # Ensure mount and docker are up</p>

<p>[Service]
Type=oneshot
ExecStart=/bin/sh {DATA_MOUNT}/scripts/backup-docker.sh
“””</p>
  <h1 id="backup-timer">
    
    
     <a href="#backup-timer">#</a><a href="#" aria-label="Back to top">Backup Timer</a>
        
    
  </h1>
      
<p>DOCKER_BACKUP_TIMER_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-backup.timer
[Unit]
Description=Daily Docker Backup Timer ({PERSISTENT_DOCKER_ROOT})
Requires=docker-backup.service</p>

<p>[Timer]
OnCalendar=<em>-</em>-* 05:00:00
AccuracySec=1h
Persistent=true
RandomizedDelaySec=600 # 10 minutes
Unit=docker-backup.service</p>

<p>[Install]
WantedBy=timers.target
“””</p>
  <h1 id="purge-service">
    
    
     <a href="#purge-service">#</a><a href="#" aria-label="Back to top">Purge Service</a>
        
    
  </h1>
      
<p>DOCKER_PURGE_SERVICE_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-purge.service
[Unit]
Description=Purge Old Docker Backups ({BACKUP_BASE_DIR})
Documentation=file://{DATA_MOUNT}/scripts/purge-docker-backups.sh
Requires=mnt-sbnb-data.mount
After=mnt-sbnb-data.mount</p>

<p>[Service]
Type=oneshot
ExecStart=/bin/sh {DATA_MOUNT}/scripts/purge-docker-backups.sh
“””</p>
  <h1 id="purge-timer">
    
    
     <a href="#purge-timer">#</a><a href="#" aria-label="Back to top">Purge Timer</a>
        
    
  </h1>
      
<p>DOCKER_PURGE_TIMER_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-purge.timer
[Unit]
Description=Daily Docker Backup Purge Timer
Requires=docker-purge.service</p>

<p>[Timer]
OnCalendar=<em>-</em>-* 06:00:00
AccuracySec=1h
Persistent=true
RandomizedDelaySec=300 # 5 minutes
Unit=docker-purge.service</p>

<p>[Install]
WantedBy=timers.target
“””</p>
  <h1 id="shutdown-backup-service">
    
    
     <a href="#shutdown-backup-service">#</a><a href="#" aria-label="Back to top">Shutdown Backup Service</a>
        
    
  </h1>
      
<p>DOCKER_SHUTDOWN_BACKUP_SERVICE_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-shutdown-backup.service
[Unit]
Description=Backup Docker Data ({PERSISTENT_DOCKER_ROOT}) on Shutdown (Best Effort)
Documentation=file://{DATA_MOUNT}/scripts/backup-docker.sh
DefaultDependencies=no # Crucial for shutdown units
Requires=mnt-sbnb-data.mount docker.service
After=mnt-sbnb-data.mount docker.service network.target
Before=shutdown.target reboot.target halt.target kexec.target umount.target final.target</p>

<p>[Service]
Type=oneshot
RemainAfterExit=true # Important for ExecStop= during shutdown
TimeoutStopSec=180 # Give backup reasonable time (3 minutes)
ExecStop=/bin/sh {DATA_MOUNT}/scripts/backup-docker.sh # Run backup on stop</p>

<p>[Install]
WantedBy=shutdown.target reboot.target halt.target kexec.target
“””</p>
  <h1 id="health-check-service">
    
    
     <a href="#health-check-service">#</a><a href="#" aria-label="Back to top">Health Check Service</a>
        
    
  </h1>
      
<p>DOCKER_HEALTH_SERVICE_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-health-check.service
[Unit]
Description=Docker Health Check Service
Documentation=file://{DATA_MOUNT}/scripts/docker-health-check.sh
Requires=mnt-sbnb-data.mount docker.service
After=mnt-sbnb-data.mount docker.service</p>

<p>[Service]
Type=oneshot
ExecStart=/bin/sh {DATA_MOUNT}/scripts/docker-health-check.sh</p>
  <h1 id="optional-resource-limits">
    
    
     <a href="#optional-resource-limits">#</a><a href="#" aria-label="Back to top">Optional resource limits</a>
        
    
  </h1>
      
  <h1 id="cpuquota10">
    
    
     <a href="#cpuquota10">#</a><a href="#" aria-label="Back to top">CPUQuota=10%</a>
        
    
  </h1>
      
  <h1 id="memorymax128m">
    
    
     <a href="#memorymax128m">#</a><a href="#" aria-label="Back to top">MemoryMax=128M</a>
        
    
  </h1>
      
<p>”””</p>
  <h1 id="health-check-timer">
    
    
     <a href="#health-check-timer">#</a><a href="#" aria-label="Back to top">Health Check Timer</a>
        
    
  </h1>
      
<p>DOCKER_HEALTH_TIMER_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-health-check.timer
[Unit]
Description=Regular Docker Health Check Timer
Requires=docker-health-check.service</p>

<p>[Timer]</p>
  <h1 id="run-5-mins-after-boot-then-every-15-mins">
    
    
     <a href="#run-5-mins-after-boot-then-every-15-mins">#</a><a href="#" aria-label="Back to top">Run 5 mins after boot, then every 15 mins</a>
        
    
  </h1>
      
<p>OnBootSec=5min
OnUnitActiveSec=15min
AccuracySec=1min
Unit=docker-health-check.service</p>

<p>[Install]
WantedBy=timers.target
“””</p>
  <h1 id="volume-check-service">
    
    
     <a href="#volume-check-service">#</a><a href="#" aria-label="Back to top">Volume Check Service</a>
        
    
  </h1>
      
<p>DOCKER_VOLUME_SERVICE_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-volume-check.service
[Unit]
Description=Docker Volume Space Check Service ({PERSISTENT_DOCKER_ROOT})
Documentation=file://{DATA_MOUNT}/scripts/docker-volume-check.sh
Requires=mnt-sbnb-data.mount docker.service
After=mnt-sbnb-data.mount docker.service</p>

<p>[Service]
Type=oneshot
ExecStart=/bin/sh {DATA_MOUNT}/scripts/docker-volume-check.sh</p>
  <h1 id="optional-resource-limits-1">
    
    
     <a href="#optional-resource-limits-1">#</a><a href="#" aria-label="Back to top">Optional resource limits</a>
        
    
  </h1>
      
  <h1 id="cpuquota10-1">
    
    
     <a href="#cpuquota10-1">#</a><a href="#" aria-label="Back to top">CPUQuota=10%</a>
        
    
  </h1>
      
  <h1 id="memorymax64m">
    
    
     <a href="#memorymax64m">#</a><a href="#" aria-label="Back to top">MemoryMax=64M</a>
        
    
  </h1>
      
<p>”””</p>
  <h1 id="volume-check-timer">
    
    
     <a href="#volume-check-timer">#</a><a href="#" aria-label="Back to top">Volume Check Timer</a>
        
    
  </h1>
      
<p>DOCKER_VOLUME_TIMER_CONTENT = f”””# File: {DATA_MOUNT}/systemd/docker-volume-check.timer
[Unit]
Description=Regular Docker Volume Check Timer
Requires=docker-volume-check.service</p>

<p>[Timer]</p>
  <h1 id="run-10-mins-after-boot-then-every-hour">
    
    
     <a href="#run-10-mins-after-boot-then-every-hour">#</a><a href="#" aria-label="Back to top">Run 10 mins after boot, then every hour</a>
        
    
  </h1>
      
<p>OnBootSec=10min
OnUnitActiveSec=1h
AccuracySec=5min
Unit=docker-volume-check.service</p>

<p>[Install]
WantedBy=timers.target
“””</p>
  <h1 id="-dictionary-of-files-to-create-">
    
    
     <a href="#-dictionary-of-files-to-create-">#</a><a href="#" aria-label="Back to top">— Dictionary of Files to Create —</a>
        
    
  </h1>
      
  <h1 id="defines-all-files-to-be-generated-by-this-script">
    
    
     <a href="#defines-all-files-to-be-generated-by-this-script">#</a><a href="#" aria-label="Back to top">Defines all files to be generated by this script</a>
        
    
  </h1>
      
<p>FILES_TO_CREATE = {
    # — ESP Files —
    f”{ESP_MOUNT}/sbnb-cmds.sh”: {
        “content”: SBNB_CMDS_SH_CONTENT,
        “permissions”: 0o755 # rwxr-xr-x
    },
    f”{ESP_MOUNT}/sbnb-tskey.txt”: {
        “content”: SBNB_TSKEY_TXT_CONTENT,
        “permissions”: 0o600 # rw——- (Restrict access to key)
    },</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># --- Data Partition Files ---
# Helper Scripts
f"{DATA_MOUNT}/scripts/backup-docker.sh": {
    "content": BACKUP_DOCKER_SH_CONTENT,
    "permissions": 0o750 # rwxr-x--- (Owner exec, group read/exec)
},
f"{DATA_MOUNT}/scripts/purge-docker-backups.sh": {
    "content": PURGE_DOCKER_BACKUPS_SH_CONTENT,
    "permissions": 0o750
},
f"{DATA_MOUNT}/scripts/docker-health-check.sh": {
    "content": DOCKER_HEALTH_CHECK_SH_CONTENT,
    "permissions": 0o750
},
f"{DATA_MOUNT}/scripts/docker-volume-check.sh": {
    "content": DOCKER_VOLUME_CHECK_SH_CONTENT,
    "permissions": 0o750
},
# Systemd Units
f"{DATA_MOUNT}/systemd/docker-backup.service": {
    "content": DOCKER_BACKUP_SERVICE_CONTENT,
    "permissions": 0o644 # rw-r--r-- (Standard systemd unit permissions)
},
f"{DATA_MOUNT}/systemd/docker-backup.timer": {
    "content": DOCKER_BACKUP_TIMER_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-purge.service": {
    "content": DOCKER_PURGE_SERVICE_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-purge.timer": {
    "content": DOCKER_PURGE_TIMER_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-shutdown-backup.service": {
    "content": DOCKER_SHUTDOWN_BACKUP_SERVICE_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-health-check.service": {
    "content": DOCKER_HEALTH_SERVICE_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-health-check.timer": {
    "content": DOCKER_HEALTH_TIMER_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-volume-check.service": {
    "content": DOCKER_VOLUME_SERVICE_CONTENT,
    "permissions": 0o644
},
f"{DATA_MOUNT}/systemd/docker-volume-check.timer": {
    "content": DOCKER_VOLUME_TIMER_CONTENT,
    "permissions": 0o644
}, }
</code></section></div></div>
  <h1 id="-global-counters-for-create_files-status-">
    
    
     <a href="#-global-counters-for-create_files-status-">#</a><a href="#" aria-label="Back to top">— Global counters for create_files status —</a>
        
    
  </h1>
      
<p>warning_count = 0
fail_count = 0</p>
  <h1 id="-main-script-logic-">
    
    
     <a href="#-main-script-logic-">#</a><a href="#" aria-label="Back to top">— Main Script Logic —</a>
        
    
  </h1>
      

<p>def check_prerequisites():
    “"”Verify script prerequisites before attempting file creation.”””
    print(“— Checking Prerequisites —”)
    passed = True
    # 1. Check root privileges
    if os.geteuid() != 0:
        print(“ERROR: Script must be run as root (UID 0).”)
        passed = False
    else:
        print(“OK: Running as root.”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># 2. Check base mount points exist and are writable
base_dirs = {ESP_MOUNT: "ESP", DATA_MOUNT: "Data"}
for bdir, name in base_dirs.items():
    bdir_path = pathlib.Path(bdir)
    print(f"Checking {name} mount point: {bdir}...")
    if not bdir_path.is_dir():
        print(f"ERROR: Base {name} directory '{bdir}' does not exist or is not a directory.")
        print(f"       Please ensure the corresponding partition is mounted correctly before running.")
        passed = False
    elif not os.access(bdir_path, os.W_OK):
        print(f"ERROR: Base {name} directory '{bdir}' is not writable by the current user (root). Check mount options or permissions.")
        passed = False
    else:
        print(f"OK: Base {name} directory '{bdir}' exists and is writable.")

# 3. Check for optional but recommended commands needed by generated scripts
print("Checking for optional command (jq)...")
try:
    if shutil.which("jq"):
        print("OK: 'jq' command found (recommended for robust daemon.json handling).")
    else:
        print("WARNING: 'jq' command not found. Generated sbnb-cmds.sh will use less robust methods for daemon.json, which might fail or overwrite existing settings.")
    # Removed rsync check as it's no longer used/preferred by the generated script
except ImportError:
    print("WARNING: Python 'shutil' module not found, cannot check for optional command (jq).")
except Exception as e:
    print(f"WARNING: Error checking for optional commands: {e}")


if not passed:
    print("----------------------------")
    print("ERROR: Prerequisites not met. Aborting script.")
    sys.exit(1)
print("--- Prerequisites OK ---")
return True
</code></section></div></div>

<p>def create_files():
    “"”Creates directories and files as defined in FILES_TO_CREATE.”””
    global warning_count, fail_count # Declare intent to modify globals
    print(“\n— Starting File Creation Process —”)
    success_count = 0
    warning_count = 0 # Reset global counter
    fail_count = 0    # Reset global counter</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># Ensure the base backup directory exists first with correct permissions
try:
    print(f"\nEnsuring base backup directory exists: {BACKUP_BASE_DIR}")
    # Create directory with specific permissions (rwxr-x---)
    os.makedirs(BACKUP_BASE_DIR, mode=BACKUP_DIR_PERMISSIONS, exist_ok=True)
    # Explicitly set permissions in case it already existed with different ones
    current_perm = stat.S_IMODE(os.stat(BACKUP_BASE_DIR).st_mode)
    if current_perm != BACKUP_DIR_PERMISSIONS:
        print(f"  Adjusting permissions on {BACKUP_BASE_DIR} to {BACKUP_DIR_PERMISSIONS:o}...") # Use :o format
        os.chmod(BACKUP_BASE_DIR, BACKUP_DIR_PERMISSIONS)
    print(f"OK: Backup directory ensured: {BACKUP_BASE_DIR} with permissions {BACKUP_DIR_PERMISSIONS:o}") # Use :o format
except OSError as e:
    print(f"ERROR: Failed to create or set permissions on {BACKUP_BASE_DIR}: {e}")
    sys.exit(f"ERROR: Could not ensure backup directory '{BACKUP_BASE_DIR}'. Exiting.")
except Exception as e:
    print(f"ERROR: An unexpected error occurred ensuring backup directory: {e}")
    sys.exit(f"ERROR: Could not ensure backup directory '{BACKUP_BASE_DIR}'. Exiting.")


# Process the files dictionary
for file_path_str, details in FILES_TO_CREATE.items():
    file_path = pathlib.Path(file_path_str)
    write_succeeded = False # Flag to track if write was successful

    try:
        content = details.get("content") # Use get() as content might be None for dirs
        permissions = details.get("permissions") # Use .get() for optional permissions
        # Assign default permissions if not specified
        if permissions is None:
            if content is None: # It's meant to be a directory
                permissions = 0o755 # Default rwxr-xr-x for directories
            else: # It's a file
                permissions = 0o644 # Default rw-r--r-- for files
            print(f"INFO: No specific permission set for {file_path}, using default {permissions:o}.") # Use :o format

    except KeyError as e:
        print(f"\nERROR: Configuration error - Missing '{e}' key for entry {file_path_str}. Skipping.")
        fail_count += 1
        continue
    except Exception as e:
        print(f"\nERROR: Configuration error for {file_path_str}: {e}. Skipping.")
        fail_count += 1
        continue

    print(f"\nProcessing: {file_path}")

    # 1. Create parent directories robustly
    try:
        parent_dir = file_path.parent
        # Check if parent needs creation (avoid os.makedirs on existing dirs if possible)
        if not parent_dir.is_dir():
            print(f"  Creating parent directory: {parent_dir}")
            # mode=0o755 sets default permissions for newly created dirs (rwxr-xr-x)
            os.makedirs(parent_dir, mode=0o755, exist_ok=True)
            # Explicitly set permissions on parent in case it was just created or exist_ok=True skipped it
            print(f"  Setting parent directory permissions to 755...") # 755 doesn't need 0o prefix
            os.chmod(parent_dir, 0o755)
        else:
            # Parent exists, ensure it's writable and has correct permissions
            print(f"  Parent directory exists: {parent_dir}")
            if not os.access(parent_dir, os.W_OK):
                print(f"  WARNING: Parent directory {parent_dir} is not writable! File write may fail.")
                warning_count += 1
            # Ensure existing parent has standard 755 permissions
            try:
                current_parent_perm = stat.S_IMODE(os.stat(parent_dir).st_mode)
                if current_parent_perm != 0o755:
                    print(f"  Ensuring parent directory permissions are 755 (currently {current_parent_perm:o})...") # Use :o format
                    os.chmod(parent_dir, 0o755)
            except OSError as e:
                print(f"  WARNING: Could not check/set permissions on existing parent {parent_dir}: {e}")
                warning_count += 1

    except OSError as e:
        print(f"  ERROR: Failed to create or set permissions on parent directory {parent_dir}: {e}")
        print(f"  Skipping item: {file_path}")
        fail_count += 1
        continue # Skip to the next file
    except Exception as e:
        print(f"  ERROR: An unexpected error occurred creating parent directory for {file_path}: {e}")
        print(f"  Skipping item: {file_path}")
        fail_count += 1
        continue

    # 2. Write the file content (or create directory if content is None)
    if content is not None: # It's a file
        try:
            print(f"  Writing content...")
            # Use write_text for atomic write where possible and UTF-8 encoding
            file_path.write_text(content, encoding='utf-8')
            print(f"  Successfully wrote: {file_path}")
            write_succeeded = True
        except IOError as e:
            print(f"  ERROR: Failed to write file {file_path}: {e}")
            fail_count += 1
            continue # Skip permissions if write failed
        except Exception as e:
            print(f"  ERROR: An unexpected error occurred writing {file_path}: {e}")
            fail_count += 1
            continue
    else: # It's a directory (content is None)
        try:
            print(f"  Ensuring directory exists: {file_path}")
            os.makedirs(file_path, mode=permissions, exist_ok=True)
            # Explicitly set permissions in case it already existed
            os.chmod(file_path, permissions)
            print(f"  Successfully ensured directory: {file_path}")
            write_succeeded = True # Treat dir success like file write success
        except OSError as e:
            print(f"  ERROR: Failed to create/set permissions on directory {file_path}: {e}")
            fail_count += 1
            continue
        except Exception as e:
            print(f"  ERROR: An unexpected error occurred ensuring directory {file_path}: {e}")
            fail_count += 1
            continue


    # 3. Set permissions (only if write/dir creation succeeded)
    if write_succeeded:
        try:
            # Check if current permissions match target permissions before attempting chmod
            current_perm = stat.S_IMODE(os.stat(file_path).st_mode)
            if current_perm != permissions:
                print(f"  Setting permissions to {permissions:o} (currently {current_perm:o})...") # Use :o format
                os.chmod(file_path, permissions)
                print(f"  Successfully set permissions for: {file_path}")
            else:
                print(f"  Permissions already set correctly ({permissions:o}) for: {file_path}") # Use :o format
            success_count += 1 # Count full success (write/dir + chmod)
        except OSError as e:
            print(f"  WARNING: Failed to set permissions on {file_path}: {e}")
            warning_count += 1 # Item created/written, but permissions failed/check failed
        except Exception as e:
            print(f"  WARNING: An unexpected error occurred setting permissions for {file_path}: {e}")
            warning_count += 1

# --- Summary ---
print("\n--- File Creation Summary ---")
print(f"Successfully processed (created/permissioned): {success_count} items")
print(f"Items processed but with warnings:             {warning_count}")
print(f"Failed operations (write/dir/parent):          {fail_count}")
print("-------------------------------\n")

total_issues = fail_count + warning_count
if total_issues &gt; 0:
    print("NOTE: Some errors or warnings occurred during file creation.")
    if fail_count &gt; 0:
        print("ERROR: Fatal errors occurred. Deployment incomplete.")
        return False # Fatal errors occurred
    else:
        print("Deployment completed, but with warnings. Please review the output above.")
        return True # Only non-fatal warnings
else:
    print("SBNB configuration file deployment completed successfully.")
    return True
</code></section></div></div>
  <h1 id="-script-execution-">
    
    
     <a href="#-script-execution-">#</a><a href="#" aria-label="Back to top">— Script Execution —</a>
        
    
  </h1>
      
<p>if <strong>name</strong> == “<strong>main</strong>”:
    print(“=====================================================================”)
    print(“ SBNB Unified Configuration Deployment Script (v2.1 - BusyBox cp) “)
    print(“=====================================================================”)
    print(f”Timestamp: {datetime.now().strftime(‘%Y-%m-%d %H:%M:%S’)}”)
    print(f”Configuring Docker persistent root: {PERSISTENT_DOCKER_ROOT}”)
    print(“Includes Backup/Purge and Health/Volume monitoring.”)
    print(“Data migration uses ‘cp -a -u’ (BusyBox friendly).”)
    print(“=====================================================================\n”)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># Store counts for final status reporting
final_warning_count = 0
final_fail_count = 0

if check_prerequisites():
    # Capture status from create_files
    create_files_success = create_files()
    # Access the global counters updated by create_files
    final_warning_count = warning_count
    final_fail_count = fail_count

    if create_files_success or (final_fail_count == 0 and final_warning_count &gt; 0) :
        # Success or only warnings - print final instructions
        print("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("!!! CRITICAL: You MUST replace the placeholder in                         !!!")
        print(f"!!!           '{ESP_MOUNT}/sbnb-tskey.txt' with your actual Tailscale auth key! !!!")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("\n--- Next Steps ---")
        print("1. Review any WARNINGS in the output above.")
        print("2. Reboot the system for sbnb-cmds.sh to take effect.")
        print("3. After reboot, verify Docker configuration and status:")
        print(f"   - Check data root: `docker info | grep 'Docker Root Dir'` (should show '{PERSISTENT_DOCKER_ROOT}')")
        print(f"   - Check status: `systemctl status docker.service`")
        print(f"   - Check boot script logs: `journalctl -t sbnb-cmds.sh --no-pager` or check `/dev/kmsg` output during boot")
        print(f"   - Check timers: `systemctl list-timers --all | grep docker`")
        print(f"   - Check helper script logs periodically: `journalctl -t backup-docker.sh -t purge-docker-backups.sh -t docker-health-check -t docker-volume-check --no-pager`")

        if final_warning_count &gt; 0:
            print("\nDeployment finished with WARNINGS.")
            sys.exit(2) # Exit code 2 for success with warnings
        else:
            print("\nDeployment finished successfully.")
            sys.exit(0) # Exit successfully
    else:
        # Fatal errors occurred during file creation
        print("\n--- Deployment Failed ---")
        print("Fatal errors occurred during file creation. System configuration may be incomplete or inconsistent.")
        sys.exit(1) # Exit with error code {% endcodeblock %}
</code></section></div></div>

<ol>
  <li><strong>Unmount the EFI Partition:</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Unmounting ESP partition ---"</span>
<span class="c"># Ensure buffers are flushed before unmounting</span>
<span class="nb">sync
sudo </span>umount /mnt/sbnb-mount
</code></section></div>    </div>
  </li>
</ol>
  <h3 id="phase-4-backing-up-data-critical">
    
    
     <a href="#phase-4-backing-up-data-critical">#</a><a href="#" aria-label="Back to top">Phase 4: Backing Up Data (CRITICAL!)</a>
        
    
  </h3>
      

<ul>
  <li><strong>Why Essential:</strong> High risk of USB drive failure. Backups are mandatory.</li>
  <li><strong>Strategy:</strong> Automate regular backups of <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
  <li><strong>File Data Backup (<code class="language-plaintext highlighter-rouge">rsync</code>):</strong> Ensure the backup destination (NAS, cloud, another server) has sufficient free space.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>  <span class="c"># Example: From Sbnb to backup-server (requires ssh key auth)</span>
  rsync <span class="nt">-avz</span> <span class="nt">--delete</span> <span class="nt">--progress</span> <span class="nt">--human-readable</span> /mnt/sbnb-data/ user@backup-server:/path/to/backups/sbnb-usb-data/
</code></section></div>    </div>
  </li>
  <li><strong>Frequency:</strong> Daily recommended for active data.</li>
  <li><strong>Automation:</strong> Use cron/systemd timers or remote triggers.</li>
  <li><strong>Testing Restores:</strong> Vital! Don’t assume backups work.</li>
  <li><strong>Conceptual Restore:</strong> Boot Linux Live env -&gt; Mount backup source -&gt; Mount target USB data partition (new/reformatted) to <code class="language-plaintext highlighter-rouge">/mnt/restore</code> -&gt; <code class="language-plaintext highlighter-rouge">sudo rsync -av --progress /path/to/backup/sbnb-usb-data/ /mnt/restore/</code> -&gt; Verify restored files (count, size, checksums, spot checks).</li>
  <li><strong>Verification:</strong> Use tools like <code class="language-plaintext highlighter-rouge">diff -r</code>, <code class="language-plaintext highlighter-rouge">md5sum</code>, or <code class="language-plaintext highlighter-rouge">sha256sum</code> to compare restored files against originals or known good copies.</li>
  <li><em>Untested backups provide a false sense of security.</em></li>
</ul>
  <h3 id="phase-5-boot-and-verify">
    
    
     <a href="#phase-5-boot-and-verify">#</a><a href="#" aria-label="Back to top">Phase 5: Boot and Verify</a>
        
    
  </h3>
      

<ol>
  <li><strong>Safely Eject:</strong> Eject USB from prep system.</li>
  <li><strong>Configure Server BIOS/UEFI:</strong> Enter setup (DEL, F2, F10, F12, etc.). Ensure UEFI Mode ON, CSM/Legacy OFF, Secure Boot OFF. Set “UEFI: USB…” as first boot device. Save &amp; Exit.</li>
  <li><strong>Boot Sbnb Linux.</strong></li>
  <li><strong>Verify Operation:</strong>
    <ul>
      <li>Monitor Boot: Watch console for <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> logs, errors.</li>
      <li>SSH into Sbnb.</li>
      <li>Check Mounts:
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,LABEL,MOUNTPOINT <span class="c"># Look for mount at /mnt/sbnb-data</span>
<span class="nb">df</span> <span class="nt">-hT</span> | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s1">'Filesystem|/mnt/sbnb-data'</span> <span class="c"># Check usage/type</span>
mount | <span class="nb">grep</span> /mnt/sbnb-data  <span class="c"># Check mount options (rw, noatime)</span>
findmnt /mnt/sbnb-data     <span class="c"># Another way to check mount info</span>
</code></section></div>        </div>
      </li>
      <li>Test Persistence:
```bash
  <h1 id="after-sshing-in">
    
    
     <a href="#after-sshing-in">#</a><a href="#" aria-label="Back to top">After SSHing in:</a>
        
    
  </h1>
      
        <p>TIMESTAMP=$(date)
echo “Sbnb USB Persistence test - $TIMESTAMP” | sudo tee /mnt/sbnb-data/persistence_test.txt &gt; /dev/null
sync &amp;&amp; echo “Synced data to disk.”
echo “File created. Content:” &amp;&amp; sudo cat /mnt/sbnb-data/persistence_test.txt
echo “Rebooting server now…” &amp;&amp; sudo reboot</p>
      </li>
    </ul>
  <h1 id="-wait-for-reboot-and-reconnect-via-ssh-">
    
    
     <a href="#-wait-for-reboot-and-reconnect-via-ssh-">#</a><a href="#" aria-label="Back to top">— Wait for reboot and reconnect via SSH —</a>
        
    
  </h1>
      
    <p>echo “Checking for file after reboot…”
if [ -f /mnt/sbnb-data/persistence_test.txt ]; then
  echo “SUCCESS: File found. Content:” &amp;&amp; sudo cat /mnt/sbnb-data/persistence_test.txt
  sudo rm /mnt/sbnb-data/persistence_test.txt # Clean up
else
  echo “FAILURE: File NOT FOUND after reboot! Persistence failed.”
fi
```</p>
  </li>
</ol>
  <h2 id="troubleshooting">
    
    
     <a href="#troubleshooting">#</a><a href="#" aria-label="Back to top">Troubleshooting</a>
        
    
  </h2>
      

<ul>
  <li><strong>Doesn’t Boot / No Bootable Device:</strong>
    <ul>
      <li>Re-verify BIOS settings (UEFI, Secure Boot OFF, Boot Order).</li>
      <li>Re-verify USB Prep: Partitions (<code class="language-plaintext highlighter-rouge">parted print</code>), ESP flags (<code class="language-plaintext highlighter-rouge">boot</code>,<code class="language-plaintext highlighter-rouge">esp</code>), ESP filesystem label (<code class="language-plaintext highlighter-rouge">blkid /dev/sdX1</code> -&gt; <code class="language-plaintext highlighter-rouge">LABEL="sbnb"</code>), EFI file path (<code class="language-plaintext highlighter-rouge">/EFI/BOOT/BOOTX64.EFI</code>).</li>
      <li>Try different USB ports (check if port provides sufficient power). Test drive health on prep machine (<code class="language-plaintext highlighter-rouge">fsck</code>, <code class="language-plaintext highlighter-rouge">badblocks -nvs /dev/sdX</code>). Recreate drive meticulously.</li>
    </ul>
  </li>
  <li><strong>Data Partition Not Mounted / <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> Empty:</strong>
    <ul>
      <li>Check boot logs (<code class="language-plaintext highlighter-rouge">journalctl -b</code>, console) for <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> errors (“Device… not found”, “Failed to mount”). Check <code class="language-plaintext highlighter-rouge">dmesg</code> for USB errors (<code class="language-plaintext highlighter-rouge">dmesg | grep -iE 'usb|sdX'</code>) or filesystem errors (<code class="language-plaintext highlighter-rouge">dmesg | grep -i ext4</code>).</li>
      <li>SSH in:
        <ul>
          <li>Verify partition &amp; label: <code class="language-plaintext highlighter-rouge">sudo blkid</code>, <code class="language-plaintext highlighter-rouge">ls -l /dev/disk/by-label/</code>. Is <code class="language-plaintext highlighter-rouge">SBNB_DATA</code> present? Does it point to the correct device?</li>
          <li>If label wrong/missing: Re-label from prep env (<code class="language-plaintext highlighter-rouge">sudo e2label /dev/sdX2 SBNB_DATA</code>).</li>
          <li>If device/label exists, try manual mount: <code class="language-plaintext highlighter-rouge">sudo mkdir -p /mnt/sbnb-data &amp;&amp; sudo mount /dev/disk/by-label/SBNB_DATA /mnt/sbnb-data</code>. Check <code class="language-plaintext highlighter-rouge">dmesg</code> for errors (e.g., <code class="language-plaintext highlighter-rouge">mount: wrong fs type, bad option, bad superblock</code>). If manual mount works, debug <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> (add <code class="language-plaintext highlighter-rouge">set -x</code>, check paths, loop duration, check script permissions <code class="language-plaintext highlighter-rouge">ls -l /mnt/sbnb/sbnb-cmds.sh</code>).</li>
          <li>Run filesystem check (unmounted): <code class="language-plaintext highlighter-rouge">sudo e2fsck -f /dev/disk/by-label/SBNB_DATA</code>.</li>
          <li>Check kernel modules: <code class="language-plaintext highlighter-rouge">lsmod | grep ext4</code>. Is the module loaded? Check <code class="language-plaintext highlighter-rouge">dmesg</code> for errors loading filesystem modules.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Poor Performance / Drive Failure:</strong>
    <ul>
      <li><strong>Performance:</strong> Inherent limitation.</li>
      <li><strong>Lifespan/Failure:</strong> Monitor <code class="language-plaintext highlighter-rouge">dmesg</code> for I/O errors. Restore from verified backups upon failure. This setup will wear out consumer flash drives with persistent writes.</li>
    </ul>
  </li>
</ul>

        </div>
        
          URL: https://ib.bsb.br/sbnb
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/to-enable-video-acceleration-on-rpi4/" title="to enable video acceleration on RPI4" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/images-to-searchable-pdf/" title="Images to Searchable PDF" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "linux>software>dotfile"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-linux-software-dotfile" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/sbnb/" title="Portable linux via Sbnb distro with persistence" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    <div class="comment-box">
      Ref. 
      <a href="https://github.com/sbnb-io/sbnb" title="https://github.com/sbnb-io/sbnb">https://github.com/sbnb-io/sbnb</a>
    </div>
    
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-05-01 16:51:46
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="linux-software-dotfile">
                  linux>software>dotfile
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/sbnb/"
        },
        "headline": "Portable linux via Sbnb distro with persistence",
        "description": "",
        "datePublished": "2025-04-07T00:00:00+00:00",
        "dateModified": "2025-05-01T19:49:12+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
