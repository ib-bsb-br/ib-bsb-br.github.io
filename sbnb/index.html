<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Portable linux via Sbnb distro with persistence - infoBAG
      
    </title>
    <meta name="title" content="Portable linux via Sbnb distro with persistence - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/sbnb/">
    <meta property="og:title" content="Portable linux via Sbnb distro with persistence - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/sbnb/">
    <meta name="twitter:title" content="Portable linux via Sbnb distro with persistence - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/sbnb/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="linux&gt;software&gt;dotfile">
      
        <meta property="article:tag" content="linux&gt;software&gt;dotfile">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Portable linux via Sbnb distro with persistence
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-04-07T00:00:00+00:00" class="post-date">
          07 Apr 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-04-17T17:52:36+00:00">
              17 Apr 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/sbnb" class="tag">sbnb</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#linux-software-dotfile" class="tag">linux>software>dotfile</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        67630 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        8666 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-04-07-sbnb.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-04-07-sbnb.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#primary-drawbacks--warnings-reiterated--expanded">Primary Drawbacks &amp; Warnings (Reiterated &amp; Expanded):</a><ul><li><a href="#when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">When Might This Be Considered? (Limited Scenarios with Full Risk Acceptance)</a></li></ul></li><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#step-by-step-instructions">Step-by-Step Instructions</a><ul><li><a href="#phase-1-prepare-the-linux-environment-opensuse-tumbleweed">Phase 1: Prepare the Linux Environment (openSUSE Tumbleweed)</a></li><li><a href="#phase-2-partition-the-usb-drive">Phase 2: Partition the USB Drive</a></li><li><a href="#phase-4-install-sbnb-boot-files-and-configuration">Phase 4: Install Sbnb Boot Files and Configuration</a></li></ul></li><li><a href="#data"><strong>data</strong></a></li><li><a href="#documentation"><strong>documentation</strong></a><ul><li><a href="#project-sbnb-single-usb-boot-and-persistent-docker-data-via-backuprestore">**Project: Sbnb Single-USB Boot and Persistent Docker Data via Backup/Restore</a></li></ul></li><li><a href="#paper_trail"><strong>paper_trail</strong></a></li></ul>
          <p>This guide provides comprehensive, step-by-step instructions for configuring a single USB flash drive (or potentially an external USB hard drive) to perform two distinct functions simultaneously:</p>

<ol>
  <li><strong>Booting the Sbnb Linux Operating System:</strong> The drive will be prepared with a standard UEFI-compatible structure, specifically an EFI System Partition (ESP) containing the Sbnb EFI bootloader (<code class="language-plaintext highlighter-rouge">sbnb.efi</code>) and necessary configuration files. This allows the server’s firmware to locate and start the Sbnb boot process. The <code class="language-plaintext highlighter-rouge">sbnb.efi</code> file itself is typically a Unified Kernel Image (UKI), bundling the Linux kernel, initramfs, and kernel command line into a single executable file.</li>
  <li><strong>Providing Simple Persistent Storage:</strong> Utilizing a separate partition on the same physical USB drive, formatted with a standard Linux filesystem (<code class="language-plaintext highlighter-rouge">ext4</code> is used in this guide). This partition is intended to be automatically mounted at the <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> directory path within the running Sbnb Linux system via a custom boot script (<code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>). This provides a space where data (like container volumes, application data, logs, user files) can persist across reboots of the otherwise ephemeral, RAM-based Sbnb OS.</li>
</ol>

<p><strong>Why <code class="language-plaintext highlighter-rouge">ext4</code> instead of LVM:</strong> Initial analysis suggested LVM might be suitable, but further review of the default Sbnb Linux build configuration indicates the necessary <code class="language-plaintext highlighter-rouge">lvm2</code> user-space tools are likely missing from the base runtime environment. Without these tools, managing LVM volumes during boot via standard scripts is infeasible unless you create a custom Sbnb build that includes the <code class="language-plaintext highlighter-rouge">lvm2</code> package. This revised guide therefore uses a standard <code class="language-plaintext highlighter-rouge">ext4</code> filesystem partition, relying only on basic tools expected to be present in Sbnb.</p>

<p><strong>Contrasting with Standard Sbnb Workflow:</strong> It’s crucial to understand that this guide describes a highly non-standard setup. The intended Sbnb workflow prioritizes resilience, performance, and statelessness:</p>

<ul>
  <li>Boot the minimal Sbnb OS from simple USB/network.</li>
  <li>Use automation (Ansible) or manual scripts (<code class="language-plaintext highlighter-rouge">sbnb-configure-storage.sh</code>) post-boot to configure LVM on internal server drives.</li>
  <li>Run workloads utilizing this fast, reliable internal storage. This guide’s method compromises these benefits for single-drive convenience under specific constraints.</li>
</ul><hr />

<blockquote>
  <p><strong>*** EXTREME CAUTION: IRREVERSIBLE DATA DESTRUCTION IMMINENT! **</strong>*</p>

  <p>This procedure involves low-level disk operations (partitioning, formatting) that will completely and <strong>PERMANENTLY ERASE ALL DATA</strong> currently residing on the USB drive you select. There is <strong>NO UNDO</strong> function. Data recovery after accidental formatting is often impossible.</p>

  <p>The most critical risk is selecting the <strong>wrong target device</strong>. Mistakenly choosing your computer’s internal hard drive (e.g., <code class="language-plaintext highlighter-rouge">/dev/sda</code>, <code class="language-plaintext highlighter-rouge">/dev/nvme0n1</code>) instead of the intended USB drive (e.g., <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, <code class="language-plaintext highlighter-rouge">/dev/sdc</code>) <strong>WILL RESULT IN CATASTROPHIC AND LIKELY IRRECOVERABLE LOSS OF YOUR OPERATING SYSTEM, APPLICATIONS, AND PERSONAL FILES.</strong></p>

  <p>You <strong>MUST</strong> verify the target device name multiple times using different commands (like <code class="language-plaintext highlighter-rouge">lsblk</code>, <code class="language-plaintext highlighter-rouge">fdisk</code>, <code class="language-plaintext highlighter-rouge">parted</code>) and cross-reference with expected drive sizes and models before executing any partitioning or formatting commands. Proceed with extreme vigilance, double-checking each step, entirely at your own sole risk!</p>
</blockquote><hr />
  <h2 id="primary-drawbacks--warnings-reiterated--expanded">
    
    
     <a href="#primary-drawbacks--warnings-reiterated--expanded">#</a><a href="#" aria-label="Back to top">Primary Drawbacks &amp; Warnings (Reiterated &amp; Expanded):</a>
        
    
  </h2>
      

<ul>
  <li><strong>Highly Non-Standard &amp; Complex:</strong> Deviates significantly from Sbnb’s design. Setup is intricate, runtime behavior depends on precise script execution and timing. Future Sbnb updates might break this.</li>
  <li><strong>Severe Performance Penalty:</strong> USB storage is inherently slow (latency, throughput, IOPS) compared to internal NVMe/SATA drives. Disk I/O to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> will be a major bottleneck.</li>
  <li><strong>Drastically Reduced Lifespan &amp; Reliability:</strong> USB flash drives will wear out quickly under persistent write load due to limited write cycles, write amplification, and lack of TRIM support. Unsuitable for write-intensive workloads or high reliability needs. Expect eventual failure and data loss without robust backups.</li>
  <li><strong>Potential Instability &amp; Boot Issues:</strong> Relies on correct partition detection, udev node creation, filesystem integrity, and <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> execution timing. Failures can leave persistent storage unavailable.</li>
</ul>
  <h3 id="when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">
    
    
     <a href="#when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">#</a><a href="#" aria-label="Back to top">When Might This Be Considered? (Limited Scenarios with Full Risk Acceptance)</a>
        
    
  </h3>
      

<ul>
  <li><strong>Temporary Testing/Experimentation ONLY:</strong> Brief evaluations on hardware lacking internal drives.</li>
  <li><strong>Specific, Very Low-Intensity, Read-Mostly Use Cases:</strong> Infrequent writes, performance irrelevant (e.g., static config kiosk).</li>
  <li><strong>Absolute Hardware Constraints:</strong> Sealed systems where internal drives are impossible, and risks are fully accepted.</li>
</ul>

<p><em>Even in these limited scenarios, regular, automated, and verified backups are non-negotiable.</em></p>
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<ul>
  <li><strong>A Suitable USB Flash Drive:</strong>
    <ul>
      <li><strong>Capacity:</strong> Min ~1GB ESP + desired data size (32GB+ recommended).</li>
      <li><strong>Quality &amp; Speed:</strong> Reputable brand, USB 3.0+ advised for marginal speed benefit. Endurance matters more than peak speed.</li>
    </ul>
  </li>
  <li><strong>A Working Linux System (Preparation Environment):</strong>
    <ul>
      <li><strong>Necessity:</strong> Required for partitioning/formatting the target USB safely. openSUSE Tumbleweed assumed.</li>
      <li><strong>Live Environment Benefit:</strong> Using a Live USB/CD (e.g., openSUSE Tumbleweed Live) is highly recommended as it provides a non-destructive environment.</li>
    </ul>
  </li>
  <li><strong>Sbnb Linux Boot File (<code class="language-plaintext highlighter-rouge">sbnb.efi</code>):</strong>
    <ul>
      <li><strong>Method 1 (Easier):</strong> Run official Sbnb install script on a temporary USB, then copy <code class="language-plaintext highlighter-rouge">/EFI/BOOT/BOOTX64.EFI</code> from its ESP.</li>
      <li><strong>Method 2 (Advanced):</strong> Build Sbnb from source, find <code class="language-plaintext highlighter-rouge">sbnb.efi</code> in <code class="language-plaintext highlighter-rouge">output/images/</code>.</li>
    </ul>
  </li>
  <li><strong>Root/Sudo Privileges:</strong> Needed on the openSUSE prep system for disk commands.</li>
  <li><strong>Internet Connection:</strong> May be needed for <code class="language-plaintext highlighter-rouge">zypper</code>.</li>
</ul>
  <h2 id="step-by-step-instructions">
    
    
     <a href="#step-by-step-instructions">#</a><a href="#" aria-label="Back to top">Step-by-Step Instructions</a>
        
    
  </h2>
      

<p><em>(Reminder: TRIPLE-CHECK your target device name, e.g., <code class="language-plaintext highlighter-rouge">/dev/sdX</code>, before every destructive command!)</em></p>
  <h3 id="phase-1-prepare-the-linux-environment-opensuse-tumbleweed">
    
    
     <a href="#phase-1-prepare-the-linux-environment-opensuse-tumbleweed">#</a><a href="#" aria-label="Back to top">Phase 1: Prepare the Linux Environment (openSUSE Tumbleweed)</a>
        
    
  </h3>
      

<ol>
  <li><strong>Boot into openSUSE:</strong> Start your preparation environment.</li>
  <li><strong>Install Necessary Tools:</strong> Open a terminal. <code class="language-plaintext highlighter-rouge">zypper refresh</code> updates package lists. <code class="language-plaintext highlighter-rouge">zypper install</code> installs tools.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">sudo </span>zypper refresh
<span class="nb">sudo </span>zypper <span class="nb">install</span> <span class="nt">-y</span> parted lvm2 dosfstools e2fsprogs
</code></section></div>    </div>
  </li>
  <li><strong>Identify Target USB Drive:</strong> <strong>CRITICAL SAFETY STEP!</strong> Unplug other USB storage.
    <ul>
      <li>Insert the target USB drive.</li>
      <li>Use multiple commands. Compare SIZE and MODEL. Check <code class="language-plaintext highlighter-rouge">dmesg | tail</code> after plugging in for kernel messages like <code class="language-plaintext highlighter-rouge">sd 2:0:0:0: [sdc] Attached SCSI removable disk</code>.
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>lsblk <span class="nt">-d</span> <span class="nt">-o</span> NAME,SIZE,MODEL,VENDOR,TYPE | <span class="nb">grep</span> <span class="s1">'disk'</span>
<span class="nb">sudo </span>fdisk <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s1">'^Disk /dev/'</span>
<span class="nb">sudo </span>parted <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s1">'^Disk /dev/'</span>
<span class="c"># Example: If consistently identified as /dev/sdc, use /dev/sdc below.</span>
</code></section></div>        </div>
      </li>
      <li>Visually confirm with YaST Partitioner (<code class="language-plaintext highlighter-rouge">sudo yast2 partitioner</code>) or GParted (<code class="language-plaintext highlighter-rouge">sudo zypper install -y gparted &amp;&amp; sudo gparted</code>) if preferred. Look for the drive matching the expected size and vendor/model.</li>
      <li>Assume <code class="language-plaintext highlighter-rouge">/dev/sdX</code> is your verified target drive. <strong>Replace it carefully!</strong></li>
    </ul>
  </li>
</ol>
  <h3 id="phase-2-partition-the-usb-drive">
    
    
     <a href="#phase-2-partition-the-usb-drive">#</a><a href="#" aria-label="Back to top">Phase 2: Partition the USB Drive</a>
        
    
  </h3>
      

<p><strong>(Warning: The following <code class="language-plaintext highlighter-rouge">parted</code> commands are DESTRUCTIVE to <code class="language-plaintext highlighter-rouge">/dev/sdX</code>. Double-check the device name!)</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/bash</span>

<span class="c"># --- Configuration ---</span>
<span class="c"># Exit immediately if a command exits with a non-zero status.</span>
<span class="c"># Treat unset variables as an error when substituting.</span>
<span class="c"># Pipelines return the exit status of the last command to exit non-zero.</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="c"># --- Variables ---</span>
<span class="c"># EFI System Partition (ESP) Label (CRITICAL - must match bootloader config)</span>
<span class="nv">ESP_LABEL</span><span class="o">=</span><span class="s2">"sbnb"</span>
<span class="c"># Data Partition Label (Recommended for identification)</span>
<span class="nv">DATA_LABEL</span><span class="o">=</span><span class="s2">"SBNB_DATA"</span>
<span class="c"># ESP Size (Adjust if needed, ~1GB is usually sufficient)</span>
<span class="nv">ESP_SIZE</span><span class="o">=</span><span class="s2">"1025MiB"</span>
<span class="c"># List of required commands for the script to function</span>
<span class="nv">REQUIRED_CMDS</span><span class="o">=(</span>
    <span class="s2">"parted"</span> <span class="s2">"mkfs.vfat"</span> <span class="s2">"mkfs.ext4"</span> <span class="s2">"wipefs"</span> <span class="s2">"findmnt"</span> <span class="s2">"lsblk"</span>
    <span class="s2">"blkid"</span> <span class="s2">"fsck.vfat"</span> <span class="s2">"e2fsck"</span> <span class="s2">"sync"</span> <span class="s2">"id"</span> <span class="s2">"grep"</span> <span class="s2">"read"</span>
    <span class="s2">"sleep"</span> <span class="s2">"xargs"</span> <span class="s2">"umount"</span> <span class="s2">"partprobe"</span> <span class="s2">"realpath"</span>
<span class="o">)</span>

<span class="c"># --- Functions ---</span>
<span class="c"># Function to check for required commands</span>
check_dependencies<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"--- Checking for required commands ---"</span>
    <span class="nb">local </span><span class="nv">missing_cmds</span><span class="o">=()</span>
    <span class="k">for </span>cmd <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">REQUIRED_CMDS</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
        if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span> &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
            </span>missing_cmds+<span class="o">=(</span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span><span class="o">)</span>
        <span class="k">fi
    done

    if</span> <span class="o">[</span> <span class="k">${#</span><span class="nv">missing_cmds</span><span class="p">[@]</span><span class="k">}</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"ERROR: The following required commands are not found:"</span> <span class="o">&gt;</span>&amp;2
        <span class="nb">printf</span> <span class="s2">" - %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">missing_cmds</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>&amp;2
        <span class="nb">echo</span> <span class="s2">"Please install them and try again."</span> <span class="o">&gt;</span>&amp;2
        <span class="nb">exit </span>1
    <span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">"All required commands found."</span>
<span class="o">}</span>

<span class="c"># Function to get the base block device for a given path (handles partitions, links, etc.)</span>
get_base_device<span class="o">()</span> <span class="o">{</span>
    <span class="nb">local </span><span class="nv">path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
    <span class="nb">local </span>resolved_path
    <span class="nv">resolved_path</span><span class="o">=</span><span class="si">$(</span><span class="nb">realpath</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">"ERROR: Cannot resolve path '</span><span class="nv">$path</span><span class="s2">'"</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
    <span class="c"># lsblk -no pkname gets the parent kernel name (base device)</span>
    lsblk <span class="nt">-no</span> pkname <span class="s2">"</span><span class="nv">$resolved_path</span><span class="s2">"</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">"ERROR: Cannot find base device for '</span><span class="nv">$resolved_path</span><span class="s2">' using lsblk."</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c"># --- Script Start ---</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">"--- USB Drive Partitioning and Formatting Script ---"</span>
<span class="nb">echo</span> <span class="s2">"---          (Version 2 - Enhanced Safety)       ---"</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"WARNING: This script is DESTRUCTIVE and will ERASE"</span>
<span class="nb">echo</span> <span class="s2">"         ALL DATA on the target device."</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="c"># --- Check for Root Privileges ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span><span class="s2">"</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: This script must be run as root (e.g., using sudo)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># --- Check Dependencies ---</span>
check_dependencies

<span class="c"># --- Check for Device Argument ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="k">:-}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$0</span><span class="s2"> /dev/sdX"</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: Please provide the target block device (e.g., /dev/sda, /dev/sdb)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">""</span>
  <span class="nb">echo</span> <span class="s2">"Available block devices (excluding ROM, loop, and RAM devices):"</span>
  lsblk <span class="nt">-d</span> <span class="nt">-o</span> NAME,SIZE,TYPE,MODEL | <span class="nb">grep</span> <span class="nt">-vE</span> <span class="s1">'rom|loop|ram'</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">DEVICE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>

<span class="c"># --- Validate Device ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: '</span><span class="nv">$DEVICE</span><span class="s2">' is not a valid block device."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># --- CRITICAL SAFETY CHECK: Prevent targeting the root filesystem device ---</span>
<span class="nb">echo</span> <span class="s2">"--- Performing safety checks ---"</span>
<span class="nv">ROOT_DEV_PATH</span><span class="o">=</span><span class="si">$(</span>findmnt <span class="nt">-n</span> <span class="nt">-o</span> SOURCE /<span class="si">)</span>
<span class="nv">ROOT_BASE_DEV_NAME</span><span class="o">=</span><span class="si">$(</span>get_base_device <span class="s2">"</span><span class="nv">$ROOT_DEV_PATH</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit </span>1 <span class="c"># Exit if function fails</span>
<span class="nv">TARGET_BASE_DEV_NAME</span><span class="o">=</span><span class="si">$(</span>get_base_device <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit </span>1

<span class="c"># Construct full device paths for comparison</span>
<span class="nv">ROOT_BASE_DEV</span><span class="o">=</span><span class="s2">"/dev/</span><span class="k">${</span><span class="nv">ROOT_BASE_DEV_NAME</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">TARGET_BASE_DEV</span><span class="o">=</span><span class="s2">"/dev/</span><span class="k">${</span><span class="nv">TARGET_BASE_DEV_NAME</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Assumes the input $DEVICE is the base device</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$TARGET_BASE_DEV</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"FATAL ERROR: Target device '</span><span class="nv">$DEVICE</span><span class="s2">' appears to be the same"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"             device ('</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">') as the running root"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"             filesystem ('</span><span class="nv">$ROOT_DEV_PATH</span><span class="s2">')."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"             Aborting to prevent data loss."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
<span class="k">fi
</span><span class="nb">echo</span> <span class="s2">"Safety check passed: Target device '</span><span class="nv">$DEVICE</span><span class="s2">' is not the root filesystem device ('</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">')."</span>

<span class="c"># Check if the device looks like an SD card reader often used for the OS drive</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">==</span> /dev/mmcblk<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"WARNING: '</span><span class="nv">$DEVICE</span><span class="s2">' looks like an SD card (e.g., /dev/mmcblk0)."</span>
    <span class="nb">echo</span> <span class="s2">"         Double-check this is not your primary OS drive!"</span>
<span class="k">fi</span>


<span class="c"># --- Confirmation ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Target Device: </span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Partitions to be created:"</span>
<span class="nb">echo</span> <span class="s2">"  1: EFI System Partition (ESP), FAT32, Label: '</span><span class="nv">$ESP_LABEL</span><span class="s2">', Size: </span><span class="nv">$ESP_SIZE</span><span class="s2">, Flags: boot, esp"</span>
<span class="nb">echo</span> <span class="s2">"  2: Linux Data Partition, ext4, Label: '</span><span class="nv">$DATA_LABEL</span><span class="s2">', Size: Remaining space"</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"ARE YOU ABSOLUTELY SURE you want to erase '</span><span class="nv">$DEVICE</span><span class="s2">' and proceed? (yes/NO): "</span> CONFIRMATION
<span class="nv">CONFIRMATION</span><span class="o">=</span><span class="k">${</span><span class="nv">CONFIRMATION</span><span class="k">:-</span><span class="nv">NO</span><span class="k">}</span> <span class="c"># Default to NO if user just presses Enter</span>

<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$CONFIRMATION</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"yes"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Operation cancelled by user."</span>
  <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Proceeding with operations on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>

<span class="c"># --- Phase 2: Partition the USB Drive ---</span>

<span class="c"># 1. Unmount Existing Partitions</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Unmounting any existing partitions on </span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}</span><span class="s2">* ---"</span>
<span class="c"># Use findmnt to get mount points and umount them safely</span>
<span class="c"># Also try to unmount the base device itself in case it's loop-mounted etc.</span>
findmnt <span class="nt">-n</span> <span class="nt">-o</span> TARGET <span class="nt">--source</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}</span><span class="s2">*"</span> | xargs <span class="nt">--no-run-if-empty</span> umount <span class="nt">-v</span> <span class="nt">-l</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Info: No partitions were mounted or umount failed (might be okay)."</span>
umount <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> &amp;&gt;/dev/null <span class="o">||</span> <span class="nb">true</span> <span class="c"># Attempt to unmount base device, ignore errors</span>
<span class="nb">sleep </span>1 <span class="c"># Give time for umount to settle</span>
lsblk <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>

<span class="c"># 2. Wipe Existing Signatures (Recommended)</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Wiping filesystem/partition signatures from </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
wipefs <span class="nt">--all</span> <span class="nt">--force</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk to ensure changes are physically written</span>

<span class="c"># 3. Create New GPT Partition Table</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating new GPT partition table on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mklabel gpt
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># 4. Create EFI System Partition (ESP)</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating ESP partition (1) on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mkpart <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">"</span> fat32 1MiB <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> <span class="nb">set </span>1 boot on
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> <span class="nb">set </span>1 esp on
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># 5. Create Linux Data Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating Linux data partition (2) on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
<span class="c"># Use the end of the ESP as the start for the data partition</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mkpart <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> ext4 <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">"</span> 100%
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>
<span class="nb">echo</span> <span class="s2">"Waiting briefly for kernel to recognize new partitions..."</span>
<span class="nb">sleep </span>2

<span class="c"># Define partition variables (assuming standard naming, e.g., /dev/sda1, /dev/sda2)</span>
<span class="c"># Adding 'p' for NVMe devices (e.g., /dev/nvme0n1p1) - check if base device name contains 'nvme'</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">==</span> <span class="k">*</span>nvme<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">PART_PREFIX</span><span class="o">=</span><span class="s2">"p"</span>
<span class="k">else
    </span><span class="nv">PART_PREFIX</span><span class="o">=</span><span class="s2">""</span>
<span class="k">fi
</span><span class="nv">ESP_PARTITION</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}${</span><span class="nv">PART_PREFIX</span><span class="k">}</span><span class="s2">1"</span>
<span class="nv">DATA_PARTITION</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}${</span><span class="nv">PART_PREFIX</span><span class="k">}</span><span class="s2">2"</span>

<span class="c"># Check if partition devices exist, retry with partprobe if needed</span>
<span class="nb">echo</span> <span class="s2">"--- Checking for partition device nodes (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">, </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">) ---"</span>
<span class="nv">PARTITIONS_FOUND</span><span class="o">=</span><span class="nb">false
</span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">[</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$ESP_PARTITION</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$DATA_PARTITION</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"Partition nodes found."</span>
        <span class="nv">PARTITIONS_FOUND</span><span class="o">=</span><span class="nb">true
        break
    </span><span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">"Partition nodes not yet found. Retrying probe (Attempt </span><span class="nv">$i</span><span class="s2">/5)..."</span>
    partprobe <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Warning: partprobe command failed, continuing check..."</span>
    <span class="nb">sleep </span>1
<span class="k">done

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$PARTITIONS_FOUND</span><span class="s2">"</span> <span class="o">=</span> <span class="nb">false</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ERROR: Partition devices (</span><span class="nv">$ESP_PARTITION</span><span class="s2">, </span><span class="nv">$DATA_PARTITION</span><span class="s2">) not found after partitioning and retries."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"       Please check manually ('lsblk </span><span class="nv">$DEVICE</span><span class="s2">', 'parted </span><span class="nv">$DEVICE</span><span class="s2"> print')."</span> <span class="o">&gt;</span>&amp;2
    lsblk <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 6. Verify Partitioning</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying partitions on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> print
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Block device view: ---"</span>
lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,PARTLABEL,MOUNTPOINT,PARTFLAGS <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"----------------------------"</span>
<span class="nb">echo</span> <span class="s2">"Expected: </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2"> (~</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">), Type EFI System, Flags: boot, esp"</span>
<span class="nb">echo</span> <span class="s2">"Expected: </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2"> (Remaining size), Type Linux filesystem"</span>
<span class="nb">echo</span> <span class="s2">"----------------------------"</span>
<span class="nb">sleep </span>2 <span class="c"># Pause for user to review</span>


<span class="c"># --- Phase 3: Format Filesystems ---</span>

<span class="c"># 1. Format EFI Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Formatting ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">) as FAT32 with label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' ---"</span>
mkfs.vfat <span class="nt">-F</span> 32 <span class="nt">-n</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># Check filesystem integrity</span>
<span class="nb">echo</span> <span class="s2">"--- Checking ESP filesystem (fsck.vfat) ---"</span>
<span class="nv">FSCK_VFAT_EXIT_CODE</span><span class="o">=</span>0
fsck.vfat <span class="nt">-a</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nv">FSCK_VFAT_EXIT_CODE</span><span class="o">=</span><span class="nv">$?</span> <span class="c"># Run fsck, capture exit code on failure</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$FSCK_VFAT_EXIT_CODE</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ESP filesystem check passed (or no check performed)."</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$FSCK_VFAT_EXIT_CODE</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Exit code 1 usually means errors were found AND corrected.</span>
  <span class="nb">echo</span> <span class="s2">"WARNING: fsck.vfat found and corrected errors on ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">). Check output above."</span>
<span class="k">else</span>
  <span class="c"># Exit codes &gt; 1 typically indicate uncorrected errors.</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: fsck.vfat reported uncorrectable errors (Exit Code: </span><span class="nv">$FSCK_VFAT_EXIT_CODE</span><span class="s2">) on ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"       Cannot proceed safely. Please investigate manually."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Verify label using blkid</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying ESP label ---"</span>
<span class="k">if </span>blkid <span class="nt">-s</span> LABEL <span class="nt">-o</span> value <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">$"</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ESP Label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' verified successfully on </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">."</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to verify ESP Label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' on </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span>&amp;2
    blkid <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Show full blkid output for debugging</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 2. Format Data Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Formatting Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">) as ext4 with label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' ---"</span>
mkfs.ext4 <span class="nt">-m</span> 0 <span class="nt">-L</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># Check the new ext4 filesystem integrity</span>
<span class="nb">echo</span> <span class="s2">"--- Checking Data partition filesystem (e2fsck) ---"</span>
<span class="c"># -f forces check even if clean, -y assumes yes to all prompts (use with caution)</span>
<span class="nv">E2FSCK_EXIT_CODE</span><span class="o">=</span>0
e2fsck <span class="nt">-f</span> <span class="nt">-y</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nv">E2FSCK_EXIT_CODE</span><span class="o">=</span><span class="nv">$?</span> <span class="c"># Capture exit code on failure</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$E2FSCK_EXIT_CODE</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Data partition filesystem check passed."</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$E2FSCK_EXIT_CODE</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># Exit code 1 means errors were corrected.</span>
    <span class="nb">echo</span> <span class="s2">"WARNING: e2fsck found and corrected errors on Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">). Check output above."</span>
<span class="k">else</span>
    <span class="c"># Exit codes &gt; 1 indicate uncorrected errors.</span>
    <span class="nb">echo</span> <span class="s2">"ERROR: e2fsck reported uncorrectable errors (Exit Code: </span><span class="nv">$E2FSCK_EXIT_CODE</span><span class="s2">) on Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">)."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"       Cannot proceed safely. Please investigate manually."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Verify the label using blkid</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying Data partition label ---"</span>
<span class="k">if </span>blkid <span class="nt">-s</span> LABEL <span class="nt">-o</span> value <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">$"</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Data Label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' verified successfully on </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">."</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to verify Data Label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' on </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span>&amp;2
    blkid <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Show full blkid output for debugging</span>
    <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">"--- Script finished successfully! ---"</span>
<span class="nb">echo</span> <span class="s2">"Device: </span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Partitions created and formatted:"</span>
lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,LABEL,PARTLABEL,MOUNTPOINT <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>

<span class="nb">exit </span>0
</code></section></div></div>
  <h3 id="phase-4-install-sbnb-boot-files-and-configuration">
    
    
     <a href="#phase-4-install-sbnb-boot-files-and-configuration">#</a><a href="#" aria-label="Back to top">Phase 4: Install Sbnb Boot Files and Configuration</a>
        
    
  </h3>
      

<ol>
  <li><strong>Mount EFI Partition:</strong> Access the ESP filesystem.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Mounting ESP partition ---"</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /mnt/sbnb-mount
<span class="nb">sudo </span>mount /dev/sdX1 /mnt/sbnb-mount
</code></section></div>    </div>
  </li>
  <li><strong>Create EFI Boot Directory:</strong> Standard UEFI fallback path.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Creating EFI boot directories ---"</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /mnt/sbnb-mount/EFI/BOOT
</code></section></div>    </div>
  </li>
  <li><strong>Copy Sbnb EFI Boot File:</strong> Place the bootloader (<code class="language-plaintext highlighter-rouge">sbnb.efi</code> as <code class="language-plaintext highlighter-rouge">BOOTX64.EFI</code>).
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Copying Sbnb EFI boot file ---"</span>
<span class="nb">sudo cp </span>sbnb.efi /mnt/sbnb-mount/EFI/BOOT/BOOTX64.EFI
</code></section></div>    </div>
  </li>
  <li><strong>(Recommended) Create Sbnb Configuration File:</strong> Place <code class="language-plaintext highlighter-rouge">sbnb-tskey.txt</code> in ESP root (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-mount/</code>). The <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> script reads this to configure Tailscale.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Creating Sbnb configuration file (sbnb-tskey.txt) ---"</span>
<span class="nb">echo</span> <span class="s2">"tskey-auth-..."</span> | <span class="nb">sudo tee</span> /mnt/sbnb-mount/sbnb-tskey.txt <span class="o">&gt;</span> /dev/null
</code></section></div>    </div>
  </li>
  <li><strong>(Crucial) Handle Data Partition Mounting via <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>:</strong>
    <ul>
      <li><strong>Context &amp; Goal:</strong> Sbnb boots -&gt; systemd -&gt; <code class="language-plaintext highlighter-rouge">sbnb.service</code> -&gt; <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> -&gt; mounts ESP to <code class="language-plaintext highlighter-rouge">/mnt/sbnb</code> -&gt; executes <code class="language-plaintext highlighter-rouge">/mnt/sbnb/sbnb-cmds.sh</code>. This script mounts the data partition (labeled <code class="language-plaintext highlighter-rouge">SBNB_DATA</code>) to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
      <li><strong>Device Detection Timing:</strong> There’s a potential race: the kernel/udev might not have created the <code class="language-plaintext highlighter-rouge">/dev/disk/by-label/SBNB_DATA</code> symlink or the <code class="language-plaintext highlighter-rouge">/dev/sdX2</code> node exactly when the script runs. The wait loop mitigates this.</li>
      <li><strong>Default Script Conflict Uncertainty:</strong> The <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> excerpt doesn’t show conflicting actions at its execution point. However, other early boot mechanisms could exist in Sbnb. If <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> behaves unexpectedly, investigate potential early boot scripts/services related to storage in your Sbnb version (advanced).</li>
      <li><strong><code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> Script (Wait Loop &amp; Logging):</strong> Create this in the ESP root (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-mount/</code> during prep).
```bash
#!/bin/sh
  <h1 id="custom-sbnb-cmdssh-for-usb-persistent-partition-setup-no-lvm">
    
    
     <a href="#custom-sbnb-cmdssh-for-usb-persistent-partition-setup-no-lvm">#</a><a href="#" aria-label="Back to top">Custom sbnb-cmds.sh for USB Persistent Partition setup (No LVM)</a>
        
    
  </h1>
      
  <h1 id="mounts-partition-labeled-data_label-to-mount_point-after-waiting-for-device">
    
    
     <a href="#mounts-partition-labeled-data_label-to-mount_point-after-waiting-for-device">#</a><a href="#" aria-label="Back to top">Mounts partition labeled DATA_LABEL to MOUNT_POINT after waiting for device.</a>
        
    
  </h1>
      
  <h1 id="for-debugging-uncomment-set--x-to-trace-command-execution">
    
    
     <a href="#for-debugging-uncomment-set--x-to-trace-command-execution">#</a><a href="#" aria-label="Back to top">For debugging, uncomment ‘set -x’ to trace command execution.</a>
        
    
  </h1>
      
  <h1 id="set--x">
    
    
     <a href="#set--x">#</a><a href="#" aria-label="Back to top">set -x</a>
        
    
  </h1>
      
      </li>
    </ul>
  </li>
</ol>
  <h1 id="function-to-log-messages-consistently-to-kernel-buffer-dmesg-and-console-tty">
    
    
     <a href="#function-to-log-messages-consistently-to-kernel-buffer-dmesg-and-console-tty">#</a><a href="#" aria-label="Back to top">Function to log messages consistently to kernel buffer (dmesg) and console (tty)</a>
        
    
  </h1>
      
<p>log_msg() {
  echo “sbnb-cmds.sh: $1” | tee /dev/kmsg
}</p>

<p>log_msg “— Running Custom USB Partition Mount Script —”</p>
  <h1 id="-configuration-">
    
    
     <a href="#-configuration-">#</a><a href="#" aria-label="Back to top">— Configuration —</a>
        
    
  </h1>
      
<p>MOUNT_POINT=”/mnt/sbnb-data”  # Target directory for persistent data
DATA_LABEL=”SBNB_DATA”        # Filesystem label of the data partition (MUST match mkfs.ext4 -L)</p>
  <h1 id="alternative-use-uuid-for-potentially-more-stable-identification-if-labels-changeconflict">
    
    
     <a href="#alternative-use-uuid-for-potentially-more-stable-identification-if-labels-changeconflict">#</a><a href="#" aria-label="Back to top">Alternative: Use UUID for potentially more stable identification if labels change/conflict</a>
        
    
  </h1>
      
  <h1 id="get-uuid-using-sudo-blkid-devsdx2-on-prep-machine-then-set">
    
    
     <a href="#get-uuid-using-sudo-blkid-devsdx2-on-prep-machine-then-set">#</a><a href="#" aria-label="Back to top">Get UUID using ‘sudo blkid /dev/sdX2’ on prep machine, then set:</a>
        
    
  </h1>
      
  <h1 id="data_uuidyour-uuid-here">
    
    
     <a href="#data_uuidyour-uuid-here">#</a><a href="#" aria-label="Back to top">DATA_UUID=”YOUR-UUID-HERE”</a>
        
    
  </h1>
      
<p>MAX_WAIT_SECONDS=15           # Max time (seconds) to wait for the device node/label
WAIT_INTERVAL=1               # Check frequency (seconds)
MOUNT_OPTS=”defaults,noatime,nodiratime” # Mount options (noatime/nodiratime reduce writes on flash)</p>
  <h1 id="-end-configuration-">
    
    
     <a href="#-end-configuration-">#</a><a href="#" aria-label="Back to top">— End Configuration —</a>
        
    
  </h1>
      

<p>DATA_DEVICE=””                # Will hold the found device path</p>
  <h1 id="-wait-loop-for-device-">
    
    
     <a href="#-wait-loop-for-device-">#</a><a href="#" aria-label="Back to top">— Wait Loop for Device —</a>
        
    
  </h1>
      
  <h1 id="attempts-to-find-the-device-by-label-or-uuid-if-configured">
    
    
     <a href="#attempts-to-find-the-device-by-label-or-uuid-if-configured">#</a><a href="#" aria-label="Back to top">Attempts to find the device by label or UUID (if configured).</a>
        
    
  </h1>
      
  <h1 id="waits-because-device-node-creation-by-kerneludev-might-be-delayed">
    
    
     <a href="#waits-because-device-node-creation-by-kerneludev-might-be-delayed">#</a><a href="#" aria-label="Back to top">Waits because device node creation by kernel/udev might be delayed.</a>
        
    
  </h1>
      
<p>elapsed_wait=0
log_msg “Waiting up to ${MAX_WAIT_SECONDS}s for device (Label: ${DATA_LABEL:-N/A})…”
while [ -z “$DATA_DEVICE” ] &amp;&amp; [ $elapsed_wait -lt $MAX_WAIT_SECONDS ]; do
  # Check for device using the label symlink first (usually faster if udev ran)
  label_path=”/dev/disk/by-label/${DATA_LABEL}”
  if [ -e “$label_path” ]; then
      # Readlink -f resolves the symlink to the actual device path (e.g., /dev/sdb2)
      DATA_DEVICE=$(readlink -f “$label_path”)
      log_msg “Found device via label symlink: $label_path -&gt; $DATA_DEVICE”
      break # Exit loop
  fi</p>

<p># Fallback: Use blkid command to scan for the label (can be slower)
  blkid_device=$(blkid -L “${DATA_LABEL}” 2&gt;/dev/null)
  if [ -n “$blkid_device” ]; then
      DATA_DEVICE=”$blkid_device”
      log_msg “Found device via blkid label lookup: $DATA_DEVICE”
      break # Exit loop
  fi</p>

<p># (Add similar checks here using DATA_UUID if using UUID instead of Label)</p>

<p># Device not found yet, wait before next check
  sleep $WAIT_INTERVAL
  elapsed_wait=$((elapsed_wait + WAIT_INTERVAL))
done</p>
  <h1 id="-mount-logic-">
    
    
     <a href="#-mount-logic-">#</a><a href="#" aria-label="Back to top">— Mount Logic —</a>
        
    
  </h1>
      
  <h1 id="proceed-only-if-a-device-path-was-successfully-determined">
    
    
     <a href="#proceed-only-if-a-device-path-was-successfully-determined">#</a><a href="#" aria-label="Back to top">Proceed only if a device path was successfully determined</a>
        
    
  </h1>
      
<p>if [ -n “$DATA_DEVICE” ] &amp;&amp; [ -e “$DATA_DEVICE” ]; then
  log_msg “Data partition device resolved to ${DATA_DEVICE} after ${elapsed_wait}s.”</p>

<p># Check if the target directory is already a mount point
  if ! mountpoint -q “$MOUNT_POINT”; then
    log_msg “Attempting to mount $DATA_DEVICE at $MOUNT_POINT with options: $MOUNT_OPTS…”
    # Ensure the target directory exists
    mkdir -p “$MOUNT_POINT”
    # Mount the device
    if mount -o “$MOUNT_OPTS” “$DATA_DEVICE” “$MOUNT_POINT”; then
      log_msg “Successfully mounted persistent partition at $MOUNT_POINT.”
    else
      mount_exit_code=$?
      log_msg “ERROR: Failed to mount $DATA_DEVICE at $MOUNT_POINT (exit code: $mount_exit_code). Check filesystem type/integrity (run fsck?). See dmesg for details.” &gt;&amp;2
    fi
  else
    # Mount point exists, verify if it’s the correct device
    log_msg “$MOUNT_POINT is already a mount point. Checking device…”
    # Check /proc/mounts for the currently mounted device at MOUNT_POINT
    if grep -qs “$DATA_DEVICE $MOUNT_POINT” /proc/mounts; then
          log_msg “Persistent partition already correctly mounted at $MOUNT_POINT.”
    else
          mounted_dev=$(grep -s “$MOUNT_POINT” /proc/mounts | awk ‘{print $1}’)
          log_msg “ERROR: $MOUNT_POINT is already mounted, but by ‘$mounted_dev’ NOT ‘$DATA_DEVICE’! Check system configuration.” &gt;&amp;2
    fi
  fi
else
  # Device wasn’t found within the timeout
  log_msg “ERROR: Data partition device (Label: ${DATA_LABEL:-N/A}) not found after waiting ${MAX_WAIT_SECONDS}s. Cannot mount persistent storage.” &gt;&amp;2
fi</p>

<p>mkdir -p /etc/docker
cp /mnt/sbnb-data/docker/docker-daemon.json.template /etc/docker/daemon.json</p>

<p>log_msg “— Finished Custom USB Partition Mount Script —”</p>
  <h1 id="exit-0-ensures-the-rest-of-the-sbnb-boot-sequence-continues">
    
    
     <a href="#exit-0-ensures-the-rest-of-the-sbnb-boot-sequence-continues">#</a><a href="#" aria-label="Back to top">Exit 0 ensures the rest of the Sbnb boot sequence continues</a>
        
    
  </h1>
      
<p>exit 0</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>    * Place script content into `/mnt/sbnb-mount/sbnb-cmds.sh`.
    * Make executable: `sudo chmod +x /mnt/sbnb-mount/sbnb-cmds.sh`.

6.  **Unmount the EFI Partition:**
    ```bash
    echo "--- Unmounting ESP partition ---"
    # Ensure buffers are flushed before unmounting
    sync
    sudo umount /mnt/sbnb-mount
    ```

### Phase 4.5: Backing Up Data (CRITICAL!)

* **Why Essential:** High risk of USB drive failure. Backups are mandatory.
* **Strategy:** Automate regular backups of `/mnt/sbnb-data`.
* **File Data Backup (`rsync`):** Ensure the backup destination (NAS, cloud, another server) has sufficient free space.
    ```bash
    # Example: From Sbnb to backup-server (requires ssh key auth)
    rsync -avz --delete --progress --human-readable /mnt/sbnb-data/ user@backup-server:/path/to/backups/sbnb-usb-data/
    ```
* **Frequency:** Daily recommended for active data.
* **Automation:** Use cron/systemd timers or remote triggers.
* **Testing Restores:** Vital! Don't assume backups work.
    * **Conceptual Restore:** Boot Linux Live env -&gt; Mount backup source -&gt; Mount target USB data partition (new/reformatted) to `/mnt/restore` -&gt; `sudo rsync -av --progress /path/to/backup/sbnb-usb-data/ /mnt/restore/` -&gt; Verify restored files (count, size, checksums, spot checks).
* **Verification:** Use tools like `diff -r`, `md5sum`, or `sha256sum` to compare restored files against originals or known good copies.
* *Untested backups provide a false sense of security.*

### Phase 5: Boot and Verify

1.  **Safely Eject:** Eject USB from prep system.
2.  **Configure Server BIOS/UEFI:** Enter setup (DEL, F2, F10, F12, etc.). Ensure UEFI Mode ON, CSM/Legacy OFF, Secure Boot OFF. Set "UEFI: USB..." as first boot device. Save &amp; Exit.
3.  **Boot Sbnb Linux.**
4.  **Verify Operation:**
    * Monitor Boot: Watch console for `sbnb-cmds.sh` logs, errors.
    * SSH into Sbnb.
    * Check Mounts:
        ```bash
        lsblk -o NAME,SIZE,TYPE,FSTYPE,LABEL,MOUNTPOINT # Look for mount at /mnt/sbnb-data
        df -hT | grep -E 'Filesystem|/mnt/sbnb-data'     # Check usage/type
        mount | grep /mnt/sbnb-data                      # Check mount options (rw, noatime)
        findmnt /mnt/sbnb-data                           # Another way to check mount info
        ```
    * Test Persistence:
        ```bash
        # After SSHing in:
        TIMESTAMP=$(date)
        echo "Sbnb USB Persistence test - $TIMESTAMP" | sudo tee /mnt/sbnb-data/persistence_test.txt &gt; /dev/null
        sync &amp;&amp; echo "Synced data to disk."
        echo "File created. Content:" &amp;&amp; sudo cat /mnt/sbnb-data/persistence_test.txt
        echo "Rebooting server now..." &amp;&amp; sudo reboot

        # --- Wait for reboot and reconnect via SSH ---
        echo "Checking for file after reboot..."
        if [ -f /mnt/sbnb-data/persistence_test.txt ]; then
          echo "SUCCESS: File found. Content:" &amp;&amp; sudo cat /mnt/sbnb-data/persistence_test.txt
          sudo rm /mnt/sbnb-data/persistence_test.txt # Clean up
        else
          echo "FAILURE: File NOT FOUND after reboot! Persistence failed."
        fi
        ```

## Troubleshooting

* **Doesn't Boot / No Bootable Device:**
    * Re-verify BIOS settings (UEFI, Secure Boot OFF, Boot Order).
    * Re-verify USB Prep: Partitions (`parted print`), ESP flags (`boot`,`esp`), ESP filesystem label (`blkid /dev/sdX1` -&gt; `LABEL="sbnb"`), EFI file path (`/EFI/BOOT/BOOTX64.EFI`).
    * Try different USB ports (check if port provides sufficient power). Test drive health on prep machine (`fsck`, `badblocks -nvs /dev/sdX`). Recreate drive meticulously.
* **Data Partition Not Mounted / `/mnt/sbnb-data` Empty:**
    * Check boot logs (`journalctl -b`, console) for `sbnb-cmds.sh` errors ("Device... not found", "Failed to mount"). Check `dmesg` for USB errors (`dmesg | grep -iE 'usb|sdX'`) or filesystem errors (`dmesg | grep -i ext4`).
    * SSH in:
        * Verify partition &amp; label: `sudo blkid`, `ls -l /dev/disk/by-label/`. Is `SBNB_DATA` present? Does it point to the correct device?
        * If label wrong/missing: Re-label from prep env (`sudo e2label /dev/sdX2 SBNB_DATA`).
        * If device/label exists, try manual mount: `sudo mkdir -p /mnt/sbnb-data &amp;&amp; sudo mount /dev/disk/by-label/SBNB_DATA /mnt/sbnb-data`. Check `dmesg` for errors (e.g., `mount: wrong fs type, bad option, bad superblock`). If manual mount works, debug `sbnb-cmds.sh` (add `set -x`, check paths, loop duration, check script permissions `ls -l /mnt/sbnb/sbnb-cmds.sh`).
        * Run filesystem check (unmounted): `sudo e2fsck -f /dev/disk/by-label/SBNB_DATA`.
        * Check kernel modules: `lsmod | grep ext4`. Is the module loaded? Check `dmesg` for errors loading filesystem modules.
* **Poor Performance / Drive Failure:**
    * **Performance:** Inherent limitation.
    * **Lifespan/Failure:** Monitor `dmesg` for I/O errors. Restore from verified backups upon failure. This setup will wear out consumer flash drives with persistent writes.

# CODE

sbnb-cmds.sh
```bash
#!/bin/sh
# Sbnb Custom Commands Script
# Mounts persistent data partition at /mnt/sbnb-data, configures Docker data-root on it,
# restores backup, restarts Docker, updates dev env script atomically, enables backup units.

# Exit immediately if a command exits with a non-zero status. Crucial for boot scripts.
# Use pipefail to ensure pipeline failure is detected.
set -e -o pipefail

# --- Script Start Logging ---
echo "[sbnb-cmds.sh] Starting custom boot commands..." &gt; /dev/kmsg

# --- Mount Persistent Data Partition ---
DATA_LABEL="SBNB_DATA"
DATA_DEVICE_SYMLINK="/dev/disk/by-label/${DATA_LABEL}"
# --- NEW Mount Point ---
DATA_MOUNT_POINT="/mnt/sbnb-data"
MAX_WAIT_SECONDS=15
WAIT_INTERVAL=1
elapsed_time=0

echo "[sbnb-cmds.sh] Waiting up to ${MAX_WAIT_SECONDS}s for data device (Label: ${DATA_LABEL})..." &gt; /dev/kmsg

# Wait for the device symlink to appear
while [ ! -e "${DATA_DEVICE_SYMLINK}" ]; do
    if [ ${elapsed_time} -ge ${MAX_WAIT_SECONDS} ]; then
        echo "[sbnb-cmds.sh] ERROR: Timeout waiting for device ${DATA_DEVICE_SYMLINK}. Persistent data cannot be mounted." &gt; /dev/kmsg
        exit 1 # Exit: cannot proceed without data partition
    fi
    sleep ${WAIT_INTERVAL}
    elapsed_time=$((elapsed_time + WAIT_INTERVAL))
done

# Resolve the actual device node using readlink -f for canonical path
DATA_DEVICE=$(readlink -f "${DATA_DEVICE_SYMLINK}")
echo "[sbnb-cmds.sh] Data partition device resolved to ${DATA_DEVICE} after ${elapsed_time}s." &gt; /dev/kmsg

# Create mount point (ensure parent /mnt/sbnb-data exists if needed, mkdir -p handles this)
# Assuming /mnt/sbnb-data exists, we create the /docker subdirectory for mounting.
mkdir -p "${DATA_MOUNT_POINT}"
echo "[sbnb-cmds.sh] Attempting to mount ${DATA_DEVICE} at ${DATA_MOUNT_POINT}..." &gt; /dev/kmsg
# Mount read-write. noatime/nodiratime improve performance by reducing metadata writes.
if mount -o rw,noatime,nodiratime "${DATA_DEVICE}" "${DATA_MOUNT_POINT}"; then
    echo "[sbnb-cmds.sh] Successfully mounted persistent partition at ${DATA_MOUNT_POINT}." &gt; /dev/kmsg
else
    echo "[sbnb-cmds.sh] ERROR: Failed to mount ${DATA_DEVICE} at ${DATA_MOUNT_POINT}!" &gt; /dev/kmsg
    exit 1 # Exit: cannot proceed without data partition mounted
fi

# --- Configure Docker data-root and Restore Data ---
echo "[sbnb-cmds.sh] Configuring Docker data-root and checking restore..." &gt; /dev/kmsg

# Define the NEW location for Docker's root data directory on the persistent partition
# --- Path updated relative to new mount point ---
DOCKER_DATA_ROOT_PERSISTENT="${DATA_MOUNT_POINT}/docker-root"
# Define the standard location for Docker's configuration file
DOCKER_CONFIG_DIR="/etc/docker"
DOCKER_CONFIG_FILE="${DOCKER_CONFIG_DIR}/daemon.json"

# Define backup location
# --- Path updated relative to new mount point ---
BACKUP_DIR="${DATA_MOUNT_POINT}/backups/docker" # Path on the mounted data partition
LATEST_LINK="${BACKUP_DIR}/docker_latest.tar.gz"

# 1. Ensure the new Docker data-root directory exists on the persistent partition
echo "[sbnb-cmds.sh] Ensuring Docker data directory exists: ${DOCKER_DATA_ROOT_PERSISTENT}" &gt; /dev/kmsg
mkdir -p "${DOCKER_DATA_ROOT_PERSISTENT}"
if [ $? -ne 0 ]; then
    echo "[sbnb-cmds.sh] ERROR: Failed to create persistent Docker data directory ${DOCKER_DATA_ROOT_PERSISTENT}!" &gt; /dev/kmsg
    exit 1
fi

# 2. Create/Update Docker daemon configuration to use the new data-root
echo "[sbnb-cmds.sh] Configuring Docker daemon (${DOCKER_CONFIG_FILE}) to use data-root: ${DOCKER_DATA_ROOT_PERSISTENT}" &gt; /dev/kmsg
mkdir -p "${DOCKER_CONFIG_DIR}"
# Create a minimal daemon.json setting the data-root.
# WARNING: This command OVERWRITES any existing ${DOCKER_CONFIG_FILE}.
# If you have other custom daemon settings (log drivers, storage opts, mirrors, etc.),
# they will be LOST. Backup the existing file first if unsure (e.g., cp ${DOCKER_CONFIG_FILE} ${DOCKER_CONFIG_FILE}.bak).
# For merging settings, consider using 'jq' if available in this environment.
printf '{\n  "data-root": "%s"\n}\n' "${DOCKER_DATA_ROOT_PERSISTENT}" &gt; "${DOCKER_CONFIG_FILE}"
if [ $? -ne 0 ]; then
    echo "[sbnb-cmds.sh] ERROR: Failed to write Docker config file ${DOCKER_CONFIG_FILE}!" &gt; /dev/kmsg
    exit 1
fi
echo "[sbnb-cmds.sh] Docker daemon configuration updated." &gt; /dev/kmsg

# 3. Restore Docker data INTO the NEW persistent location (if backup exists)
echo "[sbnb-cmds.sh] Checking for Docker backup..." &gt; /dev/kmsg
# Check if the target directory is empty before attempting restore.
# This prevents accidentally overwriting existing data if restore is run multiple times without cleanup.
if [ -L "${LATEST_LINK}" ] &amp;&amp; [ -z "$(ls -A "${DOCKER_DATA_ROOT_PERSISTENT}")" ]; then
    # Attempt to resolve the absolute path of the file the symlink points to
    ACTUAL_BACKUP_FILE=$(readlink -f "${LATEST_LINK}")
    # Check if readlink succeeded (exit status 0) AND the target file actually exists
    if [ $? -eq 0 ] &amp;&amp; [ -f "${ACTUAL_BACKUP_FILE}" ]; then
        echo "[sbnb-cmds.sh] Found latest backup: ${ACTUAL_BACKUP_FILE}. Restoring to ${DOCKER_DATA_ROOT_PERSISTENT}..." &gt; /dev/kmsg
        # Extract archive directly into the new persistent data-root directory.
        # IMPORTANT: Assumes the backup archive contains the contents *of* the docker data dir
        # (e.g., image/, volumes/, containers/) directly at the top level.
        # If the archive contains a leading directory (e.g., 'docker/' or './'), adjust the -C path or use --strip-components=1 with tar.
        # Verify archive structure first if unsure, e.g., using: tar -tf "${ACTUAL_BACKUP_FILE}" | head -n 5
        if tar -xzf "${ACTUAL_BACKUP_FILE}" -C "${DOCKER_DATA_ROOT_PERSISTENT}"; then
            echo "[sbnb-cmds.sh] Docker data restored successfully to persistent storage." &gt; /dev/kmsg
        else
            echo "[sbnb-cmds.sh] ERROR: Failed to extract Docker data from ${ACTUAL_BACKUP_FILE} to ${DOCKER_DATA_ROOT_PERSISTENT}! Docker might start fresh or with inconsistent data." &gt; /dev/kmsg
            # Clean up potentially corrupted/partial restore attempt
            rm -rf "${DOCKER_DATA_ROOT_PERSISTENT:?}/"*
            # Allowing Docker to start fresh might be safer.
        fi
    else
        echo "[sbnb-cmds.sh] WARNING: Latest backup link '${LATEST_LINK}' exists but is broken or points to non-existent file. Skipping restore." &gt; /dev/kmsg
    fi
elif [ -L "${LATEST_LINK}" ]; then
     echo "[sbnb-cmds.sh] Docker data directory ${DOCKER_DATA_ROOT_PERSISTENT} is not empty. Skipping restore to avoid overwrite." &gt; /dev/kmsg
else
    echo "[sbnb-cmds.sh] No latest Docker backup link found (${LATEST_LINK}). Docker will use/create data in ${DOCKER_DATA_ROOT_PERSISTENT}." &gt; /dev/kmsg
fi
echo "[sbnb-cmds.sh] Docker data-root configuration and restore check finished." &gt; /dev/kmsg

# --- Restart Docker Service ---
# Explicitly reload daemon config and restart Docker to apply data-root change.
# Reload ensures systemd is aware of the potentially changed daemon.json before restarting.
echo "[sbnb-cmds.sh] Reloading systemd daemon and restarting Docker service..." &gt; /dev/kmsg
if systemctl daemon-reload &amp;&amp; systemctl restart docker; then
    echo "[sbnb-cmds.sh] Docker service restarted successfully." &gt; /dev/kmsg
else
    # --- FIX: Exit on Docker restart failure ---
    echo "[sbnb-cmds.sh] ERROR: Failed to reload systemd or restart Docker service! Halting script." &gt; /dev/kmsg
    # Exit because subsequent steps might depend on Docker running correctly.
    # Remove 'exit 1' below and restore comment if continuing on failure is the desired behavior.
    exit 1
fi


# --- Update sbnb-dev-env.sh Script (Atomic Method) ---
# This script uses a named volume backed by a path on the persistent storage.
TARGET_DEV_ENV_SCRIPT="/usr/sbin/sbnb-dev-env.sh"
TARGET_DIR=$(dirname "${TARGET_DEV_ENV_SCRIPT}")
TMP_SCRIPT="" # Initialize temporary script variable

# Setup trap to automatically clean up the temporary file ${TMP_SCRIPT} if the script exits
# prematurely (e.g., due to an error [EXIT] or signals [HUP, INT, QUIT, TERM]).
trap 'if [ -n "${TMP_SCRIPT}" ] &amp;&amp; [ -f "${TMP_SCRIPT}" ]; then rm -f "${TMP_SCRIPT}"; echo "[sbnb-cmds.sh] Cleaned up temporary file ${TMP_SCRIPT}" &gt; /dev/kmsg; fi' EXIT HUP INT QUIT TERM

echo "[sbnb-cmds.sh] Attempting atomic update of ${TARGET_DEV_ENV_SCRIPT}..." &gt; /dev/kmsg

# NOTE: This section assumes ${TARGET_DIR} is writable in the current boot environment.
# Ensure the target directory exists
if [ ! -d "${TARGET_DIR}" ]; then
    echo "[sbnb-cmds.sh] ERROR: Target directory ${TARGET_DIR} does not exist. Cannot update script." &gt; /dev/kmsg
    exit 1
fi

# Create a temporary file securely in the target directory
# Using mktemp is preferred for security and avoiding collisions.
TMP_SCRIPT=$(mktemp "${TARGET_DIR}/sbnb-dev-env.sh.XXXXXX")
if [ -z "${TMP_SCRIPT}" ] || [ ! -f "${TMP_SCRIPT}" ]; then
    echo "[sbnb-cmds.sh] ERROR: Failed to create temporary file in ${TARGET_DIR}." &gt; /dev/kmsg
    exit 1
fi
echo "[sbnb-cmds.sh] Created temporary file: ${TMP_SCRIPT}" &gt; /dev/kmsg

# Write the new script content to the temporary file using a quoted here document.
# Quoting 'EOF' prevents shell expansion of variables ($VAR) inside the here document.
cat &lt;&lt;'EOF' &gt; "${TMP_SCRIPT}"
#!/bin/sh
# Exit immediately if a command exits with a non-zero status.
# Treat unset variables as an error when substituting.
# Print commands and their arguments as they are executed.
# The return value of a pipeline is the status of the last command to exit with a non-zero status,
# or zero if no command exited with a non-zero status.
set -euxo pipefail

# --- Configuration ---
# Use Ubuntu 24.04 LTS as the base image.
IMAGE="ubuntu:24.04"
# Name for the development environment container.
NAME="sbnb-dev-env"
# Name for the Docker named volume for persistent data FOR THIS CONTAINER.
DATA_VOLUME_NAME="sbnb-dev-data"
# --- Specify the host path where THIS specific named volume's data should be stored ---
# --- Path updated relative to new mount point /mnt/sbnb-data ---
DATA_VOLUME_HOST_PATH="/mnt/sbnb-data/docker-volumes/${DATA_VOLUME_NAME}"
# Target directory inside the container for persistent data.
DATA_CONTAINER_DIR="/data"
# Initialization script path on the host (relative to the mounted '/' -&gt; '/host').
INIT_SCRIPT_HOST_PATH="/usr/sbin/_sbnb-dev-env-container.sh"

# --- Check if container is already running ---
# Check if container is already running using Docker's name filter.
# -q outputs only IDs, --filter selects by name (anchored ^/name$), grep -q . checks if any output exists.
echo "Checking for existing container: ${NAME}..."
if docker ps -q --filter "name=^/${NAME}$" | grep -q .; then
    echo "Attaching to existing container: ${NAME}"
    # Execute tmux, creating a new session named 'sbnb-dev-env' if it doesn't exist,
    # or attaching to it if it does.
    docker exec -it "${NAME}" tmux new-session -A -s sbnb-dev-env
    exit 0 # Exit successfully after attaching
fi

# --- Prerequisites Check ---

# --- Ensure the specific host directory FOR THIS VOLUME exists ---
# When binding a named volume to a specific host path using the 'local' driver options below,
# the target host path MUST exist beforehand.
echo "Checking if host path for volume data exists: ${DATA_VOLUME_HOST_PATH}"
# Create the specific directory for this volume if it doesn't exist
mkdir -p "${DATA_VOLUME_HOST_PATH}"
if [ $? -ne 0 ]; then
    echo "Error: Failed to create host path for volume data: ${DATA_VOLUME_HOST_PATH}" &gt;&amp;2
    exit 1
fi
echo "Host path for volume data found/created: ${DATA_VOLUME_HOST_PATH}"
# ---&gt; IMPORTANT PERMISSIONS NOTE &lt;---
# Ensure this host directory (${DATA_VOLUME_HOST_PATH}) has the correct permissions
# (e.g., ownership/group/mode) for the user/process running inside the container
# that needs to write to ${DATA_CONTAINER_DIR}. Docker does NOT automatically manage
# permissions on pre-existing host paths used this way. Incorrect host path permissions
# are a common cause of 'Permission denied' errors inside the container for this setup.
# Example: sudo chown $(id -u):$(id -g) ${DATA_VOLUME_HOST_PATH} (Run this manually if needed)

# Ensure the Docker named volume exists, create if not, binding it to the specified host path.
echo "Checking if Docker volume exists: ${DATA_VOLUME_NAME}"
if ! docker volume inspect "${DATA_VOLUME_NAME}" &gt; /dev/null 2&gt;&amp;1; then
    echo "Volume ${DATA_VOLUME_NAME} not found. Creating and binding to ${DATA_VOLUME_HOST_PATH}..."
    # Create the volume using the 'local' driver with options to bind it to a specific host path.
    docker volume create \
      --driver local \
      --opt type=none \
      --opt "device=${DATA_VOLUME_HOST_PATH}" \
      --opt o=bind \
      "${DATA_VOLUME_NAME}"
    echo "Volume ${DATA_VOLUME_NAME} created and bound to host path."
else
    echo "Volume ${DATA_VOLUME_NAME} already exists."
    # NOTE (Edge Case): This check assumes the existing volume is correctly bound to ${DATA_VOLUME_HOST_PATH}.
fi

# Ensure the initialization script exists on the host
# This check remains crucial as the script is still accessed via the host mount.
echo "Checking if initialization script exists: ${INIT_SCRIPT_HOST_PATH}"
if [ ! -f "${INIT_SCRIPT_HOST_PATH}" ]; then
    echo "Error: Initialization script not found on host: ${INIT_SCRIPT_HOST_PATH}" &gt;&amp;2
    exit 1 # Exit if script doesn't exist
fi
echo "Initialization script found."


# --- Create and run a new dev container ---
echo "Creating new development container: ${NAME} with image ${IMAGE}"
# Note: Docker's main data-root is now configured via daemon.json (by sbnb-cmds.sh)
# to use persistent storage. This volume mount provides specific persistent storage for this container.
docker run \
    -it \
    -d \
    --privileged \
    -v /root:/root \
    -v /dev:/dev \
    -v /:/host \
    -v /var/run/docker.sock:/var/run/docker.sock \
    -v "${DATA_VOLUME_NAME}:${DATA_CONTAINER_DIR}" \
    --net=host \
    --name "${NAME}" \
    --rm \
    --pull=always \
    --ulimit nofile=262144:262144 \
    "${IMAGE}" \
    sleep infinity
# End of docker run command options. IMAGE and COMMAND follow.

# --- Execute initialization script inside the container ---
echo "Executing initialization script inside the container (${INIT_SCRIPT_HOST_PATH})..."
# CRITICAL: The successful setup and usability of the container environment heavily depend
# on the correct execution and content of the script located at /host${INIT_SCRIPT_HOST_PATH}.
# Ensure that script performs all necessary setup steps required within the container.
docker exec -it "${NAME}" bash "/host${INIT_SCRIPT_HOST_PATH}" # Note the path combines /host + script path

# --- Attach to the container's tmux session ---
echo "Attaching to the new container's tmux session..."
docker exec -it "${NAME}" tmux new-session -A -s sbnb-dev-env

echo "-----------------------------------------------------"
echo "Container ${NAME} is running. Initialization script executed. Attached via tmux."
echo "Specific data for this container is persisted in Docker named volume: ${DATA_VOLUME_NAME}"
echo "(Volume data is stored on the host at: ${DATA_VOLUME_HOST_PATH})"
echo "Docker main data-root is configured via /etc/docker/daemon.json."
echo "Remember to configure applications inside the container to use '${DATA_CONTAINER_DIR}' for storage."
echo "Ensure host path '${DATA_VOLUME_HOST_PATH}' has correct permissions for container processes."
echo "-----------------------------------------------------"
EOF

# Check if cat succeeded (redundant check if set -e is active, but harmless)
if [ $? -ne 0 ]; then
    echo "[sbnb-cmds.sh] ERROR: Failed to write content to temporary file ${TMP_SCRIPT}." &gt; /dev/kmsg
    # Trap will handle cleanup
    exit 1
fi

# Set execute permissions on the temporary file
echo "[sbnb-cmds.sh] Setting execute permissions on ${TMP_SCRIPT}..." &gt; /dev/kmsg
if ! chmod +x "${TMP_SCRIPT}"; then
    echo "[sbnb-cmds.sh] ERROR: Failed to set execute permissions on temporary file ${TMP_SCRIPT}." &gt; /dev/kmsg
    # Trap will handle cleanup
    exit 1 # Exit: script must be executable
fi

# Atomically replace the target script with the temporary file
# mv is atomic when moving files within the same filesystem.
echo "[sbnb-cmds.sh] Atomically replacing ${TARGET_DEV_ENV_SCRIPT} with ${TMP_SCRIPT}..." &gt; /dev/kmsg
if ! mv "${TMP_SCRIPT}" "${TARGET_DEV_ENV_SCRIPT}"; then
    echo "[sbnb-cmds.sh] ERROR: Failed to move temporary file ${TMP_SCRIPT} to ${TARGET_DEV_ENV_SCRIPT}." &gt; /dev/kmsg
    # Trap will handle cleanup of TMP_SCRIPT if it still exists
    exit 1
fi

# If mv succeeds, the temporary file no longer exists under its old name.
# Clear TMP_SCRIPT variable so the trap doesn't try to remove the (now moved) file.
TMP_SCRIPT=""
echo "[sbnb-cmds.sh] Successfully updated ${TARGET_DEV_ENV_SCRIPT}." &gt; /dev/kmsg
echo "[sbnb-cmds.sh] Update of ${TARGET_DEV_ENV_SCRIPT} finished." &gt; /dev/kmsg


# --- Enable Systemd Units for Backup/Purge ---
# --- Path updated relative to new mount point ---
SYSTEMD_SOURCE_DIR="/mnt/sbnb/systemd" # Units stored on data partition

echo "[sbnb-cmds.sh] Enabling custom systemd units for Docker backup/purge (Source: ${SYSTEMD_SOURCE_DIR})..." &gt; /dev/kmsg
SYSTEMD_TARGET_DIR="/etc/systemd/system"
TIMERS_WANTS_DIR="${SYSTEMD_TARGET_DIR}/timers.target.wants"

# Ensure systemd directories exist in the ephemeral overlay filesystem
mkdir -p "${SYSTEMD_TARGET_DIR}"
mkdir -p "${TIMERS_WANTS_DIR}"

# Check if source directory with unit files exists on persistent storage
if [ -d "${SYSTEMD_SOURCE_DIR}" ]; then
    # Symlink the unit files from persistent storage to the ephemeral systemd directory.
    # Use -f to force overwrite if links already exist.
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-backup.service" "${SYSTEMD_TARGET_DIR}/"
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-shutdown-backup.service" "${SYSTEMD_TARGET_DIR}/"
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-purge.service" "${SYSTEMD_TARGET_DIR}/"
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-backup.timer" "${SYSTEMD_TARGET_DIR}/" # Link base timer unit too
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-purge.timer" "${SYSTEMD_TARGET_DIR}/"  # Link base timer unit too

    # Link timer units into timers.target.wants to ensure they are started by systemd
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-backup.timer" "${TIMERS_WANTS_DIR}/"
    ln -sf "${SYSTEMD_SOURCE_DIR}/docker-purge.timer" "${TIMERS_WANTS_DIR}/"

    # --- FIX: Removed redundant systemd daemon-reload ---
    # Reloading systemd configuration is necessary after linking new unit files or changing configs like daemon.json.
    # The reload before 'docker restart' already handled the daemon.json change awareness.
    # While reloading again here is safe, it's likely redundant unless the custom units have complex dependencies resolved by the reload.
    # systemctl daemon-reload

    # Explicitly enable the units. This creates necessary symlinks for boot/shutdown targets.
    systemctl enable docker-backup.timer docker-purge.timer docker-shutdown-backup.service

    echo "[sbnb-cmds.sh] Systemd units for backup linked and enabled." &gt; /dev/kmsg
else
    echo "[sbnb-cmds.sh] WARNING: Systemd source directory ${SYSTEMD_SOURCE_DIR} not found. Cannot enable backup units." &gt; /dev/kmsg
fi

# --- Script Finish Logging ---
echo "[sbnb-cmds.sh] Finished custom boot commands." &gt; /dev/kmsg

# Clear trap on successful exit to prevent it from running unnecessarily.
trap - EXIT HUP INT QUIT TERM
exit 0
</code></section></div></div>
<p>sbnb-tskey.txt</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>tskey-auth-k7hXL7D7hS11CNTRL-Px38yn7swFYWnQ7WdCeCGYVL4baCyYXXc

</code></section></div></div>
<p>scripts\backup-docker.sh</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c"># File: /mnt/sbnb-data/scripts/backup-docker.sh</span>
<span class="c"># Script to stop docker, create a backup, and restart docker.</span>
<span class="c"># Assumes tools like tar, gzip, systemctl, ln, mv, date, sleep, mkdir, nice are available.</span>

<span class="nb">set</span> <span class="nt">-e</span> <span class="c"># Exit on error</span>

<span class="nv">BACKUP_DIR</span><span class="o">=</span><span class="s2">"/mnt/sbnb-data/backups/docker"</span>
<span class="nv">DOCKER_DATA_DIR</span><span class="o">=</span><span class="s2">"/var/lib/docker"</span>
<span class="nv">TIMESTAMP</span><span class="o">=</span><span class="si">$(</span><span class="nb">date</span> +<span class="s2">"%Y%m%d_%H%M%S"</span><span class="si">)</span>
<span class="nv">BACKUP_FILE</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">/docker_backup_</span><span class="k">${</span><span class="nv">TIMESTAMP</span><span class="k">}</span><span class="s2">.tar.gz"</span>
<span class="nv">LATEST_LINK</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">/docker_latest.tar.gz"</span> <span class="c"># Symlink to the latest backup</span>

<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Starting Docker backup process..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Ensure backup directory exists</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] ERROR: Failed to create backup directory </span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">!"</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Stop Docker gracefully</span>
<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Stopping Docker service..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if </span>systemctl is-active <span class="nt">--quiet</span> docker.service<span class="p">;</span> <span class="k">then
    if</span> <span class="o">!</span> systemctl stop docker.service<span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Failed to stop Docker service gracefully. Proceeding with backup cautiously."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="k">else</span>
        <span class="c"># Add a small delay to ensure Docker processes have terminated</span>
        <span class="nb">sleep </span>5
    <span class="k">fi
else
    </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Docker service already stopped."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi</span>

<span class="c"># Create the compressed backup</span>
<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Creating backup archive: </span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_DATA_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># Create archive containing paths relative to /var/lib (e.g., 'docker/...')</span>
    <span class="c"># Use nice to lower CPU priority (if available, remove 'nice -n 19' if command is missing)</span>
    <span class="c"># ionice was removed as it's unavailable in this environment.</span>
    <span class="k">if </span><span class="nb">nice</span> <span class="nt">-n</span> 19 <span class="nb">tar</span> <span class="nt">-czf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-C</span> /var/lib docker<span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Backup created successfully: </span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/kmsg
        <span class="c"># Update the 'latest' symlink atomically</span>
        <span class="nb">ln</span> <span class="nt">-sfT</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">.tmp"</span> <span class="o">&amp;&amp;</span> <span class="nb">mv</span> <span class="nt">-Tf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">.tmp"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">"</span>
        <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Updated latest backup link to point to </span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/kmsg
        <span class="k">else
            </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Failed to update latest backup link."</span> <span class="o">&gt;</span> /dev/kmsg
        <span class="k">fi
    else
        </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] ERROR: tar command failed! Backup not created."</span> <span class="o">&gt;</span> /dev/kmsg
        <span class="c"># Attempt to restart docker even if backup failed</span>
    <span class="k">fi
else
    </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Docker data directory </span><span class="k">${</span><span class="nv">DOCKER_DATA_DIR</span><span class="k">}</span><span class="s2"> not found. Skipping backup."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi</span>

<span class="c"># Restart Docker</span>
<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Starting Docker service..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if</span> <span class="o">!</span> systemctl start docker.service<span class="p">;</span> <span class="k">then
     </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Failed to start Docker service after backup attempt."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Docker backup process finished."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="nb">exit </span>0
</code></section></div></div>
<p>scripts\purge-docker-backups.sh</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c"># File: /mnt/sbnb-data/scripts/purge-docker-backups.sh</span>
<span class="c"># Script to remove old Docker backups, keeping the last N.</span>
<span class="c"># Assumes tools like find, sort, head, cut, xargs, rm, wc, mkdir, echo are available.</span>

<span class="nb">set</span> <span class="nt">-e</span> <span class="c"># Exit on error</span>

<span class="nv">BACKUP_DIR</span><span class="o">=</span><span class="s2">"/mnt/sbnb-data/backups/docker"</span>
<span class="nv">KEEP_COUNT</span><span class="o">=</span>3 <span class="c"># Number of backups to keep (adjust as needed)</span>

<span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] Purging old Docker backups in </span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">, keeping </span><span class="k">${</span><span class="nv">KEEP_COUNT</span><span class="k">}</span><span class="s2">..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Ensure backup directory exists</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] ERROR: Failed to ensure backup directory </span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2"> exists!"</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="nb">exit </span>1
<span class="k">fi</span>


<span class="c"># Count existing backups (only files matching the pattern)</span>
<span class="c"># Use find ... -print | wc -l which is safer than parsing ls output</span>
<span class="nv">backup_count</span><span class="o">=</span><span class="si">$(</span>find <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-maxdepth</span> 1 <span class="nt">-name</span> <span class="s1">'docker_backup_*.tar.gz'</span> <span class="nt">-type</span> f <span class="nt">-print</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">backup_count</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-gt</span> <span class="s2">"</span><span class="k">${</span><span class="nv">KEEP_COUNT</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># List all backup files by modification time (oldest first),</span>
    <span class="c"># calculate how many to delete, and delete them.</span>
    <span class="nv">to_delete_count</span><span class="o">=</span><span class="k">$((</span> backup_count <span class="o">-</span> KEEP_COUNT <span class="k">))</span>
    <span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] Found </span><span class="k">${</span><span class="nv">backup_count</span><span class="k">}</span><span class="s2"> backups. Deleting </span><span class="k">${</span><span class="nv">to_delete_count</span><span class="k">}</span><span class="s2"> oldest ones."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="c"># Use -print0 and xargs -0 for safety with filenames containing special characters</span>
    find <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-maxdepth</span> 1 <span class="nt">-name</span> <span class="s1">'docker_backup_*.tar.gz'</span> <span class="nt">-type</span> f <span class="nt">-printf</span> <span class="s1">'%T@ %p\0'</span> | <span class="se">\</span>
        <span class="nb">sort</span> <span class="nt">-zn</span> | <span class="se">\</span>
        <span class="nb">head</span> <span class="nt">-zn</span> <span class="s2">"</span><span class="k">${</span><span class="nv">to_delete_count</span><span class="k">}</span><span class="s2">"</span> | <span class="se">\</span>
        <span class="nb">cut</span> <span class="nt">-z</span> <span class="nt">-d</span><span class="s1">' '</span> <span class="nt">-f2-</span> | <span class="se">\</span>
        xargs <span class="nt">-0</span> <span class="nt">-r</span> <span class="nb">rm</span> <span class="nt">-v</span> <span class="nt">--</span> <span class="c"># Use -r to avoid running rm if head outputs nothing</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
         </span><span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] Purge completed."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="k">else</span>
         <span class="c"># Log error but don't exit, as failure isn't critical for system operation</span>
         <span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] WARNING: Purge command finished with errors (check rm output above)."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="k">fi
else
    </span><span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] </span><span class="k">${</span><span class="nv">backup_count</span><span class="k">}</span><span class="s2"> backups found, which is less than or equal to </span><span class="k">${</span><span class="nv">KEEP_COUNT</span><span class="k">}</span><span class="s2">. No backups purged."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi

</span><span class="nb">exit </span>0
</code></section></div></div>
<p>System Volume Information\IndexerVolumeGuid</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>{ A A A 9 C D 4 5 - 2 E 9 1 - 4 F 7 9 - B 1 4 F - 2 0 9 9 6 F 9 C F 1 C A } 
</code></section></div></div>
<p>systemd\docker-backup.service</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># File: /mnt/sbnb-data/systemd/docker-backup.service
# Service unit to run the backup script

[Unit]
Description=Backup Docker Data to Persistent Storage
Requires=mnt-sbnb-data.mount docker.service
After=mnt-sbnb-data.mount docker.service

[Service]
Type=oneshot
# Run the backup script stored on the persistent drive
ExecStart=/mnt/sbnb/scripts/backup-docker.sh
</code></section></div></div>
<p>systemd\docker-backup.timer</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># File: /mnt/sbnb-data/systemd/docker-backup.timer
# Timer unit to trigger the backup service daily at 5 AM

[Unit]
Description=Daily Docker Backup Timer

[Timer]
# Run daily at 5 AM system time
OnCalendar=*-*-* 05:00:00
AccuracySec=1h
Persistent=true # Run once on boot if missed due to downtime

[Install]
WantedBy=timers.target
</code></section></div></div>
<p>systemd\docker-purge.service</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># File: /mnt/sbnb-data/systemd/docker-purge.service
# Service unit to run the purge script

[Unit]
Description=Purge Old Docker Backups
Requires=mnt-sbnb-data.mount
After=mnt-sbnb-data.mount

[Service]
Type=oneshot
ExecStart=/mnt/sbnb/scripts/purge-docker-backups.sh
</code></section></div></div>
<p>systemd\docker-purge.timer</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># File: /mnt/sbnb-data/systemd/docker-purge.timer
# Timer unit to trigger the purge service daily (e.g., at 6 AM)

[Unit]
Description=Daily Docker Backup Purge Timer

[Timer]
OnCalendar=*-*-* 06:00:00
AccuracySec=1h
Persistent=true

[Install]
WantedBy=timers.target
</code></section></div></div>
<p>systemd\docker-shutdown-backup.service</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code># File: /mnt/sbnb-data/systemd/docker-shutdown-backup.service
# Service unit to attempt a backup on clean shutdown

[Unit]
Description=Backup Docker Data on Shutdown (Best Effort)
# Run late in shutdown, requires persistent storage &amp; docker (to stop it)
DefaultDependencies=no
Requires=mnt-sbnb-data.mount docker.service
After=mnt-sbnb-data.mount docker.service
Before=shutdown.target reboot.target halt.target kexec.target umount.target final.target

[Service]
Type=oneshot
RemainAfterExit=true # Allows ExecStop to run
# Run the backup script when the service is stopped during shutdown
ExecStop=/mnt/sbnb/scripts/backup-docker.sh

[Install]
WantedBy=shutdown.target reboot.target halt.target kexec.target
</code></section></div></div><hr />
  <h2 id="data">
    
    
     <a href="#data">#</a><a href="#" aria-label="Back to top"><strong>data</strong></a>
        
    
  </h2>
      
<ul>
  <li><strong>Project:</strong> Custom Sbnb Linux setup using a single USB drive for boot and persistent data storage.</li>
  <li><strong>Hardware Context:</strong> x86-64 machine, single USB drive partitioned into ESP (FAT32) and Data (Ext4).</li>
  <li><strong>Software Context:</strong> Sbnb Linux (Buildroot-based, Systemd init, ephemeral overlayfs root), Docker.</li>
  <li><strong>Initial Issue:</strong> Boot stall after <code class="language-plaintext highlighter-rouge">systemd[1]: Started Journal Service.</code>.</li>
  <li><strong>Initial Issue Root Cause:</strong> Mismatch between <code class="language-plaintext highlighter-rouge">sbnb.service</code> dependency (<code class="language-plaintext highlighter-rouge">Wants=dev-disk-by-partlabel-sbnb.device</code>) and USB ESP partition setup (missing partition label <code class="language-plaintext highlighter-rouge">sbnb</code>).</li>
  <li><strong>Initial Issue Solution:</strong> Set partition label <code class="language-plaintext highlighter-rouge">sbnb</code> on ESP partition (<code class="language-plaintext highlighter-rouge">/dev/sdx1</code>) using <code class="language-plaintext highlighter-rouge">parted name 1 sbnb</code>.</li>
  <li><strong>Second Issue:</strong> Requirement for Docker data persistence (<code class="language-plaintext highlighter-rouge">/var/lib/docker</code>) on the data partition (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>).</li>
  <li><strong>Chosen Strategy:</strong> Keep Docker data ephemeral (<code class="language-plaintext highlighter-rouge">/var/lib/docker</code> in RAM overlay) and use a backup/restore mechanism with persistent storage (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>).</li>
  <li><strong>Implementation Files (Persistent Storage - <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/backup-docker.sh</code> (Executable Shell Script)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/purge-docker-backups.sh</code> (Executable Shell Script)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-backup.service</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-backup.timer</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-shutdown-backup.service</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-purge.service</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-purge.timer</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/</code> (Directory for backup archives)</li>
    </ul>
  </li>
  <li><strong>Implementation File (ESP - <code class="language-plaintext highlighter-rouge">/mnt/sbnb</code>):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb/sbnb-cmds.sh</code> (Executable Shell Script, modified for restore and unit enabling)</li>
    </ul>
  </li>
  <li><strong>Key Script Logic (<code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>):</strong> Mounts data partition, restores latest backup from data partition to ephemeral <code class="language-plaintext highlighter-rouge">/var/lib/docker</code>, creates symlinks for systemd units from data partition to ephemeral <code class="language-plaintext highlighter-rouge">/etc/systemd/system</code>, reloads systemd, enables units.</li>
  <li><strong>Key Script Logic (<code class="language-plaintext highlighter-rouge">backup-docker.sh</code>):</strong> Stops Docker, creates compressed tar archive of <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> onto data partition backup dir, updates <code class="language-plaintext highlighter-rouge">_latest</code> symlink, restarts Docker. Runs with lowered CPU priority (<code class="language-plaintext highlighter-rouge">nice</code>), I/O priority adjustment (<code class="language-plaintext highlighter-rouge">ionice</code>) removed due to unavailability.</li>
  <li><strong>Key Script Logic (<code class="language-plaintext highlighter-rouge">purge-docker-backups.sh</code>):</strong> Finds backups matching pattern, keeps the latest <code class="language-plaintext highlighter-rouge">N</code> (default 3), deletes older ones.</li>
  <li><strong>Systemd Units:</strong> Define services to run scripts and timers to trigger them periodically (<code class="language-plaintext highlighter-rouge">OnCalendar</code>) or on shutdown (<code class="language-plaintext highlighter-rouge">ExecStop=</code> in shutdown service).</li>
  <li><strong>Verification:</strong> Use <code class="language-plaintext highlighter-rouge">systemctl list-timers</code>, <code class="language-plaintext highlighter-rouge">systemctl status</code>, <code class="language-plaintext highlighter-rouge">journalctl -u</code>, <code class="language-plaintext highlighter-rouge">journalctl -b | grep ...</code>, and practical tests (manual trigger, check files after reboot).
<strong>data</strong></li>
</ul>
  <h2 id="documentation">
    
    
     <a href="#documentation">#</a><a href="#" aria-label="Back to top"><strong>documentation</strong></a>
        
    
  </h2>
      
  <h3 id="project-sbnb-single-usb-boot-and-persistent-docker-data-via-backuprestore">
    
    
     <a href="#project-sbnb-single-usb-boot-and-persistent-docker-data-via-backuprestore">#</a><a href="#" aria-label="Back to top">**Project: Sbnb Single-USB Boot and Persistent Docker Data via Backup/Restore</a>
        
    
  </h3>
      

<p><strong>1. Background and Goal:</strong></p>

<ul>
  <li><strong>System:</strong> Sbnb Linux (minimalist, RAM-based overlayfs root, systemd init).</li>
  <li><strong>Objective:</strong> Configure Sbnb to boot from a single USB drive while also using a separate partition on the same drive for persistent data storage, specifically for Docker containers and volumes.</li>
  <li><strong>Deviation:</strong> This setup deviates from the standard Sbnb practice of using internal server storage (LVM) configured post-boot via automation (e.g., Ansible).</li>
  <li><strong>Reference Tutorial:</strong> Initial attempts followed concepts from the “Single USB for Sbnb Boot and Persistent Storage” tutorial.</li>
</ul>

<p><strong>2. Initial Boot Problem and Resolution:</strong></p>

<ul>
  <li><strong>Symptom:</strong> System boot stalled indefinitely after the log message <code class="language-plaintext highlighter-rouge">systemd[1]: Started Journal Service.</code>.</li>
  <li><strong>Analysis:</strong> Debugging using <code class="language-plaintext highlighter-rouge">journalctl</code> and Sbnb source code (<code class="language-plaintext highlighter-rouge">sbnb.service</code>) revealed a dependency conflict. The <code class="language-plaintext highlighter-rouge">sbnb.service</code> unit explicitly required (<code class="language-plaintext highlighter-rouge">Wants=</code>) the device <code class="language-plaintext highlighter-rouge">dev-disk-by-partlabel-sbnb</code>. However, the USB preparation steps (both from the tutorial and Sbnb’s <code class="language-plaintext highlighter-rouge">create_raw.sh</code>) only set the <em>filesystem label</em> (<code class="language-plaintext highlighter-rouge">mkfs.vfat -n sbnb</code>) on the ESP partition, not the required <em>partition label</em>. Systemd could not find the device via its partition label and waited indefinitely.</li>
  <li><strong>Solution:</strong> Boot into a rescue/live environment, identify the USB device (e.g., <code class="language-plaintext highlighter-rouge">/dev/sdx</code>), and set the partition label on the first (ESP) partition using <code class="language-plaintext highlighter-rouge">sudo parted /dev/sdx name 1 sbnb</code>.</li>
  <li><strong>Result:</strong> After applying the partition label, the system booted successfully past the previous stall point.</li>
</ul>

<p><strong>3. Docker Data Persistence Strategy (Backup/Restore):</strong></p>

<ul>
  <li><strong>Problem:</strong> Docker’s default data directory (<code class="language-plaintext highlighter-rouge">/var/lib/docker</code>) resides within Sbnb’s ephemeral RAM overlay filesystem and is lost on reboot. Direct configuration of Docker’s <code class="language-plaintext highlighter-rouge">data-root</code> to persistent storage via <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code> failed because <code class="language-plaintext highlighter-rouge">/etc</code> is also ephemeral.</li>
  <li><strong>Chosen Strategy:</strong> Keep Docker running with its data in the ephemeral <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> directory. Implement a backup and restore mechanism using the persistent data partition (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>).
    <ul>
      <li><strong>Restore:</strong> On each boot, the <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> script restores the most recent backup from <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/</code> into <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> <em>before</em> the Docker service is started by systemd.</li>
      <li><strong>Backup:</strong> Systemd timers trigger a service periodically (e.g., daily) and on clean shutdown (best-effort) to run a script (<code class="language-plaintext highlighter-rouge">backup-docker.sh</code>) that stops Docker, creates a compressed archive (<code class="language-plaintext highlighter-rouge">.tar.gz</code>) of <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> onto <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/</code>, updates a <code class="language-plaintext highlighter-rouge">docker_latest.tar.gz</code> symlink, and restarts Docker.</li>
      <li><strong>Purge:</strong> A separate systemd timer triggers a script (<code class="language-plaintext highlighter-rouge">purge-docker-backups.sh</code>) to delete old backups, retaining a configured number of recent ones.</li>
    </ul>
  </li>
</ul>

<p><strong>4. Implementation Details:</strong></p>

<ul>
  <li><strong>Persistent File Locations (on Data Partition, mounted at <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>):</strong>
    <ul>
      <li>Backup Archives: <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/docker_backup_YYYYMMDD_HHMMSS.tar.gz</code></li>
      <li>Latest Backup Symlink: <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/docker_latest.tar.gz</code></li>
      <li>Scripts: <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/backup-docker.sh</code>, <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/purge-docker-backups.sh</code> (Must be executable).</li>
      <li>Systemd Units: <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/</code> containing <code class="language-plaintext highlighter-rouge">docker-backup.service</code>, <code class="language-plaintext highlighter-rouge">docker-backup.timer</code>, <code class="language-plaintext highlighter-rouge">docker-shutdown-backup.service</code>, <code class="language-plaintext highlighter-rouge">docker-purge.service</code>, <code class="language-plaintext highlighter-rouge">docker-purge.timer</code>.</li>
    </ul>
  </li>
  <li><strong>Boot Script (on ESP Partition, mounted at <code class="language-plaintext highlighter-rouge">/mnt/sbnb</code>):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb/sbnb-cmds.sh</code>: Contains logic executed early in boot by <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> (which is run by <code class="language-plaintext highlighter-rouge">sbnb.service</code>). See artifact <code class="language-plaintext highlighter-rouge">sbnb_cmds_backup_restore</code> for the full script content. Key actions:
        <ul>
          <li>Waits for and mounts the data partition (<code class="language-plaintext highlighter-rouge">/dev/disk/by-label/SBNB_DATA</code>) to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
          <li>Checks for <code class="language-plaintext highlighter-rouge">${BACKUP_DIR}/docker_latest.tar.gz</code>. If valid, removes existing <code class="language-plaintext highlighter-rouge">/var/lib/docker/*</code> and extracts the backup archive to <code class="language-plaintext highlighter-rouge">/var/lib</code>. Handles missing/broken links gracefully.</li>
          <li>Creates symlinks from the persistent systemd units in <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/</code> to the ephemeral <code class="language-plaintext highlighter-rouge">/etc/systemd/system/</code> directory and appropriate <code class="language-plaintext highlighter-rouge">.wants</code> directories.</li>
          <li>Runs <code class="language-plaintext highlighter-rouge">systemctl daemon-reload</code>.</li>
          <li>Runs <code class="language-plaintext highlighter-rouge">systemctl enable</code> for the timers and the shutdown service.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Backup Script (<code class="language-plaintext highlighter-rouge">backup-docker.sh</code>):</strong> See artifact <code class="language-plaintext highlighter-rouge">sbnb_docker_backup_scripts_v2</code>. Key actions: Stops docker, runs <code class="language-plaintext highlighter-rouge">nice -n 19 tar -czf ... -C /var/lib docker</code>, updates symlink, starts docker. <code class="language-plaintext highlighter-rouge">ionice</code> was removed due to unavailability.</li>
  <li><strong>Purge Script (<code class="language-plaintext highlighter-rouge">purge-docker-backups.sh</code>):</strong> See artifact <code class="language-plaintext highlighter-rouge">sbnb_docker_backup_scripts_v2</code>. Key actions: Finds backups by pattern, counts them, deletes the oldest if count exceeds <code class="language-plaintext highlighter-rouge">KEEP_COUNT</code> (default 3).</li>
  <li><strong>Systemd Units:</strong> See artifact <code class="language-plaintext highlighter-rouge">sbnb_docker_backup_units_v2</code>. Define the services that execute the scripts and the timers (<code class="language-plaintext highlighter-rouge">OnCalendar=daily</code>) that trigger the backup and purge services. The shutdown service uses <code class="language-plaintext highlighter-rouge">ExecStop=</code> and <code class="language-plaintext highlighter-rouge">DefaultDependencies=no</code> to run during shutdown.</li>
</ul>

<p><strong>5. Verification:</strong></p>

<ul>
  <li><strong>Boot:</strong> Check <code class="language-plaintext highlighter-rouge">journalctl -b | grep sbnb-cmds.sh</code> for successful execution and restore messages.</li>
  <li><strong>Docker:</strong> Verify Docker starts and <code class="language-plaintext highlighter-rouge">docker ps</code>, <code class="language-plaintext highlighter-rouge">docker images</code> show expected state restored from backup (if one existed).</li>
  <li><strong>Timers:</strong> Check <code class="language-plaintext highlighter-rouge">systemctl list-timers | grep docker-</code> to ensure timers are active and scheduled.</li>
  <li><strong>Services:</strong> Check <code class="language-plaintext highlighter-rouge">systemctl status *.timer *.service | grep docker-</code> to see loaded/active/enabled states.</li>
  <li><strong>Manual Trigger:</strong> Test backup via <code class="language-plaintext highlighter-rouge">sudo systemctl start docker-backup.service</code> and check for the archive file and symlink in <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/</code>. Test purge similarly.</li>
  <li><strong>Reboot Test:</strong> Create data within a container volume, trigger a backup manually or wait for the timer, reboot, and verify the data is present after the restore runs on the next boot.</li>
</ul>

<p><strong>documentation</strong>
<strong>organized_information</strong></p>
  <h2 id="paper_trail">
    
    
     <a href="#paper_trail">#</a><a href="#" aria-label="Back to top"><strong>paper_trail</strong></a>
        
    
  </h2>
      
<ol>
  <li><strong>Initial Goal:</strong> Configure Sbnb Linux for single-USB boot and persistent storage based on an online tutorial.</li>
  <li><strong>Problem Encountered:</strong> System failed to boot, stalling after <code class="language-plaintext highlighter-rouge">systemd[1]: Started Journal Service.</code>.</li>
  <li><strong>Initial Analysis:</strong> Logs suggested potential issues with device dependencies (<code class="language-plaintext highlighter-rouge">/dev/disk/by-partlabel/sbnb</code>), overlayfs, or EFI mounts.</li>
  <li><strong>Refined Analysis (with Tutorial Context):</strong> Determined the tutorial set a <em>filesystem label</em> (<code class="language-plaintext highlighter-rouge">LABEL=sbnb</code>) but Sbnb’s <code class="language-plaintext highlighter-rouge">sbnb.service</code> required a <em>partition label</em> (<code class="language-plaintext highlighter-rouge">PARTLABEL=sbnb</code>), causing an unmet systemd dependency and the boot stall.</li>
  <li><strong>Solution 1 Implemented:</strong> Partition label <code class="language-plaintext highlighter-rouge">sbnb</code> was set on the ESP using <code class="language-plaintext highlighter-rouge">parted</code>. <strong>Outcome:</strong> System booted successfully.</li>
  <li><strong>New Goal:</strong> Ensure Docker data persists on the second USB partition (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>) as <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> is ephemeral.</li>
  <li><strong>Strategy Considered (Persistent <code class="language-plaintext highlighter-rouge">data-root</code>):</strong> Configure Docker via <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code> to use <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/docker-root</code>.</li>
  <li><strong>Problem with Strategy 1:</strong> Realized <code class="language-plaintext highlighter-rouge">/etc</code> is ephemeral in Sbnb; <code class="language-plaintext highlighter-rouge">daemon.json</code> changes wouldn’t survive reboot.</li>
  <li><strong>Strategy Considered (Backup/Restore):</strong> Keep Docker ephemeral, restore data from <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> on boot, back up data to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> periodically/on shutdown.</li>
  <li><strong>Implementation Attempt (Backup/Restore):</strong> User attempted implementation, but logs showed failures.</li>
  <li><strong>Analysis of Failure:</strong> Logs indicated <code class="language-plaintext highlighter-rouge">log_message: not found</code> errors (undefined function in <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>) and an inappropriate <code class="language-plaintext highlighter-rouge">systemctl reload</code> call within <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>. These errors prevented the Docker restore/config logic from running correctly, leading to Docker using default ephemeral storage and failing storage driver setup.</li>
  <li><strong>Decision:</strong> User chose to stick with the Backup/Restore strategy.</li>
  <li><strong>Solution 2 Implemented:</strong> Provided corrected <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> script specifically for the Backup/Restore strategy, removing the <code class="language-plaintext highlighter-rouge">log_message</code> and <code class="language-plaintext highlighter-rouge">systemctl reload</code> errors, ensuring proper restore logic, and including systemd unit enabling. Provided necessary backup/purge scripts and systemd units to be stored on the persistent data partition.</li>
  <li><strong>Current Status:</strong> User has the final set of scripts, units, and boot script modifications required to implement the chosen Backup/Restore strategy for Docker data persistence. Verification steps provided.</li>
</ol>

<p><strong>paper_trail</strong></p>

        </div>
        
          URL: https://ib.bsb.br/sbnb
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/to-enable-video-acceleration-on-rpi4/" title="to enable video acceleration on RPI4" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/images-to-searchable-pdf/" title="Images to Searchable PDF" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "linux>software>dotfile"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-linux-software-dotfile" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/sbnb/" title="Portable linux via Sbnb distro with persistence" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    <div class="comment-box">
      Ref. 
      <a href="https://github.com/sbnb-io/sbnb" title="https://github.com/sbnb-io/sbnb">https://github.com/sbnb-io/sbnb</a>
    </div>
    
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-04-17 15:37:49
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="linux-software-dotfile">
                  linux>software>dotfile
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/sbnb/"
        },
        "headline": "Portable linux via Sbnb distro with persistence",
        "description": "",
        "datePublished": "2025-04-07T00:00:00+00:00",
        "dateModified": "2025-04-17T17:52:36+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
