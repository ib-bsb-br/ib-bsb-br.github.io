<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Portable linux via Sbnb distro with persistence - infoBAG
      
    </title>
    <meta name="title" content="Portable linux via Sbnb distro with persistence - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/sbnb/">
    <meta property="og:title" content="Portable linux via Sbnb distro with persistence - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/sbnb/">
    <meta name="twitter:title" content="Portable linux via Sbnb distro with persistence - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/sbnb/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="linux&gt;software&gt;dotfile">
      
        <meta property="article:tag" content="linux&gt;software&gt;dotfile">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Portable linux via Sbnb distro with persistence
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-04-07T00:00:00+00:00" class="post-date">
          07 Apr 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-04-19T20:27:26+00:00">
              19 Apr 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/sbnb" class="tag">sbnb</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#linux-software-dotfile" class="tag">linux>software>dotfile</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        52960 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        6716 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-04-07-sbnb.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-04-07-sbnb.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#-extreme-caution-irreversible-data-destruction-imminent-"><strong>***** EXTREME CAUTION: IRREVERSIBLE DATA DESTRUCTION IMMINENT! *****</strong></a></li></ul>
          <p>This guide provides comprehensive, step-by-step instructions for configuring a single USB flash drive (or potentially an external USB hard drive) to perform two distinct functions simultaneously:</p>

<ol>
  <li><strong>Booting the Sbnb Linux Operating System:</strong> The drive will be prepared with a standard UEFI-compatible structure, specifically an EFI System Partition (ESP) containing the Sbnb EFI bootloader (<code class="language-plaintext highlighter-rouge">sbnb.efi</code>) and necessary configuration files. This allows the server’s firmware to locate and start the Sbnb boot process. The <code class="language-plaintext highlighter-rouge">sbnb.efi</code> file itself is typically a Unified Kernel Image (UKI), bundling the Linux kernel, initramfs, and kernel command line into a single executable file.</li>
  <li><strong>Providing Simple Persistent Storage:</strong> Utilizing a separate partition on the same physical USB drive, formatted with a standard Linux filesystem (<code class="language-plaintext highlighter-rouge">ext4</code> is used in this guide). This partition is intended to be automatically mounted at the <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> directory path within the running Sbnb Linux system via a custom boot script (<code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>). This provides a space where data (like container volumes, application data, logs, user files) can persist across reboots of the otherwise ephemeral, RAM-based Sbnb OS.</li>
</ol>

<p><strong>Why <code class="language-plaintext highlighter-rouge">ext4</code> instead of LVM:</strong> Initial analysis suggested LVM might be suitable, but further review of the default Sbnb Linux build configuration indicates the necessary <code class="language-plaintext highlighter-rouge">lvm2</code> user-space tools are likely missing from the base runtime environment. Without these tools, managing LVM volumes during boot via standard scripts is infeasible unless you create a custom Sbnb build that includes the <code class="language-plaintext highlighter-rouge">lvm2</code> package. This revised guide therefore uses a standard <code class="language-plaintext highlighter-rouge">ext4</code> filesystem partition, relying only on basic tools expected to be present in Sbnb.</p>

<p><strong>Contrasting with Standard Sbnb Workflow:</strong> It’s crucial to understand that this guide describes a highly non-standard setup. The intended Sbnb workflow prioritizes resilience, performance, and statelessness:</p>

<ul>
  <li>Boot the minimal Sbnb OS from simple USB/network.</li>
  <li>Use automation (Ansible) or manual scripts (<code class="language-plaintext highlighter-rouge">sbnb-configure-storage.sh</code>) post-boot to configure LVM on internal server drives.</li>
  <li>Run workloads utilizing this fast, reliable internal storage. This guide’s method compromises these benefits for single-drive convenience under specific constraints.</li>
</ul><hr />

<blockquote>
  <h5 id="-extreme-caution-irreversible-data-destruction-imminent-">
    
    
     <a href="#-extreme-caution-irreversible-data-destruction-imminent-">#</a><a href="#" aria-label="Back to top"><strong>***** EXTREME CAUTION: IRREVERSIBLE DATA DESTRUCTION IMMINENT! *****</strong></a>
        
    
  </h5>
      

  <p>This procedure involves low-level disk operations (partitioning, formatting) that will completely and <strong>PERMANENTLY ERASE ALL DATA</strong> currently residing on the USB drive you select. There is <strong>NO UNDO</strong> function. Data recovery after accidental formatting is often impossible.</p>

  <p>The most critical risk is selecting the <strong>wrong target device</strong>. Mistakenly choosing your computer’s internal hard drive (e.g., <code class="language-plaintext highlighter-rouge">/dev/sda</code>, <code class="language-plaintext highlighter-rouge">/dev/nvme0n1</code>) instead of the intended USB drive (e.g., <code class="language-plaintext highlighter-rouge">/dev/sdb</code>, <code class="language-plaintext highlighter-rouge">/dev/sdc</code>) <strong>WILL RESULT IN CATASTROPHIC AND LIKELY IRRECOVERABLE LOSS OF YOUR OPERATING SYSTEM, APPLICATIONS, AND PERSONAL FILES.</strong></p>

  <p>You <strong>MUST</strong> verify the target device name multiple times using different commands (like <code class="language-plaintext highlighter-rouge">lsblk</code>, <code class="language-plaintext highlighter-rouge">fdisk</code>, <code class="language-plaintext highlighter-rouge">parted</code>) and cross-reference with expected drive sizes and models before executing any partitioning or formatting commands. Proceed with extreme vigilance, double-checking each step, entirely at your own sole risk!</p>
</blockquote><hr />
  <h2 id="primary-drawbacks--warnings-reiterated--expanded">
    
    
     <a href="#primary-drawbacks--warnings-reiterated--expanded">#</a><a href="#" aria-label="Back to top">Primary Drawbacks &amp; Warnings (Reiterated &amp; Expanded):</a>
        
    
  </h2>
      

<ul>
  <li><strong>Highly Non-Standard &amp; Complex:</strong> Deviates significantly from Sbnb’s design. Setup is intricate, runtime behavior depends on precise script execution and timing. Future Sbnb updates might break this.</li>
  <li><strong>Severe Performance Penalty:</strong> USB storage is inherently slow (latency, throughput, IOPS) compared to internal NVMe/SATA drives. Disk I/O to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> will be a major bottleneck.</li>
  <li><strong>Drastically Reduced Lifespan &amp; Reliability:</strong> USB flash drives will wear out quickly under persistent write load due to limited write cycles, write amplification, and lack of TRIM support. Unsuitable for write-intensive workloads or high reliability needs. Expect eventual failure and data loss without robust backups.</li>
  <li><strong>Potential Instability &amp; Boot Issues:</strong> Relies on correct partition detection, udev node creation, filesystem integrity, and <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> execution timing. Failures can leave persistent storage unavailable.</li>
</ul>
  <h3 id="when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">
    
    
     <a href="#when-might-this-be-considered-limited-scenarios-with-full-risk-acceptance">#</a><a href="#" aria-label="Back to top">When Might This Be Considered? (Limited Scenarios with Full Risk Acceptance)</a>
        
    
  </h3>
      

<ul>
  <li><strong>Temporary Testing/Experimentation ONLY:</strong> Brief evaluations on hardware lacking internal drives.</li>
  <li><strong>Specific, Very Low-Intensity, Read-Mostly Use Cases:</strong> Infrequent writes, performance irrelevant (e.g., static config kiosk).</li>
  <li><strong>Absolute Hardware Constraints:</strong> Sealed systems where internal drives are impossible, and risks are fully accepted.</li>
</ul>

<p><em>Even in these limited scenarios, regular, automated, and verified backups are non-negotiable.</em></p>
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<ul>
  <li><strong>A Suitable USB Flash Drive:</strong>
    <ul>
      <li><strong>Capacity:</strong> Min ~1GB ESP + desired data size (32GB+ recommended).</li>
      <li><strong>Quality &amp; Speed:</strong> Reputable brand, USB 3.0+ advised for marginal speed benefit. Endurance matters more than peak speed.</li>
    </ul>
  </li>
  <li><strong>A Working Linux System (Preparation Environment):</strong>
    <ul>
      <li><strong>Necessity:</strong> Required for partitioning/formatting the target USB safely. openSUSE Tumbleweed assumed.</li>
      <li><strong>Live Environment Benefit:</strong> Using a Live USB/CD (e.g., openSUSE Tumbleweed Live) is highly recommended as it provides a non-destructive environment.</li>
    </ul>
  </li>
  <li><strong>Sbnb Linux Boot File (<code class="language-plaintext highlighter-rouge">sbnb.efi</code>):</strong>
    <ul>
      <li><strong>Method 1 (Easier):</strong> Run official Sbnb install script on a temporary USB, then copy <code class="language-plaintext highlighter-rouge">/EFI/BOOT/BOOTX64.EFI</code> from its ESP.</li>
      <li><strong>Method 2 (Advanced):</strong> Build Sbnb from source, find <code class="language-plaintext highlighter-rouge">sbnb.efi</code> in <code class="language-plaintext highlighter-rouge">output/images/</code>.</li>
    </ul>
  </li>
  <li><strong>Root/Sudo Privileges:</strong> Needed on the openSUSE prep system for disk commands.</li>
  <li><strong>Internet Connection:</strong> May be needed for <code class="language-plaintext highlighter-rouge">zypper</code>.</li>
</ul>
  <h2 id="step-by-step-instructions">
    
    
     <a href="#step-by-step-instructions">#</a><a href="#" aria-label="Back to top">Step-by-Step Instructions</a>
        
    
  </h2>
      

<p><em>(Reminder: TRIPLE-CHECK your target device name, e.g., <code class="language-plaintext highlighter-rouge">/dev/sdX</code>, before every destructive command!)</em></p>
  <h3 id="phase-1-prepare-the-linux-environment-opensuse-tumbleweed">
    
    
     <a href="#phase-1-prepare-the-linux-environment-opensuse-tumbleweed">#</a><a href="#" aria-label="Back to top">Phase 1: Prepare the Linux Environment (openSUSE Tumbleweed)</a>
        
    
  </h3>
      

<ol>
  <li><strong>Boot into openSUSE:</strong> Start your preparation environment.</li>
  <li><strong>Install Necessary Tools:</strong> Open a terminal. <code class="language-plaintext highlighter-rouge">zypper refresh</code> updates package lists. <code class="language-plaintext highlighter-rouge">zypper install</code> installs tools.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">sudo </span>zypper refresh
<span class="nb">sudo </span>zypper <span class="nb">install</span> <span class="nt">-y</span> parted lvm2 dosfstools e2fsprogs
</code></section></div>    </div>
  </li>
  <li><strong>Identify Target USB Drive:</strong> <strong>CRITICAL SAFETY STEP!</strong> Unplug other USB storage.
    <ul>
      <li>Insert the target USB drive.</li>
      <li>Use multiple commands. Compare SIZE and MODEL. Check <code class="language-plaintext highlighter-rouge">dmesg | tail</code> after plugging in for kernel messages like <code class="language-plaintext highlighter-rouge">sd 2:0:0:0: [sdc] Attached SCSI removable disk</code>.
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>lsblk <span class="nt">-d</span> <span class="nt">-o</span> NAME,SIZE,MODEL,VENDOR,TYPE | <span class="nb">grep</span> <span class="s1">'disk'</span>
<span class="nb">sudo </span>fdisk <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s1">'^Disk /dev/'</span>
<span class="nb">sudo </span>parted <span class="nt">-l</span> | <span class="nb">grep</span> <span class="s1">'^Disk /dev/'</span>
<span class="c"># Example: If consistently identified as /dev/sdc, use /dev/sdc below.</span>
</code></section></div>        </div>
      </li>
      <li>Visually confirm with YaST Partitioner (<code class="language-plaintext highlighter-rouge">sudo yast2 partitioner</code>) or GParted (<code class="language-plaintext highlighter-rouge">sudo zypper install -y gparted &amp;&amp; sudo gparted</code>) if preferred. Look for the drive matching the expected size and vendor/model.</li>
      <li>Assume <code class="language-plaintext highlighter-rouge">/dev/sdX</code> is your verified target drive. <strong>Replace it carefully!</strong></li>
    </ul>
  </li>
</ol>
  <h3 id="phase-2-partition-the-usb-drive">
    
    
     <a href="#phase-2-partition-the-usb-drive">#</a><a href="#" aria-label="Back to top">Phase 2: Partition the USB Drive</a>
        
    
  </h3>
      

<p><strong>(Warning: The following <code class="language-plaintext highlighter-rouge">parted</code> commands are DESTRUCTIVE to <code class="language-plaintext highlighter-rouge">/dev/sdX</code>. Double-check the device name!)</strong></p>

<p>This script automates the partitioning and formatting process. Save it as <code class="language-plaintext highlighter-rouge">prepare_usb.sh</code>, make it executable (<code class="language-plaintext highlighter-rouge">chmod +x prepare_usb.sh</code>), and run it with <code class="language-plaintext highlighter-rouge">sudo ./prepare_usb.sh /dev/sdX</code> (replacing <code class="language-plaintext highlighter-rouge">/dev/sdX</code> with your verified target device).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/bash</span>

<span class="c"># --- Configuration ---</span>
<span class="c"># Exit immediately if a command exits with a non-zero status.</span>
<span class="c"># Treat unset variables as an error when substituting.</span>
<span class="c"># Pipelines return the exit status of the last command to exit non-zero.</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="c"># --- Variables ---</span>
<span class="c"># EFI System Partition (ESP) Label (CRITICAL - must match bootloader config)</span>
<span class="nv">ESP_LABEL</span><span class="o">=</span><span class="s2">"sbnb"</span>
<span class="c"># Data Partition Label (Recommended for identification)</span>
<span class="nv">DATA_LABEL</span><span class="o">=</span><span class="s2">"SBNB_DATA"</span>
<span class="c"># ESP Size (Adjust if needed, ~1GB is usually sufficient)</span>
<span class="nv">ESP_SIZE</span><span class="o">=</span><span class="s2">"1025MiB"</span>
<span class="c"># List of required commands for the script to function</span>
<span class="nv">REQUIRED_CMDS</span><span class="o">=(</span>
  <span class="s2">"parted"</span> <span class="s2">"mkfs.vfat"</span> <span class="s2">"mkfs.ext4"</span> <span class="s2">"wipefs"</span> <span class="s2">"findmnt"</span> <span class="s2">"lsblk"</span>
  <span class="s2">"blkid"</span> <span class="s2">"fsck.vfat"</span> <span class="s2">"e2fsck"</span> <span class="s2">"sync"</span> <span class="s2">"id"</span> <span class="s2">"grep"</span> <span class="s2">"read"</span>
  <span class="s2">"sleep"</span> <span class="s2">"xargs"</span> <span class="s2">"umount"</span> <span class="s2">"partprobe"</span> <span class="s2">"realpath"</span>
<span class="o">)</span>

<span class="c"># --- Functions ---</span>
<span class="c"># Function to check for required commands</span>
check_dependencies<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">"--- Checking for required commands ---"</span>
  <span class="nb">local </span><span class="nv">missing_cmds</span><span class="o">=()</span>
  <span class="k">for </span>cmd <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">REQUIRED_CMDS</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span> &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
      </span>missing_cmds+<span class="o">=(</span><span class="s2">"</span><span class="nv">$cmd</span><span class="s2">"</span><span class="o">)</span>
    <span class="k">fi
  done

  if</span> <span class="o">[</span> <span class="k">${#</span><span class="nv">missing_cmds</span><span class="p">[@]</span><span class="k">}</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ERROR: The following required commands are not found:"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">printf</span> <span class="s2">" - %s</span><span class="se">\n</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">missing_cmds</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"Please install them and try again."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
  <span class="k">fi
  </span><span class="nb">echo</span> <span class="s2">"All required commands found."</span>
<span class="o">}</span>

<span class="c"># Function to get the base block device for a given path (handles partitions, links, etc.)</span>
get_base_device<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="nb">local </span>resolved_path
  <span class="nv">resolved_path</span><span class="o">=</span><span class="si">$(</span><span class="nb">realpath</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">"ERROR: Cannot resolve path '</span><span class="nv">$path</span><span class="s2">'"</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
  <span class="c"># lsblk -no pkname gets the parent kernel name (base device)</span>
  lsblk <span class="nt">-no</span> pkname <span class="s2">"</span><span class="nv">$resolved_path</span><span class="s2">"</span> <span class="o">||</span> <span class="o">{</span> <span class="nb">echo</span> <span class="s2">"ERROR: Cannot find base device for '</span><span class="nv">$resolved_path</span><span class="s2">' using lsblk."</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c"># --- Script Start ---</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">"--- USB Drive Partitioning and Formatting Script ---"</span>
<span class="nb">echo</span> <span class="s2">"---  (Version 2 - Enhanced Safety)      ---"</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"WARNING: This script is DESTRUCTIVE and will ERASE"</span>
<span class="nb">echo</span> <span class="s2">" ALL DATA on the target device."</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="c"># --- Check for Root Privileges ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">id</span> <span class="nt">-u</span><span class="si">)</span><span class="s2">"</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: This script must be run as root (e.g., using sudo)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># --- Check Dependencies ---</span>
check_dependencies

<span class="c"># --- Check for Device Argument ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="k">${</span><span class="nv">1</span><span class="k">:-}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Usage: </span><span class="nv">$0</span><span class="s2"> /dev/sdX"</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: Please provide the target block device (e.g., /dev/sda, /dev/sdb)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">""</span>
  <span class="nb">echo</span> <span class="s2">"Available block devices (excluding ROM, loop, and RAM devices):"</span>
  lsblk <span class="nt">-d</span> <span class="nt">-o</span> NAME,SIZE,TYPE,MODEL | <span class="nb">grep</span> <span class="nt">-vE</span> <span class="s1">'rom|loop|ram'</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nv">DEVICE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>

<span class="c"># --- Validate Device ---</span>
<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: '</span><span class="nv">$DEVICE</span><span class="s2">' is not a valid block device."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># --- CRITICAL SAFETY CHECK: Prevent targeting the root filesystem device ---</span>
<span class="nb">echo</span> <span class="s2">"--- Performing safety checks ---"</span>
<span class="nv">ROOT_DEV_PATH</span><span class="o">=</span><span class="si">$(</span>findmnt <span class="nt">-n</span> <span class="nt">-o</span> SOURCE /<span class="si">)</span>
<span class="nv">ROOT_BASE_DEV_NAME</span><span class="o">=</span><span class="si">$(</span>get_base_device <span class="s2">"</span><span class="nv">$ROOT_DEV_PATH</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit </span>1 <span class="c"># Exit if function fails</span>
<span class="nv">TARGET_BASE_DEV_NAME</span><span class="o">=</span><span class="si">$(</span>get_base_device <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span><span class="si">)</span> <span class="o">||</span> <span class="nb">exit </span>1

<span class="c"># Construct full device paths for comparison</span>
<span class="nv">ROOT_BASE_DEV</span><span class="o">=</span><span class="s2">"/dev/</span><span class="k">${</span><span class="nv">ROOT_BASE_DEV_NAME</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">TARGET_BASE_DEV</span><span class="o">=</span><span class="s2">"/dev/</span><span class="k">${</span><span class="nv">TARGET_BASE_DEV_NAME</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Assumes the input $DEVICE is the base device</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$TARGET_BASE_DEV</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"FATAL ERROR: Target device '</span><span class="nv">$DEVICE</span><span class="s2">' appears to be the same"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">" device ('</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">') as the running root"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">" filesystem ('</span><span class="nv">$ROOT_DEV_PATH</span><span class="s2">')."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">" Aborting to prevent data loss."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi
</span><span class="nb">echo</span> <span class="s2">"Safety check passed: Target device '</span><span class="nv">$DEVICE</span><span class="s2">' is not the root filesystem device ('</span><span class="nv">$ROOT_BASE_DEV</span><span class="s2">')."</span>

<span class="c"># Check if the device looks like an SD card reader often used for the OS drive</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">==</span> /dev/mmcblk<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"WARNING: '</span><span class="nv">$DEVICE</span><span class="s2">' looks like an SD card (e.g., /dev/mmcblk0)."</span>
  <span class="nb">echo</span> <span class="s2">" Double-check this is not your primary OS drive!"</span>
<span class="k">fi</span>


<span class="c"># --- Confirmation ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Target Device: </span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Partitions to be created:"</span>
<span class="nb">echo</span> <span class="s2">"  1: EFI System Partition (ESP), FAT32, Label: '</span><span class="nv">$ESP_LABEL</span><span class="s2">', Size: </span><span class="nv">$ESP_SIZE</span><span class="s2">, Flags: boot, esp"</span>
<span class="nb">echo</span> <span class="s2">"  2: Linux Data Partition, ext4, Label: '</span><span class="nv">$DATA_LABEL</span><span class="s2">', Size: Remaining space"</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">read</span> <span class="nt">-p</span> <span class="s2">"ARE YOU ABSOLUTELY SURE you want to erase '</span><span class="nv">$DEVICE</span><span class="s2">' and proceed? (yes/NO): "</span> CONFIRMATION
<span class="nv">CONFIRMATION</span><span class="o">=</span><span class="k">${</span><span class="nv">CONFIRMATION</span><span class="k">:-</span><span class="nv">NO</span><span class="k">}</span> <span class="c"># Default to NO if user just presses Enter</span>

<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$CONFIRMATION</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"yes"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Operation cancelled by user."</span>
  <span class="nb">exit </span>0
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Proceeding with operations on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>

<span class="c"># --- Phase 2: Partition the USB Drive ---</span>

<span class="c"># 1. Unmount Existing Partitions</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Unmounting any existing partitions on </span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}</span><span class="s2">* ---"</span>
<span class="c"># Use findmnt to get mount points and umount them safely</span>
<span class="c"># Also try to unmount the base device itself in case it's loop-mounted etc.</span>
findmnt <span class="nt">-n</span> <span class="nt">-o</span> TARGET <span class="nt">--source</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}</span><span class="s2">*"</span> | xargs <span class="nt">--no-run-if-empty</span> umount <span class="nt">-v</span> <span class="nt">-l</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Info: No partitions were mounted or umount failed (might be okay)."</span>
umount <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> &amp;&gt;/dev/null <span class="o">||</span> <span class="nb">true</span> <span class="c"># Attempt to unmount base device, ignore errors</span>
<span class="nb">sleep </span>1 <span class="c"># Give time for umount to settle</span>
lsblk <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>

<span class="c"># 2. Wipe Existing Signatures (Recommended)</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Wiping filesystem/partition signatures from </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
wipefs <span class="nt">--all</span> <span class="nt">--force</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk to ensure changes are physically written</span>

<span class="c"># 3. Create New GPT Partition Table</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating new GPT partition table on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mklabel gpt
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># 4. Create EFI System Partition (ESP)</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating ESP partition (1) on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mkpart <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">"</span> fat32 1MiB <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> <span class="nb">set </span>1 boot on
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> <span class="nb">set </span>1 esp on
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># 5. Create Linux Data Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Creating Linux data partition (2) on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
<span class="c"># Use the end of the ESP as the start for the data partition</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> mkpart <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> ext4 <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">"</span> 100%
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>
<span class="nb">echo</span> <span class="s2">"Waiting briefly for kernel to recognize new partitions..."</span>
<span class="nb">sleep </span>2

<span class="c"># Define partition variables (assuming standard naming, e.g., /dev/sda1, /dev/sda2)</span>
<span class="c"># Adding 'p' for NVMe devices (e.g., /dev/nvme0n1p1) - check if base device name contains 'nvme'</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">==</span> <span class="k">*</span>nvme<span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
  </span><span class="nv">PART_PREFIX</span><span class="o">=</span><span class="s2">"p"</span>
<span class="k">else
  </span><span class="nv">PART_PREFIX</span><span class="o">=</span><span class="s2">""</span>
<span class="k">fi
</span><span class="nv">ESP_PARTITION</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}${</span><span class="nv">PART_PREFIX</span><span class="k">}</span><span class="s2">1"</span>
<span class="nv">DATA_PARTITION</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DEVICE</span><span class="k">}${</span><span class="nv">PART_PREFIX</span><span class="k">}</span><span class="s2">2"</span>

<span class="c"># Check if partition devices exist, retry with partprobe if needed</span>
<span class="nb">echo</span> <span class="s2">"--- Checking for partition device nodes (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">, </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">) ---"</span>
<span class="nv">PARTITIONS_FOUND</span><span class="o">=</span><span class="nb">false
</span><span class="k">for </span>i <span class="k">in</span> <span class="o">{</span>1..5<span class="o">}</span><span class="p">;</span> <span class="k">do
  if</span> <span class="o">[</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$ESP_PARTITION</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nt">-b</span> <span class="s2">"</span><span class="nv">$DATA_PARTITION</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Partition nodes found."</span>
    <span class="nv">PARTITIONS_FOUND</span><span class="o">=</span><span class="nb">true
    break
  </span><span class="k">fi
  </span><span class="nb">echo</span> <span class="s2">"Partition nodes not yet found. Retrying probe (Attempt </span><span class="nv">$i</span><span class="s2">/5)..."</span>
  partprobe <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"Warning: partprobe command failed, continuing check..."</span>
  <span class="nb">sleep </span>1
<span class="k">done

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$PARTITIONS_FOUND</span><span class="s2">"</span> <span class="o">=</span> <span class="nb">false</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ERROR: Partition devices (</span><span class="nv">$ESP_PARTITION</span><span class="s2">, </span><span class="nv">$DATA_PARTITION</span><span class="s2">) not found after partitioning and retries."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"    Please check manually ('lsblk </span><span class="nv">$DEVICE</span><span class="s2">', 'parted </span><span class="nv">$DEVICE</span><span class="s2"> print')."</span> <span class="o">&gt;</span>&amp;2
  lsblk <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 6. Verify Partitioning</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying partitions on </span><span class="nv">$DEVICE</span><span class="s2"> ---"</span>
parted <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span> <span class="nt">--script</span> <span class="nt">--</span> print
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Block device view: ---"</span>
lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,PARTLABEL,MOUNTPOINT,PARTFLAGS <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"----------------------------"</span>
<span class="nb">echo</span> <span class="s2">"Expected: </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2"> (~</span><span class="k">${</span><span class="nv">ESP_SIZE</span><span class="k">}</span><span class="s2">), Type EFI System, Flags: boot, esp"</span>
<span class="nb">echo</span> <span class="s2">"Expected: </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2"> (Remaining size), Type Linux filesystem"</span>
<span class="nb">echo</span> <span class="s2">"----------------------------"</span>
<span class="nb">sleep </span>2 <span class="c"># Pause for user to review</span>


<span class="c"># --- Phase 3: Format Filesystems ---</span>

<span class="c"># 1. Format EFI Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Formatting ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">) as FAT32 with label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' ---"</span>
mkfs.vfat <span class="nt">-F</span> 32 <span class="nt">-n</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># Check filesystem integrity</span>
<span class="nb">echo</span> <span class="s2">"--- Checking ESP filesystem (fsck.vfat) ---"</span>
<span class="nv">FSCK_VFAT_EXIT_CODE</span><span class="o">=</span>0
fsck.vfat <span class="nt">-a</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nv">FSCK_VFAT_EXIT_CODE</span><span class="o">=</span><span class="nv">$?</span> <span class="c"># Run fsck, capture exit code on failure</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$FSCK_VFAT_EXIT_CODE</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ESP filesystem check passed (or no check performed)."</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$FSCK_VFAT_EXIT_CODE</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Exit code 1 usually means errors were found AND corrected.</span>
  <span class="nb">echo</span> <span class="s2">"WARNING: fsck.vfat found and corrected errors on ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">). Check output above."</span>
<span class="k">else</span>
  <span class="c"># Exit codes &gt; 1 typically indicate uncorrected errors.</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: fsck.vfat reported uncorrectable errors (Exit Code: </span><span class="nv">$FSCK_VFAT_EXIT_CODE</span><span class="s2">) on ESP partition (</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"    Cannot proceed safely. Please investigate manually."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Verify label using blkid</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying ESP label ---"</span>
<span class="k">if </span>blkid <span class="nt">-s</span> LABEL <span class="nt">-o</span> value <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">$"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"ESP Label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' verified successfully on </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">."</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to verify ESP Label '</span><span class="k">${</span><span class="nv">ESP_LABEL</span><span class="k">}</span><span class="s2">' on </span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span>&amp;2
  blkid <span class="s2">"</span><span class="k">${</span><span class="nv">ESP_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Show full blkid output for debugging</span>
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># 2. Format Data Partition</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"--- Formatting Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">) as ext4 with label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' ---"</span>
mkfs.ext4 <span class="nt">-m</span> 0 <span class="nt">-L</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">sync</span> <span class="c"># Flush kernel buffers to disk</span>

<span class="c"># Check the new ext4 filesystem integrity</span>
<span class="nb">echo</span> <span class="s2">"--- Checking Data partition filesystem (e2fsck) ---"</span>
<span class="c"># -f forces check even if clean, -y assumes yes to all prompts (use with caution)</span>
<span class="nv">E2FSCK_EXIT_CODE</span><span class="o">=</span>0
e2fsck <span class="nt">-f</span> <span class="nt">-y</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="o">||</span> <span class="nv">E2FSCK_EXIT_CODE</span><span class="o">=</span><span class="nv">$?</span> <span class="c"># Capture exit code on failure</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$E2FSCK_EXIT_CODE</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Data partition filesystem check passed."</span>
<span class="k">elif</span> <span class="o">[</span> <span class="nv">$E2FSCK_EXIT_CODE</span> <span class="nt">-eq</span> 1 <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Exit code 1 means errors were corrected.</span>
  <span class="nb">echo</span> <span class="s2">"WARNING: e2fsck found and corrected errors on Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">). Check output above."</span>
<span class="k">else</span>
  <span class="c"># Exit codes &gt; 1 indicate uncorrected errors.</span>
  <span class="nb">echo</span> <span class="s2">"ERROR: e2fsck reported uncorrectable errors (Exit Code: </span><span class="nv">$E2FSCK_EXIT_CODE</span><span class="s2">) on Data partition (</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">)."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">echo</span> <span class="s2">"    Cannot proceed safely. Please investigate manually."</span> <span class="o">&gt;</span>&amp;2
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Verify the label using blkid</span>
<span class="nb">echo</span> <span class="s2">"--- Verifying Data partition label ---"</span>
<span class="k">if </span>blkid <span class="nt">-s</span> LABEL <span class="nt">-o</span> value <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">$"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"Data Label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' verified successfully on </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">."</span>
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to verify Data Label '</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">' on </span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span>&amp;2
  blkid <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_PARTITION</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Show full blkid output for debugging</span>
  <span class="nb">exit </span>1
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>
<span class="nb">echo</span> <span class="s2">"--- Script finished successfully! ---"</span>
<span class="nb">echo</span> <span class="s2">"Device: </span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"Partitions created and formatted:"</span>
lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,LABEL,PARTLABEL,MOUNTPOINT <span class="s2">"</span><span class="nv">$DEVICE</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"-----------------------------------------------------"</span>

<span class="nb">exit </span>0
</code></section></div></div>
  <h3 id="phase-3-install-sbnb-boot-files-and-configuration">
    
    
     <a href="#phase-3-install-sbnb-boot-files-and-configuration">#</a><a href="#" aria-label="Back to top">Phase 3: Install Sbnb Boot Files and Configuration</a>
        
    
  </h3>
      

<ol>
  <li><strong>Mount EFI Partition:</strong> Access the ESP filesystem. Replace <code class="language-plaintext highlighter-rouge">/dev/sdX1</code> with the actual ESP partition device name identified earlier.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Mounting ESP partition ---"</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /mnt/sbnb-mount
<span class="nb">sudo </span>mount /dev/sdX1 /mnt/sbnb-mount
</code></section></div>    </div>
  </li>
  <li><strong>Create EFI Boot Directory:</strong> Standard UEFI fallback path.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Creating EFI boot directories ---"</span>
<span class="nb">sudo mkdir</span> <span class="nt">-p</span> /mnt/sbnb-mount/EFI/BOOT
</code></section></div>    </div>
  </li>
  <li><strong>Copy Sbnb EFI Boot File:</strong> Place the bootloader (<code class="language-plaintext highlighter-rouge">sbnb.efi</code> as <code class="language-plaintext highlighter-rouge">BOOTX64.EFI</code>). Replace <code class="language-plaintext highlighter-rouge">/path/to/your/sbnb.efi</code> with the actual path to the file you obtained.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Copying Sbnb EFI boot file ---"</span>
<span class="nb">sudo cp</span> /path/to/your/sbnb.efi /mnt/sbnb-mount/EFI/BOOT/BOOTX64.EFI
</code></section></div>    </div>
  </li>
  <li><strong>(Recommended) Create Sbnb Configuration File:</strong> Place <code class="language-plaintext highlighter-rouge">sbnb-tskey.txt</code> in ESP root (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-mount/</code>). The <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> script reads this to configure Tailscale. Replace <code class="language-plaintext highlighter-rouge">tskey-auth-...</code> with your actual Tailscale auth key.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Creating Sbnb configuration file (sbnb-tskey.txt) ---"</span>
<span class="nb">echo</span> <span class="s2">"tskey-auth-..."</span> | <span class="nb">sudo tee</span> /mnt/sbnb-mount/sbnb-tskey.txt <span class="o">&gt;</span> /dev/null
</code></section></div>    </div>
  </li>
  <li><strong>(Crucial) Handle Data Partition Mounting via <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>:</strong>
    <ul>
      <li><strong>Context &amp; Goal:</strong> Sbnb boots -&gt; systemd -&gt; <code class="language-plaintext highlighter-rouge">sbnb.service</code> -&gt; <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> -&gt; mounts ESP to <code class="language-plaintext highlighter-rouge">/mnt/sbnb</code> -&gt; executes <code class="language-plaintext highlighter-rouge">/mnt/sbnb/sbnb-cmds.sh</code>. This script mounts the data partition (labeled <code class="language-plaintext highlighter-rouge">SBNB_DATA</code>) to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
      <li><strong>Device Detection Timing:</strong> There’s a potential race: the kernel/udev might not have created the <code class="language-plaintext highlighter-rouge">/dev/disk/by-label/SBNB_DATA</code> symlink or the <code class="language-plaintext highlighter-rouge">/dev/sdX2</code> node exactly when the script runs. The wait loop mitigates this.</li>
      <li><strong>Default Script Conflict Uncertainty:</strong> The <code class="language-plaintext highlighter-rouge">boot-sbnb.sh</code> excerpt doesn’t show conflicting actions at its execution point. However, other early boot mechanisms could exist in Sbnb. If <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> behaves unexpectedly, investigate potential early boot scripts/services related to storage in your Sbnb version (advanced).</li>
      <li><strong><code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> Script (Wait Loop &amp; Logging):</strong> Create this file in the ESP root (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-mount/</code> during prep). Save the following content to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-mount/sbnb-cmds.sh</code>:</li>
    </ul>

    <div class="language-sh highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c"># Custom sbnb-cmds.sh for USB Persistent Partition setup (No LVM)</span>
<span class="c"># Mounts partition labeled DATA_LABEL to MOUNT_POINT after waiting for device.</span>
<span class="c"># For debugging, uncomment 'set -x' to trace command execution.</span>
<span class="c"># set -x</span>

<span class="c"># Function to log messages consistently to kernel buffer (dmesg) and console (tty)</span>
log_msg<span class="o">()</span> <span class="o">{</span>
  <span class="nb">echo</span> <span class="s2">"sbnb-cmds.sh: </span><span class="nv">$1</span><span class="s2">"</span> | <span class="nb">tee</span> /dev/kmsg
<span class="o">}</span>

log_msg <span class="s2">"--- Running Custom USB Partition Mount Script ---"</span>

<span class="c"># --- Configuration ---</span>
<span class="nv">MOUNT_POINT</span><span class="o">=</span><span class="s2">"/mnt/sbnb-data"</span>  <span class="c"># Target directory for persistent data</span>
<span class="nv">DATA_LABEL</span><span class="o">=</span><span class="s2">"SBNB_DATA"</span> <span class="c"># Filesystem label of the data partition (MUST match mkfs.ext4 -L)</span>
<span class="c"># Alternative: Use UUID for potentially more stable identification if labels change/conflict</span>
<span class="c"># Get UUID using 'sudo blkid /dev/sdX2' on prep machine, then set:</span>
<span class="c"># DATA_UUID="YOUR-UUID-HERE"</span>
<span class="nv">MAX_WAIT_SECONDS</span><span class="o">=</span>15    <span class="c"># Max time (seconds) to wait for the device node/label</span>
<span class="nv">WAIT_INTERVAL</span><span class="o">=</span>1   <span class="c"># Check frequency (seconds)</span>
<span class="nv">MOUNT_OPTS</span><span class="o">=</span><span class="s2">"defaults,noatime,nodiratime"</span> <span class="c"># Mount options (noatime/nodiratime reduce writes on flash)</span>
<span class="c"># --- End Configuration ---</span>

<span class="nv">DATA_DEVICE</span><span class="o">=</span><span class="s2">""</span> <span class="c"># Will hold the found device path</span>

<span class="c"># --- Wait Loop for Device ---</span>
<span class="c"># Attempts to find the device by label or UUID (if configured).</span>
<span class="c"># Waits because device node creation by kernel/udev might be delayed.</span>
<span class="nv">elapsed_wait</span><span class="o">=</span>0
log_msg <span class="s2">"Waiting up to </span><span class="k">${</span><span class="nv">MAX_WAIT_SECONDS</span><span class="k">}</span><span class="s2">s for device (Label: </span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">:-</span><span class="nv">N</span><span class="p">/A</span><span class="k">}</span><span class="s2">)..."</span>
<span class="k">while</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$DATA_DEVICE</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nv">$elapsed_wait</span> <span class="nt">-lt</span> <span class="nv">$MAX_WAIT_SECONDS</span> <span class="o">]</span><span class="p">;</span> <span class="k">do</span>
  <span class="c"># Check for device using the label symlink first (usually faster if udev ran)</span>
  <span class="nv">label_path</span><span class="o">=</span><span class="s2">"/dev/disk/by-label/</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$label_path</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    <span class="c"># Readlink -f resolves the symlink to the actual device path (e.g., /dev/sdb2)</span>
    <span class="nv">DATA_DEVICE</span><span class="o">=</span><span class="si">$(</span><span class="nb">readlink</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$label_path</span><span class="s2">"</span><span class="si">)</span>
    log_msg <span class="s2">"Found device via label symlink: </span><span class="nv">$label_path</span><span class="s2"> -&gt; </span><span class="nv">$DATA_DEVICE</span><span class="s2">"</span>
    <span class="nb">break</span> <span class="c"># Exit loop</span>
  <span class="k">fi</span>

  <span class="c"># Fallback: Use blkid command to scan for the label (can be slower)</span>
  <span class="nv">blkid_device</span><span class="o">=</span><span class="si">$(</span>blkid <span class="nt">-L</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span> 2&gt;/dev/null<span class="si">)</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$blkid_device</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">DATA_DEVICE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$blkid_device</span><span class="s2">"</span>
    log_msg <span class="s2">"Found device via blkid label lookup: </span><span class="nv">$DATA_DEVICE</span><span class="s2">"</span>
    <span class="nb">break</span> <span class="c"># Exit loop</span>
  <span class="k">fi</span>

  <span class="c"># (Add similar checks here using DATA_UUID if using UUID instead of Label)</span>

  <span class="c"># Device not found yet, wait before next check</span>
  <span class="nb">sleep</span> <span class="nv">$WAIT_INTERVAL</span>
  <span class="nv">elapsed_wait</span><span class="o">=</span><span class="k">$((</span>elapsed_wait <span class="o">+</span> WAIT_INTERVAL<span class="k">))</span>
<span class="k">done</span>

<span class="c"># --- Mount Logic ---</span>
<span class="c"># Proceed only if a device path was successfully determined</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$DATA_DEVICE</span><span class="s2">"</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$DATA_DEVICE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span>log_msg <span class="s2">"Data partition device resolved to </span><span class="k">${</span><span class="nv">DATA_DEVICE</span><span class="k">}</span><span class="s2"> after </span><span class="k">${</span><span class="nv">elapsed_wait</span><span class="k">}</span><span class="s2">s."</span>

  <span class="c"># Check if the target directory is already a mount point</span>
  <span class="k">if</span> <span class="o">!</span> mountpoint <span class="nt">-q</span> <span class="s2">"</span><span class="nv">$MOUNT_POINT</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
    </span>log_msg <span class="s2">"Attempting to mount </span><span class="nv">$DATA_DEVICE</span><span class="s2"> at </span><span class="nv">$MOUNT_POINT</span><span class="s2"> with options: </span><span class="nv">$MOUNT_OPTS</span><span class="s2">..."</span>
    <span class="c"># Ensure the target directory exists</span>
    <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$MOUNT_POINT</span><span class="s2">"</span>
    <span class="c"># Mount the device</span>
    <span class="k">if </span>mount <span class="nt">-o</span> <span class="s2">"</span><span class="nv">$MOUNT_OPTS</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$DATA_DEVICE</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$MOUNT_POINT</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
      </span>log_msg <span class="s2">"Successfully mounted persistent partition at </span><span class="nv">$MOUNT_POINT</span><span class="s2">."</span>
    <span class="k">else
      </span><span class="nv">mount_exit_code</span><span class="o">=</span><span class="nv">$?</span>
      log_msg <span class="s2">"ERROR: Failed to mount </span><span class="nv">$DATA_DEVICE</span><span class="s2"> at </span><span class="nv">$MOUNT_POINT</span><span class="s2"> (exit code: </span><span class="nv">$mount_exit_code</span><span class="s2">). Check filesystem type/integrity (run fsck?). See dmesg for details."</span> <span class="o">&gt;</span>&amp;2
    <span class="k">fi
  else</span>
    <span class="c"># Mount point exists, verify if it's the correct device</span>
    log_msg <span class="s2">"</span><span class="nv">$MOUNT_POINT</span><span class="s2"> is already a mount point. Checking device..."</span>
    <span class="c"># Check /proc/mounts for the currently mounted device at MOUNT_POINT</span>
    <span class="k">if </span><span class="nb">grep</span> <span class="nt">-qs</span> <span class="s2">"</span><span class="nv">$DATA_DEVICE</span><span class="s2"> </span><span class="nv">$MOUNT_POINT</span><span class="s2">"</span> /proc/mounts<span class="p">;</span> <span class="k">then
      </span>log_msg <span class="s2">"Persistent partition already correctly mounted at </span><span class="nv">$MOUNT_POINT</span><span class="s2">."</span>
    <span class="k">else
      </span><span class="nv">mounted_dev</span><span class="o">=</span><span class="si">$(</span><span class="nb">grep</span> <span class="nt">-s</span> <span class="s2">"</span><span class="nv">$MOUNT_POINT</span><span class="s2">"</span> /proc/mounts | <span class="nb">awk</span> <span class="s1">'{print $1}'</span><span class="si">)</span>
      log_msg <span class="s2">"ERROR: </span><span class="nv">$MOUNT_POINT</span><span class="s2"> is already mounted, but by '</span><span class="nv">$mounted_dev</span><span class="s2">' NOT '</span><span class="nv">$DATA_DEVICE</span><span class="s2">'! Check system configuration."</span> <span class="o">&gt;</span>&amp;2
    <span class="k">fi
  fi
else</span>
  <span class="c"># Device wasn't found within the timeout</span>
  log_msg <span class="s2">"ERROR: Data partition device (Label: </span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">:-</span><span class="nv">N</span><span class="p">/A</span><span class="k">}</span><span class="s2">) not found after waiting </span><span class="k">${</span><span class="nv">MAX_WAIT_SECONDS</span><span class="k">}</span><span class="s2">s. Cannot mount persistent storage."</span> <span class="o">&gt;</span>&amp;2
<span class="k">fi</span>

<span class="c"># Example: Copy a template Docker config if needed (adjust path as necessary)</span>
<span class="c"># if [ -f "/mnt/sbnb-data/docker/docker-daemon.json.template" ]; then</span>
<span class="c">#   mkdir -p /etc/docker</span>
<span class="c">#   cp /mnt/sbnb-data/docker/docker-daemon.json.template /etc/docker/daemon.json</span>
<span class="c">#   log_msg "Copied Docker daemon template."</span>
<span class="c"># fi</span>

log_msg <span class="s2">"--- Finished Custom USB Partition Mount Script ---"</span>
<span class="c"># Exit 0 ensures the rest of the Sbnb boot sequence continues</span>
<span class="nb">exit </span>0
</code></section></div>    </div>
    <ul>
      <li>Make the script executable:
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">sudo chmod</span> +x /mnt/sbnb-mount/sbnb-cmds.sh
</code></section></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Unmount the EFI Partition:</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">echo</span> <span class="s2">"--- Unmounting ESP partition ---"</span>
<span class="c"># Ensure buffers are flushed before unmounting</span>
<span class="nb">sync
sudo </span>umount /mnt/sbnb-mount
</code></section></div>    </div>
  </li>
</ol>
  <h3 id="phase-4-backing-up-data-critical">
    
    
     <a href="#phase-4-backing-up-data-critical">#</a><a href="#" aria-label="Back to top">Phase 4: Backing Up Data (CRITICAL!)</a>
        
    
  </h3>
      

<ul>
  <li><strong>Why Essential:</strong> High risk of USB drive failure. Backups are mandatory.</li>
  <li><strong>Strategy:</strong> Automate regular backups of <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
  <li><strong>File Data Backup (<code class="language-plaintext highlighter-rouge">rsync</code>):</strong> Ensure the backup destination (NAS, cloud, another server) has sufficient free space.
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>  <span class="c"># Example: From Sbnb to backup-server (requires ssh key auth)</span>
  rsync <span class="nt">-avz</span> <span class="nt">--delete</span> <span class="nt">--progress</span> <span class="nt">--human-readable</span> /mnt/sbnb-data/ user@backup-server:/path/to/backups/sbnb-usb-data/
</code></section></div>    </div>
  </li>
  <li><strong>Frequency:</strong> Daily recommended for active data.</li>
  <li><strong>Automation:</strong> Use cron/systemd timers or remote triggers.</li>
  <li><strong>Testing Restores:</strong> Vital! Don’t assume backups work.</li>
  <li><strong>Conceptual Restore:</strong> Boot Linux Live env -&gt; Mount backup source -&gt; Mount target USB data partition (new/reformatted) to <code class="language-plaintext highlighter-rouge">/mnt/restore</code> -&gt; <code class="language-plaintext highlighter-rouge">sudo rsync -av --progress /path/to/backup/sbnb-usb-data/ /mnt/restore/</code> -&gt; Verify restored files (count, size, checksums, spot checks).</li>
  <li><strong>Verification:</strong> Use tools like <code class="language-plaintext highlighter-rouge">diff -r</code>, <code class="language-plaintext highlighter-rouge">md5sum</code>, or <code class="language-plaintext highlighter-rouge">sha256sum</code> to compare restored files against originals or known good copies.</li>
  <li><em>Untested backups provide a false sense of security.</em></li>
</ul>
  <h3 id="phase-5-boot-and-verify">
    
    
     <a href="#phase-5-boot-and-verify">#</a><a href="#" aria-label="Back to top">Phase 5: Boot and Verify</a>
        
    
  </h3>
      

<ol>
  <li><strong>Safely Eject:</strong> Eject USB from prep system.</li>
  <li><strong>Configure Server BIOS/UEFI:</strong> Enter setup (DEL, F2, F10, F12, etc.). Ensure UEFI Mode ON, CSM/Legacy OFF, Secure Boot OFF. Set “UEFI: USB…” as first boot device. Save &amp; Exit.</li>
  <li><strong>Boot Sbnb Linux.</strong></li>
  <li><strong>Verify Operation:</strong>
    <ul>
      <li>Monitor Boot: Watch console for <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> logs, errors.</li>
      <li>SSH into Sbnb.</li>
      <li>Check Mounts:
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>lsblk <span class="nt">-o</span> NAME,SIZE,TYPE,FSTYPE,LABEL,MOUNTPOINT <span class="c"># Look for mount at /mnt/sbnb-data</span>
<span class="nb">df</span> <span class="nt">-hT</span> | <span class="nb">grep</span> <span class="nt">-E</span> <span class="s1">'Filesystem|/mnt/sbnb-data'</span> <span class="c"># Check usage/type</span>
mount | <span class="nb">grep</span> /mnt/sbnb-data  <span class="c"># Check mount options (rw, noatime)</span>
findmnt /mnt/sbnb-data     <span class="c"># Another way to check mount info</span>
</code></section></div>        </div>
      </li>
      <li>Test Persistence:
```bash
  <h1 id="after-sshing-in">
    
    
     <a href="#after-sshing-in">#</a><a href="#" aria-label="Back to top">After SSHing in:</a>
        
    
  </h1>
      
        <p>TIMESTAMP=$(date)
echo “Sbnb USB Persistence test - $TIMESTAMP” | sudo tee /mnt/sbnb-data/persistence_test.txt &gt; /dev/null
sync &amp;&amp; echo “Synced data to disk.”
echo “File created. Content:” &amp;&amp; sudo cat /mnt/sbnb-data/persistence_test.txt
echo “Rebooting server now…” &amp;&amp; sudo reboot</p>
      </li>
    </ul>
  <h1 id="-wait-for-reboot-and-reconnect-via-ssh-">
    
    
     <a href="#-wait-for-reboot-and-reconnect-via-ssh-">#</a><a href="#" aria-label="Back to top">— Wait for reboot and reconnect via SSH —</a>
        
    
  </h1>
      
    <p>echo “Checking for file after reboot…”
if [ -f /mnt/sbnb-data/persistence_test.txt ]; then
  echo “SUCCESS: File found. Content:” &amp;&amp; sudo cat /mnt/sbnb-data/persistence_test.txt
  sudo rm /mnt/sbnb-data/persistence_test.txt # Clean up
else
  echo “FAILURE: File NOT FOUND after reboot! Persistence failed.”
fi
```</p>
  </li>
</ol>
  <h2 id="troubleshooting">
    
    
     <a href="#troubleshooting">#</a><a href="#" aria-label="Back to top">Troubleshooting</a>
        
    
  </h2>
      

<ul>
  <li><strong>Doesn’t Boot / No Bootable Device:</strong>
    <ul>
      <li>Re-verify BIOS settings (UEFI, Secure Boot OFF, Boot Order).</li>
      <li>Re-verify USB Prep: Partitions (<code class="language-plaintext highlighter-rouge">parted print</code>), ESP flags (<code class="language-plaintext highlighter-rouge">boot</code>,<code class="language-plaintext highlighter-rouge">esp</code>), ESP filesystem label (<code class="language-plaintext highlighter-rouge">blkid /dev/sdX1</code> -&gt; <code class="language-plaintext highlighter-rouge">LABEL="sbnb"</code>), EFI file path (<code class="language-plaintext highlighter-rouge">/EFI/BOOT/BOOTX64.EFI</code>).</li>
      <li>Try different USB ports (check if port provides sufficient power). Test drive health on prep machine (<code class="language-plaintext highlighter-rouge">fsck</code>, <code class="language-plaintext highlighter-rouge">badblocks -nvs /dev/sdX</code>). Recreate drive meticulously.</li>
    </ul>
  </li>
  <li><strong>Data Partition Not Mounted / <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> Empty:</strong>
    <ul>
      <li>Check boot logs (<code class="language-plaintext highlighter-rouge">journalctl -b</code>, console) for <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> errors (“Device… not found”, “Failed to mount”). Check <code class="language-plaintext highlighter-rouge">dmesg</code> for USB errors (<code class="language-plaintext highlighter-rouge">dmesg | grep -iE 'usb|sdX'</code>) or filesystem errors (<code class="language-plaintext highlighter-rouge">dmesg | grep -i ext4</code>).</li>
      <li>SSH in:
        <ul>
          <li>Verify partition &amp; label: <code class="language-plaintext highlighter-rouge">sudo blkid</code>, <code class="language-plaintext highlighter-rouge">ls -l /dev/disk/by-label/</code>. Is <code class="language-plaintext highlighter-rouge">SBNB_DATA</code> present? Does it point to the correct device?</li>
          <li>If label wrong/missing: Re-label from prep env (<code class="language-plaintext highlighter-rouge">sudo e2label /dev/sdX2 SBNB_DATA</code>).</li>
          <li>If device/label exists, try manual mount: <code class="language-plaintext highlighter-rouge">sudo mkdir -p /mnt/sbnb-data &amp;&amp; sudo mount /dev/disk/by-label/SBNB_DATA /mnt/sbnb-data</code>. Check <code class="language-plaintext highlighter-rouge">dmesg</code> for errors (e.g., <code class="language-plaintext highlighter-rouge">mount: wrong fs type, bad option, bad superblock</code>). If manual mount works, debug <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> (add <code class="language-plaintext highlighter-rouge">set -x</code>, check paths, loop duration, check script permissions <code class="language-plaintext highlighter-rouge">ls -l /mnt/sbnb/sbnb-cmds.sh</code>).</li>
          <li>Run filesystem check (unmounted): <code class="language-plaintext highlighter-rouge">sudo e2fsck -f /dev/disk/by-label/SBNB_DATA</code>.</li>
          <li>Check kernel modules: <code class="language-plaintext highlighter-rouge">lsmod | grep ext4</code>. Is the module loaded? Check <code class="language-plaintext highlighter-rouge">dmesg</code> for errors loading filesystem modules.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Poor Performance / Drive Failure:</strong>
    <ul>
      <li><strong>Performance:</strong> Inherent limitation.</li>
      <li><strong>Lifespan/Failure:</strong> Monitor <code class="language-plaintext highlighter-rouge">dmesg</code> for I/O errors. Restore from verified backups upon failure. This setup will wear out consumer flash drives with persistent writes.</li>
    </ul>
  </li>
</ul><hr />
  <h2 id="additional-files-example-backuprestore-implementation">
    
    
     <a href="#additional-files-example-backuprestore-implementation">#</a><a href="#" aria-label="Back to top">Additional Files (Example Backup/Restore Implementation)</a>
        
    
  </h2>
      

<p>These files would typically reside on the persistent data partition (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>) and be managed/executed via <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> or systemd units symlinked from the persistent storage during boot.</p>

<p><strong><code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> (Modified for Backup/Restore Logic)</strong></p>

<p>This is an example showing how <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> might be modified to handle Docker data restore and systemd unit enabling. <strong>Integrate this logic carefully into the <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> script created in Phase 3.</strong></p>

<div class="language-sh highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c"># Sbnb Custom Commands Script (Modified Example for Backup/Restore)</span>
<span class="c"># Mounts persistent data partition, optionally restores Docker data,</span>
<span class="c"># configures Docker data-root (if needed), enables systemd units.</span>

<span class="c"># Exit immediately if a command exits with a non-zero status. Crucial for boot scripts.</span>
<span class="c"># Use pipefail to ensure pipeline failure is detected.</span>
<span class="nb">set</span> <span class="nt">-e</span> <span class="nt">-o</span> pipefail

<span class="c"># --- Script Start Logging ---</span>
<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Starting custom boot commands (Backup/Restore Example)..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># --- Mount Persistent Data Partition (Same as Phase 3) ---</span>
<span class="nv">DATA_LABEL</span><span class="o">=</span><span class="s2">"SBNB_DATA"</span>
<span class="nv">DATA_DEVICE_SYMLINK</span><span class="o">=</span><span class="s2">"/dev/disk/by-label/</span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">DATA_MOUNT_POINT</span><span class="o">=</span><span class="s2">"/mnt/sbnb-data"</span>
<span class="nv">MAX_WAIT_SECONDS</span><span class="o">=</span>15
<span class="nv">WAIT_INTERVAL</span><span class="o">=</span>1
<span class="nv">elapsed_time</span><span class="o">=</span>0

<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Waiting up to </span><span class="k">${</span><span class="nv">MAX_WAIT_SECONDS</span><span class="k">}</span><span class="s2">s for data device (Label: </span><span class="k">${</span><span class="nv">DATA_LABEL</span><span class="k">}</span><span class="s2">)..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">while</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-e</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_DEVICE_SYMLINK</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">do
  if</span> <span class="o">[</span> <span class="k">${</span><span class="nv">elapsed_time</span><span class="k">}</span> <span class="nt">-ge</span> <span class="k">${</span><span class="nv">MAX_WAIT_SECONDS</span><span class="k">}</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Timeout waiting for device </span><span class="k">${</span><span class="nv">DATA_DEVICE_SYMLINK</span><span class="k">}</span><span class="s2">. Persistent data cannot be mounted."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="nb">exit </span>1 <span class="c"># Exit: cannot proceed without data partition</span>
  <span class="k">fi
  </span><span class="nb">sleep</span> <span class="k">${</span><span class="nv">WAIT_INTERVAL</span><span class="k">}</span>
  <span class="nv">elapsed_time</span><span class="o">=</span><span class="k">$((</span>elapsed_time <span class="o">+</span> WAIT_INTERVAL<span class="k">))</span>
<span class="k">done
</span><span class="nv">DATA_DEVICE</span><span class="o">=</span><span class="si">$(</span><span class="nb">readlink</span> <span class="nt">-f</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_DEVICE_SYMLINK</span><span class="k">}</span><span class="s2">"</span><span class="si">)</span>
<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Data partition device resolved to </span><span class="k">${</span><span class="nv">DATA_DEVICE</span><span class="k">}</span><span class="s2"> after </span><span class="k">${</span><span class="nv">elapsed_time</span><span class="k">}</span><span class="s2">s."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Attempting to mount </span><span class="k">${</span><span class="nv">DATA_DEVICE</span><span class="k">}</span><span class="s2"> at </span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if </span>mount <span class="nt">-o</span> rw,noatime,nodiratime <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_DEVICE</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Successfully mounted persistent partition at </span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Failed to mount </span><span class="k">${</span><span class="nv">DATA_DEVICE</span><span class="k">}</span><span class="s2"> at </span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">!"</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="nb">exit </span>1 <span class="c"># Exit: cannot proceed without data partition mounted</span>
<span class="k">fi</span>

<span class="c"># --- Configure Docker data-root and Restore Data ---</span>
<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Configuring Docker data-root and checking restore..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Define the location for Docker's root data directory on the persistent partition</span>
<span class="nv">DOCKER_DATA_ROOT_PERSISTENT</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">/docker-root"</span>
<span class="c"># Define the standard location for Docker's configuration file</span>
<span class="nv">DOCKER_CONFIG_DIR</span><span class="o">=</span><span class="s2">"/etc/docker"</span>
<span class="nv">DOCKER_CONFIG_FILE</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_CONFIG_DIR</span><span class="k">}</span><span class="s2">/daemon.json"</span>
<span class="c"># Define backup location on the mounted data partition</span>
<span class="nv">BACKUP_DIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">/backups/docker"</span>
<span class="nv">LATEST_LINK</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">/docker_latest.tar.gz"</span>
<span class="c"># --- Target for restore (ephemeral) ---</span>
<span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="o">=</span><span class="s2">"/var/lib/docker"</span>

<span class="c"># 1. Ensure the persistent Docker data-root directory exists (if using direct persistent data-root)</span>
<span class="c"># echo "[sbnb-cmds.sh] Ensuring Docker data directory exists: ${DOCKER_DATA_ROOT_PERSISTENT}" &gt; /dev/kmsg</span>
<span class="c"># mkdir -p "${DOCKER_DATA_ROOT_PERSISTENT}"</span>
<span class="c"># if [ $? -ne 0 ]; then</span>
<span class="c">#   echo "[sbnb-cmds.sh] ERROR: Failed to create persistent Docker data directory ${DOCKER_DATA_ROOT_PERSISTENT}!" &gt; /dev/kmsg</span>
<span class="c">#   exit 1</span>
<span class="c"># fi</span>

<span class="c"># 2. Create/Update Docker daemon configuration (if needed for data-root or other settings)</span>
<span class="c"># echo "[sbnb-cmds.sh] Configuring Docker daemon (${DOCKER_CONFIG_FILE}) to use data-root: ${DOCKER_DATA_ROOT_PERSISTENT}" &gt; /dev/kmsg</span>
<span class="c"># mkdir -p "${DOCKER_CONFIG_DIR}"</span>
<span class="c"># printf '{\n  "data-root": "%s"\n}\n' "${DOCKER_DATA_ROOT_PERSISTENT}" &gt; "${DOCKER_CONFIG_FILE}"</span>
<span class="c"># if [ $? -ne 0 ]; then</span>
<span class="c">#   echo "[sbnb-cmds.sh] ERROR: Failed to write Docker config file ${DOCKER_CONFIG_FILE}!" &gt; /dev/kmsg</span>
<span class="c">#   exit 1</span>
<span class="c"># fi</span>
<span class="c"># echo "[sbnb-cmds.sh] Docker daemon configuration updated." &gt; /dev/kmsg</span>

<span class="c"># 3. Restore Docker data INTO the EPHEMERAL location (if backup exists)</span>
<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Checking for Docker backup to restore to </span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="k">}</span><span class="s2">..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="c"># Ensure ephemeral target directory exists and is empty before restore</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">rm</span> <span class="nt">-rf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span>:?<span class="k">}</span><span class="s2">/"</span><span class="k">*</span> <span class="c"># Safety: ensure var is set before rm -rf *</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-L</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nv">ACTUAL_BACKUP_FILE</span><span class="o">=</span><span class="si">$(</span><span class="nb">readlink</span> <span class="nt">-f</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">"</span><span class="si">)</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ACTUAL_BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Found latest backup: </span><span class="k">${</span><span class="nv">ACTUAL_BACKUP_FILE</span><span class="k">}</span><span class="s2">. Restoring to </span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="k">}</span><span class="s2">..."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="c"># Extract archive directly into the ephemeral data-root directory.</span>
    <span class="k">if </span><span class="nb">tar</span> <span class="nt">-xzf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">ACTUAL_BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-C</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
      </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Docker data restored successfully to ephemeral storage."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="k">else
      </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Failed to extract Docker data from </span><span class="k">${</span><span class="nv">ACTUAL_BACKUP_FILE</span><span class="k">}</span><span class="s2"> to </span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="k">}</span><span class="s2">! Docker will start fresh."</span> <span class="o">&gt;</span> /dev/kmsg
      <span class="nb">rm</span> <span class="nt">-rf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span>:?<span class="k">}</span><span class="s2">/"</span><span class="k">*</span> <span class="c"># Clean up partial restore</span>
    <span class="k">fi
  else
    </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] WARNING: Latest backup link '</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">' exists but is broken or points to non-existent file. Skipping restore."</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="k">fi
else
  </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] No latest Docker backup link found (</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">). Docker will start fresh in </span><span class="k">${</span><span class="nv">DOCKER_DATA_EPHEMERAL</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi
</span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Docker data restore check finished."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># --- Restart Docker Service (if needed, e.g., after config change; not needed for just restore) ---</span>
<span class="c"># echo "[sbnb-cmds.sh] Reloading systemd daemon and restarting Docker service..." &gt; /dev/kmsg</span>
<span class="c"># if systemctl daemon-reload &amp;&amp; systemctl restart docker; then</span>
<span class="c">#   echo "[sbnb-cmds.sh] Docker service restarted successfully." &gt; /dev/kmsg</span>
<span class="c"># else</span>
<span class="c">#   echo "[sbnb-cmds.sh] ERROR: Failed to reload systemd or restart Docker service! Halting script." &gt; /dev/kmsg</span>
<span class="c">#   exit 1</span>
<span class="c"># fi</span>

<span class="c"># --- Update sbnb-dev-env.sh Script (Atomic Method - Example) ---</span>
<span class="c"># This part is specific to the user's dev environment script and might not be needed universally.</span>
<span class="c"># Adjust paths and logic as required.</span>
<span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="o">=</span><span class="s2">"/usr/sbin/sbnb-dev-env.sh"</span>
<span class="nv">SOURCE_DEV_ENV_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">/scripts/sbnb-dev-env.sh"</span> <span class="c"># Assuming it's stored persistently</span>
<span class="nv">TARGET_DIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">"</span><span class="si">)</span>
<span class="nv">TMP_SCRIPT</span><span class="o">=</span><span class="s2">""</span>

<span class="nb">trap</span> <span class="s1">'if [ -n "${TMP_SCRIPT}" ] &amp;&amp; [ -f "${TMP_SCRIPT}" ]; then rm -f "${TMP_SCRIPT}"; echo "[sbnb-cmds.sh] Cleaned up temporary file ${TMP_SCRIPT}" &gt; /dev/kmsg; fi'</span> EXIT HUP INT QUIT TERM

<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Attempting atomic update of </span><span class="k">${</span><span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2"> from </span><span class="k">${</span><span class="nv">SOURCE_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if</span> <span class="o">[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SOURCE_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-d</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TARGET_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Target directory </span><span class="k">${</span><span class="nv">TARGET_DIR</span><span class="k">}</span><span class="s2"> does not exist. Cannot update script."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="nb">exit </span>1
  <span class="k">fi
  </span><span class="nv">TMP_SCRIPT</span><span class="o">=</span><span class="si">$(</span><span class="nb">mktemp</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TARGET_DIR</span><span class="k">}</span><span class="s2">/sbnb-dev-env.sh.XXXXXX"</span><span class="si">)</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span> <span class="o">||</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-f</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Failed to create temporary file in </span><span class="k">${</span><span class="nv">TARGET_DIR</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="nb">exit </span>1
  <span class="k">fi</span>
  <span class="c"># Copy content from persistent storage to temp file</span>
  <span class="k">if </span><span class="nb">cp</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SOURCE_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
    if </span><span class="nb">chmod</span> +x <span class="s2">"</span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
      if </span><span class="nb">mv</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span><span class="nv">TMP_SCRIPT</span><span class="o">=</span><span class="s2">""</span> <span class="c"># Clear var so trap doesn't remove it</span>
        <span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Successfully updated </span><span class="k">${</span><span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
      <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Failed to move temporary file </span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2"> to </span><span class="k">${</span><span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
        <span class="nb">exit </span>1
      <span class="k">fi
    else
      </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Failed to set execute permissions on temporary file </span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
      <span class="nb">exit </span>1
    <span class="k">fi
  else
      </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] ERROR: Failed to copy content from </span><span class="k">${</span><span class="nv">SOURCE_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2"> to </span><span class="k">${</span><span class="nv">TMP_SCRIPT</span><span class="k">}</span><span class="s2">."</span> <span class="o">&gt;</span> /dev/kmsg
      <span class="nb">exit </span>1
  <span class="k">fi
else
  </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] WARNING: Source script </span><span class="k">${</span><span class="nv">SOURCE_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2"> not found. Skipping update."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi
</span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Update of </span><span class="k">${</span><span class="nv">TARGET_DEV_ENV_SCRIPT</span><span class="k">}</span><span class="s2"> finished."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># --- Enable Systemd Units for Backup/Purge ---</span>
<span class="nv">SYSTEMD_SOURCE_DIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">DATA_MOUNT_POINT</span><span class="k">}</span><span class="s2">/systemd"</span> <span class="c"># Units stored on data partition</span>
<span class="nv">SYSTEMD_TARGET_DIR</span><span class="o">=</span><span class="s2">"/etc/systemd/system"</span>
<span class="nv">TIMERS_WANTS_DIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/timers.target.wants"</span>
<span class="nv">SHUTDOWN_WANTS_DIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/shutdown.target.wants"</span> <span class="c"># Adjust if needed</span>

<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Enabling custom systemd units for Docker backup/purge (Source: </span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">)..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Ensure systemd directories exist in the ephemeral overlay filesystem</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TIMERS_WANTS_DIR</span><span class="k">}</span><span class="s2">"</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SHUTDOWN_WANTS_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="c"># Create if shutdown service uses Wants=shutdown.target</span>

<span class="c"># Check if source directory with unit files exists on persistent storage</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Symlink the unit files from persistent storage to the ephemeral systemd directory.</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">/docker-backup.service"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/"</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">/docker-shutdown-backup.service"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/"</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">/docker-purge.service"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/"</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">/docker-backup.timer"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/"</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2">/docker-purge.timer"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/"</span>

  <span class="c"># Link timer units into timers.target.wants to ensure they are started by systemd</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/docker-backup.timer"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TIMERS_WANTS_DIR</span><span class="k">}</span><span class="s2">/"</span>
  <span class="nb">ln</span> <span class="nt">-sf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">SYSTEMD_TARGET_DIR</span><span class="k">}</span><span class="s2">/docker-purge.timer"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TIMERS_WANTS_DIR</span><span class="k">}</span><span class="s2">/"</span>
  <span class="c"># Link shutdown service if it uses Wants=shutdown.target in [Install]</span>
  <span class="c"># ln -sf "${SYSTEMD_TARGET_DIR}/docker-shutdown-backup.service" "${SHUTDOWN_WANTS_DIR}/"</span>

  <span class="c"># Reload systemd config AFTER linking units</span>
  <span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Reloading systemd daemon..."</span> <span class="o">&gt;</span> /dev/kmsg
  systemctl daemon-reload

  <span class="c"># Explicitly enable the units (creates necessary symlinks based on [Install] section)</span>
  <span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Enabling systemd units..."</span> <span class="o">&gt;</span> /dev/kmsg
  systemctl <span class="nb">enable </span>docker-backup.timer docker-purge.timer docker-shutdown-backup.service

  <span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Systemd units for backup linked and enabled."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">else
  </span><span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] WARNING: Systemd source directory </span><span class="k">${</span><span class="nv">SYSTEMD_SOURCE_DIR</span><span class="k">}</span><span class="s2"> not found. Cannot enable backup units."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi</span>

<span class="c"># --- Script Finish Logging ---</span>
<span class="nb">echo</span> <span class="s2">"[sbnb-cmds.sh] Finished custom boot commands."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Clear trap on successful exit to prevent it from running unnecessarily.</span>
<span class="nb">trap</span> - EXIT HUP INT QUIT TERM
<span class="nb">exit </span>0
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">sbnb-tskey.txt</code> (ESP Root)</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><section><code>tskey-auth-...
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/backup-docker.sh</code></strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c"># File: /mnt/sbnb-data/scripts/backup-docker.sh</span>
<span class="c"># Script to stop docker, create a backup, and restart docker.</span>
<span class="c"># Assumes tools like tar, gzip, systemctl, ln, mv, date, sleep, mkdir, nice are available.</span>

<span class="nb">set</span> <span class="nt">-e</span> <span class="c"># Exit on error</span>

<span class="nv">BACKUP_DIR</span><span class="o">=</span><span class="s2">"/mnt/sbnb-data/backups/docker"</span>
<span class="nv">DOCKER_DATA_DIR</span><span class="o">=</span><span class="s2">"/var/lib/docker"</span> <span class="c"># Source is ephemeral</span>
<span class="nv">TIMESTAMP</span><span class="o">=</span><span class="si">$(</span><span class="nb">date</span> +<span class="s2">"%Y%m%d_%H%M%S"</span><span class="si">)</span>
<span class="nv">BACKUP_FILE</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">/docker_backup_</span><span class="k">${</span><span class="nv">TIMESTAMP</span><span class="k">}</span><span class="s2">.tar.gz"</span>
<span class="nv">LATEST_LINK</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">/docker_latest.tar.gz"</span> <span class="c"># Symlink to the latest backup</span>

<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Starting Docker backup process..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Ensure backup directory exists</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] ERROR: Failed to create backup directory </span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">!"</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Stop Docker gracefully</span>
<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Stopping Docker service..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if </span>systemctl is-active <span class="nt">--quiet</span> docker.service<span class="p">;</span> <span class="k">then
  if</span> <span class="o">!</span> systemctl stop docker.service<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Failed to stop Docker service gracefully. Proceeding with backup cautiously."</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="k">else</span>
    <span class="c"># Add a small delay to ensure Docker processes have terminated</span>
    <span class="nb">sleep </span>5
  <span class="k">fi
else
  </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Docker service already stopped."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi</span>

<span class="c"># Create the compressed backup</span>
<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Creating backup archive: </span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if</span> <span class="o">[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_DATA_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># Create archive containing paths relative to /var/lib (e.g., 'docker/...')</span>
  <span class="c"># Use nice to lower CPU priority (if available, remove 'nice -n 19' if command is missing)</span>
  <span class="k">if </span><span class="nb">nice</span> <span class="nt">-n</span> 19 <span class="nb">tar</span> <span class="nt">-czf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-C</span> /var/lib docker<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Backup created successfully: </span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="c"># Update the 'latest' symlink atomically</span>
    <span class="nb">ln</span> <span class="nt">-sfT</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">.tmp"</span> <span class="o">&amp;&amp;</span> <span class="nb">mv</span> <span class="nt">-Tf</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">.tmp"</span> <span class="s2">"</span><span class="k">${</span><span class="nv">LATEST_LINK</span><span class="k">}</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
      </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Updated latest backup link to point to </span><span class="k">${</span><span class="nv">BACKUP_FILE</span><span class="k">}</span><span class="s2">"</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="k">else
      </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Failed to update latest backup link."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="k">fi
  else
    </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] ERROR: tar command failed! Backup not created."</span> <span class="o">&gt;</span> /dev/kmsg
    <span class="c"># Attempt to restart docker even if backup failed</span>
  <span class="k">fi
else
  </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Docker data directory </span><span class="k">${</span><span class="nv">DOCKER_DATA_DIR</span><span class="k">}</span><span class="s2"> not found. Skipping backup."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi</span>

<span class="c"># Restart Docker</span>
<span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Starting Docker service..."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">if</span> <span class="o">!</span> systemctl start docker.service<span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] WARNING: Failed to start Docker service after backup attempt."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">"[backup-docker.sh] Docker backup process finished."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="nb">exit </span>0
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/purge-docker-backups.sh</code></strong></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c"># File: /mnt/sbnb-data/scripts/purge-docker-backups.sh</span>
<span class="c"># Script to remove old Docker backups, keeping the last N.</span>
<span class="c"># Assumes tools like find, sort, head, cut, xargs, rm, wc, mkdir, echo are available.</span>

<span class="nb">set</span> <span class="nt">-e</span> <span class="c"># Exit on error</span>

<span class="nv">BACKUP_DIR</span><span class="o">=</span><span class="s2">"/mnt/sbnb-data/backups/docker"</span>
<span class="nv">KEEP_COUNT</span><span class="o">=</span>3 <span class="c"># Number of backups to keep (adjust as needed)</span>

<span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] Purging old Docker backups in </span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">, keeping </span><span class="k">${</span><span class="nv">KEEP_COUNT</span><span class="k">}</span><span class="s2">..."</span> <span class="o">&gt;</span> /dev/kmsg

<span class="c"># Ensure backup directory exists</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span><span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] ERROR: Failed to ensure backup directory </span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2"> exists!"</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="nb">exit </span>1
<span class="k">fi</span>


<span class="c"># Count existing backups (only files matching the pattern)</span>
<span class="c"># Use find ... -print | wc -l which is safer than parsing ls output</span>
<span class="nv">backup_count</span><span class="o">=</span><span class="si">$(</span>find <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-maxdepth</span> 1 <span class="nt">-name</span> <span class="s1">'docker_backup_*.tar.gz'</span> <span class="nt">-type</span> f <span class="nt">-print</span> | <span class="nb">wc</span> <span class="nt">-l</span><span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">backup_count</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-gt</span> <span class="s2">"</span><span class="k">${</span><span class="nv">KEEP_COUNT</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="c"># List all backup files by modification time (oldest first),</span>
  <span class="c"># calculate how many to delete, and delete them.</span>
  <span class="nv">to_delete_count</span><span class="o">=</span><span class="k">$((</span> backup_count <span class="o">-</span> KEEP_COUNT <span class="k">))</span>
  <span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] Found </span><span class="k">${</span><span class="nv">backup_count</span><span class="k">}</span><span class="s2"> backups. Deleting </span><span class="k">${</span><span class="nv">to_delete_count</span><span class="k">}</span><span class="s2"> oldest ones."</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="c"># Use -print0 and xargs -0 for safety with filenames containing special characters</span>
  find <span class="s2">"</span><span class="k">${</span><span class="nv">BACKUP_DIR</span><span class="k">}</span><span class="s2">"</span> <span class="nt">-maxdepth</span> 1 <span class="nt">-name</span> <span class="s1">'docker_backup_*.tar.gz'</span> <span class="nt">-type</span> f <span class="nt">-printf</span> <span class="s1">'%T@ %p\0'</span> | <span class="se">\</span>
    <span class="nb">sort</span> <span class="nt">-zn</span> | <span class="se">\</span>
    <span class="nb">head</span> <span class="nt">-zn</span> <span class="s2">"</span><span class="k">${</span><span class="nv">to_delete_count</span><span class="k">}</span><span class="s2">"</span> | <span class="se">\</span>
    <span class="nb">cut</span> <span class="nt">-z</span> <span class="nt">-d</span><span class="s1">' '</span> <span class="nt">-f2-</span> | <span class="se">\</span>
    xargs <span class="nt">-0</span> <span class="nt">-r</span> <span class="nb">rm</span> <span class="nt">-v</span> <span class="nt">--</span> <span class="c"># Use -r to avoid running rm if head outputs nothing</span>
  <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] Purge completed."</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="k">else</span>
    <span class="c"># Log error but don't exit, as failure isn't critical for system operation</span>
    <span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] WARNING: Purge command finished with errors (check rm output above)."</span> <span class="o">&gt;</span> /dev/kmsg
  <span class="k">fi
else
  </span><span class="nb">echo</span> <span class="s2">"[purge-docker-backups.sh] </span><span class="k">${</span><span class="nv">backup_count</span><span class="k">}</span><span class="s2"> backups found, which is less than or equal to </span><span class="k">${</span><span class="nv">KEEP_COUNT</span><span class="k">}</span><span class="s2">. No backups purged."</span> <span class="o">&gt;</span> /dev/kmsg
<span class="k">fi

</span><span class="nb">exit </span>0
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/System Volume Information/IndexerVolumeGuid</code> (Example - Often auto-generated)</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><section><code>{ A A A 9 C D 4 5 - 2 E 9 1 - 4 F 7 9 - B 1 4 F - 2 0 9 9 6 F 9 C F 1 C A }
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-backup.service</code></strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><section><code><span class="c"># File: /mnt/sbnb-data/systemd/docker-backup.service
# Service unit to run the backup script
</span>
<span class="nn">[Unit]</span>
<span class="py">Description</span><span class="p">=</span><span class="s">Backup Docker Data to Persistent Storage</span>
<span class="c"># Requires persistent data mount and Docker service (to stop/start it)
</span><span class="py">Requires</span><span class="p">=</span><span class="s">mnt-sbnb-data.mount docker.service</span>
<span class="py">After</span><span class="p">=</span><span class="s">mnt-sbnb-data.mount docker.service</span>

<span class="nn">[Service]</span>
<span class="py">Type</span><span class="p">=</span><span class="s">oneshot</span>
<span class="c"># Run the backup script stored on the persistent drive
# Note: Path assumes ESP is mounted at /mnt/sbnb during script execution
# If sbnb-cmds.sh mounts data partition at /mnt/sbnb-data, use that path:
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/mnt/sbnb-data/scripts/backup-docker.sh</span>
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-backup.timer</code></strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><section><code><span class="c"># File: /mnt/sbnb-data/systemd/docker-backup.timer
# Timer unit to trigger the backup service daily at 5 AM
</span>
<span class="nn">[Unit]</span>
<span class="py">Description</span><span class="p">=</span><span class="s">Daily Docker Backup Timer</span>

<span class="nn">[Timer]</span>
<span class="c"># Run daily at 5 AM system time
</span><span class="py">OnCalendar</span><span class="p">=</span><span class="s">*-*-* 05:00:00</span>
<span class="py">AccuracySec</span><span class="p">=</span><span class="s">1h</span>
<span class="py">Persistent</span><span class="p">=</span><span class="s">true # Run once on boot if missed due to downtime</span>

<span class="nn">[Install]</span>
<span class="py">WantedBy</span><span class="p">=</span><span class="s">timers.target</span>
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-purge.service</code></strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><section><code><span class="c"># File: /mnt/sbnb-data/systemd/docker-purge.service
# Service unit to run the purge script
</span>
<span class="nn">[Unit]</span>
<span class="py">Description</span><span class="p">=</span><span class="s">Purge Old Docker Backups</span>
<span class="py">Requires</span><span class="p">=</span><span class="s">mnt-sbnb-data.mount</span>
<span class="py">After</span><span class="p">=</span><span class="s">mnt-sbnb-data.mount</span>

<span class="nn">[Service]</span>
<span class="py">Type</span><span class="p">=</span><span class="s">oneshot</span>
<span class="c"># Adjust path if needed based on where data partition is mounted
</span><span class="py">ExecStart</span><span class="p">=</span><span class="s">/mnt/sbnb-data/scripts/purge-docker-backups.sh</span>
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-purge.timer</code></strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><section><code><span class="c"># File: /mnt/sbnb-data/systemd/docker-purge.timer
# Timer unit to trigger the purge service daily (e.g., at 6 AM)
</span>
<span class="nn">[Unit]</span>
<span class="py">Description</span><span class="p">=</span><span class="s">Daily Docker Backup Purge Timer</span>

<span class="nn">[Timer]</span>
<span class="py">OnCalendar</span><span class="p">=</span><span class="s">*-*-* 06:00:00</span>
<span class="py">AccuracySec</span><span class="p">=</span><span class="s">1h</span>
<span class="py">Persistent</span><span class="p">=</span><span class="s">true</span>

<span class="nn">[Install]</span>
<span class="py">WantedBy</span><span class="p">=</span><span class="s">timers.target</span>
</code></section></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-shutdown-backup.service</code></strong></p>

<div class="language-ini highlighter-rouge"><div class="highlight"><section><code><span class="c"># File: /mnt/sbnb-data/systemd/docker-shutdown-backup.service
# Service unit to attempt a backup on clean shutdown
</span>
<span class="nn">[Unit]</span>
<span class="py">Description</span><span class="p">=</span><span class="s">Backup Docker Data on Shutdown (Best Effort)</span>
<span class="c"># Run late in shutdown, requires persistent storage &amp; docker (to stop it)
</span><span class="py">DefaultDependencies</span><span class="p">=</span><span class="s">no</span>
<span class="py">Requires</span><span class="p">=</span><span class="s">mnt-sbnb-data.mount docker.service</span>
<span class="py">After</span><span class="p">=</span><span class="s">mnt-sbnb-data.mount docker.service</span>
<span class="py">Before</span><span class="p">=</span><span class="s">shutdown.target reboot.target halt.target kexec.target umount.target final.target</span>

<span class="nn">[Service]</span>
<span class="py">Type</span><span class="p">=</span><span class="s">oneshot</span>
<span class="py">RemainAfterExit</span><span class="p">=</span><span class="s">true # Allows ExecStop to run</span>
<span class="c"># Run the backup script when the service is stopped during shutdown
# Adjust path if needed
</span><span class="py">ExecStop</span><span class="p">=</span><span class="s">/mnt/sbnb-data/scripts/backup-docker.sh</span>

<span class="nn">[Install]</span>
<span class="c"># Ensure this service is wanted by relevant shutdown targets
</span><span class="py">WantedBy</span><span class="p">=</span><span class="s">shutdown.target reboot.target halt.target kexec.target</span>
</code></section></div></div><hr />

<p><strong>Data Summary</strong></p>

<ul>
  <li><strong>Project:</strong> Custom Sbnb Linux setup using a single USB drive for boot and persistent data storage.</li>
  <li><strong>Hardware Context:</strong> x86-64 machine, single USB drive partitioned into ESP (FAT32, PARTLABEL=sbnb) and Data (Ext4, LABEL=SBNB_DATA).</li>
  <li><strong>Software Context:</strong> Sbnb Linux (Buildroot-based, Systemd init, ephemeral overlayfs root), Docker.</li>
  <li><strong>Initial Issue:</strong> Boot stall after <code class="language-plaintext highlighter-rouge">systemd[1]: Started Journal Service.</code>.</li>
  <li><strong>Initial Issue Root Cause:</strong> Mismatch between <code class="language-plaintext highlighter-rouge">sbnb.service</code> dependency (<code class="language-plaintext highlighter-rouge">Wants=dev-disk-by-partlabel-sbnb.device</code>) and USB ESP partition setup (missing partition label <code class="language-plaintext highlighter-rouge">sbnb</code>).</li>
  <li><strong>Initial Issue Solution:</strong> Set partition label <code class="language-plaintext highlighter-rouge">sbnb</code> on ESP partition (<code class="language-plaintext highlighter-rouge">/dev/sdx1</code>) using <code class="language-plaintext highlighter-rouge">parted name 1 sbnb</code>.</li>
  <li><strong>Docker Persistence Strategy:</strong> Keep Docker data ephemeral (<code class="language-plaintext highlighter-rouge">/var/lib/docker</code> in RAM overlay) and use a backup/restore mechanism with persistent storage (<code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>).</li>
  <li><strong>Implementation Files (Persistent Storage - <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/backup-docker.sh</code> (Executable Shell Script)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/scripts/purge-docker-backups.sh</code> (Executable Shell Script)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-backup.service</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-backup.timer</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-shutdown-backup.service</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-purge.service</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/systemd/docker-purge.timer</code> (Systemd Unit)</li>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb-data/backups/docker/</code> (Directory for backup archives)</li>
    </ul>
  </li>
  <li><strong>Implementation File (ESP - mounted at <code class="language-plaintext highlighter-rouge">/mnt/sbnb</code> during boot):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">/mnt/sbnb/sbnb-cmds.sh</code> (Executable Shell Script, modified for restore and unit enabling)</li>
    </ul>
  </li>
  <li><strong>Key Script Logic (<code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>):</strong> Mounts data partition, restores latest backup from data partition to ephemeral <code class="language-plaintext highlighter-rouge">/var/lib/docker</code>, creates symlinks for systemd units from data partition to ephemeral <code class="language-plaintext highlighter-rouge">/etc/systemd/system</code>, reloads systemd, enables units.</li>
  <li><strong>Key Script Logic (<code class="language-plaintext highlighter-rouge">backup-docker.sh</code>):</strong> Stops Docker, creates compressed tar archive of <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> onto data partition backup dir, updates <code class="language-plaintext highlighter-rouge">_latest</code> symlink, restarts Docker.</li>
  <li><strong>Key Script Logic (<code class="language-plaintext highlighter-rouge">purge-docker-backups.sh</code>):</strong> Finds backups matching pattern, keeps the latest <code class="language-plaintext highlighter-rouge">N</code> (default 3), deletes older ones.</li>
  <li><strong>Systemd Units:</strong> Define services to run scripts and timers to trigger them periodically (<code class="language-plaintext highlighter-rouge">OnCalendar</code>) or on shutdown (<code class="language-plaintext highlighter-rouge">ExecStop=</code> in shutdown service).</li>
  <li><strong>Verification:</strong> Use <code class="language-plaintext highlighter-rouge">systemctl list-timers</code>, <code class="language-plaintext highlighter-rouge">systemctl status</code>, <code class="language-plaintext highlighter-rouge">journalctl -u</code>, <code class="language-plaintext highlighter-rouge">journalctl -b | grep ...</code>, and practical tests.</li>
</ul>

<p><strong>Documentation Summary</strong></p>

<ul>
  <li><strong>Project:</strong> Sbnb Single-USB Boot and Persistent Docker Data via Backup/Restore.</li>
  <li><strong>Background:</strong> Sbnb Linux (minimalist, RAM-based) configured for single USB boot and persistent Docker data, deviating from standard internal LVM usage.</li>
  <li><strong>Initial Problem:</strong> Boot stall due to missing ESP <em>partition label</em> (<code class="language-plaintext highlighter-rouge">sbnb</code>) required by <code class="language-plaintext highlighter-rouge">sbnb.service</code>. Resolved by setting the label with <code class="language-plaintext highlighter-rouge">parted</code>.</li>
  <li><strong>Docker Persistence Strategy:</strong> Backup/Restore chosen over direct persistent <code class="language-plaintext highlighter-rouge">data-root</code> due to ephemeral <code class="language-plaintext highlighter-rouge">/etc</code>. Data restored from <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> to <code class="language-plaintext highlighter-rouge">/var/lib/docker</code> on boot via <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>. Backups created periodically/on shutdown to <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code> via systemd-triggered scripts. Old backups purged.</li>
  <li><strong>Implementation:</strong> Details locations and key logic of <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>, backup/purge scripts, and systemd units stored on the persistent data partition and linked/enabled during boot.</li>
  <li><strong>Verification:</strong> Outlines steps using <code class="language-plaintext highlighter-rouge">journalctl</code>, <code class="language-plaintext highlighter-rouge">systemctl</code>, and practical reboot tests to confirm functionality.</li>
</ul>

<p><strong>Paper Trail Summary</strong></p>

<ol>
  <li><strong>Goal:</strong> Single-USB Sbnb boot + persistent storage (tutorial-based).</li>
  <li><strong>Problem:</strong> Boot stall (<code class="language-plaintext highlighter-rouge">Started Journal Service</code>).</li>
  <li><strong>Analysis:</strong> Device dependency issue (<code class="language-plaintext highlighter-rouge">dev-disk-by-partlabel-sbnb</code>).</li>
  <li><strong>Refined Analysis:</strong> Tutorial set <em>filesystem</em> label, Sbnb needed <em>partition</em> label.</li>
  <li><strong>Solution 1:</strong> Set ESP partition label <code class="language-plaintext highlighter-rouge">sbnb</code> via <code class="language-plaintext highlighter-rouge">parted</code>. <strong>Result:</strong> Boot success.</li>
  <li><strong>New Goal:</strong> Docker data persistence on <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
  <li><strong>Strategy 1 (Rejected):</strong> Persistent <code class="language-plaintext highlighter-rouge">data-root</code> via <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code>. <strong>Problem:</strong> <code class="language-plaintext highlighter-rouge">/etc</code> is ephemeral.</li>
  <li><strong>Strategy 2 (Chosen):</strong> Backup/Restore using <code class="language-plaintext highlighter-rouge">/mnt/sbnb-data</code>.</li>
  <li><strong>Implementation 1:</strong> User attempt failed.</li>
  <li><strong>Analysis of Failure:</strong> <code class="language-plaintext highlighter-rouge">log_message: not found</code>, bad <code class="language-plaintext highlighter-rouge">systemctl reload</code> in <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code>, preventing restore/config.</li>
  <li><strong>Decision:</strong> Stick with Backup/Restore.</li>
  <li><strong>Solution 2:</strong> Provided corrected <code class="language-plaintext highlighter-rouge">sbnb-cmds.sh</code> for Backup/Restore, plus persistent scripts/units.</li>
  <li><strong>Current Status:</strong> User has necessary files/instructions for Backup/Restore implementation. Verification steps provided.</li>
</ol>

        </div>
        
          URL: https://ib.bsb.br/sbnb
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/to-enable-video-acceleration-on-rpi4/" title="to enable video acceleration on RPI4" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/images-to-searchable-pdf/" title="Images to Searchable PDF" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "linux>software>dotfile"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-linux-software-dotfile" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/sbnb/" title="Portable linux via Sbnb distro with persistence" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    <div class="comment-box">
      Ref. 
      <a href="https://github.com/sbnb-io/sbnb" title="https://github.com/sbnb-io/sbnb">https://github.com/sbnb-io/sbnb</a>
    </div>
    
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-04-30 04:24:44
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="linux-software-dotfile">
                  linux>software>dotfile
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/sbnb/"
        },
        "headline": "Portable linux via Sbnb distro with persistence",
        "description": "",
        "datePublished": "2025-04-07T00:00:00+00:00",
        "dateModified": "2025-04-19T20:27:26+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
