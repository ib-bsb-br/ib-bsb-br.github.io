<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    
      Gingko Python WebSocket script — infoBAG
    
  </title>
  <meta name="title" content="Gingko Python WebSocket script">
  <meta name="description" content="can't steer unless already moving">

  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="Gingko Python WebSocket script — infoBAG">
  <meta property="og:description" content="can't steer unless already moving">
  <meta property="og:url" content="https://ib.bsb.br/gingko-python-websocket-script/">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="infoBAG">
  

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Gingko Python WebSocket script — infoBAG">
  <meta name="twitter:description" content="can't steer unless already moving">
  

  <link rel="canonical" href="https://ib.bsb.br/gingko-python-websocket-script/">
  <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">

  
    <meta name="keywords" content="scripts>cloud">
    
      <meta property="article:tag" content="scripts>cloud">
    
  

  <!-- Favicons and Icons -->
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  

  <link href="/style.css" rel="stylesheet">
</head>
  <body class="post-content-body">
    
    
    
    
        
        
        "<p>A Python WebSocket client script was successfully developed to enable programmatic interaction with the Gingko Writer application. The project began with the goal of establishing a stable connection to <code class="language-plaintext highlighter-rouge">wss://app.gingkowriter.com/ws</code>, managing authentication through cookies, and handling various message types such as <code class="language-plaintext highlighter-rouge">'rt:join'</code>, <code class="language-plaintext highlighter-rouge">'trees'</code>, and <code class="language-plaintext highlighter-rouge">'user'</code>.  An initial script provided basic connection logic, logging, and message exchange capabilities.\n    
        
        
        "The development process then encountered challenges related to using the established connection for specific tasks, like creating cards. This practical application focus required deeper investigation into message formatting, asynchronous handling of user input alongside incoming messages, and the implementation of a structured request mechanism.  The project required guidance on adding an interactive command interface, concurrent processing, improved logging, and robust error handling to ensure maintainability and extensibility.\n    
        
        
        "A revised Python script was subsequently developed. This version incorporated credentials and authentication details from browser Developer Tools, ensuring proper formatting of the <code class="language-plaintext highlighter-rouge">'rt:join'</code> message with the correct <code class="language-plaintext highlighter-rouge">tr</code>, <code class="language-plaintext highlighter-rouge">uid</code>, and <code class="language-plaintext highlighter-rouge">m</code> parameters.  The script’s message handling was enhanced to process messages like <code class="language-plaintext highlighter-rouge">'rt:joinOk'</code> (join confirmation) and <code class="language-plaintext highlighter-rouge">'pushOk'</code> (push acknowledgment).  Securing credentials through environment variables and using valid, up-to-date system cookies was emphasized.\n    
        
        
        "Initial testing revealed, via execution logs, that the <code class="language-plaintext highlighter-rouge">'rt:joinOk'</code> message was not being received, indicating a potential authentication problem.  Diagnostic steps and instructions for correctly extracting authentication details from Developer Tools were provided, prompting a script update.  This led to a successful connection and correct card creation within Gingko Writer, confirmed by subsequent logs showing push messages, <code class="language-plaintext highlighter-rouge">'pushOk'</code> acknowledgments, and seamless card hierarchy creation.\n    
        
        
        "Throughout the project, issues with authentication parameter accuracy, session checkpoints, and real-time message exchange were addressed. Key milestones included accurate formatting of the <code class="language-plaintext highlighter-rouge">'rt:join'</code> message and correct interpretation of server acknowledgments. These achievements transformed the initial script into a functional tool for interacting with the Gingko Writer service.\n    
        
        
        "The collaborative effort resulted in a robust Python WebSocket client capable of securely connecting to the Gingko Writer server and performing operations like creating structured card hierarchies. This was accomplished by meticulously resolving authentication problems, improving message handling, and ensuring adaptability through enhanced logging and error management. This foundation supports future extensions, such as adding interactive features or integrating more message types, increasing the script’s utility for programmatically managing Gingko Writer documents.</p>\n    
        
        
        "\n    
        
        
        "<p>{% codeblock python %}\n    
        
        
        "import asyncio\n    
        
        
        "import json\n    
        
        
        "import logging\n    
        
        
        "import random\n    
        
        
        "import string\n    
        
        
        "import time\n    
        
        
        "import websockets\n    
        
        
        "from websockets.exceptions import ConnectionClosedError, WebSocketException</p>\n    
        
        
        "\n    
        
        
        "<h1 id="configure-logging-for-detailed-debugging">Configure logging for detailed debugging</h1>\n    
        
        
        "<p>logging.basicConfig(\n    
        
        
        "    level=logging.DEBUG,  # Set to DEBUG for comprehensive logs\n    
        
        
        "    format=’%(asctime)s - %(levelname)s - %(message)s’\n    
        
        
        ")\n    
        
        
        "logger = logging.getLogger(<strong>name</strong>)</p>\n    
        
        
        "\n    
        
        
        "<p>class GingkoWebsocketClient:\n    
        
        
        "    “””\n    
        
        
        "    A client to interact with the Gingko Writer application via WebSocket.\n    
        
        
        "    “””</p>\n    
        
        
        "\n    
        
        
        "<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def __init__(self, url: str, cookies: str, tree_id: str, user_id: str, auth_token: str):\n    
        
        
        "    """\n    
        
        
        "    Initializes the GingkoWebsocketClient with the necessary credentials and parameters.\n    
        
        
        "\n    
        
        
        "    Args:\n    
        
        
        "        url (str): The WebSocket URL for the Gingko Writer application.\n    
        
        
        "        cookies (str): The authentication cookies.\n    
        
        
        "        tree_id (str): The ID of the tree (document) to interact with.\n    
        
        
        "        user_id (str): The user's Gingko Writer user ID.\n    
        
        
        "        auth_token (str): The authentication token from the 'rt:join' message.\n    
        
        
        "    """\n    
        
        
        "    self.url = url\n    
        
        
        "    self.cookies = cookies\n    
        
        
        "    self.tree_id = tree_id\n    
        
        
        "    self.user_id = user_id\n    
        
        
        "    self.auth_token = auth_token\n    
        
        
        "    self.session_id = None\n    
        
        
        "    self.checkpoint = None\n    
        
        
        "    self.push_ok_event = asyncio.Event()\n    
        
        
        "    self.ws = None\n    
        
        
        "    self.reconnect_attempts = 0\n    
        
        
        "    self.max_reconnect_attempts = 5\n    
        
        
        "\n    
        
        
        "async def generate_timestamp(self) -&gt; str:\n    
        
        
        "    """\n    
        
        
        "    Generates a unique timestamp for operations.\n    
        
        
        "\n    
        
        
        "    Returns:\n    
        
        
        "        str: A timestamp string in the format 'milliseconds:sequence:session_fragment'\n    
        
        
        "    """\n    
        
        
        "    millis = int(time.time() * 1000)\n    
        
        
        "    sequence = random.randint(0, 9)\n    
        
        
        "    session_fragment = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))\n    
        
        
        "    return f"{millis}:{sequence}:{session_fragment}"\n    
        
        
        "\n    
        
        
        "async def generate_card_id(self) -&gt; str:\n    
        
        
        "    """\n    
        
        
        "    Generates a unique card ID.\n    
        
        
        "\n    
        
        
        "    Returns:\n    
        
        
        "        str: A 24-character alphanumeric string.\n    
        
        
        "    """\n    
        
        
        "    return ''.join(random.choices(string.ascii_letters + string.digits, k=24))\n    
        
        
        "\n    
        
        
        "async def send_message(self, message_type: str, data: dict):\n    
        
        
        "    """\n    
        
        
        "    Sends a formatted message over the WebSocket connection.\n    
        
        
        "\n    
        
        
        "    Args:\n    
        
        
        "        message_type (str): The type of the message (e.g., 'push', 'rt:join').\n    
        
        
        "        data (dict): The message data payload.\n    
        
        
        "    """\n    
        
        
        "    if self.ws is None:\n    
        
        
        "        logger.error("WebSocket connection is not established.")\n    
        
        
        "        return\n    
        
        
        "    message = {"t": message_type, "d": data}\n    
        
        
        "    try:\n    
        
        
        "        await self.ws.send(json.dumps(message))\n    
        
        
        "        logger.debug(f"Sent {message_type} message: {json.dumps(data)}")\n    
        
        
        "    except Exception as e:\n    
        
        
        "        logger.error(f"Failed to send message '{message_type}': {e}")\n    
        
        
        "\n    
        
        
        "async def handle_user_message(self, data: dict):\n    
        
        
        "    logger.info(f"Received user data: {json.dumps(data, indent=2)}")\n    
        
        
        "\n    
        
        
        "async def handle_trees_message(self, data: list):\n    
        
        
        "    trees = data\n    
        
        
        "    logger.info(f"Received trees data: {json.dumps(trees, indent=2)}")\n    
        
        
        "    tree_ids = [tree['id'] for tree in trees]\n    
        
        
        "    if self.tree_id in tree_ids:\n    
        
        
        "        self.session_id = "SessionNotProvided"\n    
        
        
        "        self.push_ok_event.set()\n    
        
        
        "        logger.info(f"Tree '{self.tree_id}' is available. Proceeding with operations.")\n    
        
        
        "    else:\n    
        
        
        "        logger.error(f"Tree '{self.tree_id}' not found in your account.")\n    
        
        
        "\n    
        
        
        "async def handle_rt_users_message(self, data: list):\n    
        
        
        "    logger.info(f"Received rt:users data: {json.dumps(data, indent=2)}")\n    
        
        
        "\n    
        
        
        "async def handle_push_ok_message(self, data: list):\n    
        
        
        "    checkpoint_list = data\n    
        
        
        "    if checkpoint_list:\n    
        
        
        "        self.checkpoint = checkpoint_list[0]\n    
        
        
        "        logger.debug(f"Updated checkpoint to: {self.checkpoint}")\n    
        
        
        "        self.push_ok_event.set()\n    
        
        
        "    else:\n    
        
        
        "        logger.warning("Received pushOk without checkpoint data.")\n    
        
        
        "\n    
        
        
        "async def handle_rt_join_ok_message(self, data: dict):\n    
        
        
        "    self.session_id = data.get("sid")\n    
        
        
        "    initial_checkpoint = data.get("chk")\n    
        
        
        "    if initial_checkpoint:\n    
        
        
        "        self.checkpoint = initial_checkpoint\n    
        
        
        "    logger.info(f"Joined session: {self.session_id}, initial checkpoint: {self.checkpoint}")\n    
        
        
        "    self.push_ok_event.set()\n    
        
        
        "\n    
        
        
        "async def handle_error_message(self, data: dict):\n    
        
        
        "    logger.error(f"Received error from server: {json.dumps(data, indent=2)}")\n    
        
        
        "\n    
        
        
        "async def handle_message(self, message_data: dict):\n    
        
        
        "    """\n    
        
        
        "    Handles incoming messages from the WebSocket.\n    
        
        
        "\n    
        
        
        "    Args:\n    
        
        
        "        message_data (dict): The received message data.\n    
        
        
        "    """\n    
        
        
        "    logger.debug(f"Received message: {json.dumps(message_data, indent=2)}")\n    
        
        
        "    message_type = message_data.get("t")\n    
        
        
        "    data = message_data.get("d", {})\n    
        
        
        "\n    
        
        
        "    handler = {\n    
        
        
        "        "user": self.handle_user_message,\n    
        
        
        "        "trees": self.handle_trees_message,\n    
        
        
        "        "rt:users": self.handle_rt_users_message,\n    
        
        
        "        "pushOk": self.handle_push_ok_message,\n    
        
        
        "        "rt:joinOk": self.handle_rt_join_ok_message,\n    
        
        
        "        "error": self.handle_error_message,\n    
        
        
        "        "ping": lambda _: self.send_message("pong", {})\n    
        
        
        "    }.get(message_type)\n    
        
        
        "\n    
        
        
        "    if handler:\n    
        
        
        "        await handler(data)\n    
        
        
        "    else:\n    
        
        
        "        logger.debug(f"Unhandled message type: {message_type}, data: {json.dumps(data, indent=2)}")\n    
        
        
        "\n    
        
        
        "async def message_handler(self):\n    
        
        
        "    """\n    
        
        
        "    Continuously handles incoming messages from the WebSocket.\n    
        
        
        "    """\n    
        
        
        "    try:\n    
        
        
        "        async for message in self.ws:\n    
        
        
        "            try:\n    
        
        
        "                message_data = json.loads(message)\n    
        
        
        "                await self.handle_message(message_data)\n    
        
        
        "            except json.JSONDecodeError as e:\n    
        
        
        "                logger.error(f"Failed to decode JSON message: {e}")\n    
        
        
        "    except (ConnectionClosedError, WebSocketException) as e:\n    
        
        
        "        logger.error(f"Connection closed: {e}")\n    
        
        
        "        await self.reconnect()\n    
        
        
        "    except Exception as e:\n    
        
        
        "        logger.error(f"Unexpected error in message handler: {e}")\n    
        
        
        "        await self.reconnect()\n    
        
        
        "\n    
        
        
        "def get_join_message(self) -&gt; dict:\n    
        
        
        "    """\n    
        
        
        "    Constructs the 'rt:join' message to join the Gingko session.\n    
        
        
        "\n    
        
        
        "    Returns:\n    
        
        
        "        dict: The 'rt:join' message data.\n    
        
        
        "    """\n    
        
        
        "    return {\n    
        
        
        "        "tr": self.tree_id,\n    
        
        
        "        "uid": self.user_id,\n    
        
        
        "        "m": ["a", self.auth_token]\n    
        
        
        "    }\n    
        
        
        "\n    
        
        
        "async def create_card(self, content: str, parent_id: str = None, position: int = 0) -&gt; str:\n    
        
        
        "    """\n    
        
        
        "    Creates a new card in the Gingko tree.\n    
        
        
        "\n    
        
        
        "    Args:\n    
        
        
        "        content (str): The content of the card.\n    
        
        
        "        parent_id (str, optional): The ID of the parent card. Defaults to None.\n    
        
        
        "        position (int, optional): The position among siblings. Defaults to 0.\n    
        
        
        "\n    
        
        
        "    Returns:\n    
        
        
        "        str: The ID of the created card.\n    
        
        
        "    """\n    
        
        
        "    card_id = await self.generate_card_id()\n    
        
        
        "    insert_ts = await self.generate_timestamp()\n    
        
        
        "    update_ts = await self.generate_timestamp()\n    
        
        
        "\n    
        
        
        "    # Insert operation\n    
        
        
        "    insert_delta = {\n    
        
        
        "        "id": card_id,\n    
        
        
        "        "ts": insert_ts,\n    
        
        
        "        "ops": [\n    
        
        
        "            {"t": "i", "c": "", "p": parent_id, "pos": position}\n    
        
        
        "        ]\n    
        
        
        "    }\n    
        
        
        "\n    
        
        
        "    # Update operation\n    
        
        
        "    update_delta = {\n    
        
        
        "        "id": card_id,\n    
        
        
        "        "ts": update_ts,\n    
        
        
        "        "ops": [\n    
        
        
        "            {"t": "u", "c": content, "e": insert_ts}\n    
        
        
        "        ]\n    
        
        
        "    }\n    
        
        
        "\n    
        
        
        "    push_data = {\n    
        
        
        "        "dlts": [insert_delta, update_delta],\n    
        
        
        "        "tr": self.tree_id,\n    
        
        
        "        "chk": self.checkpoint or insert_ts\n    
        
        
        "    }\n    
        
        
        "\n    
        
        
        "    self.push_ok_event.clear()\n    
        
        
        "    await self.send_message("push", push_data)\n    
        
        
        "    logger.info(f"Sent push for card '{content}' with ID {card_id}")\n    
        
        
        "\n    
        
        
        "    try:\n    
        
        
        "        await asyncio.wait_for(self.push_ok_event.wait(), timeout=10)\n    
        
        
        "        logger.info(f"Push acknowledgment received for card '{content}'")\n    
        
        
        "    except asyncio.TimeoutError:\n    
        
        
        "        logger.error("Did not receive pushOk acknowledgment in time.")\n    
        
        
        "        raise Exception("pushOk timeout")\n    
        
        
        "\n    
        
        
        "    return card_id\n    
        
        
        "\n    
        
        
        "async def create_tree_structure(self, structure: list, parent_id: str = None):\n    
        
        
        "    """\n    
        
        
        "    Recursively creates a tree structure based on the provided data.\n    
        
        
        "\n    
        
        
        "    Args:\n    
        
        
        "        structure (list): A list of dicts representing the tree structure.\n    
        
        
        "        parent_id (str, optional): The ID of the parent card. Defaults to None.\n    
        
        
        "    """\n    
        
        
        "    for position, node in enumerate(structure):\n    
        
        
        "        content = node.get("content", "").strip()\n    
        
        
        "        children = node.get("children", [])\n    
        
        
        "\n    
        
        
        "        if not content:\n    
        
        
        "            logger.warning("Encountered node without content. Skipping.")\n    
        
        
        "            continue\n    
        
        
        "\n    
        
        
        "        try:\n    
        
        
        "            card_id = await self.create_card(content, parent_id, position)\n    
        
        
        "            logger.info(f"Created card '{content}' with ID {card_id}")\n    
        
        
        "\n    
        
        
        "            if children:\n    
        
        
        "                await self.create_tree_structure(children, card_id)\n    
        
        
        "\n    
        
        
        "            # Small delay to avoid overwhelming the server\n    
        
        
        "            await asyncio.sleep(0.1)\n    
        
        
        "        except Exception as e:\n    
        
        
        "            logger.error(f"Failed to create card '{content}': {e}")\n    
        
        
        "\n    
        
        
        "async def perform_operations(self):\n    
        
        
        "    """\n    
        
        
        "    Performs desired operations after establishing the WebSocket connection.\n    
        
        
        "    This could be interacting with the tree, creating cards, etc.\n    
        
        
        "    """\n    
        
        
        "    logger.info("Starting operations...")\n    
        
        
        "\n    
        
        
        "    # Example: Create a single card.\n    
        
        
        "    example_structure = [\n    
        
        
        "        {\n    
        
        
        "            "content": "Automated Root Card",\n    
        
        
        "            "children": [\n    
        
        
        "                {"content": "Automated Child 1"},\n    
        
        
        "                {"content": "Automated Child 2"}\n    
        
        
        "            ]\n    
        
        
        "        }\n    
        
        
        "    ]\n    
        
        
        "\n    
        
        
        "    await self.create_tree_structure(example_structure)\n    
        
        
        "    logger.info("Completed creating example card structure.")\n    
        
        
        "\n    
        
        
        "async def connect(self):\n    
        
        
        "    """\n    
        
        
        "    Establishes the WebSocket connection and handles reconnection logic.\n    
        
        
        "    """\n    
        
        
        "    while self.reconnect_attempts &lt; self.max_reconnect_attempts:\n    
        
        
        "        try:\n    
        
        
        "            async with websockets.connect(\n    
        
        
        "                self.url,\n    
        
        
        "                extra_headers={"Cookie": self.cookies}\n    
        
        
        "            ) as ws:\n    
        
        
        "                self.ws = ws\n    
        
        
        "                self.reconnect_attempts = 0\n    
        
        
        "                logger.info(f"Connected to {self.url}")\n    
        
        
        "\n    
        
        
        "                # Send 'rt:join' message\n    
        
        
        "                join_message = self.get_join_message()\n    
        
        
        "                await self.send_message("rt:join", join_message)\n    
        
        
        "                logger.debug(f"Sent 'rt:join' message: {json.dumps(join_message)}")\n    
        
        
        "                logger.debug("Waiting for 'rt:joinOk' message...")\n    
        
        
        "\n    
        
        
        "                # Start handling incoming messages\n    
        
        
        "                message_task = asyncio.create_task(self.message_handler())\n    
        
        
        "\n    
        
        
        "                # Wait until session ID is received\n    
        
        
        "                try:\n    
        
        
        "                    await asyncio.wait_for(self.push_ok_event.wait(), timeout=10)\n    
        
        
        "                except asyncio.TimeoutError:\n    
        
        
        "                    logger.error("Did not receive 'rt:joinOk' acknowledgment in time.")\n    
        
        
        "                    await self.reconnect()\n    
        
        
        "                    continue\n    
        
        
        "\n    
        
        
        "                # Proceed with operations\n    
        
        
        "                await self.perform_operations()\n    
        
        
        "\n    
        
        
        "                # Keep the connection alive\n    
        
        
        "                await message_task\n    
        
        
        "\n    
        
        
        "        except Exception as e:\n    
        
        
        "            logger.exception(f"Connection error: {e}")\n    
        
        
        "            await self.reconnect()\n    
        
        
        "\n    
        
        
        "async def reconnect(self):\n    
        
        
        "    """\n    
        
        
        "    Handles reconnection logic with exponential backoff.\n    
        
        
        "    """\n    
        
        
        "    self.reconnect_attempts += 1\n    
        
        
        "    if self.reconnect_attempts &gt;= self.max_reconnect_attempts:\n    
        
        
        "        logger.error("Maximum reconnection attempts reached. Exiting.")\n    
        
        
        "        return\n    
        
        
        "    wait_time = min(2 ** self.reconnect_attempts, 60)\n    
        
        
        "    logger.info(f"Attempting to reconnect in {wait_time} seconds (Attempt {self.reconnect_attempts}/{self.max_reconnect_attempts})...")\n    
        
        
        "    await asyncio.sleep(wait_time)\n    
        
        
        "    logger.info("Reconnecting...")\n    
        
        
        "    # Reset session-specific data\n    
        
        
        "    self.session_id = None\n    
        
        
        "    self.checkpoint = None\n    
        
        
        "    self.push_ok_event.clear()\n    
        
        
        "\n    
        
        
        "async def start(self):\n    
        
        
        "    """\n    
        
        
        "    Starts the client, connects to the server, and initiates operations.\n    
        
        
        "    """\n    
        
        
        "    try:\n    
        
        
        "        await self.connect()\n    
        
        
        "    except KeyboardInterrupt:\n    
        
        
        "        logger.info("Interrupted by user.")\n    
        
        
        "        if self.ws:\n    
        
        
        "            await self.ws.close()\n    
        
        
        "    except Exception as e:\n    
        
        
        "        logger.exception(f"An unexpected error occurred: {e}")\n    
        
        
        "\n    
        
        
        "@staticmethod\n    
        
        
        "def load_credentials_from_env():\n    
        
        
        "    """\n    
        
        
        "    Loads credentials from environment variables.\n    
        
        
        "\n    
        
        
        "    Returns:\n    
        
        
        "        tuple: A tuple containing url, cookies, tree_id, user_id, auth_token\n    
        
        
        "    """\n    
        
        
        "    url = "wss://app.gingkowriter.com/ws"  # Fixed URL\n    
        
        
        "    cookies = (\n    
        
        
        "        "connect.sid=s%3AXkJFI98eqQGZr1RAGBIfYsYBVr-Uut3U.1km8qszBYRbt4y8Pt%2FrfFiJYiJxOanDTVmG5M1neBO8; "\n    
        
        
        "        "_lr_uf_-jtqjrc=75363195-2f23-4367-a280-285f990f7e05; "\n    
        
        
        "        "_BEAMER_USER_ID_mYJLRImY38547=25ddf751-0c59-4586-802b-363c9ae86222; "\n    
        
        
        "        "_BEAMER_FIRST_VISIT_mYJLRImY38547=2024-10-12T23:25:51.320Z; "\n    
        
        
        "        "__stripe_mid=cf6d738b-2f4f-4056-80c1-1c9c71add535b51abb; "\n    
        
        
        "        "_BEAMER_LAST_POST_SHOWN_mYJLRImY38547=null; "\n    
        
        
        "        "_BEAMER_DATE_mYJLRImY38547=2024-11-02T18:12:51.544Z; "\n    
        
        
        "        "_BEAMER_FILTER_BY_URL_mYJLRImY38547=false; "\n    
        
        
        "        "__stripe_sid=ff6a432e-a911-4aec-b705-f4d2ee20b821a790e3; "\n    
        
        
        "        "_lr_tabs_-jtqjrc%2Fgingko-writer-production={%22sessionID%22:4%2C%22recordingID%22:%225-30ccf034-7be8-4a09-818c-d0bb25704c75%22%2C%22lastActivity%22:1730633141817%2C%22hasActivity%22:true}; "\n    
        
        
        "        "_lr_hb_-jtqjrc%2Fgingko-writer-production={%22heartbeat%22:1730633141818}"\n    
        
        
        "    )\n    
        
        
        "    tree_id = "6oj4Rzb"  # As per your 'rt:join' message\n    
        
        
        "    user_id = "h9ogoeh2o2u7"  # As per your 'rt:join' message\n    
        
        
        "    auth_token = "TLOBcFHCOPU6oI6mYHKdpR5F"  # As per your 'rt:join' message\n    
        
        
        "    return url, cookies, tree_id, user_id, auth_token\n    
        
        
        "</code></pre></div></div>\n    
        
        
        "\n    
        
        
        "<p>async def main():\n    
        
        
        "    “””\n    
        
        
        "    Main function to start the GingkoWebsocketClient.\n    
        
        
        "    “””\n    
        
        
        "    # Load credentials directly from provided data\n    
        
        
        "    URL, COOKIES, TREE_ID, USER_ID, AUTH_TOKEN = GingkoWebsocketClient.load_credentials_from_env()</p>\n    
        
        
        "\n    
        
        
        "<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>client = GingkoWebsocketClient(URL, COOKIES, TREE_ID, USER_ID, AUTH_TOKEN)\n    
        
        
        "await client.start()\n    
        
        
        "</code></pre></div></div>\n    
        
        
        "\n    
        
        
        "<p>if <strong>name</strong> == “<strong>main</strong>”:\n    
        
        
        "    asyncio.run(main())\n    
        
        
        "{%22sessionID%22:4%2C%22recordingID%22:%225-30ccf034-7be8-4a09-818c-d0bb25704c75%22%2C%22lastActivity%22:1730633141817%2C%22hasActivity%22:true}; “\n    
        
        
        "            “<em>lr_hb</em>-jtqjrc%2Fgingko-writer-production={%22heartbeat%22:1730633141818}”\n    
        
        
        "        )\n    
        
        
        "        tree_id = “6oj4Rzb”  # As per your ‘rt:join’ message\n    
        
        
        "        user_id = “h9ogoeh2o2u7”  # As per your ‘rt:join’ message\n    
        
        
        "        auth_token = “TLOBcFHCOPU6oI6mYHKdpR5F”  # As per your ‘rt:join’ message\n    
        
        
        "        return url, cookies, tree_id, user_id, auth_token</p>\n    
        
        
        "\n    
        
        
        "<p>async def main():\n    
        
        
        "    “””\n    
        
        
        "    Main function to start the GingkoWebsocketClient.\n    
        
        
        "    “””\n    
        
        
        "    # Load credentials directly from provided data\n    
        
        
        "    URL, COOKIES, TREE_ID, USER_ID, AUTH_TOKEN = GingkoWebsocketClient.load_credentials_from_env()</p>\n    
        
        
        "\n    
        
        
        "<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>client = GingkoWebsocketClient(URL, COOKIES, TREE_ID, USER_ID, AUTH_TOKEN)\n    
        
        
        "await client.start()\n    
        
        
        "</code></pre></div></div>\n    
        
        
        "\n    
        
        
        "<p>if <strong>name</strong> == “<strong>main</strong>”:\n    
        
        
        "    asyncio.run(main())\n    
        
        
        "{% endcodeblock %}</p>\n    "
  <header class="header-container">
    <nav aria-label="Main navigation" class="header-content">
      <a href="/" aria-label="Home">
        <img src="/favicon.ico" alt="Home" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/tags" aria-label="Tags">
        <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/events" aria-label="Events">
        <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/archive" aria-label="Archive">
        <img src="/assets/Loose_Stone_Pile.gif" alt="Archive" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
    </nav>
    <h1 class="post-title">Gingko Python WebSocket script</h1>
    <div class="post-meta">
      <time datetime="2024-11-03T00:00:00+00:00" class="post-date">
        03 Nov 2024
      </time>
      
        <span class="post-updated">
          ↣
          <time datetime="2024-11-04T10:05:37+00:00">04 Nov 2024</time>
        </span>
      
      
        <p class="post-slug">
          Slug: <a href="https://ib.bsb.br/gingko-python-websocket-script" class="tag">gingko-python-websocket-script</a>
        </p>
      
      
        <p class="post-tags">
          Tags:
          
            <a href="https://ib.bsb.br/tags/#scripts-cloud" class="tag">scripts>cloud</a>
          
        </p>
      
    </div>
    <div class="post-actions">
      <div class="page-stats mt-3" role="status" aria-label="Page statistics">
        <span class="badge bg-primary">
          18852 characters
        </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
          1701 words
        </span>
      </div>
      <div class="action-buttons d-flex flex-wrap gap-2">
        
          
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-11-03-gingko-python-websocket-script.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                <span class="button-text">Improve this page?</span>
                <span class="info-text">aberto.</span>
              </button>
            </form>
          
          <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-11-03-gingko-python-websocket-script.md"
                method="GET"
                target="_blank"
                rel="noopener noreferrer"
                class="d-inline-block">
            <button type="submit" class="btn btn-danger" aria-label="View page revision history">
              View revision history
            </button>
          </form>
        
      </div>
    </div>
  </header>
  <main class="content">
    <article class="post-wrapper">
      <div class="post-content-body">
        

        

      </div>
      
        URL: https://ib.bsb.br/gingko-python-websocket-script
      
    </article>
    <nav class="post-navigation" aria-label="Post navigation">
      
        <div class="nav-arrow prev">
          <a href="/zutty-linux-terminal/" title="Zutty Linux terminal" rel="prev">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ/lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
          </a>
        </div>
      
      
        <div class="nav-arrow next">
          <a href="/etcinitdperformance-governorssh/" title="/etc/init.d/performance_governors.sh" rel="next">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
          </a>
        </div>
      
    </nav>
    
  </main>
  <footer class="site-footer">
    <p>
      <a href="#" aria-label="Back to top">
        <img src="/assets/Rope_(Old).gif" alt="Back to top" width="32" height="32" loading="lazy">
      </a><a href="https://ib.bsb.br/404" aria-label="404">2024-12-28 18:06:39</a>‎ ⇔‎ <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">ℹ</a>‎ <a href="/" aria-label="Homepage">infoBAG</a>
    </p>
  </footer>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://ib.bsb.br/gingko-python-websocket-script/"
    },
    "headline": "Gingko Python WebSocket script",
    "description": "",
    "datePublished": "2024-11-03T00:00:00+00:00",
    "dateModified": "2024-11-04T10:05:37+00:00",
    "author": {
      "@type": "Person",
      "name": "Author"
    },
    "publisher": {
      "@type": "Organization",
      "name": "infoBAG"
      
    }
    
  }
  </script>
  <script src="/assets/js/prism.js" defer></script>
</body>
</html>
