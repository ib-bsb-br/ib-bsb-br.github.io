<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    
      WhatsapPY data — infoBAG
    
  </title>
  <meta name="title" content="WhatsapPY data" />
  <meta name="description" content="can't steer unless already moving" />  
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="WhatsapPY data — infoBAG" />
  <meta property="og:description" content="can't steer unless already moving" />
  <meta property="og:url" content="https://ib.bsb.br/whatsappy/" />
  <meta property="og:type" content="article" />
  <meta property="og:site_name" content="infoBAG" />
    
  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="WhatsapPY data — infoBAG">
  <meta name="twitter:description" content="can't steer unless already moving">
    
  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://ib.bsb.br/whatsappy/"
    },
    "headline": "WhatsapPY data",
    "description": "",
    "datePublished": "2024-04-28T00:00:00+00:00",
    "dateModified": "2024-10-10T14:28:09+00:00",
    "author": {
      "@type": "Person",
      "name": "Author"
    },
    "publisher": {
      "@type": "Organization",
      "name": "infoBAG",
      
    }
    
  }
  </script>  
  <link rel="canonical" href="https://ib.bsb.br/whatsappy/">
  <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">  
  
    <meta name="keywords" content="scripts">
    
      <meta property="article:tag" content="scripts">
    
    
  <!-- Favicons and Icons -->
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
  <link href="/style.css" rel="stylesheet">  
  <script src="/assets/js/prism.js" defer></script>
</head>
<body class="post-content-body">
  <header class="header-container">
    <nav aria-label="Main navigation" class="header-content">
      <a href="/" aria-label="Home">
        <img src="/favicon.ico" alt="Home" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/tags" aria-label="Tags">
        <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/events" aria-label="Events">
        <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/archive" aria-label="Archive">
        <img src="/assets/Loose_Stone_Pile.gif" alt="Archive" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>      
    </nav>
    <h1 class="post-title">WhatsapPY data</h1>
        <div class="post-meta">
          <time datetime="2024-04-28T00:00:00+00:00" class="post-date">
            28 Apr 2024</time>
          
            <span class="post-updated"> &rightarrowtail; <time datetime="2024-10-10T14:28:09+00:00">10 Oct 2024</time></span>
          
          
          <div class="post-info">
            Edit: aberto.
          </div>
          
          
          <div class="post-tags">
            Tags:
            
            <a href="https://ib.bsb.br/tags/#scripts" class="tag">
              scripts
            </a>
          
          
          </div>
          
          <div class="post-actions">
            <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-04-28-whatsappy.md" target="_blank" rel="noopener noreferrer" class="btn-primary">
              Improve this page
            </a>&hArr;<a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-04-28-whatsappy.md" target="_blank" rel="noopener noreferrer" class="btn-secondary">
              View revision history
            </a>
          </div>
        </div>
  </header>
  <main class="content">
    <article class="post-wrapper">      
      <div class="post-content">
        

        <section data-filename="python_code-block.py" data-code="import pandas as pd
import re
from typing import List, Tuple, Optional, Dict, Any
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime, time
import logging
from enum import Enum
class MessageType(Enum):
TEXT = &quot;text&quot;
MEDIA = &quot;media&quot;
SYSTEM = &quot;system&quot;
@dataclass
class Message:
date: datetime
time: time
sender: str
content: str
type: MessageType
class WhatsAppDataProcessor:
def __init__(self, file_path: str, config: Optional[Dict[str, Any]] = None):
&quot;&quot;&quot;Initialize the WhatsApp chat processor with optional configuration.
Args:
file_path: Path to the WhatsApp chat export file
config: Optional configuration dictionary with processing settings
Raises:
FileNotFoundError: If the specified file doesn't exist
&quot;&quot;&quot;
self.file_path = Path(file_path)
if not self.file_path.exists():
raise FileNotFoundError(f&quot;Chat file not found: {file_path}&quot;)
# Default configuration
self.config = {
'max_line_length': 32767,  # Excel's maximum cell content length
'preserve_emoji': True,
'remove_system_messages': False,
'date_format': '%d/%m/%y',
'time_format': '%H:%M:%S',
'output_encoding': 'utf-8',
'normalize_whitespace': True
}
if config:
self.config.update(config)
self.chat_data: Optional[str] = None
self.data_frame: Optional[pd.DataFrame] = None
# Set up logging
logging.basicConfig(level=logging.INFO)
self.logger = logging.getLogger(__name__)
def _is_system_message(self, sender: str, content: str) -&gt; bool:
&quot;&quot;&quot;Detect if a message is a system message.
Args:
sender: Message sender
content: Message content
Returns:
bool indicating if the message is a system message
&quot;&quot;&quot;
system_patterns = [
r&quot;changed the subject to&quot;,
r&quot;added \d&quot;,
r&quot;left$&quot;,
r&quot;changed this group's icon&quot;,
r&quot;Messages and calls are end-to-end encrypted&quot;,
]
return any(re.search(pattern, content) for pattern in system_patterns)
def _normalize_message(self, message: str) -&gt; str:
&quot;&quot;&quot;Normalize a message by converting newlines and handling special characters.
Args:
message: The raw message text
Returns:
Normalized message as a single line
&quot;&quot;&quot;
if not self.config['normalize_whitespace']:
return message
# Preserve emojis if configured
if self.config['preserve_emoji']:
# Convert emojis to temporary placeholders
emoji_pattern = r'[\U0001F000-\U0001F999]'
emojis = re.finditer(emoji_pattern, message)
emoji_map = {m.group(): f&quot;__EMOJI_{i}__&quot; for i, m in enumerate(emojis)}
for emoji, placeholder in emoji_map.items():
message = message.replace(emoji, placeholder)
# Normalize whitespace and newlines
message = re.sub(r'\r\n|\r|\n', ' ', message)
message = re.sub(r'\s+', ' ', message)
message = message.strip()
# Restore emojis if they were preserved
if self.config['preserve_emoji']:
for emoji, placeholder in emoji_map.items():
message = message.replace(placeholder, emoji)
# Truncate if exceeds max length
if len(message) &gt; self.config['max_line_length']:
message = message[:self.config['max_line_length']-3] + &quot;...&quot;
return message
def _detect_message_type(self, content: str) -&gt; MessageType:
&quot;&quot;&quot;Detect the type of message based on its content.
Args:
content: Message content
Returns:
MessageType enum value
&quot;&quot;&quot;
media_patterns = [
r'&lt;Media omitted&gt;',
r'image omitted',
r'video omitted',
r'audio omitted',
r'document omitted',
r'sticker omitted',
r'GIF omitted'
]
if any(re.search(pattern, content, re.IGNORECASE) for pattern in media_patterns):
return MessageType.MEDIA
return MessageType.TEXT
def _process_message_chunk(self, chunk: List[Tuple[str, str, str, str]]) -&gt; Optional[Message]:
&quot;&quot;&quot;Process a chunk of message lines into a single message entry.
Args:
chunk: List containing the message header and continuation lines
Returns:
Optional[Message] object containing the processed message data
&quot;&quot;&quot;
if not chunk:
return None
date_str, time_str, sender, first_line = chunk[0]
continuation_lines = [line[0] for line in chunk[1:]]
# Combine message lines
full_message = first_line
if continuation_lines:
full_message += ' ' + ' '.join(continuation_lines)
# Normalize the message
normalized_message = self._normalize_message(full_message)
# Convert date and time strings to proper types
try:
date = datetime.strptime(date_str, self.config['date_format']).date()
time_obj = datetime.strptime(time_str, self.config['time_format']).time()
except ValueError as e:
self.logger.warning(f&quot;Date/time parsing error: {e}&quot;)
return None
# Detect message type
msg_type = self._detect_message_type(normalized_message)
# Check if it's a system message
if self._is_system_message(sender, normalized_message):
msg_type = MessageType.SYSTEM
if self.config['remove_system_messages']:
return None
return Message(
date=date,
time=time_obj,
sender=sender.strip(),
content=normalized_message,
type=msg_type
)
def parse_chat(self) -&gt; None:
&quot;&quot;&quot;Parses the chat data into structured components.
Raises:
ValueError: If chat data isn't loaded or if no valid messages are found
RuntimeError: If message parsing fails
&quot;&quot;&quot;
if self.chat_data is None:
raise ValueError(&quot;Chat data is not loaded. Please run read_chat() first.&quot;)
# Enhanced regex pattern for better message header detection
date_time_pattern = (
r'^\[(?P&lt;date&gt;\d{2}/\d{2}/\d{2}), (?P&lt;time&gt;\d{2}:\d{2}:\d{2})\] '
r'(?P&lt;sender&gt;[^:]+): (?P&lt;content&gt;.*?)$'
)
try:
lines = [line.strip() for line in self.chat_data.split('\n') if line.strip()]
messages: List[Message] = []
current_chunk = []
for line in lines:
match = re.match(date_time_pattern, line)
if match:
# Process previous chunk if it exists
if current_chunk:
processed_msg = self._process_message_chunk(current_chunk)
if processed_msg:
messages.append(processed_msg)
current_chunk = []
# Start new message chunk
current_chunk.append(match.groups())
elif current_chunk:
# Add continuation line
current_chunk.append([line])
# Process the final chunk
if current_chunk:
processed_msg = self._process_message_chunk(current_chunk)
if processed_msg:
messages.append(processed_msg)
if not messages:
raise ValueError(&quot;No valid messages found in the chat data&quot;)
# Convert messages to DataFrame
self.data_frame = pd.DataFrame([
{
'Date': msg.date,
'Time': msg.time,
'Sender': msg.sender,
'Message': msg.content,
'Type': msg.type.value
}
for msg in messages
])
except Exception as e:
raise RuntimeError(f&quot;Error parsing chat data: {e}&quot;)
def save_to_file(self, output_path: str = 'result.csv') -&gt; None:
&quot;&quot;&quot;Saves the parsed data to a CSV file with proper encoding and escaping.
Args:
output_path: Path where the CSV file will be saved
Raises:
ValueError: If data frame is not created
IOError: If there are issues saving the file
&quot;&quot;&quot;
if self.data_frame is None:
raise ValueError(&quot;Data frame is not created. Please run parse_chat() first.&quot;)
try:
self.data_frame.to_csv(
output_path,
index=False,
sep='\t',
encoding=self.config['output_encoding'],
quoting=1,  # Quote all non-numeric fields
escapechar='\\',  # Use backslash as escape character
date_format='%Y-%m-%d'  # ISO format for dates
)
self.logger.info(f&quot;Successfully saved {len(self.data_frame)} messages to {output_path}&quot;)
except IOError as e:
raise IOError(f&quot;Error saving to file: {e}&quot;)
def read_chat(self) -&gt; None:
&quot;&quot;&quot;Reads the chat data from the file with proper encoding handling.
Raises:
IOError: If there are issues reading the file
&quot;&quot;&quot;
try:
with open(self.file_path, 'r', encoding=self.config['output_encoding'], errors='ignore') as file:
self.chat_data = file.read()
if not self.chat_data.strip():
raise ValueError(&quot;The chat file is empty&quot;)
self.logger.info(f&quot;Successfully read chat file: {self.file_path}&quot;)
except IOError as e:
raise IOError(f&quot;Error reading chat file: {e}&quot;)
def main():
try:
# Example configuration
config = {
'preserve_emoji': True,
'remove_system_messages': True,
'normalize_whitespace': True
}
processor = WhatsAppDataProcessor('chat.txt', config)
processor.read_chat()
processor.parse_chat()
processor.save_to_file()
except Exception as e:
logging.error(f&quot;Error processing chat: {e}&quot;)
if __name__ == &quot;__main__&quot;:
main()" data-download-link="" data-download-link-label="Download Python"><code class="language-python">import pandas as pd
import re
from typing import List, Tuple, Optional, Dict, Any
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime, time
import logging
from enum import Enum
class MessageType(Enum):
TEXT = "text"
MEDIA = "media"
SYSTEM = "system"
@dataclass
class Message:
date: datetime
time: time
sender: str
content: str
type: MessageType
class WhatsAppDataProcessor:
def __init__(self, file_path: str, config: Optional[Dict[str, Any]] = None):
"""Initialize the WhatsApp chat processor with optional configuration.
Args:
file_path: Path to the WhatsApp chat export file
config: Optional configuration dictionary with processing settings
Raises:
FileNotFoundError: If the specified file doesn't exist
"""
self.file_path = Path(file_path)
if not self.file_path.exists():
raise FileNotFoundError(f"Chat file not found: {file_path}")
# Default configuration
self.config = {
'max_line_length': 32767,  # Excel's maximum cell content length
'preserve_emoji': True,
'remove_system_messages': False,
'date_format': '%d/%m/%y',
'time_format': '%H:%M:%S',
'output_encoding': 'utf-8',
'normalize_whitespace': True
}
if config:
self.config.update(config)
self.chat_data: Optional[str] = None
self.data_frame: Optional[pd.DataFrame] = None
# Set up logging
logging.basicConfig(level=logging.INFO)
self.logger = logging.getLogger(__name__)
def _is_system_message(self, sender: str, content: str) -&gt; bool:
"""Detect if a message is a system message.
Args:
sender: Message sender
content: Message content
Returns:
bool indicating if the message is a system message
"""
system_patterns = [
r"changed the subject to",
r"added \d",
r"left$",
r"changed this group's icon",
r"Messages and calls are end-to-end encrypted",
]
return any(re.search(pattern, content) for pattern in system_patterns)
def _normalize_message(self, message: str) -&gt; str:
"""Normalize a message by converting newlines and handling special characters.
Args:
message: The raw message text
Returns:
Normalized message as a single line
"""
if not self.config['normalize_whitespace']:
return message
# Preserve emojis if configured
if self.config['preserve_emoji']:
# Convert emojis to temporary placeholders
emoji_pattern = r'[\U0001F000-\U0001F999]'
emojis = re.finditer(emoji_pattern, message)
emoji_map = {m.group(): f"__EMOJI_{i}__" for i, m in enumerate(emojis)}
for emoji, placeholder in emoji_map.items():
message = message.replace(emoji, placeholder)
# Normalize whitespace and newlines
message = re.sub(r'\r\n|\r|\n', ' ', message)
message = re.sub(r'\s+', ' ', message)
message = message.strip()
# Restore emojis if they were preserved
if self.config['preserve_emoji']:
for emoji, placeholder in emoji_map.items():
message = message.replace(placeholder, emoji)
# Truncate if exceeds max length
if len(message) &gt; self.config['max_line_length']:
message = message[:self.config['max_line_length']-3] + "..."
return message
def _detect_message_type(self, content: str) -&gt; MessageType:
"""Detect the type of message based on its content.
Args:
content: Message content
Returns:
MessageType enum value
"""
media_patterns = [
r'<Media omitted="">',
r'image omitted',
r'video omitted',
r'audio omitted',
r'document omitted',
r'sticker omitted',
r'GIF omitted'
]
if any(re.search(pattern, content, re.IGNORECASE) for pattern in media_patterns):
return MessageType.MEDIA
return MessageType.TEXT
def _process_message_chunk(self, chunk: List[Tuple[str, str, str, str]]) -&gt; Optional[Message]:
"""Process a chunk of message lines into a single message entry.
Args:
chunk: List containing the message header and continuation lines
Returns:
Optional[Message] object containing the processed message data
"""
if not chunk:
return None
date_str, time_str, sender, first_line = chunk[0]
continuation_lines = [line[0] for line in chunk[1:]]
# Combine message lines
full_message = first_line
if continuation_lines:
full_message += ' ' + ' '.join(continuation_lines)
# Normalize the message
normalized_message = self._normalize_message(full_message)
# Convert date and time strings to proper types
try:
date = datetime.strptime(date_str, self.config['date_format']).date()
time_obj = datetime.strptime(time_str, self.config['time_format']).time()
except ValueError as e:
self.logger.warning(f"Date/time parsing error: {e}")
return None
# Detect message type
msg_type = self._detect_message_type(normalized_message)
# Check if it's a system message
if self._is_system_message(sender, normalized_message):
msg_type = MessageType.SYSTEM
if self.config['remove_system_messages']:
return None
return Message(
date=date,
time=time_obj,
sender=sender.strip(),
content=normalized_message,
type=msg_type
)
def parse_chat(self) -&gt; None:
"""Parses the chat data into structured components.
Raises:
ValueError: If chat data isn't loaded or if no valid messages are found
RuntimeError: If message parsing fails
"""
if self.chat_data is None:
raise ValueError("Chat data is not loaded. Please run read_chat() first.")
# Enhanced regex pattern for better message header detection
date_time_pattern = (
r'^\[(?P<date>\d{2}/\d{2}/\d{2}), (?P<time>\d{2}:\d{2}:\d{2})\] '
r'(?P<sender>[^:]+): (?P<content>.*?)$'
)
try:
lines = [line.strip() for line in self.chat_data.split('\n') if line.strip()]
messages: List[Message] = []
current_chunk = []
for line in lines:
match = re.match(date_time_pattern, line)
if match:
# Process previous chunk if it exists
if current_chunk:
processed_msg = self._process_message_chunk(current_chunk)
if processed_msg:
messages.append(processed_msg)
current_chunk = []
# Start new message chunk
current_chunk.append(match.groups())
elif current_chunk:
# Add continuation line
current_chunk.append([line])
# Process the final chunk
if current_chunk:
processed_msg = self._process_message_chunk(current_chunk)
if processed_msg:
messages.append(processed_msg)
if not messages:
raise ValueError("No valid messages found in the chat data")
# Convert messages to DataFrame
self.data_frame = pd.DataFrame([
{
'Date': msg.date,
'Time': msg.time,
'Sender': msg.sender,
'Message': msg.content,
'Type': msg.type.value
}
for msg in messages
])
except Exception as e:
raise RuntimeError(f"Error parsing chat data: {e}")
def save_to_file(self, output_path: str = 'result.csv') -&gt; None:
"""Saves the parsed data to a CSV file with proper encoding and escaping.
Args:
output_path: Path where the CSV file will be saved
Raises:
ValueError: If data frame is not created
IOError: If there are issues saving the file
"""
if self.data_frame is None:
raise ValueError("Data frame is not created. Please run parse_chat() first.")
try:
self.data_frame.to_csv(
output_path,
index=False,
sep='\t',
encoding=self.config['output_encoding'],
quoting=1,  # Quote all non-numeric fields
escapechar='\\',  # Use backslash as escape character
date_format='%Y-%m-%d'  # ISO format for dates
)
self.logger.info(f"Successfully saved {len(self.data_frame)} messages to {output_path}")
except IOError as e:
raise IOError(f"Error saving to file: {e}")
def read_chat(self) -&gt; None:
"""Reads the chat data from the file with proper encoding handling.
Raises:
IOError: If there are issues reading the file
"""
try:
with open(self.file_path, 'r', encoding=self.config['output_encoding'], errors='ignore') as file:
self.chat_data = file.read()
if not self.chat_data.strip():
raise ValueError("The chat file is empty")
self.logger.info(f"Successfully read chat file: {self.file_path}")
except IOError as e:
raise IOError(f"Error reading chat file: {e}")
def main():
try:
# Example configuration
config = {
'preserve_emoji': True,
'remove_system_messages': True,
'normalize_whitespace': True
}
processor = WhatsAppDataProcessor('chat.txt', config)
processor.read_chat()
processor.parse_chat()
processor.save_to_file()
except Exception as e:
logging.error(f"Error processing chat: {e}")
if __name__ == "__main__":
main()&lt;/code&gt;&lt;/section&gt;

</content></sender></time></date></Media></code></section>

      </div>
    </article>
    <nav class="post-navigation" aria-label="Post navigation">
      
      <div class="nav-arrow prev">
        <a href="/ordenamento/" title="Ordenamento Jurídico Brasileiro [redução eidética]" rel="prev">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ/lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
        </a>
      </div>
      
      
      <div class="nav-arrow next">
        <a href="/stf-scraper/" title="STF Scraper [script]" rel="next">
          <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
        </a>
      </div>
      
    </nav>    
    
    <div class="comment-box">
      Reference:
      <a href="https://github.com/chris18369/Whatsappdata" title="https://github.com/chris18369/Whatsappdata">https://github.com/chris18369/Whatsappdata</a>
    </div>
        
  </main>
  <footer class="site-footer">
      <p>
        
        
        
        2024-10-15 14:59:49
        <a href="/" aria-label="Homepage">
          &#8505; infoBAG
        </a>
        <a href="#" aria-label="Back to top">
          <img src="/assets/Rope_(Old).gif" alt="Back to top" width="32" height="32" loading="lazy">
        </a>
      </p>
    </footer>
</body>
</html>
