<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        WhatsapPY data - infoBAG
      
    </title>
    <meta name="title" content="WhatsapPY data - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/whatsappy/">
    <meta property="og:title" content="WhatsapPY data - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/whatsappy/">
    <meta name="twitter:title" content="WhatsapPY data - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/whatsappy/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scripts">
      
        <meta property="article:tag" content="scripts">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          WhatsapPY data
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2024-04-28T00:00:00+00:00" class="post-date">
          28 Apr 2024
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-02-01T21:29:53+00:00">
              01 Feb 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/whatsappy" class="tag">whatsappy</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scripts" class="tag">scripts</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        11806 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        924 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-04-28-whatsappy.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-04-28-whatsappy.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          

          <section class="code-block-container" role="group" aria-label="Python Code Block" data-filename="python_code_block.py" data-code="import pandas as pd
import re
from typing import List, Tuple, Optional, Dict, Any
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime, time
import logging
from enum import Enum

class MessageType(Enum):
    TEXT = &quot;text&quot;
    MEDIA = &quot;media&quot;
    SYSTEM = &quot;system&quot;

@dataclass
class Message:
    date: datetime
    time: time
    sender: str
    content: str
    type: MessageType

class WhatsAppDataProcessor:
    def __init__(self, file_path: str, config: Optional[Dict[str, Any]] = None):
        &quot;&quot;&quot;Initialize the WhatsApp chat processor with optional configuration.
        
        Args:
            file_path: Path to the WhatsApp chat export file
            config: Optional configuration dictionary with processing settings
        
        Raises:
            FileNotFoundError: If the specified file doesn&#39;t exist
        &quot;&quot;&quot;
        self.file_path = Path(file_path)
        if not self.file_path.exists():
            raise FileNotFoundError(f&quot;Chat file not found: {file_path}&quot;)
        
        # Default configuration
        self.config = {
            &#39;max_line_length&#39;: 32767,  # Excel&#39;s maximum cell content length
            &#39;preserve_emoji&#39;: True,
            &#39;remove_system_messages&#39;: False,
            &#39;date_format&#39;: &#39;%d/%m/%y&#39;,
            &#39;time_format&#39;: &#39;%H:%M:%S&#39;,
            &#39;output_encoding&#39;: &#39;utf-8&#39;,
            &#39;normalize_whitespace&#39;: True
        }
        if config:
            self.config.update(config)
            
        self.chat_data: Optional[str] = None
        self.data_frame: Optional[pd.DataFrame] = None
        
        # Set up logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    def _is_system_message(self, sender: str, content: str) -&gt; bool:
        &quot;&quot;&quot;Detect if a message is a system message.
        
        Args:
            sender: Message sender
            content: Message content
            
        Returns:
            bool indicating if the message is a system message
        &quot;&quot;&quot;
        system_patterns = [
            r&quot;changed the subject to&quot;,
            r&quot;added \d&quot;,
            r&quot;left$&quot;,
            r&quot;changed this group&#39;s icon&quot;,
            r&quot;Messages and calls are end-to-end encrypted&quot;,
        ]
        return any(re.search(pattern, content) for pattern in system_patterns)

    def _normalize_message(self, message: str) -&gt; str:
        &quot;&quot;&quot;Normalize a message by converting newlines and handling special characters.
        
        Args:
            message: The raw message text
            
        Returns:
            Normalized message as a single line
        &quot;&quot;&quot;
        if not self.config[&#39;normalize_whitespace&#39;]:
            return message
            
        # Preserve emojis if configured
        if self.config[&#39;preserve_emoji&#39;]:
            # Convert emojis to temporary placeholders
            emoji_pattern = r&#39;[\U0001F000-\U0001F999]&#39;
            emojis = re.finditer(emoji_pattern, message)
            emoji_map = {m.group(): f&quot;__EMOJI_{i}__&quot; for i, m in enumerate(emojis)}
            for emoji, placeholder in emoji_map.items():
                message = message.replace(emoji, placeholder)
        
        # Normalize whitespace and newlines
        message = re.sub(r&#39;\r\n|\r|\n&#39;, &#39; &#39;, message)
        message = re.sub(r&#39;\s+&#39;, &#39; &#39;, message)
        message = message.strip()
        
        # Restore emojis if they were preserved
        if self.config[&#39;preserve_emoji&#39;]:
            for emoji, placeholder in emoji_map.items():
                message = message.replace(placeholder, emoji)
        
        # Truncate if exceeds max length
        if len(message) &gt; self.config[&#39;max_line_length&#39;]:
            message = message[:self.config[&#39;max_line_length&#39;]-3] + &quot;...&quot;
            
        return message

    def _detect_message_type(self, content: str) -&gt; MessageType:
        &quot;&quot;&quot;Detect the type of message based on its content.
        
        Args:
            content: Message content
            
        Returns:
            MessageType enum value
        &quot;&quot;&quot;
        media_patterns = [
            r&#39;&lt;Media omitted&gt;&#39;,
            r&#39;image omitted&#39;,
            r&#39;video omitted&#39;,
            r&#39;audio omitted&#39;,
            r&#39;document omitted&#39;,
            r&#39;sticker omitted&#39;,
            r&#39;GIF omitted&#39;
        ]
        
        if any(re.search(pattern, content, re.IGNORECASE) for pattern in media_patterns):
            return MessageType.MEDIA
            
        return MessageType.TEXT

    def _process_message_chunk(self, chunk: List[Tuple[str, str, str, str]]) -&gt; Optional[Message]:
        &quot;&quot;&quot;Process a chunk of message lines into a single message entry.
        
        Args:
            chunk: List containing the message header and continuation lines
        
        Returns:
            Optional[Message] object containing the processed message data
        &quot;&quot;&quot;
        if not chunk:
            return None
        
        date_str, time_str, sender, first_line = chunk[0]
        continuation_lines = [line[0] for line in chunk[1:]]
        
        # Combine message lines
        full_message = first_line
        if continuation_lines:
            full_message += &#39; &#39; + &#39; &#39;.join(continuation_lines)
            
        # Normalize the message
        normalized_message = self._normalize_message(full_message)
        
        # Convert date and time strings to proper types
        try:
            date = datetime.strptime(date_str, self.config[&#39;date_format&#39;]).date()
            time_obj = datetime.strptime(time_str, self.config[&#39;time_format&#39;]).time()
        except ValueError as e:
            self.logger.warning(f&quot;Date/time parsing error: {e}&quot;)
            return None
            
        # Detect message type
        msg_type = self._detect_message_type(normalized_message)
        
        # Check if it&#39;s a system message
        if self._is_system_message(sender, normalized_message):
            msg_type = MessageType.SYSTEM
            if self.config[&#39;remove_system_messages&#39;]:
                return None
                
        return Message(
            date=date,
            time=time_obj,
            sender=sender.strip(),
            content=normalized_message,
            type=msg_type
        )

    def parse_chat(self) -&gt; None:
        &quot;&quot;&quot;Parses the chat data into structured components.
        
        Raises:
            ValueError: If chat data isn&#39;t loaded or if no valid messages are found
            RuntimeError: If message parsing fails
        &quot;&quot;&quot;
        if self.chat_data is None:
            raise ValueError(&quot;Chat data is not loaded. Please run read_chat() first.&quot;)

        # Enhanced regex pattern for better message header detection
        date_time_pattern = (
            r&#39;^\[(?P&lt;date&gt;\d{2}/\d{2}/\d{2}), (?P&lt;time&gt;\d{2}:\d{2}:\d{2})\] &#39;
            r&#39;(?P&lt;sender&gt;[^:]+): (?P&lt;content&gt;.*?)$&#39;
        )
        
        try:
            lines = [line.strip() for line in self.chat_data.split(&#39;\n&#39;) if line.strip()]
            messages: List[Message] = []
            current_chunk = []
            
            for line in lines:
                match = re.match(date_time_pattern, line)
                if match:
                    # Process previous chunk if it exists
                    if current_chunk:
                        processed_msg = self._process_message_chunk(current_chunk)
                        if processed_msg:
                            messages.append(processed_msg)
                        current_chunk = []
                    
                    # Start new message chunk
                    current_chunk.append(match.groups())
                elif current_chunk:
                    # Add continuation line
                    current_chunk.append([line])

            # Process the final chunk
            if current_chunk:
                processed_msg = self._process_message_chunk(current_chunk)
                if processed_msg:
                    messages.append(processed_msg)

            if not messages:
                raise ValueError(&quot;No valid messages found in the chat data&quot;)

            # Convert messages to DataFrame
            self.data_frame = pd.DataFrame([
                {
                    &#39;Date&#39;: msg.date,
                    &#39;Time&#39;: msg.time,
                    &#39;Sender&#39;: msg.sender,
                    &#39;Message&#39;: msg.content,
                    &#39;Type&#39;: msg.type.value
                }
                for msg in messages
            ])

        except Exception as e:
            raise RuntimeError(f&quot;Error parsing chat data: {e}&quot;)

    def save_to_file(self, output_path: str = &#39;result.csv&#39;) -&gt; None:
        &quot;&quot;&quot;Saves the parsed data to a CSV file with proper encoding and escaping.
        
        Args:
            output_path: Path where the CSV file will be saved
        
        Raises:
            ValueError: If data frame is not created
            IOError: If there are issues saving the file
        &quot;&quot;&quot;
        if self.data_frame is None:
            raise ValueError(&quot;Data frame is not created. Please run parse_chat() first.&quot;)
            
        try:
            self.data_frame.to_csv(
                output_path,
                index=False,
                sep=&#39;\t&#39;,
                encoding=self.config[&#39;output_encoding&#39;],
                quoting=1,  # Quote all non-numeric fields
                escapechar=&#39;\\&#39;,  # Use backslash as escape character
                date_format=&#39;%Y-%m-%d&#39;  # ISO format for dates
            )
            self.logger.info(f&quot;Successfully saved {len(self.data_frame)} messages to {output_path}&quot;)
        except IOError as e:
            raise IOError(f&quot;Error saving to file: {e}&quot;)

    def read_chat(self) -&gt; None:
        &quot;&quot;&quot;Reads the chat data from the file with proper encoding handling.
        
        Raises:
            IOError: If there are issues reading the file
        &quot;&quot;&quot;
        try:
            with open(self.file_path, &#39;r&#39;, encoding=self.config[&#39;output_encoding&#39;], errors=&#39;ignore&#39;) as file:
                self.chat_data = file.read()
            if not self.chat_data.strip():
                raise ValueError(&quot;The chat file is empty&quot;)
            self.logger.info(f&quot;Successfully read chat file: {self.file_path}&quot;)
        except IOError as e:
            raise IOError(f&quot;Error reading chat file: {e}&quot;)

def main():
    try:
        # Example configuration
        config = {
            &#39;preserve_emoji&#39;: True,
            &#39;remove_system_messages&#39;: True,
            &#39;normalize_whitespace&#39;: True
        }
        
        processor = WhatsAppDataProcessor(&#39;chat.txt&#39;, config)
        processor.read_chat()
        processor.parse_chat()
        processor.save_to_file()
        
    except Exception as e:
        logging.error(f&quot;Error processing chat: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()" data-download-link="" data-download-label="Download Python">
  <code class="language-python">import pandas as pd
import re
from typing import List, Tuple, Optional, Dict, Any
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime, time
import logging
from enum import Enum

class MessageType(Enum):
    TEXT = &quot;text&quot;
    MEDIA = &quot;media&quot;
    SYSTEM = &quot;system&quot;

@dataclass
class Message:
    date: datetime
    time: time
    sender: str
    content: str
    type: MessageType

class WhatsAppDataProcessor:
    def __init__(self, file_path: str, config: Optional[Dict[str, Any]] = None):
        &quot;&quot;&quot;Initialize the WhatsApp chat processor with optional configuration.
        
        Args:
            file_path: Path to the WhatsApp chat export file
            config: Optional configuration dictionary with processing settings
        
        Raises:
            FileNotFoundError: If the specified file doesn&#39;t exist
        &quot;&quot;&quot;
        self.file_path = Path(file_path)
        if not self.file_path.exists():
            raise FileNotFoundError(f&quot;Chat file not found: {file_path}&quot;)
        
        # Default configuration
        self.config = {
            &#39;max_line_length&#39;: 32767,  # Excel&#39;s maximum cell content length
            &#39;preserve_emoji&#39;: True,
            &#39;remove_system_messages&#39;: False,
            &#39;date_format&#39;: &#39;%d/%m/%y&#39;,
            &#39;time_format&#39;: &#39;%H:%M:%S&#39;,
            &#39;output_encoding&#39;: &#39;utf-8&#39;,
            &#39;normalize_whitespace&#39;: True
        }
        if config:
            self.config.update(config)
            
        self.chat_data: Optional[str] = None
        self.data_frame: Optional[pd.DataFrame] = None
        
        # Set up logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)

    def _is_system_message(self, sender: str, content: str) -&gt; bool:
        &quot;&quot;&quot;Detect if a message is a system message.
        
        Args:
            sender: Message sender
            content: Message content
            
        Returns:
            bool indicating if the message is a system message
        &quot;&quot;&quot;
        system_patterns = [
            r&quot;changed the subject to&quot;,
            r&quot;added \d&quot;,
            r&quot;left$&quot;,
            r&quot;changed this group&#39;s icon&quot;,
            r&quot;Messages and calls are end-to-end encrypted&quot;,
        ]
        return any(re.search(pattern, content) for pattern in system_patterns)

    def _normalize_message(self, message: str) -&gt; str:
        &quot;&quot;&quot;Normalize a message by converting newlines and handling special characters.
        
        Args:
            message: The raw message text
            
        Returns:
            Normalized message as a single line
        &quot;&quot;&quot;
        if not self.config[&#39;normalize_whitespace&#39;]:
            return message
            
        # Preserve emojis if configured
        if self.config[&#39;preserve_emoji&#39;]:
            # Convert emojis to temporary placeholders
            emoji_pattern = r&#39;[\U0001F000-\U0001F999]&#39;
            emojis = re.finditer(emoji_pattern, message)
            emoji_map = {m.group(): f&quot;__EMOJI_{i}__&quot; for i, m in enumerate(emojis)}
            for emoji, placeholder in emoji_map.items():
                message = message.replace(emoji, placeholder)
        
        # Normalize whitespace and newlines
        message = re.sub(r&#39;\r\n|\r|\n&#39;, &#39; &#39;, message)
        message = re.sub(r&#39;\s+&#39;, &#39; &#39;, message)
        message = message.strip()
        
        # Restore emojis if they were preserved
        if self.config[&#39;preserve_emoji&#39;]:
            for emoji, placeholder in emoji_map.items():
                message = message.replace(placeholder, emoji)
        
        # Truncate if exceeds max length
        if len(message) &gt; self.config[&#39;max_line_length&#39;]:
            message = message[:self.config[&#39;max_line_length&#39;]-3] + &quot;...&quot;
            
        return message

    def _detect_message_type(self, content: str) -&gt; MessageType:
        &quot;&quot;&quot;Detect the type of message based on its content.
        
        Args:
            content: Message content
            
        Returns:
            MessageType enum value
        &quot;&quot;&quot;
        media_patterns = [
            r&#39;&lt;Media omitted&gt;&#39;,
            r&#39;image omitted&#39;,
            r&#39;video omitted&#39;,
            r&#39;audio omitted&#39;,
            r&#39;document omitted&#39;,
            r&#39;sticker omitted&#39;,
            r&#39;GIF omitted&#39;
        ]
        
        if any(re.search(pattern, content, re.IGNORECASE) for pattern in media_patterns):
            return MessageType.MEDIA
            
        return MessageType.TEXT

    def _process_message_chunk(self, chunk: List[Tuple[str, str, str, str]]) -&gt; Optional[Message]:
        &quot;&quot;&quot;Process a chunk of message lines into a single message entry.
        
        Args:
            chunk: List containing the message header and continuation lines
        
        Returns:
            Optional[Message] object containing the processed message data
        &quot;&quot;&quot;
        if not chunk:
            return None
        
        date_str, time_str, sender, first_line = chunk[0]
        continuation_lines = [line[0] for line in chunk[1:]]
        
        # Combine message lines
        full_message = first_line
        if continuation_lines:
            full_message += &#39; &#39; + &#39; &#39;.join(continuation_lines)
            
        # Normalize the message
        normalized_message = self._normalize_message(full_message)
        
        # Convert date and time strings to proper types
        try:
            date = datetime.strptime(date_str, self.config[&#39;date_format&#39;]).date()
            time_obj = datetime.strptime(time_str, self.config[&#39;time_format&#39;]).time()
        except ValueError as e:
            self.logger.warning(f&quot;Date/time parsing error: {e}&quot;)
            return None
            
        # Detect message type
        msg_type = self._detect_message_type(normalized_message)
        
        # Check if it&#39;s a system message
        if self._is_system_message(sender, normalized_message):
            msg_type = MessageType.SYSTEM
            if self.config[&#39;remove_system_messages&#39;]:
                return None
                
        return Message(
            date=date,
            time=time_obj,
            sender=sender.strip(),
            content=normalized_message,
            type=msg_type
        )

    def parse_chat(self) -&gt; None:
        &quot;&quot;&quot;Parses the chat data into structured components.
        
        Raises:
            ValueError: If chat data isn&#39;t loaded or if no valid messages are found
            RuntimeError: If message parsing fails
        &quot;&quot;&quot;
        if self.chat_data is None:
            raise ValueError(&quot;Chat data is not loaded. Please run read_chat() first.&quot;)

        # Enhanced regex pattern for better message header detection
        date_time_pattern = (
            r&#39;^\[(?P&lt;date&gt;\d{2}/\d{2}/\d{2}), (?P&lt;time&gt;\d{2}:\d{2}:\d{2})\] &#39;
            r&#39;(?P&lt;sender&gt;[^:]+): (?P&lt;content&gt;.*?)$&#39;
        )
        
        try:
            lines = [line.strip() for line in self.chat_data.split(&#39;\n&#39;) if line.strip()]
            messages: List[Message] = []
            current_chunk = []
            
            for line in lines:
                match = re.match(date_time_pattern, line)
                if match:
                    # Process previous chunk if it exists
                    if current_chunk:
                        processed_msg = self._process_message_chunk(current_chunk)
                        if processed_msg:
                            messages.append(processed_msg)
                        current_chunk = []
                    
                    # Start new message chunk
                    current_chunk.append(match.groups())
                elif current_chunk:
                    # Add continuation line
                    current_chunk.append([line])

            # Process the final chunk
            if current_chunk:
                processed_msg = self._process_message_chunk(current_chunk)
                if processed_msg:
                    messages.append(processed_msg)

            if not messages:
                raise ValueError(&quot;No valid messages found in the chat data&quot;)

            # Convert messages to DataFrame
            self.data_frame = pd.DataFrame([
                {
                    &#39;Date&#39;: msg.date,
                    &#39;Time&#39;: msg.time,
                    &#39;Sender&#39;: msg.sender,
                    &#39;Message&#39;: msg.content,
                    &#39;Type&#39;: msg.type.value
                }
                for msg in messages
            ])

        except Exception as e:
            raise RuntimeError(f&quot;Error parsing chat data: {e}&quot;)

    def save_to_file(self, output_path: str = &#39;result.csv&#39;) -&gt; None:
        &quot;&quot;&quot;Saves the parsed data to a CSV file with proper encoding and escaping.
        
        Args:
            output_path: Path where the CSV file will be saved
        
        Raises:
            ValueError: If data frame is not created
            IOError: If there are issues saving the file
        &quot;&quot;&quot;
        if self.data_frame is None:
            raise ValueError(&quot;Data frame is not created. Please run parse_chat() first.&quot;)
            
        try:
            self.data_frame.to_csv(
                output_path,
                index=False,
                sep=&#39;\t&#39;,
                encoding=self.config[&#39;output_encoding&#39;],
                quoting=1,  # Quote all non-numeric fields
                escapechar=&#39;\\&#39;,  # Use backslash as escape character
                date_format=&#39;%Y-%m-%d&#39;  # ISO format for dates
            )
            self.logger.info(f&quot;Successfully saved {len(self.data_frame)} messages to {output_path}&quot;)
        except IOError as e:
            raise IOError(f&quot;Error saving to file: {e}&quot;)

    def read_chat(self) -&gt; None:
        &quot;&quot;&quot;Reads the chat data from the file with proper encoding handling.
        
        Raises:
            IOError: If there are issues reading the file
        &quot;&quot;&quot;
        try:
            with open(self.file_path, &#39;r&#39;, encoding=self.config[&#39;output_encoding&#39;], errors=&#39;ignore&#39;) as file:
                self.chat_data = file.read()
            if not self.chat_data.strip():
                raise ValueError(&quot;The chat file is empty&quot;)
            self.logger.info(f&quot;Successfully read chat file: {self.file_path}&quot;)
        except IOError as e:
            raise IOError(f&quot;Error reading chat file: {e}&quot;)

def main():
    try:
        # Example configuration
        config = {
            &#39;preserve_emoji&#39;: True,
            &#39;remove_system_messages&#39;: True,
            &#39;normalize_whitespace&#39;: True
        }
        
        processor = WhatsAppDataProcessor(&#39;chat.txt&#39;, config)
        processor.read_chat()
        processor.parse_chat()
        processor.save_to_file()
        
    except Exception as e:
        logging.error(f&quot;Error processing chat: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main()</code>
</section>

        </div>
        
          URL: https://ib.bsb.br/whatsappy
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/ordenamento/" title="Ordenamento Jurídico Brasileiro [redução eidética]" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/stf-scraper/" title="STF Scraper [script]" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/whisper-splitter/" title="Split `.wav` for Whisper" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="/stf-scraper/" title="STF Scraper [script]" rel="next">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    <div class="comment-box">
      Ref. 
      <a href="https://github.com/chris18369/Whatsappdata" title="https://github.com/chris18369/Whatsappdata">https://github.com/chris18369/Whatsappdata</a>
    </div>
    
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-10-04 22:52:55
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scripts">
                  scripts
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/whatsappy/"
        },
        "headline": "WhatsapPY data",
        "description": "",
        "datePublished": "2024-04-28T00:00:00+00:00",
        "dateModified": "2025-02-01T21:29:53+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
