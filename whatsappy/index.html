<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    
      WhatsapPY data — infoBAG
    
  </title>
  <meta name="title" content="WhatsapPY data">
  <meta name="description" content="can't steer unless already moving">

  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="WhatsapPY data — infoBAG">
  <meta property="og:description" content="can't steer unless already moving">
  <meta property="og:url" content="https://ib.bsb.br/whatsappy/">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="infoBAG">
  

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="WhatsapPY data — infoBAG">
  <meta name="twitter:description" content="can't steer unless already moving">
  

  <link rel="canonical" href="https://ib.bsb.br/whatsappy/">
  <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">

  
    <meta name="keywords" content="scripts">
    
      <meta property="article:tag" content="scripts">
    
  

  <!-- Favicons and Icons -->
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  

  <link href="/style.css" rel="stylesheet">
</head>
  <body class="post-content-body">
    
    
    
    
        
        
        "<section data-filename="python_code-block.py" data-code="import pandas as pd\n    
        
        
        "import re\n    
        
        
        "from typing import List, Tuple, Optional, Dict, Any\n    
        
        
        "from pathlib import Path\n    
        
        
        "from dataclasses import dataclass\n    
        
        
        "from datetime import datetime, time\n    
        
        
        "import logging\n    
        
        
        "from enum import Enum\n    
        
        
        "class MessageType(Enum):\n    
        
        
        "TEXT = &quot;text&quot;\n    
        
        
        "MEDIA = &quot;media&quot;\n    
        
        
        "SYSTEM = &quot;system&quot;\n    
        
        
        "@dataclass\n    
        
        
        "class Message:\n    
        
        
        "date: datetime\n    
        
        
        "time: time\n    
        
        
        "sender: str\n    
        
        
        "content: str\n    
        
        
        "type: MessageType\n    
        
        
        "class WhatsAppDataProcessor:\n    
        
        
        "def __init__(self, file_path: str, config: Optional[Dict[str, Any]] = None):\n    
        
        
        "&quot;&quot;&quot;Initialize the WhatsApp chat processor with optional configuration.\n    
        
        
        "Args:\n    
        
        
        "file_path: Path to the WhatsApp chat export file\n    
        
        
        "config: Optional configuration dictionary with processing settings\n    
        
        
        "Raises:\n    
        
        
        "FileNotFoundError: If the specified file doesn't exist\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "self.file_path = Path(file_path)\n    
        
        
        "if not self.file_path.exists():\n    
        
        
        "raise FileNotFoundError(f&quot;Chat file not found: {file_path}&quot;)\n    
        
        
        "# Default configuration\n    
        
        
        "self.config = {\n    
        
        
        "'max_line_length': 32767,  # Excel's maximum cell content length\n    
        
        
        "'preserve_emoji': True,\n    
        
        
        "'remove_system_messages': False,\n    
        
        
        "'date_format': '%d/%m/%y',\n    
        
        
        "'time_format': '%H:%M:%S',\n    
        
        
        "'output_encoding': 'utf-8',\n    
        
        
        "'normalize_whitespace': True\n    
        
        
        "}\n    
        
        
        "if config:\n    
        
        
        "self.config.update(config)\n    
        
        
        "self.chat_data: Optional[str] = None\n    
        
        
        "self.data_frame: Optional[pd.DataFrame] = None\n    
        
        
        "# Set up logging\n    
        
        
        "logging.basicConfig(level=logging.INFO)\n    
        
        
        "self.logger = logging.getLogger(__name__)\n    
        
        
        "def _is_system_message(self, sender: str, content: str) -&gt; bool:\n    
        
        
        "&quot;&quot;&quot;Detect if a message is a system message.\n    
        
        
        "Args:\n    
        
        
        "sender: Message sender\n    
        
        
        "content: Message content\n    
        
        
        "Returns:\n    
        
        
        "bool indicating if the message is a system message\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "system_patterns = [\n    
        
        
        "r&quot;changed the subject to&quot;,\n    
        
        
        "r&quot;added \d&quot;,\n    
        
        
        "r&quot;left$&quot;,\n    
        
        
        "r&quot;changed this group's icon&quot;,\n    
        
        
        "r&quot;Messages and calls are end-to-end encrypted&quot;,\n    
        
        
        "]\n    
        
        
        "return any(re.search(pattern, content) for pattern in system_patterns)\n    
        
        
        "def _normalize_message(self, message: str) -&gt; str:\n    
        
        
        "&quot;&quot;&quot;Normalize a message by converting newlines and handling special characters.\n    
        
        
        "Args:\n    
        
        
        "message: The raw message text\n    
        
        
        "Returns:\n    
        
        
        "Normalized message as a single line\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "if not self.config['normalize_whitespace']:\n    
        
        
        "return message\n    
        
        
        "# Preserve emojis if configured\n    
        
        
        "if self.config['preserve_emoji']:\n    
        
        
        "# Convert emojis to temporary placeholders\n    
        
        
        "emoji_pattern = r'[\U0001F000-\U0001F999]'\n    
        
        
        "emojis = re.finditer(emoji_pattern, message)\n    
        
        
        "emoji_map = {m.group(): f&quot;__EMOJI_{i}__&quot; for i, m in enumerate(emojis)}\n    
        
        
        "for emoji, placeholder in emoji_map.items():\n    
        
        
        "message = message.replace(emoji, placeholder)\n    
        
        
        "# Normalize whitespace and newlines\n    
        
        
        "message = re.sub(r'\r\n|\r|\n', ' ', message)\n    
        
        
        "message = re.sub(r'\s+', ' ', message)\n    
        
        
        "message = message.strip()\n    
        
        
        "# Restore emojis if they were preserved\n    
        
        
        "if self.config['preserve_emoji']:\n    
        
        
        "for emoji, placeholder in emoji_map.items():\n    
        
        
        "message = message.replace(placeholder, emoji)\n    
        
        
        "# Truncate if exceeds max length\n    
        
        
        "if len(message) &gt; self.config['max_line_length']:\n    
        
        
        "message = message[:self.config['max_line_length']-3] + &quot;...&quot;\n    
        
        
        "return message\n    
        
        
        "def _detect_message_type(self, content: str) -&gt; MessageType:\n    
        
        
        "&quot;&quot;&quot;Detect the type of message based on its content.\n    
        
        
        "Args:\n    
        
        
        "content: Message content\n    
        
        
        "Returns:\n    
        
        
        "MessageType enum value\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "media_patterns = [\n    
        
        
        "r'&lt;Media omitted&gt;',\n    
        
        
        "r'image omitted',\n    
        
        
        "r'video omitted',\n    
        
        
        "r'audio omitted',\n    
        
        
        "r'document omitted',\n    
        
        
        "r'sticker omitted',\n    
        
        
        "r'GIF omitted'\n    
        
        
        "]\n    
        
        
        "if any(re.search(pattern, content, re.IGNORECASE) for pattern in media_patterns):\n    
        
        
        "return MessageType.MEDIA\n    
        
        
        "return MessageType.TEXT\n    
        
        
        "def _process_message_chunk(self, chunk: List[Tuple[str, str, str, str]]) -&gt; Optional[Message]:\n    
        
        
        "&quot;&quot;&quot;Process a chunk of message lines into a single message entry.\n    
        
        
        "Args:\n    
        
        
        "chunk: List containing the message header and continuation lines\n    
        
        
        "Returns:\n    
        
        
        "Optional[Message] object containing the processed message data\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "if not chunk:\n    
        
        
        "return None\n    
        
        
        "date_str, time_str, sender, first_line = chunk[0]\n    
        
        
        "continuation_lines = [line[0] for line in chunk[1:]]\n    
        
        
        "# Combine message lines\n    
        
        
        "full_message = first_line\n    
        
        
        "if continuation_lines:\n    
        
        
        "full_message += ' ' + ' '.join(continuation_lines)\n    
        
        
        "# Normalize the message\n    
        
        
        "normalized_message = self._normalize_message(full_message)\n    
        
        
        "# Convert date and time strings to proper types\n    
        
        
        "try:\n    
        
        
        "date = datetime.strptime(date_str, self.config['date_format']).date()\n    
        
        
        "time_obj = datetime.strptime(time_str, self.config['time_format']).time()\n    
        
        
        "except ValueError as e:\n    
        
        
        "self.logger.warning(f&quot;Date/time parsing error: {e}&quot;)\n    
        
        
        "return None\n    
        
        
        "# Detect message type\n    
        
        
        "msg_type = self._detect_message_type(normalized_message)\n    
        
        
        "# Check if it's a system message\n    
        
        
        "if self._is_system_message(sender, normalized_message):\n    
        
        
        "msg_type = MessageType.SYSTEM\n    
        
        
        "if self.config['remove_system_messages']:\n    
        
        
        "return None\n    
        
        
        "return Message(\n    
        
        
        "date=date,\n    
        
        
        "time=time_obj,\n    
        
        
        "sender=sender.strip(),\n    
        
        
        "content=normalized_message,\n    
        
        
        "type=msg_type\n    
        
        
        ")\n    
        
        
        "def parse_chat(self) -&gt; None:\n    
        
        
        "&quot;&quot;&quot;Parses the chat data into structured components.\n    
        
        
        "Raises:\n    
        
        
        "ValueError: If chat data isn't loaded or if no valid messages are found\n    
        
        
        "RuntimeError: If message parsing fails\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "if self.chat_data is None:\n    
        
        
        "raise ValueError(&quot;Chat data is not loaded. Please run read_chat() first.&quot;)\n    
        
        
        "# Enhanced regex pattern for better message header detection\n    
        
        
        "date_time_pattern = (\n    
        
        
        "r'^\[(?P&lt;date&gt;\d{2}/\d{2}/\d{2}), (?P&lt;time&gt;\d{2}:\d{2}:\d{2})\] '\n    
        
        
        "r'(?P&lt;sender&gt;[^:]+): (?P&lt;content&gt;.*?)$'\n    
        
        
        ")\n    
        
        
        "try:\n    
        
        
        "lines = [line.strip() for line in self.chat_data.split('\n') if line.strip()]\n    
        
        
        "messages: List[Message] = []\n    
        
        
        "current_chunk = []\n    
        
        
        "for line in lines:\n    
        
        
        "match = re.match(date_time_pattern, line)\n    
        
        
        "if match:\n    
        
        
        "# Process previous chunk if it exists\n    
        
        
        "if current_chunk:\n    
        
        
        "processed_msg = self._process_message_chunk(current_chunk)\n    
        
        
        "if processed_msg:\n    
        
        
        "messages.append(processed_msg)\n    
        
        
        "current_chunk = []\n    
        
        
        "# Start new message chunk\n    
        
        
        "current_chunk.append(match.groups())\n    
        
        
        "elif current_chunk:\n    
        
        
        "# Add continuation line\n    
        
        
        "current_chunk.append([line])\n    
        
        
        "# Process the final chunk\n    
        
        
        "if current_chunk:\n    
        
        
        "processed_msg = self._process_message_chunk(current_chunk)\n    
        
        
        "if processed_msg:\n    
        
        
        "messages.append(processed_msg)\n    
        
        
        "if not messages:\n    
        
        
        "raise ValueError(&quot;No valid messages found in the chat data&quot;)\n    
        
        
        "# Convert messages to DataFrame\n    
        
        
        "self.data_frame = pd.DataFrame([\n    
        
        
        "{\n    
        
        
        "'Date': msg.date,\n    
        
        
        "'Time': msg.time,\n    
        
        
        "'Sender': msg.sender,\n    
        
        
        "'Message': msg.content,\n    
        
        
        "'Type': msg.type.value\n    
        
        
        "}\n    
        
        
        "for msg in messages\n    
        
        
        "])\n    
        
        
        "except Exception as e:\n    
        
        
        "raise RuntimeError(f&quot;Error parsing chat data: {e}&quot;)\n    
        
        
        "def save_to_file(self, output_path: str = 'result.csv') -&gt; None:\n    
        
        
        "&quot;&quot;&quot;Saves the parsed data to a CSV file with proper encoding and escaping.\n    
        
        
        "Args:\n    
        
        
        "output_path: Path where the CSV file will be saved\n    
        
        
        "Raises:\n    
        
        
        "ValueError: If data frame is not created\n    
        
        
        "IOError: If there are issues saving the file\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "if self.data_frame is None:\n    
        
        
        "raise ValueError(&quot;Data frame is not created. Please run parse_chat() first.&quot;)\n    
        
        
        "try:\n    
        
        
        "self.data_frame.to_csv(\n    
        
        
        "output_path,\n    
        
        
        "index=False,\n    
        
        
        "sep='\t',\n    
        
        
        "encoding=self.config['output_encoding'],\n    
        
        
        "quoting=1,  # Quote all non-numeric fields\n    
        
        
        "escapechar='\\',  # Use backslash as escape character\n    
        
        
        "date_format='%Y-%m-%d'  # ISO format for dates\n    
        
        
        ")\n    
        
        
        "self.logger.info(f&quot;Successfully saved {len(self.data_frame)} messages to {output_path}&quot;)\n    
        
        
        "except IOError as e:\n    
        
        
        "raise IOError(f&quot;Error saving to file: {e}&quot;)\n    
        
        
        "def read_chat(self) -&gt; None:\n    
        
        
        "&quot;&quot;&quot;Reads the chat data from the file with proper encoding handling.\n    
        
        
        "Raises:\n    
        
        
        "IOError: If there are issues reading the file\n    
        
        
        "&quot;&quot;&quot;\n    
        
        
        "try:\n    
        
        
        "with open(self.file_path, 'r', encoding=self.config['output_encoding'], errors='ignore') as file:\n    
        
        
        "self.chat_data = file.read()\n    
        
        
        "if not self.chat_data.strip():\n    
        
        
        "raise ValueError(&quot;The chat file is empty&quot;)\n    
        
        
        "self.logger.info(f&quot;Successfully read chat file: {self.file_path}&quot;)\n    
        
        
        "except IOError as e:\n    
        
        
        "raise IOError(f&quot;Error reading chat file: {e}&quot;)\n    
        
        
        "def main():\n    
        
        
        "try:\n    
        
        
        "# Example configuration\n    
        
        
        "config = {\n    
        
        
        "'preserve_emoji': True,\n    
        
        
        "'remove_system_messages': True,\n    
        
        
        "'normalize_whitespace': True\n    
        
        
        "}\n    
        
        
        "processor = WhatsAppDataProcessor('chat.txt', config)\n    
        
        
        "processor.read_chat()\n    
        
        
        "processor.parse_chat()\n    
        
        
        "processor.save_to_file()\n    
        
        
        "except Exception as e:\n    
        
        
        "logging.error(f&quot;Error processing chat: {e}&quot;)\n    
        
        
        "if __name__ == &quot;__main__&quot;:\n    
        
        
        "main()" data-download-link="" data-download-link-label="Download Python"><code class="language-python">import pandas as pd\n    
        
        
        "import re\n    
        
        
        "from typing import List, Tuple, Optional, Dict, Any\n    
        
        
        "from pathlib import Path\n    
        
        
        "from dataclasses import dataclass\n    
        
        
        "from datetime import datetime, time\n    
        
        
        "import logging\n    
        
        
        "from enum import Enum\n    
        
        
        "class MessageType(Enum):\n    
        
        
        "TEXT = "text"\n    
        
        
        "MEDIA = "media"\n    
        
        
        "SYSTEM = "system"\n    
        
        
        "@dataclass\n    
        
        
        "class Message:\n    
        
        
        "date: datetime\n    
        
        
        "time: time\n    
        
        
        "sender: str\n    
        
        
        "content: str\n    
        
        
        "type: MessageType\n    
        
        
        "class WhatsAppDataProcessor:\n    
        
        
        "def __init__(self, file_path: str, config: Optional[Dict[str, Any]] = None):\n    
        
        
        """"Initialize the WhatsApp chat processor with optional configuration.\n    
        
        
        "Args:\n    
        
        
        "file_path: Path to the WhatsApp chat export file\n    
        
        
        "config: Optional configuration dictionary with processing settings\n    
        
        
        "Raises:\n    
        
        
        "FileNotFoundError: If the specified file doesn't exist\n    
        
        
        """"\n    
        
        
        "self.file_path = Path(file_path)\n    
        
        
        "if not self.file_path.exists():\n    
        
        
        "raise FileNotFoundError(f"Chat file not found: {file_path}")\n    
        
        
        "# Default configuration\n    
        
        
        "self.config = {\n    
        
        
        "'max_line_length': 32767,  # Excel's maximum cell content length\n    
        
        
        "'preserve_emoji': True,\n    
        
        
        "'remove_system_messages': False,\n    
        
        
        "'date_format': '%d/%m/%y',\n    
        
        
        "'time_format': '%H:%M:%S',\n    
        
        
        "'output_encoding': 'utf-8',\n    
        
        
        "'normalize_whitespace': True\n    
        
        
        "}\n    
        
        
        "if config:\n    
        
        
        "self.config.update(config)\n    
        
        
        "self.chat_data: Optional[str] = None\n    
        
        
        "self.data_frame: Optional[pd.DataFrame] = None\n    
        
        
        "# Set up logging\n    
        
        
        "logging.basicConfig(level=logging.INFO)\n    
        
        
        "self.logger = logging.getLogger(__name__)\n    
        
        
        "def _is_system_message(self, sender: str, content: str) -&gt; bool:\n    
        
        
        """"Detect if a message is a system message.\n    
        
        
        "Args:\n    
        
        
        "sender: Message sender\n    
        
        
        "content: Message content\n    
        
        
        "Returns:\n    
        
        
        "bool indicating if the message is a system message\n    
        
        
        """"\n    
        
        
        "system_patterns = [\n    
        
        
        "r"changed the subject to",\n    
        
        
        "r"added \d",\n    
        
        
        "r"left$",\n    
        
        
        "r"changed this group's icon",\n    
        
        
        "r"Messages and calls are end-to-end encrypted",\n    
        
        
        "]\n    
        
        
        "return any(re.search(pattern, content) for pattern in system_patterns)\n    
        
        
        "def _normalize_message(self, message: str) -&gt; str:\n    
        
        
        """"Normalize a message by converting newlines and handling special characters.\n    
        
        
        "Args:\n    
        
        
        "message: The raw message text\n    
        
        
        "Returns:\n    
        
        
        "Normalized message as a single line\n    
        
        
        """"\n    
        
        
        "if not self.config['normalize_whitespace']:\n    
        
        
        "return message\n    
        
        
        "# Preserve emojis if configured\n    
        
        
        "if self.config['preserve_emoji']:\n    
        
        
        "# Convert emojis to temporary placeholders\n    
        
        
        "emoji_pattern = r'[\U0001F000-\U0001F999]'\n    
        
        
        "emojis = re.finditer(emoji_pattern, message)\n    
        
        
        "emoji_map = {m.group(): f"__EMOJI_{i}__" for i, m in enumerate(emojis)}\n    
        
        
        "for emoji, placeholder in emoji_map.items():\n    
        
        
        "message = message.replace(emoji, placeholder)\n    
        
        
        "# Normalize whitespace and newlines\n    
        
        
        "message = re.sub(r'\r\n|\r|\n', ' ', message)\n    
        
        
        "message = re.sub(r'\s+', ' ', message)\n    
        
        
        "message = message.strip()\n    
        
        
        "# Restore emojis if they were preserved\n    
        
        
        "if self.config['preserve_emoji']:\n    
        
        
        "for emoji, placeholder in emoji_map.items():\n    
        
        
        "message = message.replace(placeholder, emoji)\n    
        
        
        "# Truncate if exceeds max length\n    
        
        
        "if len(message) &gt; self.config['max_line_length']:\n    
        
        
        "message = message[:self.config['max_line_length']-3] + "..."\n    
        
        
        "return message\n    
        
        
        "def _detect_message_type(self, content: str) -&gt; MessageType:\n    
        
        
        """"Detect the type of message based on its content.\n    
        
        
        "Args:\n    
        
        
        "content: Message content\n    
        
        
        "Returns:\n    
        
        
        "MessageType enum value\n    
        
        
        """"\n    
        
        
        "media_patterns = [\n    
        
        
        "r'<Media omitted="">',\n    
        
        
        "r'image omitted',\n    
        
        
        "r'video omitted',\n    
        
        
        "r'audio omitted',\n    
        
        
        "r'document omitted',\n    
        
        
        "r'sticker omitted',\n    
        
        
        "r'GIF omitted'\n    
        
        
        "]\n    
        
        
        "if any(re.search(pattern, content, re.IGNORECASE) for pattern in media_patterns):\n    
        
        
        "return MessageType.MEDIA\n    
        
        
        "return MessageType.TEXT\n    
        
        
        "def _process_message_chunk(self, chunk: List[Tuple[str, str, str, str]]) -&gt; Optional[Message]:\n    
        
        
        """"Process a chunk of message lines into a single message entry.\n    
        
        
        "Args:\n    
        
        
        "chunk: List containing the message header and continuation lines\n    
        
        
        "Returns:\n    
        
        
        "Optional[Message] object containing the processed message data\n    
        
        
        """"\n    
        
        
        "if not chunk:\n    
        
        
        "return None\n    
        
        
        "date_str, time_str, sender, first_line = chunk[0]\n    
        
        
        "continuation_lines = [line[0] for line in chunk[1:]]\n    
        
        
        "# Combine message lines\n    
        
        
        "full_message = first_line\n    
        
        
        "if continuation_lines:\n    
        
        
        "full_message += ' ' + ' '.join(continuation_lines)\n    
        
        
        "# Normalize the message\n    
        
        
        "normalized_message = self._normalize_message(full_message)\n    
        
        
        "# Convert date and time strings to proper types\n    
        
        
        "try:\n    
        
        
        "date = datetime.strptime(date_str, self.config['date_format']).date()\n    
        
        
        "time_obj = datetime.strptime(time_str, self.config['time_format']).time()\n    
        
        
        "except ValueError as e:\n    
        
        
        "self.logger.warning(f"Date/time parsing error: {e}")\n    
        
        
        "return None\n    
        
        
        "# Detect message type\n    
        
        
        "msg_type = self._detect_message_type(normalized_message)\n    
        
        
        "# Check if it's a system message\n    
        
        
        "if self._is_system_message(sender, normalized_message):\n    
        
        
        "msg_type = MessageType.SYSTEM\n    
        
        
        "if self.config['remove_system_messages']:\n    
        
        
        "return None\n    
        
        
        "return Message(\n    
        
        
        "date=date,\n    
        
        
        "time=time_obj,\n    
        
        
        "sender=sender.strip(),\n    
        
        
        "content=normalized_message,\n    
        
        
        "type=msg_type\n    
        
        
        ")\n    
        
        
        "def parse_chat(self) -&gt; None:\n    
        
        
        """"Parses the chat data into structured components.\n    
        
        
        "Raises:\n    
        
        
        "ValueError: If chat data isn't loaded or if no valid messages are found\n    
        
        
        "RuntimeError: If message parsing fails\n    
        
        
        """"\n    
        
        
        "if self.chat_data is None:\n    
        
        
        "raise ValueError("Chat data is not loaded. Please run read_chat() first.")\n    
        
        
        "# Enhanced regex pattern for better message header detection\n    
        
        
        "date_time_pattern = (\n    
        
        
        "r'^\[(?P<date>\d{2}/\d{2}/\d{2}), (?P<time>\d{2}:\d{2}:\d{2})\] '\n    
        
        
        "r'(?P<sender>[^:]+): (?P<content>.*?)$'\n    
        
        
        ")\n    
        
        
        "try:\n    
        
        
        "lines = [line.strip() for line in self.chat_data.split('\n') if line.strip()]\n    
        
        
        "messages: List[Message] = []\n    
        
        
        "current_chunk = []\n    
        
        
        "for line in lines:\n    
        
        
        "match = re.match(date_time_pattern, line)\n    
        
        
        "if match:\n    
        
        
        "# Process previous chunk if it exists\n    
        
        
        "if current_chunk:\n    
        
        
        "processed_msg = self._process_message_chunk(current_chunk)\n    
        
        
        "if processed_msg:\n    
        
        
        "messages.append(processed_msg)\n    
        
        
        "current_chunk = []\n    
        
        
        "# Start new message chunk\n    
        
        
        "current_chunk.append(match.groups())\n    
        
        
        "elif current_chunk:\n    
        
        
        "# Add continuation line\n    
        
        
        "current_chunk.append([line])\n    
        
        
        "# Process the final chunk\n    
        
        
        "if current_chunk:\n    
        
        
        "processed_msg = self._process_message_chunk(current_chunk)\n    
        
        
        "if processed_msg:\n    
        
        
        "messages.append(processed_msg)\n    
        
        
        "if not messages:\n    
        
        
        "raise ValueError("No valid messages found in the chat data")\n    
        
        
        "# Convert messages to DataFrame\n    
        
        
        "self.data_frame = pd.DataFrame([\n    
        
        
        "{\n    
        
        
        "'Date': msg.date,\n    
        
        
        "'Time': msg.time,\n    
        
        
        "'Sender': msg.sender,\n    
        
        
        "'Message': msg.content,\n    
        
        
        "'Type': msg.type.value\n    
        
        
        "}\n    
        
        
        "for msg in messages\n    
        
        
        "])\n    
        
        
        "except Exception as e:\n    
        
        
        "raise RuntimeError(f"Error parsing chat data: {e}")\n    
        
        
        "def save_to_file(self, output_path: str = 'result.csv') -&gt; None:\n    
        
        
        """"Saves the parsed data to a CSV file with proper encoding and escaping.\n    
        
        
        "Args:\n    
        
        
        "output_path: Path where the CSV file will be saved\n    
        
        
        "Raises:\n    
        
        
        "ValueError: If data frame is not created\n    
        
        
        "IOError: If there are issues saving the file\n    
        
        
        """"\n    
        
        
        "if self.data_frame is None:\n    
        
        
        "raise ValueError("Data frame is not created. Please run parse_chat() first.")\n    
        
        
        "try:\n    
        
        
        "self.data_frame.to_csv(\n    
        
        
        "output_path,\n    
        
        
        "index=False,\n    
        
        
        "sep='\t',\n    
        
        
        "encoding=self.config['output_encoding'],\n    
        
        
        "quoting=1,  # Quote all non-numeric fields\n    
        
        
        "escapechar='\\',  # Use backslash as escape character\n    
        
        
        "date_format='%Y-%m-%d'  # ISO format for dates\n    
        
        
        ")\n    
        
        
        "self.logger.info(f"Successfully saved {len(self.data_frame)} messages to {output_path}")\n    
        
        
        "except IOError as e:\n    
        
        
        "raise IOError(f"Error saving to file: {e}")\n    
        
        
        "def read_chat(self) -&gt; None:\n    
        
        
        """"Reads the chat data from the file with proper encoding handling.\n    
        
        
        "Raises:\n    
        
        
        "IOError: If there are issues reading the file\n    
        
        
        """"\n    
        
        
        "try:\n    
        
        
        "with open(self.file_path, 'r', encoding=self.config['output_encoding'], errors='ignore') as file:\n    
        
        
        "self.chat_data = file.read()\n    
        
        
        "if not self.chat_data.strip():\n    
        
        
        "raise ValueError("The chat file is empty")\n    
        
        
        "self.logger.info(f"Successfully read chat file: {self.file_path}")\n    
        
        
        "except IOError as e:\n    
        
        
        "raise IOError(f"Error reading chat file: {e}")\n    
        
        
        "def main():\n    
        
        
        "try:\n    
        
        
        "# Example configuration\n    
        
        
        "config = {\n    
        
        
        "'preserve_emoji': True,\n    
        
        
        "'remove_system_messages': True,\n    
        
        
        "'normalize_whitespace': True\n    
        
        
        "}\n    
        
        
        "processor = WhatsAppDataProcessor('chat.txt', config)\n    
        
        
        "processor.read_chat()\n    
        
        
        "processor.parse_chat()\n    
        
        
        "processor.save_to_file()\n    
        
        
        "except Exception as e:\n    
        
        
        "logging.error(f"Error processing chat: {e}")\n    
        
        
        "if __name__ == "__main__":\n    
        
        
        "main()&lt;/code&gt;&lt;/section&gt;\n    
        
        
        "\n    
        
        
        "</content></sender></time></date></Media></code></section>\n    "
  <header class="header-container">
    <nav aria-label="Main navigation" class="header-content">
      <a href="/" aria-label="Home">
        <img src="/favicon.ico" alt="Home" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/tags" aria-label="Tags">
        <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/events" aria-label="Events">
        <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
      <a href="/archive" aria-label="Archive">
        <img src="/assets/Loose_Stone_Pile.gif" alt="Archive" class="favicon search-link" width="45" height="45" loading="lazy">
      </a>
    </nav>
    <h1 class="post-title">WhatsapPY data</h1>
    <div class="post-meta">
      <time datetime="2024-04-28T00:00:00+00:00" class="post-date">
        28 Apr 2024
      </time>
      
        <span class="post-updated">
          ↣
          <time datetime="2024-10-10T14:28:09+00:00">10 Oct 2024</time>
        </span>
      
      
        <p class="post-slug">
          Slug: <a href="https://ib.bsb.br/whatsappy" class="tag">whatsappy</a>
        </p>
      
      
        <p class="post-tags">
          Tags:
          
            <a href="https://ib.bsb.br/tags/#scripts" class="tag">scripts</a>
          
        </p>
      
    </div>
    <div class="post-actions">
      <div class="page-stats mt-3" role="status" aria-label="Page statistics">
        <span class="badge bg-primary">
          16519 characters
        </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
          1854 words
        </span>
      </div>
      <div class="action-buttons d-flex flex-wrap gap-2">
        
          
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-04-28-whatsappy.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                <span class="button-text">Improve this page?</span>
                <span class="info-text">aberto.</span>
              </button>
            </form>
          
          <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-04-28-whatsappy.md"
                method="GET"
                target="_blank"
                rel="noopener noreferrer"
                class="d-inline-block">
            <button type="submit" class="btn btn-danger" aria-label="View page revision history">
              View revision history
            </button>
          </form>
        
      </div>
    </div>
  </header>
  <main class="content">
    <article class="post-wrapper">
      <div class="post-content-body">
        

        

      </div>
      
        URL: https://ib.bsb.br/whatsappy
      
    </article>
    <nav class="post-navigation" aria-label="Post navigation">
      
        <div class="nav-arrow prev">
          <a href="/ordenamento/" title="Ordenamento Jurídico Brasileiro [redução eidética]" rel="prev">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ/lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
          </a>
        </div>
      
      
        <div class="nav-arrow next">
          <a href="/stf-scraper/" title="STF Scraper [script]" rel="next">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
          </a>
        </div>
      
    </nav>
    
    <div class="comment-box">
        Reference: <a href="https://github.com/chris18369/Whatsappdata" title="https://github.com/chris18369/Whatsappdata">https://github.com/chris18369/Whatsappdata</a>
    </div>
    
  </main>
  <footer class="site-footer">
    <p>
      <a href="#" aria-label="Back to top">
        <img src="/assets/Rope_(Old).gif" alt="Back to top" width="32" height="32" loading="lazy">
      </a><a href="https://ib.bsb.br/404" aria-label="404">2024-12-28 18:00:44</a>‎ ⇔‎ <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">ℹ</a>‎ <a href="/" aria-label="Homepage">infoBAG</a>
    </p>
  </footer>
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://ib.bsb.br/whatsappy/"
    },
    "headline": "WhatsapPY data",
    "description": "",
    "datePublished": "2024-04-28T00:00:00+00:00",
    "dateModified": "2024-10-10T14:28:09+00:00",
    "author": {
      "@type": "Person",
      "name": "Author"
    },
    "publisher": {
      "@type": "Organization",
      "name": "infoBAG"
      
    }
    
  }
  </script>
  <script src="/assets/js/prism.js" defer></script>
</body>
</html>
