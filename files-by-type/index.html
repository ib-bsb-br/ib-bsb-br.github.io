<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Organize files by type - infoBAG
      
    </title>
    <meta name="title" content="Organize files by type - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/files-by-type/">
    <meta property="og:title" content="Organize files by type - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/files-by-type/">
    <meta name="twitter:title" content="Organize files by type - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/files-by-type/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scripts&gt;rust,scripts&gt;python">
      
        <meta property="article:tag" content="scripts&gt;rust">
      
        <meta property="article:tag" content="scripts&gt;python">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Organize files by type
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2024-05-30T00:00:00+00:00" class="post-date">
          30 May 2024
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-04-08T10:26:27+00:00">
              08 Apr 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/files-by-type" class="tag">files-by-type</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scripts-rust" class="tag">scripts>rust</a>
            
              <a href="https://ib.bsb.br/tags/#scripts-python" class="tag">scripts>python</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        44854 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        4614 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-05-30-files-by-type.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-05-30-files-by-type.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#building-and-running-the-file-organizer-on-windows">Building and Running the File Organizer on Windows</a><ul><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#creating-the-project">Creating the Project</a></li><li><a href="#building-the-project">Building the Project</a><ul><li><a href="#debug-build-for-development">Debug Build (For Development)</a></li><li><a href="#release-build-for-distribution">Release Build (For Distribution)</a></li></ul></li><li><a href="#running-the-tool">Running the Tool</a><ul><li><a href="#getting-help">Getting Help</a></li><li><a href="#usage-examples">Usage Examples</a><ul><li><a href="#basic-file-organization">Basic File Organization</a></li><li><a href="#moving-files-with-duplicate-handling">Moving Files with Duplicate Handling</a></li><li><a href="#organizing-by-file-extension">Organizing by File Extension</a></li><li><a href="#advanced-configuration">Advanced Configuration</a></li></ul></li></ul></li><li><a href="#common-options-reference">Common Options Reference</a></li><li><a href="#testing-your-installation">Testing Your Installation</a></li><li><a href="#cargotoml">Cargo.toml</a></li><li><a href="#mainrs">main.rs</a></li></ul></li></ul>
          <h1 id="building-and-running-the-file-organizer-on-windows">
    
    
     <a href="#building-and-running-the-file-organizer-on-windows">#</a><a href="#" aria-label="Back to top">Building and Running the File Organizer on Windows</a>
        
    
  </h1>
      
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<p>Before you begin, you need to install Rust:</p>

<ol>
  <li>Visit <a href="https://rustup.rs/">https://rustup.rs/</a> to download the Rust installer</li>
  <li>Run the installer to set up:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">rustc</code> (the compiler)</li>
      <li><code class="language-plaintext highlighter-rouge">cargo</code> (the build tool and package manager)</li>
    </ul>
  </li>
</ol>
  <h2 id="creating-the-project">
    
    
     <a href="#creating-the-project">#</a><a href="#" aria-label="Back to top">Creating the Project</a>
        
    
  </h2>
      

<p>Open a command prompt and run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c"># Create a new Rust project</span>
cargo new file_organizer_rs
<span class="nb">cd </span>file_organizer_rs

<span class="c"># Replace default files with project files</span>
<span class="c"># Replace the contents of Cargo.toml with the provided configuration</span>
<span class="c"># Replace the contents of src/main.rs with the provided source code</span>
</code></section></div></div>
  <h2 id="building-the-project">
    
    
     <a href="#building-the-project">#</a><a href="#" aria-label="Back to top">Building the Project</a>
        
    
  </h2>
      
  <h3 id="debug-build-for-development">
    
    
     <a href="#debug-build-for-development">#</a><a href="#" aria-label="Back to top">Debug Build (For Development)</a>
        
    
  </h3>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo build
</code></section></div></div>

<p>The executable will be created in the <code class="language-plaintext highlighter-rouge">target/debug/</code> directory.</p>
  <h3 id="release-build-for-distribution">
    
    
     <a href="#release-build-for-distribution">#</a><a href="#" aria-label="Back to top">Release Build (For Distribution)</a>
        
    
  </h3>
      

<p>For a smaller, optimized executable:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo build <span class="nt">--release</span>
</code></section></div></div>

<p>The executable will be created in the <code class="language-plaintext highlighter-rouge">target/release/</code> directory.</p>
  <h2 id="running-the-tool">
    
    
     <a href="#running-the-tool">#</a><a href="#" aria-label="Back to top">Running the Tool</a>
        
    
  </h2>
      
  <h3 id="getting-help">
    
    
     <a href="#getting-help">#</a><a href="#" aria-label="Back to top">Getting Help</a>
        
    
  </h3>
      

<p>View all available options:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--help</span>
</code></section></div></div>
  <h3 id="usage-examples">
    
    
     <a href="#usage-examples">#</a><a href="#" aria-label="Back to top">Usage Examples</a>
        
    
  </h3>
      
  <h4 id="basic-file-organization">
    
    
     <a href="#basic-file-organization">#</a><a href="#" aria-label="Back to top">Basic File Organization</a>
        
    
  </h4>
      

<p>Copy files by category from Downloads to an organized folder:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--source</span> C:<span class="se">\U</span>sers<span class="se">\Y</span>ourUser<span class="se">\D</span>ownloads <span class="nt">--target</span> C:<span class="se">\O</span>rganizedFiles
</code></section></div></div>
  <h4 id="moving-files-with-duplicate-handling">
    
    
     <a href="#moving-files-with-duplicate-handling">#</a><a href="#" aria-label="Back to top">Moving Files with Duplicate Handling</a>
        
    
  </h4>
      

<p>Move files from Downloads, adding timestamps to duplicates:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--source</span> C:<span class="se">\U</span>sers<span class="se">\Y</span>ourUser<span class="se">\D</span>ownloads <span class="nt">--target</span> C:<span class="se">\O</span>rganizedFiles <span class="nt">--move</span> <span class="nt">--timestamp-duplicates</span>
</code></section></div></div>
  <h4 id="organizing-by-file-extension">
    
    
     <a href="#organizing-by-file-extension">#</a><a href="#" aria-label="Back to top">Organizing by File Extension</a>
        
    
  </h4>
      

<p>Organize files by extension, including hidden files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> <span class="s2">"C:</span><span class="se">\P</span><span class="s2">ath</span><span class="se">\T</span><span class="s2">o</span><span class="se">\S</span><span class="s2">ource"</span> <span class="nt">-t</span> <span class="s2">"C:</span><span class="se">\P</span><span class="s2">ath</span><span class="se">\T</span><span class="s2">o</span><span class="se">\T</span><span class="s2">arget"</span> <span class="nt">--organize-by</span> extension <span class="nt">--include-hidden</span>
</code></section></div></div>
  <h4 id="advanced-configuration">
    
    
     <a href="#advanced-configuration">#</a><a href="#" aria-label="Back to top">Advanced Configuration</a>
        
    
  </h4>
      

<p>Use a custom configuration file and log all activity:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> .<span class="se">\i</span>nput <span class="nt">-t</span> .<span class="se">\o</span>utput <span class="nt">-c</span> .<span class="se">\m</span>y_config.json <span class="nt">--log-file</span> activity.log <span class="nt">--overwrite</span>
</code></section></div></div>
  <h2 id="common-options-reference">
    
    
     <a href="#common-options-reference">#</a><a href="#" aria-label="Back to top">Common Options Reference</a>
        
    
  </h2>
      

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Short</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--source</code></td>
      <td><code class="language-plaintext highlighter-rouge">-s</code></td>
      <td>Source directory to organize files from</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--target</code></td>
      <td><code class="language-plaintext highlighter-rouge">-t</code></td>
      <td>Target directory to place organized files</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--move</code></td>
      <td> </td>
      <td>Move files instead of copying them</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--organize-by</code></td>
      <td> </td>
      <td>Organization method (extension or category)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--timestamp-duplicates</code></td>
      <td> </td>
      <td>Add timestamp to duplicate files</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--include-hidden</code></td>
      <td><code class="language-plaintext highlighter-rouge">-i</code></td>
      <td>Include hidden files and directories</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--overwrite</code></td>
      <td> </td>
      <td>Overwrite existing files in target</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--config</code></td>
      <td><code class="language-plaintext highlighter-rouge">-c</code></td>
      <td>Path to custom configuration file</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--log-file</code></td>
      <td> </td>
      <td>Write logs to specified file</td>
    </tr>
  </tbody>
</table>
  <h2 id="testing-your-installation">
    
    
     <a href="#testing-your-installation">#</a><a href="#" aria-label="Back to top">Testing Your Installation</a>
        
    
  </h2>
      

<p>After building, verify your installation works by running a simple test:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c"># Create test directories</span>
<span class="nb">mkdir </span>test_source test_target

<span class="c"># Copy some test files to test_source</span>
<span class="c"># Then run the organizer</span>
.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> .<span class="se">\t</span>est_source <span class="nt">-t</span> .<span class="se">\t</span>est_target
</code></section></div></div>
  <h2 id="cargotoml">
    
    
     <a href="#cargotoml">#</a><a href="#" aria-label="Back to top">Cargo.toml</a>
        
    
  </h2>
      

<div class="language-toml highlighter-rouge"><div class="highlight"><section><code><span class="c"># Cargo.toml (Fixed fern feature)</span>
<span class="nn">[package]</span>
<span class="py">name</span> <span class="p">=</span> <span class="s">"rust_file_organizer"</span>
<span class="py">version</span> <span class="p">=</span> <span class="s">"0.1.0"</span>
<span class="py">edition</span> <span class="p">=</span> <span class="s">"2021"</span>
<span class="py">description</span> <span class="p">=</span> <span class="s">"A Rust utility for organizing files by category or extension."</span>
<span class="py">authors</span> <span class="p">=</span> <span class="p">[</span><span class="s">"AI Assistant"</span><span class="p">]</span> <span class="c"># Replace with actual author</span>
<span class="py">license</span> <span class="p">=</span> <span class="s">"MIT OR Apache-2.0"</span> <span class="c"># Choose appropriate license</span>

<span class="nn">[dependencies]</span>
<span class="c"># Command-line argument parsing</span>
<span class="py">clap</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"4.5"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"derive"</span><span class="p">,</span> <span class="s">"cargo"</span><span class="p">,</span> <span class="s">"env"</span><span class="p">]</span> <span class="p">}</span> <span class="c"># cargo/env features allow reading from Cargo.toml/env vars</span>

<span class="c"># Directory traversal</span>
<span class="py">walkdir</span> <span class="p">=</span> <span class="s">"2.5"</span>

<span class="c"># JSON parsing for configuration files</span>
<span class="py">serde</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"1.0"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"derive"</span><span class="p">]</span> <span class="p">}</span>
<span class="py">serde_json</span> <span class="p">=</span> <span class="s">"1.0"</span>

<span class="c"># Logging framework</span>
<span class="py">log</span> <span class="p">=</span> <span class="s">"0.4"</span>
<span class="c"># Using fern for flexible file/console logging setup</span>
<span class="c"># **Fix:** Enable the 'colored' feature for fern</span>
<span class="py">fern</span> <span class="o">=</span> <span class="p">{</span> <span class="py">version</span> <span class="p">=</span> <span class="s">"0.6"</span><span class="p">,</span> <span class="py">features</span> <span class="p">=</span> <span class="p">[</span><span class="s">"colored"</span><span class="p">]</span> <span class="p">}</span>

<span class="c"># Date and time handling for timestamps</span>
<span class="py">chrono</span> <span class="p">=</span> <span class="s">"0.4"</span>

<span class="c"># Flexible error handling and context reporting</span>
<span class="py">anyhow</span> <span class="p">=</span> <span class="s">"1.0"</span>

<span class="c"># Optional: More robust file operations (especially cross-device move)</span>
<span class="c"># fs_extra = "1.3" # Keep commented unless needed; std lib fallback implemented</span>

<span class="c"># Windows-specific dependencies are NOT needed here as std lib is used for hidden check</span>
<span class="c"># [target.'cfg(windows)'.dependencies]</span>
<span class="c"># windows = { version = "0.56", features = [...] }</span>

<span class="c"># Release profile optimizations (optional but recommended for smaller/faster executables)</span>
<span class="nn">[profile.release]</span>
<span class="c"># 'z' optimizes aggressively for size, potentially sacrificing some speed compared to 's' or '3'.</span>
<span class="py">opt-level</span> <span class="p">=</span> <span class="s">'z'</span>
<span class="c"># Enable Link-Time Optimization across crates for potential performance gains and size reduction.</span>
<span class="py">lto</span> <span class="p">=</span> <span class="kc">true</span>
<span class="c"># Maximize optimization opportunities by using a single codegen unit (can significantly increase compile times).</span>
<span class="py">codegen-units</span> <span class="p">=</span> <span class="mi">1</span>
<span class="c"># Remove symbols from the binary for smaller size.</span>
<span class="c"># Alternatively, use `cargo strip` (requires `cargo install cargo-strip`) or set `debuginfo = 0` (removes debug symbols only).</span>
<span class="py">strip</span> <span class="p">=</span> <span class="kc">true</span>
<span class="c"># Abort on panic instead of unwinding the stack. Reduces binary size but prevents catching panics.</span>
<span class="py">panic</span> <span class="p">=</span> <span class="s">'abort'</span>
</code></section></div></div>
  <h2 id="mainrs">
    
    
     <a href="#mainrs">#</a><a href="#" aria-label="Back to top">main.rs</a>
        
    
  </h2>
      

<section data-filename="rust_code-block.txt" data-code="// src/main.rs: Rust implementation of the file organizer utility.
// This version fixes compilation errors and ensures completeness.
use anyhow::{bail, Context, Result}; // Use anyhow for convenient error handling
use clap::Parser; // For command-line argument parsing
use chrono::Local; // For generating timestamps
use fern::colors::{Color, ColoredLevelConfig}; // For colored logging output
use log::{debug, error, info, warn, LevelFilter}; // Logging facade
use serde::Deserialize; // For deserializing JSON config
use std::{
collections::{HashMap, HashSet},
env, // For CARGO_PKG_VERSION
// Removed unused 'File' import
fs::{self}, // Standard file system operations
io::{self, ErrorKind},
path::{Path, PathBuf},
time::Instant, // For accurate duration measurement
};
use walkdir::{DirEntry, WalkDir}; // For efficient directory traversal
// --- Configuration Structures ---
/// Represents the structure of the JSON configuration file for categories.
#[derive(Deserialize, Debug, Clone)]
struct CategoriesConfig(HashMap&lt;String, Vec&lt;String&gt;&gt;);
/// Provides the default file categorization configuration.
fn default_categories() -&gt; CategoriesConfig {
let mut map = HashMap::new();
macro_rules! add_category {
($map:expr, $name:expr, [$($ext:expr),* $(,)?]) =&gt; {
$map.insert($name.to_string(), vec![$($ext.to_string()),*]);
};
}
add_category!(map, &quot;images&quot;, [&quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.webp&quot;, &quot;.tiff&quot;, &quot;.svg&quot;, &quot;.ico&quot;]);
add_category!(map, &quot;documents&quot;, [&quot;.pdf&quot;, &quot;.docx&quot;, &quot;.doc&quot;, &quot;.txt&quot;, &quot;.rtf&quot;, &quot;.odt&quot;, &quot;.xlsx&quot;, &quot;.xls&quot;, &quot;.csv&quot;, &quot;.pptx&quot;, &quot;.ppt&quot;, &quot;.md&quot;, &quot;.tex&quot;, &quot;.chm&quot;, &quot;.epub&quot;]);
add_category!(map, &quot;videos&quot;, [&quot;.mp4&quot;, &quot;.avi&quot;, &quot;.mkv&quot;, &quot;.mov&quot;, &quot;.wmv&quot;, &quot;.flv&quot;, &quot;.webm&quot;]);
add_category!(map, &quot;audio&quot;, [&quot;.mp3&quot;, &quot;.wav&quot;, &quot;.flac&quot;, &quot;.aac&quot;, &quot;.ogg&quot;, &quot;.m4a&quot;]);
add_category!(map, &quot;archives&quot;, [&quot;.zip&quot;, &quot;.rar&quot;, &quot;.tar&quot;, &quot;.gz&quot;, &quot;.bz2&quot;, &quot;.7z&quot;, &quot;.iso&quot;]);
add_category!(map, &quot;code&quot;, [&quot;.py&quot;, &quot;.java&quot;, &quot;.c&quot;, &quot;.cpp&quot;, &quot;.h&quot;, &quot;.cs&quot;, &quot;.html&quot;, &quot;.css&quot;, &quot;.js&quot;, &quot;.ts&quot;, &quot;.jsx&quot;, &quot;.tsx&quot;, &quot;.xml&quot;, &quot;.json&quot;, &quot;.yaml&quot;, &quot;.yml&quot;, &quot;.sh&quot;, &quot;.bat&quot;, &quot;.ps1&quot;, &quot;.rb&quot;, &quot;.php&quot;, &quot;.go&quot;, &quot;.rs&quot;, &quot;.swift&quot;, &quot;.kt&quot;, &quot;.ipynb&quot;, &quot;.sql&quot;, &quot;.toml&quot;]);
add_category!(map, &quot;apps&quot;, [&quot;.exe&quot;, &quot;.msi&quot;, &quot;.apk&quot;, &quot;.dmg&quot;, &quot;.deb&quot;, &quot;.rpm&quot;, &quot;.app&quot;]);
add_category!(map, &quot;fonts&quot;, [&quot;.ttf&quot;, &quot;.otf&quot;, &quot;.woff&quot;, &quot;.woff2&quot;]);
add_category!(map, &quot;shortcuts&quot;, [&quot;.lnk&quot;, &quot;.url&quot;]);
map.insert(&quot;other&quot;.to_string(), vec![]);
CategoriesConfig(map)
}
/// Loads category configuration from a specified JSON file path.
fn load_config_file(config_path: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;CategoriesConfig&gt; {
match config_path {
Some(path) if path.is_file() =&gt; {
info!(&quot;Loading category configuration from: {}&quot;, path.display());
let file_content = fs::read_to_string(path)
.with_context(|| format!(&quot;Failed to read config file: {}&quot;, path.display()))?;
let mut config: HashMap&lt;String, Vec&lt;String&gt;&gt; = serde_json::from_str(&amp;file_content)
.with_context(|| format!(&quot;Failed to parse JSON config file: {}&quot;, path.display()))?;
config.entry(&quot;other&quot;.to_string()).or_insert_with(Vec::new);
info!(&quot;Successfully loaded and validated custom configuration.&quot;);
Ok(CategoriesConfig(config))
}
Some(path) =&gt; {
warn!(
&quot;Config path '{}' provided but is not a valid file. Using default categories.&quot;,
path.display()
);
Ok(default_categories())
}
None =&gt; {
info!(&quot;No config file specified. Using default category configuration.&quot;);
Ok(default_categories())
}
}
}
/// Determines the category name (String) for a given file based on its extension.
fn categorize_file(filename: &amp;Path, categories_config: &amp;CategoriesConfig) -&gt; String {
let extension = filename
.extension()
.and_then(|s| s.to_str())
.map(|s| format!(&quot;.{}&quot;, s.to_lowercase()))
.unwrap_or_else(|| &quot;no_extension&quot;.to_string());
if extension == &quot;no_extension&quot; { return extension; }
for (category, extensions) in &amp;categories_config.0 {
if extensions.contains(&amp;extension) { return category.clone(); }
}
&quot;other&quot;.to_string()
}
// --- Platform Specific ---
/// Checks if a file or directory is hidden on Windows using standard library features.
#[cfg(windows)]
fn is_hidden(path: &amp;Path) -&gt; Result&lt;bool&gt; {
use std::os::windows::fs::MetadataExt;
let metadata = fs::metadata(path)
.with_context(|| format!(&quot;Failed to get metadata for {}&quot;, path.display()))?;
let attributes = metadata.file_attributes();
// Use the raw value 0x2 for FILE_ATTRIBUTE_HIDDEN when using std::os::windows::fs
const FILE_ATTRIBUTE_HIDDEN_VALUE: u32 = 0x2;
Ok((attributes &amp; FILE_ATTRIBUTE_HIDDEN_VALUE) != 0)
}
/// Checks if a file or directory is hidden on Unix-like systems (conventionally, starts with '.').
#[cfg(not(windows))]
fn is_hidden(path: &amp;Path) -&gt; Result&lt;bool&gt; {
Ok(path
.file_name()
.and_then(|s| s.to_str())
.map(|s| s.starts_with('.'))
.unwrap_or(false))
}
/// Helper for walkdir filter_entry to check hidden status.
fn should_keep_entry(entry: &amp;DirEntry, include_hidden: bool) -&gt; bool {
if include_hidden { return true; }
match is_hidden(entry.path()) {
Ok(hidden) =&gt; !hidden,
Err(err) =&gt; {
warn!(
&quot;Could not determine hidden status for {}: {}. Excluding entry.&quot;,
entry.path().display(), err
);
false // Exclude if check fails (safer default)
}
}
}
// --- Command Line Arguments ---
#[derive(clap::ValueEnum, Clone, Debug, PartialEq, Eq)]
enum OrganizeMethod { Category, Extension, }
#[derive(Parser, Debug)]
#[command(author, version, about = &quot;Organize files by category or extension (Rust version).&quot;,
long_about = &quot;A Rust utility for organizing files from source directories into categorized target folders based on file types or extensions.&quot;,
help_template = &quot;{before-help}{name} {version}\n{author-with-newline}{about-with-newline}\n{usage-heading} {usage}\n\n{all-args}{after-help}&quot;
)]
struct CliArgs {
#[arg(short, long, value_name = &quot;DIR&quot;)] source: PathBuf,
#[arg(short, long, value_name = &quot;DIR&quot;)] target: PathBuf,
#[arg(short, long, value_name = &quot;FILE&quot;)] config: Option&lt;PathBuf&gt;,
#[arg(long, value_enum, default_value_t = OrganizeMethod::Category)] organize_by: OrganizeMethod,
#[arg(long)] move_files: bool,
#[arg(long, conflicts_with_all = [&quot;skip_existing&quot;, &quot;overwrite&quot;])] timestamp_duplicates: bool,
#[arg(long, short = 'k', conflicts_with_all = [&quot;timestamp_duplicates&quot;, &quot;overwrite&quot;])] skip_existing: bool,
#[arg(long, conflicts_with_all = [&quot;timestamp_duplicates&quot;, &quot;skip_existing&quot;])] overwrite: bool,
#[arg(long, short = 'i')] include_hidden: bool,
#[arg(long, short = 'l')] follow_links: bool,
#[arg(long, requires = &quot;move_files&quot;)] remove_empty_source_dirs: bool,
#[arg(long, value_name = &quot;FILE&quot;)] log_file: Option&lt;PathBuf&gt;,
#[arg(long, value_parser = clap::value_parser!(LevelFilter), default_value = &quot;info&quot;)] log_level: LevelFilter,
}
// --- Core Logic ---
/// Holds statistics about the file processing operation.
#[derive(Debug, Default)]
struct ProcessStats {
/// Count of directory entries successfully yielded by the filtered WalkDir iterator.
total_scanned: u64,
processed: u64,
skipped: u64,
errors: u64,
failed_files: Vec&lt;(PathBuf, String)&gt;, // Stores paths and error context
}
/// Scans the source directory for unique file extensions.
fn get_all_extensions(
source_directory: &amp;Path,
include_hidden: bool,
follow_links: bool,
) -&gt; Result&lt;HashSet&lt;String&gt;&gt; {
let mut extensions = HashSet::new();
info!(&quot;Scanning source directory for all unique file extensions...&quot;);
let walker = WalkDir::new(source_directory)
.follow_links(follow_links)
.into_iter();
let mut count = 0;
for entry_result in walker.filter_entry(|e| should_keep_entry(e, include_hidden)) {
match entry_result {
Ok(entry) =&gt; {
let path = entry.path();
if path.is_file() {
count += 1;
if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
extensions.insert(ext.to_lowercase());
}
if count % 1000 == 0 { debug!(&quot;Scanned {} files for extensions...&quot;, count); }
}
}
Err(e) =&gt; warn!(&quot;Error accessing entry during extension scan: {}&quot;, e),
}
}
info!(&quot;Found {} unique extensions.&quot;, extensions.len());
Ok(extensions)
}
/// Creates necessary target subfolders.
fn create_target_folders(
base_dir: &amp;Path,
organize_by: &amp;OrganizeMethod,
categories_config: Option&lt;&amp;CategoriesConfig&gt;,
all_extensions: Option&lt;&amp;HashSet&lt;String&gt;&gt;,
) -&gt; Result&lt;()&gt; {
info!(&quot;Ensuring target base directory exists: {}&quot;, base_dir.display());
fs::create_dir_all(base_dir)
.with_context(|| format!(&quot;Failed to create base target directory: {}&quot;, base_dir.display()))?;
let folders_to_create: HashSet&lt;String&gt; = match organize_by {
OrganizeMethod::Category =&gt; {
let mut folders = categories_config
.map(|cfg| cfg.0.keys().cloned().collect::&lt;HashSet&lt;String&gt;&gt;())
.unwrap_or_default();
folders.insert(&quot;other&quot;.to_string());
folders.insert(&quot;no_extension&quot;.to_string());
folders
}
OrganizeMethod::Extension =&gt; {
let mut folders = all_extensions.cloned().unwrap_or_default();
folders.insert(&quot;no_extension&quot;.to_string());
folders
}
};
info!(
&quot;Creating target subfolders (mode: {:?}). Total potential folders: {}&quot;,
organize_by,
folders_to_create.len()
);
let mut created_count = 0;
for folder_name in &amp;folders_to_create {
if folder_name.is_empty() { warn!(&quot;Skipping creation of folder with empty name.&quot;); continue; }
let folder_path = base_dir.join(folder_name);
if !folder_path.exists() {
fs::create_dir_all(&amp;folder_path).with_context(|| {
format!(&quot;Failed to create target folder '{}'&quot;, folder_path.display())
})?;
debug!(&quot;Created target folder: {}&quot;, folder_path.display());
created_count += 1;
}
}
info!(&quot;Created {} new target subfolders.&quot;, created_count);
Ok(())
}
/// Attempts to move a file, falling back to copy-then-delete on cross-device errors.
fn move_file_with_fallback(source: &amp;Path, target: &amp;Path) -&gt; io::Result&lt;()&gt; {
match fs::rename(source, target) {
Ok(_) =&gt; Ok(()),
Err(rename_error) =&gt; {
// Note: Relies on platform-specific OS error codes (Windows: 17, Unix: 18/libc::EXDEV). Might be brittle.
let is_cross_device = || -&gt; bool {
#[cfg(windows)] { rename_error.raw_os_error() == Some(17) }
#[cfg(unix)] { rename_error.raw_os_error() == Some(18) }
#[cfg(not(any(windows, unix)))] { false }
};
if is_cross_device() {
warn!(&quot;Rename failed (cross-device error detected), attempting copy+delete fallback for move: {} -&gt; {}&quot;, source.display(), target.display());
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source, target)?;
fs::remove_file(source)?;
Ok(())
} else { Err(rename_error) }
}
}
}
/// Main function to perform the file organization.
fn organize_files(args: &amp;CliArgs, categories_config: &amp;CategoriesConfig) -&gt; Result&lt;ProcessStats&gt; {
if !args.source.is_dir() { bail!(&quot;Source directory '{}' is invalid or not found.&quot;, args.source.display()); }
if !args.target.exists() {
info!(&quot;Creating target directory: {}&quot;, args.target.display());
fs::create_dir_all(&amp;args.target).with_context(|| format!(&quot;Could not create target directory '{}'&quot;, args.target.display()))?;
} else if !args.target.is_dir() { bail!(&quot;Target path '{}' exists but is not a directory.&quot;, args.target.display()); }
info!(&quot;Preparing target folders...&quot;);
let extensions_for_folders = if args.organize_by == OrganizeMethod::Extension {
Some(get_all_extensions(&amp;args.source, args.include_hidden, args.follow_links)?)
} else { None };
create_target_folders(&amp;args.target, &amp;args.organize_by, Some(categories_config), extensions_for_folders.as_ref())?;
info!(&quot;Starting file processing...&quot;);
let mut stats = ProcessStats::default();
let mut file_counter = 0u64;
let walker = WalkDir::new(&amp;args.source).follow_links(args.follow_links).into_iter();
for entry_result in walker.filter_entry(|e| should_keep_entry(e, args.include_hidden)) {
stats.total_scanned += 1; // Count filtered entries
let entry = match entry_result {
Ok(e) =&gt; e,
Err(e) =&gt; {
let path_display = e.path().unwrap_or_else(|| Path::new(&quot;?&quot;)).display();
error!(&quot;Error scanning path {}: {}&quot;, path_display, e);
stats.errors += 1;
// Provide default PathBuf if e.path() is None
stats.failed_files.push((
e.path().map_or_else(|| PathBuf::from(&quot;?&quot;), |p| p.to_path_buf()),
format!(&quot;Scan error: {:?}&quot;, e),
));
continue;
}
};
if !entry.file_type().is_file() { stats.skipped += 1; continue; }
file_counter += 1;
let source_path = entry.path();
let progress_prefix = format!(&quot;[{}]&quot;, file_counter);
let file_result: Result&lt;()&gt; = (|| {
let file_name = source_path.file_name().with_context(|| format!(&quot;Could not get filename for path: {}&quot;, source_path.display()))?;
let target_subfolder_name = match args.organize_by {
OrganizeMethod::Category =&gt; categorize_file(source_path, categories_config),
OrganizeMethod::Extension =&gt; source_path.extension().and_then(|s| s.to_str()).map(|s| s.to_lowercase()).unwrap_or_else(|| &quot;no_extension&quot;.to_string()),
};
let target_folder_path = args.target.join(&amp;target_subfolder_name);
let mut target_file_path = target_folder_path.join(file_name);
if target_file_path.exists() {
if args.skip_existing {
info!(&quot;{} Skipping (target exists): {}&quot;, progress_prefix, target_file_path.display());
stats.skipped += 1; return Ok(());
} else if args.timestamp_duplicates {
let original_target_path_display = target_file_path.display().to_string();
let mut counter = 1;
// Use file_name directly, it's already &amp;OsStr
let stem = source_path.file_stem().unwrap_or(file_name);
let ext = source_path.extension().unwrap_or_default();
const MAX_TIMESTAMP_ATTEMPTS: u32 = 1000;
loop {
let timestamp = Local::now().format(&quot;%Y%m%d_%H%M%S&quot;);
let mut new_name_os = std::ffi::OsString::new();
new_name_os.push(stem);
new_name_os.push(format!(&quot;_{}_{}&quot;, timestamp, counter));
if !ext.is_empty() { new_name_os.push(&quot;.&quot;); new_name_os.push(ext); }
target_file_path = target_folder_path.join(&amp;new_name_os);
if !target_file_path.exists() { break; }
counter += 1;
if counter &gt; MAX_TIMESTAMP_ATTEMPTS { bail!(&quot;Could not find unique timestamped name for {} after {} attempts. Skipping.&quot;, original_target_path_display, MAX_TIMESTAMP_ATTEMPTS); }
}
info!(&quot;{} Target exists '{}'. Renaming duplicate to: {}&quot;, progress_prefix, original_target_path_display, target_file_path.display());
} else if args.overwrite { warn!(&quot;{} Overwriting existing target file: {}&quot;, progress_prefix, target_file_path.display()); }
else { warn!(&quot;{} Overwriting existing target file (default): {}&quot;, progress_prefix, target_file_path.display()); }
}
fs::create_dir_all(&amp;target_folder_path).with_context(|| format!(&quot;Failed to ensure target directory '{}' exists&quot;, target_folder_path.display()))?;
let operation_desc = if args.move_files { &quot;move&quot; } else { &quot;copy&quot; };
debug!(&quot;{} Attempting to {} '{}' to '{}'&quot;, progress_prefix, operation_desc, source_path.display(), target_file_path.display());
if args.move_files {
move_file_with_fallback(source_path, &amp;target_file_path).with_context(|| format!(&quot;Failed to move '{}' to '{}'&quot;, source_path.display(), target_file_path.display()))?;
} else {
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source_path, &amp;target_file_path).map(|_| ()).with_context(|| format!(&quot;Failed to copy '{}' to '{}'&quot;, source_path.display(), target_file_path.display()))?;
}
stats.processed += 1;
Ok(())
})(); // End inner closure
if let Err(e) = file_result {
error!(&quot;{} Failed to process '{}': {:?}&quot;, progress_prefix, source_path.display(), e);
stats.errors += 1;
stats.failed_files.push((source_path.to_path_buf(), format!(&quot;{:?}&quot;, e)));
}
} // End main loop
Ok(stats)
}
/// Recursively removes empty folders starting from the bottom up.
fn remove_empty_folders(directory: &amp;Path) -&gt; Result&lt;u32&gt; {
let mut removed_count = 0u32;
info!(&quot;Attempting to remove empty directories within: {}&quot;, directory.display());
let mut dirs_to_check = Vec::new();
for entry_result in WalkDir::new(directory).min_depth(1) {
match entry_result {
Ok(entry) if entry.file_type().is_dir() =&gt; { dirs_to_check.push(entry.into_path()); }
Ok(_) =&gt; {}
Err(e) =&gt; warn!(&quot;Error accessing entry during empty dir scan: {}&quot;, e),
}
}
dirs_to_check.sort_by(|a, b| b.components().count().cmp(&amp;a.components().count()));
for dir_path in dirs_to_check {
if !dir_path.is_dir() { continue; }
match fs::read_dir(&amp;dir_path) {
Ok(mut read_dir) =&gt; {
if read_dir.next().is_none() { // Directory is empty
match fs::remove_dir(&amp;dir_path) {
Ok(_) =&gt; { info!(&quot;Removed empty directory: {}&quot;, dir_path.display()); removed_count += 1; }
Err(e) =&gt; { if e.kind() != ErrorKind::NotFound { warn!(&quot;Could not remove presumably empty directory '{}': {}&quot;, dir_path.display(), e); } }
}
}
}
Err(e) =&gt; { if e.kind() != ErrorKind::NotFound { warn!(&quot;Could not read directory '{}' to check emptiness: {}&quot;, dir_path.display(), e); } }
}
}
info!(&quot;Finished removing empty directories. Removed: {}&quot;, removed_count);
Ok(removed_count)
}
// --- Logging Setup ---
/// Sets up logging using the fern crate.
fn setup_logging(log_level: LevelFilter, log_file: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;()&gt; {
let colors = ColoredLevelConfig::new().error(Color::Red).warn(Color::Yellow).info(Color::Green).debug(Color::Blue).trace(Color::BrightBlack);
let base_config = fern::Dispatch::new()
.format(move |out, message, record| {
out.finish(format_args!(
&quot;[{} {} {}] {}&quot;,
chrono::Local::now().format(&quot;%Y-%m-%d %H:%M:%S%.3f&quot;), colors.color(record.level()), record.target(), message
))
})
.level(log_level)
.level_for(&quot;hyper&quot;, LevelFilter::Warn).level_for(&quot;mio&quot;, LevelFilter::Warn).level_for(&quot;want&quot;, LevelFilter::Warn).level_for(&quot;reqwest&quot;, LevelFilter::Warn).level_for(&quot;rustls&quot;, LevelFilter::Warn);
let stderr_logger = fern::Dispatch::new().filter(move |metadata| { log_level &lt;= LevelFilter::Debug || metadata.target().starts_with(env!(&quot;CARGO_PKG_NAME&quot;)) }).chain(std::io::stderr());
let mut final_dispatch = base_config.chain(stderr_logger);
let mut file_logger_ok = false;
if let Some(log_path) = log_file {
match fern::log_file(log_path) {
Ok(file_output) =&gt; { final_dispatch = final_dispatch.chain(file_output); file_logger_ok = true; }
Err(e) =&gt; { eprintln!(&quot;Error: Failed to create log file '{}': {}. Logging to console only.&quot;, log_path.display(), e); }
}
}
final_dispatch.apply().context(&quot;Failed to set up logging&quot;)?;
if file_logger_ok { if let Some(path) = log_file { info!(&quot;File logging enabled to: {}&quot;, path.display()); } }
Ok(())
}
// --- Main Application Entry Point ---
fn main() -&gt; Result&lt;()&gt; {
let overall_start_time = Instant::now(); // Start timing
let args = CliArgs::parse();
setup_logging(args.log_level, args.log_file.as_ref())?;
info!(&quot;Rust File Organizer (v{}) starting...&quot;, env!(&quot;CARGO_PKG_VERSION&quot;));
debug!(&quot;Arguments received: {:?}&quot;, args);
info!(&quot;Source directory: {}&quot;, args.source.display());
info!(&quot;Target directory: {}&quot;, args.target.display());
info!(&quot;Organization mode: {:?}&quot;, args.organize_by);
info!(&quot;Operation: {}&quot;, if args.move_files { &quot;Move&quot; } else { &quot;Copy&quot; });
info!(&quot;Include hidden: {}&quot;, args.include_hidden);
info!(&quot;Follow links: {}&quot;, args.follow_links);
if args.skip_existing { info!(&quot;Duplicate handling: Skip existing&quot;); }
else if args.timestamp_duplicates { info!(&quot;Duplicate handling: Timestamp duplicates&quot;); }
else if args.overwrite { info!(&quot;Duplicate handling: Overwrite existing (explicitly)&quot;); }
else { info!(&quot;Duplicate handling: Overwrite existing (default)&quot;); }
let categories = load_config_file(args.config.as_ref())?;
let result = organize_files(&amp;args, &amp;categories);
match result {
Ok(stats) =&gt; {
if args.move_files &amp;&amp; args.remove_empty_source_dirs &amp;&amp; stats.processed &gt; 0 {
// Note: Cleanup errors are logged but do not cause a non-zero exit code.
if let Err(e) = remove_empty_folders(&amp;args.source) { error!(&quot;Error during empty source directory removal: {:?}&quot;, e); }
}
let overall_duration = overall_start_time.elapsed();
let summary = format!(
&quot;Operation completed in {:.2?}. Scanned Entries: {}, Processed Files: {}, Skipped: {}, Errors: {}&quot;,
overall_duration, stats.total_scanned, stats.processed, stats.skipped, stats.errors
);
info!(&quot;{}&quot;, summary);
println!(&quot;\n{}&quot;, summary);
if stats.errors &gt; 0 {
eprintln!(&quot;\n--- Errors occurred during processing: ---&quot;);
for (path, error_msg) in &amp;stats.failed_files {
eprintln!(&quot; - File: {}&quot;, path.display());
eprintln!(&quot;   Error: {}&quot;, error_msg);
}
eprintln!(&quot;-----------------------------------------&quot;);
eprintln!(&quot;Warning: {} errors occurred. Please check logs (stderr/file) for full details.&quot;, stats.errors);
// Consider exiting with non-zero status for scripting if errors occurred
// std::process::exit(1);
}
}
Err(e) =&gt; {
error!(&quot;Critical error during file organization: {:?}&quot;, e);
eprintln!(&quot;\nError: File organization failed critically. Check logs (stderr/file) for details.&quot;);
std::process::exit(1);
}
}
info!(&quot;Rust File Organizer finished.&quot;);
Ok(())
}
// --- Testing Notes ---
// To properly test this application, consider using crates like:
// - `assert_fs`: For creating temporary file/directory structures for tests.
// - `predicates`: For making assertions about file system state (e.g., file exists, content matches).
// - `assert_cmd`: For testing the command-line interface behavior, arguments, exit codes, and output.
//
// Example Test Scenarios (Conceptual):
// - Test basic copy/move by category and extension.
// - Test duplicate handling flags (skip, timestamp, overwrite) work correctly.
// - Test hidden file handling with and without the --include-hidden flag.
// - Test symbolic link handling with and without the --follow-links flag.
// - Test behavior with empty source or target directories.
// - Test custom configuration loading and verify correct categorization (including missing 'other').
// - Test empty directory removal after a successful move operation.
// - Test error handling for scenarios like insufficient permissions (harder to automate reliably).
// - Test long path handling specifically on Windows (requires careful test setup).
// - Test cross-device move fallback behavior.
// - Test handling of filenames with non-UTF8 characters (requires OsStr handling)." data-download-link="" data-download-link-label="Download Rust"><code class="language-rust">// src/main.rs: Rust implementation of the file organizer utility.
// This version fixes compilation errors and ensures completeness.
use anyhow::{bail, Context, Result}; // Use anyhow for convenient error handling
use clap::Parser; // For command-line argument parsing
use chrono::Local; // For generating timestamps
use fern::colors::{Color, ColoredLevelConfig}; // For colored logging output
use log::{debug, error, info, warn, LevelFilter}; // Logging facade
use serde::Deserialize; // For deserializing JSON config
use std::{
collections::{HashMap, HashSet},
env, // For CARGO_PKG_VERSION
// Removed unused 'File' import
fs::{self}, // Standard file system operations
io::{self, ErrorKind},
path::{Path, PathBuf},
time::Instant, // For accurate duration measurement
};
use walkdir::{DirEntry, WalkDir}; // For efficient directory traversal
// --- Configuration Structures ---
/// Represents the structure of the JSON configuration file for categories.
#[derive(Deserialize, Debug, Clone)]
struct CategoriesConfig(HashMap&lt;String, Vec<String>&gt;);
/// Provides the default file categorization configuration.
fn default_categories() -&gt; CategoriesConfig {
let mut map = HashMap::new();
macro_rules! add_category {
($map:expr, $name:expr, [$($ext:expr),* $(,)?]) =&gt; {
$map.insert($name.to_string(), vec![$($ext.to_string()),*]);
};
}
add_category!(map, "images", [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff", ".svg", ".ico"]);
add_category!(map, "documents", [".pdf", ".docx", ".doc", ".txt", ".rtf", ".odt", ".xlsx", ".xls", ".csv", ".pptx", ".ppt", ".md", ".tex", ".chm", ".epub"]);
add_category!(map, "videos", [".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm"]);
add_category!(map, "audio", [".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a"]);
add_category!(map, "archives", [".zip", ".rar", ".tar", ".gz", ".bz2", ".7z", ".iso"]);
add_category!(map, "code", [".py", ".java", ".c", ".cpp", ".h", ".cs", ".html", ".css", ".js", ".ts", ".jsx", ".tsx", ".xml", ".json", ".yaml", ".yml", ".sh", ".bat", ".ps1", ".rb", ".php", ".go", ".rs", ".swift", ".kt", ".ipynb", ".sql", ".toml"]);
add_category!(map, "apps", [".exe", ".msi", ".apk", ".dmg", ".deb", ".rpm", ".app"]);
add_category!(map, "fonts", [".ttf", ".otf", ".woff", ".woff2"]);
add_category!(map, "shortcuts", [".lnk", ".url"]);
map.insert("other".to_string(), vec![]);
CategoriesConfig(map)
}
/// Loads category configuration from a specified JSON file path.
fn load_config_file(config_path: Option&lt;&amp;PathBuf&gt;) -&gt; Result<CategoriesConfig> {
match config_path {
Some(path) if path.is_file() =&gt; {
info!("Loading category configuration from: {}", path.display());
let file_content = fs::read_to_string(path)
.with_context(|| format!("Failed to read config file: {}", path.display()))?;
let mut config: HashMap&lt;String, Vec<String>&gt; = serde_json::from_str(&amp;file_content)
.with_context(|| format!("Failed to parse JSON config file: {}", path.display()))?;
config.entry("other".to_string()).or_insert_with(Vec::new);
info!("Successfully loaded and validated custom configuration.");
Ok(CategoriesConfig(config))
}
Some(path) =&gt; {
warn!(
"Config path '{}' provided but is not a valid file. Using default categories.",
path.display()
);
Ok(default_categories())
}
None =&gt; {
info!("No config file specified. Using default category configuration.");
Ok(default_categories())
}
}
}
/// Determines the category name (String) for a given file based on its extension.
fn categorize_file(filename: &amp;Path, categories_config: &amp;CategoriesConfig) -&gt; String {
let extension = filename
.extension()
.and_then(|s| s.to_str())
.map(|s| format!(".{}", s.to_lowercase()))
.unwrap_or_else(|| "no_extension".to_string());
if extension == "no_extension" { return extension; }
for (category, extensions) in &amp;categories_config.0 {
if extensions.contains(&amp;extension) { return category.clone(); }
}
"other".to_string()
}
// --- Platform Specific ---
/// Checks if a file or directory is hidden on Windows using standard library features.
#[cfg(windows)]
fn is_hidden(path: &amp;Path) -&gt; Result<bool> {
use std::os::windows::fs::MetadataExt;
let metadata = fs::metadata(path)
.with_context(|| format!("Failed to get metadata for {}", path.display()))?;
let attributes = metadata.file_attributes();
// Use the raw value 0x2 for FILE_ATTRIBUTE_HIDDEN when using std::os::windows::fs
const FILE_ATTRIBUTE_HIDDEN_VALUE: u32 = 0x2;
Ok((attributes &amp; FILE_ATTRIBUTE_HIDDEN_VALUE) != 0)
}
/// Checks if a file or directory is hidden on Unix-like systems (conventionally, starts with '.').
#[cfg(not(windows))]
fn is_hidden(path: &amp;Path) -&gt; Result<bool> {
Ok(path
.file_name()
.and_then(|s| s.to_str())
.map(|s| s.starts_with('.'))
.unwrap_or(false))
}
/// Helper for walkdir filter_entry to check hidden status.
fn should_keep_entry(entry: &amp;DirEntry, include_hidden: bool) -&gt; bool {
if include_hidden { return true; }
match is_hidden(entry.path()) {
Ok(hidden) =&gt; !hidden,
Err(err) =&gt; {
warn!(
"Could not determine hidden status for {}: {}. Excluding entry.",
entry.path().display(), err
);
false // Exclude if check fails (safer default)
}
}
}
// --- Command Line Arguments ---
#[derive(clap::ValueEnum, Clone, Debug, PartialEq, Eq)]
enum OrganizeMethod { Category, Extension, }
#[derive(Parser, Debug)]
#[command(author, version, about = "Organize files by category or extension (Rust version).",
long_about = "A Rust utility for organizing files from source directories into categorized target folders based on file types or extensions.",
help_template = "{before-help}{name} {version}\n{author-with-newline}{about-with-newline}\n{usage-heading} {usage}\n\n{all-args}{after-help}"
)]
struct CliArgs {
#[arg(short, long, value_name = "DIR")] source: PathBuf,
#[arg(short, long, value_name = "DIR")] target: PathBuf,
#[arg(short, long, value_name = "FILE")] config: Option<PathBuf>,
#[arg(long, value_enum, default_value_t = OrganizeMethod::Category)] organize_by: OrganizeMethod,
#[arg(long)] move_files: bool,
#[arg(long, conflicts_with_all = ["skip_existing", "overwrite"])] timestamp_duplicates: bool,
#[arg(long, short = 'k', conflicts_with_all = ["timestamp_duplicates", "overwrite"])] skip_existing: bool,
#[arg(long, conflicts_with_all = ["timestamp_duplicates", "skip_existing"])] overwrite: bool,
#[arg(long, short = 'i')] include_hidden: bool,
#[arg(long, short = 'l')] follow_links: bool,
#[arg(long, requires = "move_files")] remove_empty_source_dirs: bool,
#[arg(long, value_name = "FILE")] log_file: Option<PathBuf>,
#[arg(long, value_parser = clap::value_parser!(LevelFilter), default_value = "info")] log_level: LevelFilter,
}
// --- Core Logic ---
/// Holds statistics about the file processing operation.
#[derive(Debug, Default)]
struct ProcessStats {
/// Count of directory entries successfully yielded by the filtered WalkDir iterator.
total_scanned: u64,
processed: u64,
skipped: u64,
errors: u64,
failed_files: Vec&lt;(PathBuf, String)&gt;, // Stores paths and error context
}
/// Scans the source directory for unique file extensions.
fn get_all_extensions(
source_directory: &amp;Path,
include_hidden: bool,
follow_links: bool,
) -&gt; Result&lt;HashSet<String>&gt; {
let mut extensions = HashSet::new();
info!("Scanning source directory for all unique file extensions...");
let walker = WalkDir::new(source_directory)
.follow_links(follow_links)
.into_iter();
let mut count = 0;
for entry_result in walker.filter_entry(|e| should_keep_entry(e, include_hidden)) {
match entry_result {
Ok(entry) =&gt; {
let path = entry.path();
if path.is_file() {
count += 1;
if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
extensions.insert(ext.to_lowercase());
}
if count % 1000 == 0 { debug!("Scanned {} files for extensions...", count); }
}
}
Err(e) =&gt; warn!("Error accessing entry during extension scan: {}", e),
}
}
info!("Found {} unique extensions.", extensions.len());
Ok(extensions)
}
/// Creates necessary target subfolders.
fn create_target_folders(
base_dir: &amp;Path,
organize_by: &amp;OrganizeMethod,
categories_config: Option&lt;&amp;CategoriesConfig&gt;,
all_extensions: Option&lt;&amp;HashSet<String>&gt;,
) -&gt; Result&lt;()&gt; {
info!("Ensuring target base directory exists: {}", base_dir.display());
fs::create_dir_all(base_dir)
.with_context(|| format!("Failed to create base target directory: {}", base_dir.display()))?;
let folders_to_create: HashSet<String> = match organize_by {
OrganizeMethod::Category =&gt; {
let mut folders = categories_config
.map(|cfg| cfg.0.keys().cloned().collect::&lt;HashSet<String>&gt;())
.unwrap_or_default();
folders.insert("other".to_string());
folders.insert("no_extension".to_string());
folders
}
OrganizeMethod::Extension =&gt; {
let mut folders = all_extensions.cloned().unwrap_or_default();
folders.insert("no_extension".to_string());
folders
}
};
info!(
"Creating target subfolders (mode: {:?}). Total potential folders: {}",
organize_by,
folders_to_create.len()
);
let mut created_count = 0;
for folder_name in &amp;folders_to_create {
if folder_name.is_empty() { warn!("Skipping creation of folder with empty name."); continue; }
let folder_path = base_dir.join(folder_name);
if !folder_path.exists() {
fs::create_dir_all(&amp;folder_path).with_context(|| {
format!("Failed to create target folder '{}'", folder_path.display())
})?;
debug!("Created target folder: {}", folder_path.display());
created_count += 1;
}
}
info!("Created {} new target subfolders.", created_count);
Ok(())
}
/// Attempts to move a file, falling back to copy-then-delete on cross-device errors.
fn move_file_with_fallback(source: &amp;Path, target: &amp;Path) -&gt; io::Result&lt;()&gt; {
match fs::rename(source, target) {
Ok(_) =&gt; Ok(()),
Err(rename_error) =&gt; {
// Note: Relies on platform-specific OS error codes (Windows: 17, Unix: 18/libc::EXDEV). Might be brittle.
let is_cross_device = || -&gt; bool {
#[cfg(windows)] { rename_error.raw_os_error() == Some(17) }
#[cfg(unix)] { rename_error.raw_os_error() == Some(18) }
#[cfg(not(any(windows, unix)))] { false }
};
if is_cross_device() {
warn!("Rename failed (cross-device error detected), attempting copy+delete fallback for move: {} -&gt; {}", source.display(), target.display());
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source, target)?;
fs::remove_file(source)?;
Ok(())
} else { Err(rename_error) }
}
}
}
/// Main function to perform the file organization.
fn organize_files(args: &amp;CliArgs, categories_config: &amp;CategoriesConfig) -&gt; Result<ProcessStats> {
if !args.source.is_dir() { bail!("Source directory '{}' is invalid or not found.", args.source.display()); }
if !args.target.exists() {
info!("Creating target directory: {}", args.target.display());
fs::create_dir_all(&amp;args.target).with_context(|| format!("Could not create target directory '{}'", args.target.display()))?;
} else if !args.target.is_dir() { bail!("Target path '{}' exists but is not a directory.", args.target.display()); }
info!("Preparing target folders...");
let extensions_for_folders = if args.organize_by == OrganizeMethod::Extension {
Some(get_all_extensions(&amp;args.source, args.include_hidden, args.follow_links)?)
} else { None };
create_target_folders(&amp;args.target, &amp;args.organize_by, Some(categories_config), extensions_for_folders.as_ref())?;
info!("Starting file processing...");
let mut stats = ProcessStats::default();
let mut file_counter = 0u64;
let walker = WalkDir::new(&amp;args.source).follow_links(args.follow_links).into_iter();
for entry_result in walker.filter_entry(|e| should_keep_entry(e, args.include_hidden)) {
stats.total_scanned += 1; // Count filtered entries
let entry = match entry_result {
Ok(e) =&gt; e,
Err(e) =&gt; {
let path_display = e.path().unwrap_or_else(|| Path::new("?")).display();
error!("Error scanning path {}: {}", path_display, e);
stats.errors += 1;
// Provide default PathBuf if e.path() is None
stats.failed_files.push((
e.path().map_or_else(|| PathBuf::from("?"), |p| p.to_path_buf()),
format!("Scan error: {:?}", e),
));
continue;
}
};
if !entry.file_type().is_file() { stats.skipped += 1; continue; }
file_counter += 1;
let source_path = entry.path();
let progress_prefix = format!("[{}]", file_counter);
let file_result: Result&lt;()&gt; = (|| {
let file_name = source_path.file_name().with_context(|| format!("Could not get filename for path: {}", source_path.display()))?;
let target_subfolder_name = match args.organize_by {
OrganizeMethod::Category =&gt; categorize_file(source_path, categories_config),
OrganizeMethod::Extension =&gt; source_path.extension().and_then(|s| s.to_str()).map(|s| s.to_lowercase()).unwrap_or_else(|| "no_extension".to_string()),
};
let target_folder_path = args.target.join(&amp;target_subfolder_name);
let mut target_file_path = target_folder_path.join(file_name);
if target_file_path.exists() {
if args.skip_existing {
info!("{} Skipping (target exists): {}", progress_prefix, target_file_path.display());
stats.skipped += 1; return Ok(());
} else if args.timestamp_duplicates {
let original_target_path_display = target_file_path.display().to_string();
let mut counter = 1;
// Use file_name directly, it's already &amp;OsStr
let stem = source_path.file_stem().unwrap_or(file_name);
let ext = source_path.extension().unwrap_or_default();
const MAX_TIMESTAMP_ATTEMPTS: u32 = 1000;
loop {
let timestamp = Local::now().format("%Y%m%d_%H%M%S");
let mut new_name_os = std::ffi::OsString::new();
new_name_os.push(stem);
new_name_os.push(format!("_{}_{}", timestamp, counter));
if !ext.is_empty() { new_name_os.push("."); new_name_os.push(ext); }
target_file_path = target_folder_path.join(&amp;new_name_os);
if !target_file_path.exists() { break; }
counter += 1;
if counter &gt; MAX_TIMESTAMP_ATTEMPTS { bail!("Could not find unique timestamped name for {} after {} attempts. Skipping.", original_target_path_display, MAX_TIMESTAMP_ATTEMPTS); }
}
info!("{} Target exists '{}'. Renaming duplicate to: {}", progress_prefix, original_target_path_display, target_file_path.display());
} else if args.overwrite { warn!("{} Overwriting existing target file: {}", progress_prefix, target_file_path.display()); }
else { warn!("{} Overwriting existing target file (default): {}", progress_prefix, target_file_path.display()); }
}
fs::create_dir_all(&amp;target_folder_path).with_context(|| format!("Failed to ensure target directory '{}' exists", target_folder_path.display()))?;
let operation_desc = if args.move_files { "move" } else { "copy" };
debug!("{} Attempting to {} '{}' to '{}'", progress_prefix, operation_desc, source_path.display(), target_file_path.display());
if args.move_files {
move_file_with_fallback(source_path, &amp;target_file_path).with_context(|| format!("Failed to move '{}' to '{}'", source_path.display(), target_file_path.display()))?;
} else {
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source_path, &amp;target_file_path).map(|_| ()).with_context(|| format!("Failed to copy '{}' to '{}'", source_path.display(), target_file_path.display()))?;
}
stats.processed += 1;
Ok(())
})(); // End inner closure
if let Err(e) = file_result {
error!("{} Failed to process '{}': {:?}", progress_prefix, source_path.display(), e);
stats.errors += 1;
stats.failed_files.push((source_path.to_path_buf(), format!("{:?}", e)));
}
} // End main loop
Ok(stats)
}
/// Recursively removes empty folders starting from the bottom up.
fn remove_empty_folders(directory: &amp;Path) -&gt; Result<u32> {
let mut removed_count = 0u32;
info!("Attempting to remove empty directories within: {}", directory.display());
let mut dirs_to_check = Vec::new();
for entry_result in WalkDir::new(directory).min_depth(1) {
match entry_result {
Ok(entry) if entry.file_type().is_dir() =&gt; { dirs_to_check.push(entry.into_path()); }
Ok(_) =&gt; {}
Err(e) =&gt; warn!("Error accessing entry during empty dir scan: {}", e),
}
}
dirs_to_check.sort_by(|a, b| b.components().count().cmp(&amp;a.components().count()));
for dir_path in dirs_to_check {
if !dir_path.is_dir() { continue; }
match fs::read_dir(&amp;dir_path) {
Ok(mut read_dir) =&gt; {
if read_dir.next().is_none() { // Directory is empty
match fs::remove_dir(&amp;dir_path) {
Ok(_) =&gt; { info!("Removed empty directory: {}", dir_path.display()); removed_count += 1; }
Err(e) =&gt; { if e.kind() != ErrorKind::NotFound { warn!("Could not remove presumably empty directory '{}': {}", dir_path.display(), e); } }
}
}
}
Err(e) =&gt; { if e.kind() != ErrorKind::NotFound { warn!("Could not read directory '{}' to check emptiness: {}", dir_path.display(), e); } }
}
}
info!("Finished removing empty directories. Removed: {}", removed_count);
Ok(removed_count)
}
// --- Logging Setup ---
/// Sets up logging using the fern crate.
fn setup_logging(log_level: LevelFilter, log_file: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;()&gt; {
let colors = ColoredLevelConfig::new().error(Color::Red).warn(Color::Yellow).info(Color::Green).debug(Color::Blue).trace(Color::BrightBlack);
let base_config = fern::Dispatch::new()
.format(move |out, message, record| {
out.finish(format_args!(
"[{} {} {}] {}",
chrono::Local::now().format("%Y-%m-%d %H:%M:%S%.3f"), colors.color(record.level()), record.target(), message
))
})
.level(log_level)
.level_for("hyper", LevelFilter::Warn).level_for("mio", LevelFilter::Warn).level_for("want", LevelFilter::Warn).level_for("reqwest", LevelFilter::Warn).level_for("rustls", LevelFilter::Warn);
let stderr_logger = fern::Dispatch::new().filter(move |metadata| { log_level &lt;= LevelFilter::Debug || metadata.target().starts_with(env!("CARGO_PKG_NAME")) }).chain(std::io::stderr());
let mut final_dispatch = base_config.chain(stderr_logger);
let mut file_logger_ok = false;
if let Some(log_path) = log_file {
match fern::log_file(log_path) {
Ok(file_output) =&gt; { final_dispatch = final_dispatch.chain(file_output); file_logger_ok = true; }
Err(e) =&gt; { eprintln!("Error: Failed to create log file '{}': {}. Logging to console only.", log_path.display(), e); }
}
}
final_dispatch.apply().context("Failed to set up logging")?;
if file_logger_ok { if let Some(path) = log_file { info!("File logging enabled to: {}", path.display()); } }
Ok(())
}
// --- Main Application Entry Point ---
fn main() -&gt; Result&lt;()&gt; {
let overall_start_time = Instant::now(); // Start timing
let args = CliArgs::parse();
setup_logging(args.log_level, args.log_file.as_ref())?;
info!("Rust File Organizer (v{}) starting...", env!("CARGO_PKG_VERSION"));
debug!("Arguments received: {:?}", args);
info!("Source directory: {}", args.source.display());
info!("Target directory: {}", args.target.display());
info!("Organization mode: {:?}", args.organize_by);
info!("Operation: {}", if args.move_files { "Move" } else { "Copy" });
info!("Include hidden: {}", args.include_hidden);
info!("Follow links: {}", args.follow_links);
if args.skip_existing { info!("Duplicate handling: Skip existing"); }
else if args.timestamp_duplicates { info!("Duplicate handling: Timestamp duplicates"); }
else if args.overwrite { info!("Duplicate handling: Overwrite existing (explicitly)"); }
else { info!("Duplicate handling: Overwrite existing (default)"); }
let categories = load_config_file(args.config.as_ref())?;
let result = organize_files(&amp;args, &amp;categories);
match result {
Ok(stats) =&gt; {
if args.move_files &amp;&amp; args.remove_empty_source_dirs &amp;&amp; stats.processed &gt; 0 {
// Note: Cleanup errors are logged but do not cause a non-zero exit code.
if let Err(e) = remove_empty_folders(&amp;args.source) { error!("Error during empty source directory removal: {:?}", e); }
}
let overall_duration = overall_start_time.elapsed();
let summary = format!(
"Operation completed in {:.2?}. Scanned Entries: {}, Processed Files: {}, Skipped: {}, Errors: {}",
overall_duration, stats.total_scanned, stats.processed, stats.skipped, stats.errors
);
info!("{}", summary);
println!("\n{}", summary);
if stats.errors &gt; 0 {
eprintln!("\n--- Errors occurred during processing: ---");
for (path, error_msg) in &amp;stats.failed_files {
eprintln!(" - File: {}", path.display());
eprintln!("   Error: {}", error_msg);
}
eprintln!("-----------------------------------------");
eprintln!("Warning: {} errors occurred. Please check logs (stderr/file) for full details.", stats.errors);
// Consider exiting with non-zero status for scripting if errors occurred
// std::process::exit(1);
}
}
Err(e) =&gt; {
error!("Critical error during file organization: {:?}", e);
eprintln!("\nError: File organization failed critically. Check logs (stderr/file) for details.");
std::process::exit(1);
}
}
info!("Rust File Organizer finished.");
Ok(())
}
// --- Testing Notes ---
// To properly test this application, consider using crates like:
// - `assert_fs`: For creating temporary file/directory structures for tests.
// - `predicates`: For making assertions about file system state (e.g., file exists, content matches).
// - `assert_cmd`: For testing the command-line interface behavior, arguments, exit codes, and output.
//
// Example Test Scenarios (Conceptual):
// - Test basic copy/move by category and extension.
// - Test duplicate handling flags (skip, timestamp, overwrite) work correctly.
// - Test hidden file handling with and without the --include-hidden flag.
// - Test symbolic link handling with and without the --follow-links flag.
// - Test behavior with empty source or target directories.
// - Test custom configuration loading and verify correct categorization (including missing 'other').
// - Test empty directory removal after a successful move operation.
// - Test error handling for scenarios like insufficient permissions (harder to automate reliably).
// - Test long path handling specifically on Windows (requires careful test setup).
// - Test cross-device move fallback behavior.
// - Test handling of filenames with non-UTF8 characters (requires OsStr handling).


## python approach

```python
#!/usr/bin/env python3
import os
import shutil
import argparse
import json
import platform
import traceback
import logging
from datetime import datetime

# --- Default Configuration ---
DEFAULT_CATEGORIES_CONFIG = {
    "images": [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff", ".svg", ".ico"],
    "documents": [".pdf", ".docx", ".doc", ".txt", ".rtf", ".odt", ".xlsx", ".xls", ".csv", ".pptx", ".ppt", ".md", ".tex", ".chm", ".epub"],
    "videos": [".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm"],
    "audio": [".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a"],
    "archives": [".zip", ".rar", ".tar", ".gz", ".bz2", ".7z", ".iso"],
    "code": [".py", ".java", ".c", ".cpp", ".h", ".cs", ".html", ".css", ".js", ".ts", ".jsx", ".tsx", ".xml", ".json", ".yaml", ".yml", ".sh", ".bat", ".ps1", ".rb", ".php", ".go", ".rs", ".swift", ".kt", ".ipynb", ".sql", ".toml"],
    "apps": [".exe", ".msi", ".apk", ".dmg", ".deb", ".rpm", ".app"],
    "fonts": [".ttf", ".otf", ".woff", ".woff2"],
    "shortcuts": [".lnk", ".url"],
    "other": []
}

# --- Utility Functions ---

def setup_logging(log_file_path=None):
    """Configures logging to console and optionally to a file."""
    log_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger('file_organizer')
    logger.setLevel(logging.INFO) # Set base level

    # Console Handler (prints INFO and above)
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)
    logger.addHandler(console_handler)

    # File Handler (prints INFO and above if path provided)
    if log_file_path:
        try:
            file_handler = logging.FileHandler(log_file_path, mode='a', encoding='utf-8')
            file_handler.setFormatter(log_formatter)
            logger.addHandler(file_handler)
            logger.info(f"Logging initialized. Log file: {log_file_path}")
        except Exception as e:
            logger.error(f"Failed to initialize log file handler at {log_file_path}: {e}")

    return logger

def handle_long_path(path):
    """Prepends the long path prefix for Windows if necessary."""
    path = os.path.abspath(path)
    if platform.system() == "Windows" and len(path) &gt; 259 and not path.startswith("\\\\?\\"):
        path = "\\\\?\\" + path
    return path

def load_config_file(config_path, logger):
    """Loads category configuration from a JSON file."""
    if config_path and os.path.isfile(config_path):
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                logger.info(f"Loading category configuration from: {config_path}")
                return json.load(f)
        except (json.JSONDecodeError, OSError) as e:
            logger.warning(f"Could not load or parse config file '{config_path}': {e}. Using default categories.")
    else:
        logger.info("Using default category configuration.")
    return DEFAULT_CATEGORIES_CONFIG

def categorize_file(filename, categories_config):
    """Determines the category of a file based on its extension."""
    _, ext = os.path.splitext(filename)
    ext = ext.lower()
    if not ext:
        return "no_extension"
    for category, extensions in categories_config.items():
        if ext in extensions:
            return category
    return "other"

def is_hidden_windows(filepath):
    """Checks if a file or directory is hidden on Windows."""
    if platform.system() != "Windows":
        return False
    try:
        attrs = os.stat(filepath).st_file_attributes
        return attrs &amp; 2 # FILE_ATTRIBUTE_HIDDEN = 2
    except OSError:
        return False # Assume not hidden if stat fails

def create_target_folders(base_dir, organize_by, categories_config, all_extensions, logger):
    """Creates necessary target folders before processing files."""
    base_dir = handle_long_path(base_dir)
    logger.info(f"Ensuring target base directory exists: {base_dir}")
    os.makedirs(base_dir, exist_ok=True) # Ensure base exists first

    folders_to_create = set()
    if organize_by == "category":
        folders_to_create = set(categories_config.keys()) | {"other", "no_extension"}
    elif organize_by == "extension":
        folders_to_create = all_extensions | {"no_extension"}
    else:
        logger.error(f"Invalid organize_by option: {organize_by}")
        raise ValueError("Invalid organize_by option.")

    logger.info(f"Creating target subfolders ({organize_by})...")
    created_count = 0
    for folder_name in folders_to_create:
        folder_path = os.path.join(base_dir, folder_name)
        if not os.path.exists(folder_path):
            try:
                os.makedirs(folder_path, exist_ok=True)
                created_count += 1
            except OSError as e:
                 logger.error(f"Failed to create target folder '{folder_path}': {e}")
    logger.info(f"Created {created_count} new target subfolders.")


def get_all_extensions(source_directory, include_hidden, follow_links, logger):
    """Scans the source directory to find all unique file extensions."""
    extensions = set()
    source_directory = handle_long_path(source_directory)
    logger.info("Scanning for all unique file extensions...")
    count = 0
    for root, dirs, files in os.walk(source_directory, followlinks=follow_links):
        root_path = handle_long_path(root)
        if not include_hidden:
            dirs[:] = [d for d in dirs if not d.startswith('.') and not is_hidden_windows(os.path.join(root_path, d))]
            files = [f for f in files if not f.startswith('.') and not is_hidden_windows(os.path.join(root_path, f))]

        for file in files:
            count +=1
            _, ext = os.path.splitext(file)
            if ext:
                extensions.add(ext[1:].lower())
            if count % 1000 == 0: # Log progress for large scans
                 logger.info(f"Scanned {count} files for extensions...")

    logger.info(f"Found {len(extensions)} unique extensions.")
    return extensions


# --- Core Logic ---

def sort_files(
    source_directory,
    target_directory,
    organize_by,
    timestamp_duplicates,
    move_files,
    categories_config,
    include_hidden,
    follow_links,
    skip_existing,
    logger
):
    """Sorts files from source to target directory based on specified options."""
    source_directory = handle_long_path(source_directory)
    target_directory = handle_long_path(target_directory)

    if not os.path.isdir(source_directory):
        logger.error(f"Source directory '{source_directory}' is invalid or not found.")
        return 0, 0

    if not os.path.exists(target_directory):
        try:
            os.makedirs(target_directory)
            logger.info(f"Created target directory: {target_directory}")
        except OSError as e:
            logger.error(f"Could not create target directory '{target_directory}': {e}")
            return 0, 0
    elif not os.path.isdir(target_directory):
        logger.error(f"Target path '{target_directory}' exists but is not a directory.")
        return 0, 0

    # --- Pre-scan and Folder Creation ---
    total_files = 0
    files_to_process = []
    logger.info("Scanning source directory to count files...")
    for root, dirs, files in os.walk(source_directory, topdown=True, followlinks=follow_links):
        root_path = handle_long_path(root)
        original_dirs = list(dirs) # Keep original list for iteration if needed
        if not include_hidden:
            dirs[:] = [d for d in dirs if not d.startswith('.') and not is_hidden_windows(os.path.join(root_path, d))]
            files = [f for f in files if not f.startswith('.') and not is_hidden_windows(os.path.join(root_path, f))]

        for file in files:
            filepath = os.path.join(root_path, file)
            # Basic check if it's actually a file before adding
            try:
                 if os.path.isfile(filepath):
                      files_to_process.append(filepath)
                      total_files += 1
                 else:
                      logger.warning(f"Item listed as file is not a file (skipping count): {filepath}")
            except OSError as e:
                 logger.warning(f"Could not access item during scan (skipping count): {filepath} - Error: {e}")


    logger.info(f"Found {total_files} files to process.")
    if total_files == 0:
        logger.info("No files found to process.")
        return 0, 0

    if organize_by == "category":
        create_target_folders(target_directory, "category", categories_config, None, logger)
    elif organize_by == "extension":
        all_exts = get_all_extensions(source_directory, include_hidden, follow_links, logger)
        create_target_folders(target_directory, "extension", None, all_exts, logger)

    # --- Process Files ---
    processed_files = 0
    skipped_files = 0
    error_files = 0
    logger.info("Starting file processing...")

    for i, filepath in enumerate(files_to_process):
        filepath = handle_long_path(filepath)
        file = os.path.basename(filepath)
        progress_prefix = f"[{i+1}/{total_files}]"

        try:
            if not os.path.exists(filepath): # Re-check existence before processing
                logger.warning(f"{progress_prefix} Skipping non-existent source file: {filepath}")
                skipped_files += 1
                continue
            if not os.path.isfile(filepath): # Ensure it's still a file
                logger.warning(f"{progress_prefix} Skipping item that is not a file: {filepath}")
                skipped_files += 1
                continue

            # Determine target folder
            if organize_by == "category":
                category = categorize_file(file, categories_config)
                target_folder = os.path.join(target_directory, category)
            elif organize_by == "extension":
                _, ext = os.path.splitext(file)
                ext_folder = ext[1:].lower() if ext else "no_extension"
                target_folder = os.path.join(target_directory, ext_folder)
            else: # Should not happen
                 logger.error(f"{progress_prefix} Invalid organization option for file {file}. Skipping.")
                 error_files += 1
                 continue

            target_fullpath = os.path.join(target_folder, file)
            target_fullpath = handle_long_path(target_fullpath)

            # Handle existing target files
            if os.path.exists(target_fullpath):
                if skip_existing:
                    logger.info(f"{progress_prefix} Skipping existing target: {target_fullpath}")
                    skipped_files += 1
                    continue
                elif timestamp_duplicates:
                    counter = 1
                    base, ext = os.path.splitext(file)
                    original_target_fullpath = target_fullpath # Store for logging
                    while os.path.exists(target_fullpath):
                        stamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                        new_name = f"{base}_{stamp}_{counter}{ext}"
                        target_fullpath = os.path.join(target_folder, new_name)
                        target_fullpath = handle_long_path(target_fullpath)
                        counter += 1
                    logger.info(f"{progress_prefix} Target exists '{original_target_fullpath}'. Renaming duplicate to: {target_fullpath}")
                else:
                    logger.warning(f"{progress_prefix} Overwriting existing target file: {target_fullpath}")
                    # Overwrite happens implicitly

            # Perform file operation
            try:
                if move_files:
                    shutil.move(filepath, target_fullpath)
                    # logger.info(f"{progress_prefix} Moved: {file} -&gt; {target_folder}") # Verbose
                else:
                    shutil.copy2(filepath, target_fullpath) # copy2 preserves metadata
                    # logger.info(f"{progress_prefix} Copied: {file} -&gt; {target_folder}") # Verbose
                processed_files += 1
            except (OSError, shutil.Error) as e: # Catch specific shutil errors too
                logger.error(f"{progress_prefix} Failed to {'move' if move_files else 'copy'} '{filepath}' to '{target_fullpath}': {e}")
                error_files += 1
            except Exception as e: # Catch any other unexpected error during file op
                 logger.error(f"{progress_prefix} Unexpected error processing '{filepath}' -&gt; '{target_fullpath}': {e}", exc_info=True) # Log traceback
                 error_files += 1

        except Exception as e: # Catch errors during path manipulation, categorization etc.
            logger.error(f"{progress_prefix} Unexpected error processing path '{filepath}': {e}", exc_info=True)
            error_files += 1

        # Optional: Print live progress to console (can be noisy)
        # print(f"Progress: {i+1}/{total_files} (P: {processed_files}, S: {skipped_files}, E: {error_files})", end="\r")


    # Final Summary
    summary = f"File organization completed. Processed: {processed_files}, Skipped: {skipped_files}, Errors: {error_files}"
    logger.info(summary)
    print(f"\n{summary}") # Also print final summary to console
    return processed_files, skipped_files + error_files

def remove_empty_folders(directory, logger):
    """Recursively removes empty folders starting from the bottom up."""
    directory = handle_long_path(directory)
    removed_count = 0
    logger.info(f"Attempting to remove empty directories from: {directory}")
    # Walk from bottom up
    for root, dirs, files in os.walk(directory, topdown=False):
        root_path = handle_long_path(root)
        # Consider hidden status if needed, but generally just check emptiness
        if not files and not dirs: # Directory is empty
            try:
                os.rmdir(root_path)
                logger.info(f"Removed empty directory: {root_path}")
                removed_count += 1
            except OSError as e:
                # Common errors: permission denied, directory not empty (race condition?)
                logger.warning(f"Could not remove directory '{root_path}': {e}")
            except Exception as e:
                 logger.error(f"Unexpected error removing directory '{root_path}': {e}", exc_info=True)

    logger.info(f"Finished removing empty directories. Removed: {removed_count}")


# --- Main Execution ---

def main():
    parser = argparse.ArgumentParser(
        description="Organize files by category or extension.",
        formatter_class=argparse.RawTextHelpFormatter
        )
    parser.add_argument("--source", "-s", required=True, help="Source directory containing files to organize.")
    parser.add_argument("--target", "-t", required=True, help="Target directory where organized files will be placed.")
    parser.add_argument("--config", "-c", help="Path to JSON config file for custom file categories and extensions.")
    parser.add_argument(
        "--organize-by", choices=["category", "extension"], default="category",
        help="Method for organizing files:\n"
             "  category: Group into folders based on categories (default).\n"
             "  extension: Group into folders named after file extensions."
        )
    parser.add_argument("--move", action="store_true", help="Move files instead of copying them.")
    parser.add_argument("--timestamp-duplicates", action="store_true", help="Append timestamp+counter to duplicate filenames instead of overwriting/skipping.")
    parser.add_argument("--skip-existing", action="store_true", help="Skip processing if a file with the same name exists in the target.")
    parser.add_argument("--include-hidden", action="store_true", help="Include hidden files/folders (e.g., starting with '.') in processing.")
    parser.add_argument("--follow-links", action="store_true", help="Follow symbolic links (process target, not link). Use with caution (potential loops).")
    parser.add_argument("--remove-empty-source-dirs", action="store_true", help="After moving (--move must be enabled), attempt to remove empty source directories.")
    parser.add_argument("--log-file", help="Optional path to a file for logging progress and errors.")

    args = parser.parse_args()

    # --- Argument Validation ---
    if args.timestamp_duplicates and args.skip_existing:
        parser.error("--timestamp-duplicates and --skip-existing cannot be used together.")
    if args.remove_empty_source_dirs and not args.move:
        parser.error("--remove-empty-source-dirs requires --move to be enabled.")

    # --- Setup ---
    logger = setup_logging(args.log_file)
    logger.info("Script starting...")
    logger.info(f"Arguments: {vars(args)}") # Log arguments used

    categories = load_config_file(args.config, logger)

    # --- Execute Sorting ---
    processed, failed_or_skipped = sort_files(
        source_directory=args.source,
        target_directory=args.target,
        organize_by=args.organize_by,
        timestamp_duplicates=args.timestamp_duplicates,
        move_files=args.move,
        categories_config=categories,
        include_hidden=args.include_hidden,
        follow_links=args.follow_links,
        skip_existing=args.skip_existing,
        logger=logger
    )

    # --- Optional Cleanup ---
    if args.move and args.remove_empty_source_dirs and processed &gt; 0:
        remove_empty_folders(args.source, logger)

    logger.info("Script finished.")
    print("\nScript finished. Check console and log file (if specified) for details.")

if __name__ == "__main__":
    main()
```
</u32></ProcessStats></String></String></String></String></PathBuf></PathBuf></bool></bool></String></CategoriesConfig></String></code></section>

        </div>
        
          URL: https://ib.bsb.br/files-by-type
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/tasks-mermaid/" title="Task Prioritization" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/dup-spotter/" title="Copy Spotter and Duplicate-File-Remover" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts>rust"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts-rust" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/files-by-type/" title="Organize files by type" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts>python"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts-python" style="display: none;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/f2p/" title="files to prompt (f2p)" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="/list-senders/" title="List sender's email addresses from Gmail unread messages" rel="next">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-04-08 08:16:24
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scripts-rust">
                  scripts>rust
                </a>
              </li>
            
          
            
            
              <li>
                <a href="#" class="tag-option " data-tag="scripts-python">
                  scripts>python
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/files-by-type/"
        },
        "headline": "Organize files by type",
        "description": "",
        "datePublished": "2024-05-30T00:00:00+00:00",
        "dateModified": "2025-04-08T10:26:27+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
