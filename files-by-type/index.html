<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Organize files by type - infoBAG
      
    </title>
    <meta name="title" content="Organize files by type - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/files-by-type/">
    <meta property="og:title" content="Organize files by type - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/files-by-type/">
    <meta name="twitter:title" content="Organize files by type - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/files-by-type/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scripts&gt;rust">
      
        <meta property="article:tag" content="scripts&gt;rust">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Organize files by type
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2024-05-30T00:00:00+00:00" class="post-date">
          30 May 2024
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-04-07T21:19:29+00:00">
              07 Apr 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/files-by-type" class="tag">files-by-type</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scripts-rust" class="tag">scripts>rust</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        46292 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        5292 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-05-30-files-by-type.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-05-30-files-by-type.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#building-and-running-the-file-organizer-on-windows">Building and Running the File Organizer on Windows</a><ul><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#creating-the-project">Creating the Project</a></li><li><a href="#building-the-project">Building the Project</a><ul><li><a href="#debug-build-for-development">Debug Build (For Development)</a></li><li><a href="#release-build-for-distribution">Release Build (For Distribution)</a></li></ul></li><li><a href="#running-the-tool">Running the Tool</a><ul><li><a href="#getting-help">Getting Help</a></li><li><a href="#usage-examples">Usage Examples</a><ul><li><a href="#basic-file-organization">Basic File Organization</a></li><li><a href="#moving-files-with-duplicate-handling">Moving Files with Duplicate Handling</a></li><li><a href="#organizing-by-file-extension">Organizing by File Extension</a></li><li><a href="#advanced-configuration">Advanced Configuration</a></li></ul></li></ul></li><li><a href="#common-options-reference">Common Options Reference</a></li><li><a href="#testing-your-installation">Testing Your Installation</a></li></ul></li><li><a href="#cargotoml-based-on-approach-3-with-updated-comments">Cargo.toml (Based on Approach 3, with updated comments)</a></li><li><a href="#command-line-argument-parsing">Command-line argument parsing</a></li><li><a href="#directory-traversal">Directory traversal</a></li><li><a href="#json-parsing-for-configuration-files">JSON parsing for configuration files</a></li><li><a href="#logging-framework">Logging framework</a></li><li><a href="#using-fern-for-flexible-fileconsole-logging-setup">Using fern for flexible file/console logging setup</a></li><li><a href="#date-and-time-handling-for-timestamps">Date and time handling for timestamps</a></li><li><a href="#flexible-error-handling-and-context-reporting">Flexible error handling and context reporting</a></li><li><a href="#optional-more-robust-file-operations-especially-cross-device-move">Optional: More robust file operations (especially cross-device move)</a></li><li><a href="#fs_extra--13--keep-commented-unless-needed-std-lib-fallback-implemented">fs_extra = “1.3” # Keep commented unless needed; std lib fallback implemented</a></li><li><a href="#windows-specific-dependencies-are-not-needed-here-as-std-lib-is-used-for-hidden-check">Windows-specific dependencies are NOT needed here as std lib is used for hidden check</a></li><li><a href="#targetcfgwindowsdependencies">[target.’cfg(windows)’.dependencies]</a></li><li><a href="#windows---version--056-features---">windows = { version = “0.56”, features = […] }</a></li><li><a href="#release-profile-optimizations-optional-but-recommended-for-smallerfaster-executables">Release profile optimizations (optional but recommended for smaller/faster executables)</a></li><li><a href="#z-optimizes-aggressively-for-size-potentially-sacrificing-some-speed-compared-to-s-or-3">‘z’ optimizes aggressively for size, potentially sacrificing some speed compared to ‘s’ or ‘3’.</a></li><li><a href="#enable-link-time-optimization-across-crates-for-potential-performance-gains-and-size-reduction">Enable Link-Time Optimization across crates for potential performance gains and size reduction.</a></li><li><a href="#maximize-optimization-opportunities-by-using-a-single-codegen-unit-can-significantly-increase-compile-times">Maximize optimization opportunities by using a single codegen unit (can significantly increase compile times).</a></li><li><a href="#remove-symbols-from-the-binary-for-smaller-size">Remove symbols from the binary for smaller size.</a></li><li><a href="#alternatively-use-cargo-strip-requires-cargo-install-cargo-strip-or-set-debuginfo--0-removes-debug-symbols-only">Alternatively, use <code class="language-plaintext highlighter-rouge">cargo strip</code> (requires <code class="language-plaintext highlighter-rouge">cargo install cargo-strip</code>) or set <code class="language-plaintext highlighter-rouge">debuginfo = 0</code> (removes debug symbols only).</a></li><li><a href="#abort-on-panic-instead-of-unwinding-the-stack-reduces-binary-size-but-prevents-catching-panics">Abort on panic instead of unwinding the stack. Reduces binary size but prevents catching panics.</a></li></ul>
          <h1 id="building-and-running-the-file-organizer-on-windows">
    
    
     <a href="#building-and-running-the-file-organizer-on-windows">#</a><a href="#" aria-label="Back to top">Building and Running the File Organizer on Windows</a>
        
    
  </h1>
      
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<p>Before you begin, you need to install Rust:</p>

<ol>
  <li>Visit <a href="https://rustup.rs/">https://rustup.rs/</a> to download the Rust installer</li>
  <li>Run the installer to set up:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">rustc</code> (the compiler)</li>
      <li><code class="language-plaintext highlighter-rouge">cargo</code> (the build tool and package manager)</li>
    </ul>
  </li>
</ol>
  <h2 id="creating-the-project">
    
    
     <a href="#creating-the-project">#</a><a href="#" aria-label="Back to top">Creating the Project</a>
        
    
  </h2>
      

<p>Open a command prompt and run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c"># Create a new Rust project</span>
cargo new file_organizer_rs
<span class="nb">cd </span>file_organizer_rs

<span class="c"># Replace default files with project files</span>
<span class="c"># Replace the contents of Cargo.toml with the provided configuration</span>
<span class="c"># Replace the contents of src/main.rs with the provided source code</span>
</code></section></div></div>
  <h2 id="building-the-project">
    
    
     <a href="#building-the-project">#</a><a href="#" aria-label="Back to top">Building the Project</a>
        
    
  </h2>
      
  <h3 id="debug-build-for-development">
    
    
     <a href="#debug-build-for-development">#</a><a href="#" aria-label="Back to top">Debug Build (For Development)</a>
        
    
  </h3>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo build
</code></section></div></div>

<p>The executable will be created in the <code class="language-plaintext highlighter-rouge">target/debug/</code> directory.</p>
  <h3 id="release-build-for-distribution">
    
    
     <a href="#release-build-for-distribution">#</a><a href="#" aria-label="Back to top">Release Build (For Distribution)</a>
        
    
  </h3>
      

<p>For a smaller, optimized executable:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo build <span class="nt">--release</span>
</code></section></div></div>

<p>The executable will be created in the <code class="language-plaintext highlighter-rouge">target/release/</code> directory.</p>
  <h2 id="running-the-tool">
    
    
     <a href="#running-the-tool">#</a><a href="#" aria-label="Back to top">Running the Tool</a>
        
    
  </h2>
      
  <h3 id="getting-help">
    
    
     <a href="#getting-help">#</a><a href="#" aria-label="Back to top">Getting Help</a>
        
    
  </h3>
      

<p>View all available options:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--help</span>
</code></section></div></div>
  <h3 id="usage-examples">
    
    
     <a href="#usage-examples">#</a><a href="#" aria-label="Back to top">Usage Examples</a>
        
    
  </h3>
      
  <h4 id="basic-file-organization">
    
    
     <a href="#basic-file-organization">#</a><a href="#" aria-label="Back to top">Basic File Organization</a>
        
    
  </h4>
      

<p>Copy files by category from Downloads to an organized folder:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--source</span> C:<span class="se">\U</span>sers<span class="se">\Y</span>ourUser<span class="se">\D</span>ownloads <span class="nt">--target</span> C:<span class="se">\O</span>rganizedFiles
</code></section></div></div>
  <h4 id="moving-files-with-duplicate-handling">
    
    
     <a href="#moving-files-with-duplicate-handling">#</a><a href="#" aria-label="Back to top">Moving Files with Duplicate Handling</a>
        
    
  </h4>
      

<p>Move files from Downloads, adding timestamps to duplicates:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--source</span> C:<span class="se">\U</span>sers<span class="se">\Y</span>ourUser<span class="se">\D</span>ownloads <span class="nt">--target</span> C:<span class="se">\O</span>rganizedFiles <span class="nt">--move</span> <span class="nt">--timestamp-duplicates</span>
</code></section></div></div>
  <h4 id="organizing-by-file-extension">
    
    
     <a href="#organizing-by-file-extension">#</a><a href="#" aria-label="Back to top">Organizing by File Extension</a>
        
    
  </h4>
      

<p>Organize files by extension, including hidden files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> <span class="s2">"C:</span><span class="se">\P</span><span class="s2">ath</span><span class="se">\T</span><span class="s2">o</span><span class="se">\S</span><span class="s2">ource"</span> <span class="nt">-t</span> <span class="s2">"C:</span><span class="se">\P</span><span class="s2">ath</span><span class="se">\T</span><span class="s2">o</span><span class="se">\T</span><span class="s2">arget"</span> <span class="nt">--organize-by</span> extension <span class="nt">--include-hidden</span>
</code></section></div></div>
  <h4 id="advanced-configuration">
    
    
     <a href="#advanced-configuration">#</a><a href="#" aria-label="Back to top">Advanced Configuration</a>
        
    
  </h4>
      

<p>Use a custom configuration file and log all activity:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> .<span class="se">\i</span>nput <span class="nt">-t</span> .<span class="se">\o</span>utput <span class="nt">-c</span> .<span class="se">\m</span>y_config.json <span class="nt">--log-file</span> activity.log <span class="nt">--overwrite</span>
</code></section></div></div>
  <h2 id="common-options-reference">
    
    
     <a href="#common-options-reference">#</a><a href="#" aria-label="Back to top">Common Options Reference</a>
        
    
  </h2>
      

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Short</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--source</code></td>
      <td><code class="language-plaintext highlighter-rouge">-s</code></td>
      <td>Source directory to organize files from</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--target</code></td>
      <td><code class="language-plaintext highlighter-rouge">-t</code></td>
      <td>Target directory to place organized files</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--move</code></td>
      <td> </td>
      <td>Move files instead of copying them</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--organize-by</code></td>
      <td> </td>
      <td>Organization method (extension or category)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--timestamp-duplicates</code></td>
      <td> </td>
      <td>Add timestamp to duplicate files</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--include-hidden</code></td>
      <td><code class="language-plaintext highlighter-rouge">-i</code></td>
      <td>Include hidden files and directories</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--overwrite</code></td>
      <td> </td>
      <td>Overwrite existing files in target</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--config</code></td>
      <td><code class="language-plaintext highlighter-rouge">-c</code></td>
      <td>Path to custom configuration file</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--log-file</code></td>
      <td> </td>
      <td>Write logs to specified file</td>
    </tr>
  </tbody>
</table>
  <h2 id="testing-your-installation">
    
    
     <a href="#testing-your-installation">#</a><a href="#" aria-label="Back to top">Testing Your Installation</a>
        
    
  </h2>
      

<p>After building, verify your installation works by running a simple test:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c"># Create test directories</span>
<span class="nb">mkdir </span>test_source test_target

<span class="c"># Copy some test files to test_source</span>
<span class="c"># Then run the organizer</span>
.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> .<span class="se">\t</span>est_source <span class="nt">-t</span> .<span class="se">\t</span>est_target
</code></section></div></div>

<p>{% codeblock toml %}</p>
  <h1 id="cargotoml-based-on-approach-3-with-updated-comments">
    
    
     <a href="#cargotoml-based-on-approach-3-with-updated-comments">#</a><a href="#" aria-label="Back to top">Cargo.toml (Based on Approach 3, with updated comments)</a>
        
    
  </h1>
      
<p>[package]
name = “rust_file_organizer”
version = “0.1.0”
edition = “2021”
description = “A Rust utility for organizing files by category or extension.”
authors = [“AI Assistant”] # Replace with actual author
license = “MIT OR Apache-2.0” # Choose appropriate license</p>

<p>[dependencies]</p>
  <h1 id="command-line-argument-parsing">
    
    
     <a href="#command-line-argument-parsing">#</a><a href="#" aria-label="Back to top">Command-line argument parsing</a>
        
    
  </h1>
      
<p>clap = { version = “4.5”, features = [“derive”, “cargo”, “env”] } # cargo/env features allow reading from Cargo.toml/env vars</p>
  <h1 id="directory-traversal">
    
    
     <a href="#directory-traversal">#</a><a href="#" aria-label="Back to top">Directory traversal</a>
        
    
  </h1>
      
<p>walkdir = “2.5”</p>
  <h1 id="json-parsing-for-configuration-files">
    
    
     <a href="#json-parsing-for-configuration-files">#</a><a href="#" aria-label="Back to top">JSON parsing for configuration files</a>
        
    
  </h1>
      
<p>serde = { version = “1.0”, features = [“derive”] }
serde_json = “1.0”</p>
  <h1 id="logging-framework">
    
    
     <a href="#logging-framework">#</a><a href="#" aria-label="Back to top">Logging framework</a>
        
    
  </h1>
      
<p>log = “0.4”</p>
  <h1 id="using-fern-for-flexible-fileconsole-logging-setup">
    
    
     <a href="#using-fern-for-flexible-fileconsole-logging-setup">#</a><a href="#" aria-label="Back to top">Using fern for flexible file/console logging setup</a>
        
    
  </h1>
      
<p>fern = “0.6”</p>
  <h1 id="date-and-time-handling-for-timestamps">
    
    
     <a href="#date-and-time-handling-for-timestamps">#</a><a href="#" aria-label="Back to top">Date and time handling for timestamps</a>
        
    
  </h1>
      
<p>chrono = “0.4”</p>
  <h1 id="flexible-error-handling-and-context-reporting">
    
    
     <a href="#flexible-error-handling-and-context-reporting">#</a><a href="#" aria-label="Back to top">Flexible error handling and context reporting</a>
        
    
  </h1>
      
<p>anyhow = “1.0”</p>
  <h1 id="optional-more-robust-file-operations-especially-cross-device-move">
    
    
     <a href="#optional-more-robust-file-operations-especially-cross-device-move">#</a><a href="#" aria-label="Back to top">Optional: More robust file operations (especially cross-device move)</a>
        
    
  </h1>
      
  <h1 id="fs_extra--13--keep-commented-unless-needed-std-lib-fallback-implemented">
    
    
     <a href="#fs_extra--13--keep-commented-unless-needed-std-lib-fallback-implemented">#</a><a href="#" aria-label="Back to top">fs_extra = “1.3” # Keep commented unless needed; std lib fallback implemented</a>
        
    
  </h1>
      
  <h1 id="windows-specific-dependencies-are-not-needed-here-as-std-lib-is-used-for-hidden-check">
    
    
     <a href="#windows-specific-dependencies-are-not-needed-here-as-std-lib-is-used-for-hidden-check">#</a><a href="#" aria-label="Back to top">Windows-specific dependencies are NOT needed here as std lib is used for hidden check</a>
        
    
  </h1>
      
  <h1 id="targetcfgwindowsdependencies">
    
    
     <a href="#targetcfgwindowsdependencies">#</a><a href="#" aria-label="Back to top">[target.’cfg(windows)’.dependencies]</a>
        
    
  </h1>
      
  <h1 id="windows---version--056-features---">
    
    
     <a href="#windows---version--056-features---">#</a><a href="#" aria-label="Back to top">windows = { version = “0.56”, features = […] }</a>
        
    
  </h1>
      
  <h1 id="release-profile-optimizations-optional-but-recommended-for-smallerfaster-executables">
    
    
     <a href="#release-profile-optimizations-optional-but-recommended-for-smallerfaster-executables">#</a><a href="#" aria-label="Back to top">Release profile optimizations (optional but recommended for smaller/faster executables)</a>
        
    
  </h1>
      
<p>[profile.release]</p>
  <h1 id="z-optimizes-aggressively-for-size-potentially-sacrificing-some-speed-compared-to-s-or-3">
    
    
     <a href="#z-optimizes-aggressively-for-size-potentially-sacrificing-some-speed-compared-to-s-or-3">#</a><a href="#" aria-label="Back to top">‘z’ optimizes aggressively for size, potentially sacrificing some speed compared to ‘s’ or ‘3’.</a>
        
    
  </h1>
      
<p>opt-level = ‘z’</p>
  <h1 id="enable-link-time-optimization-across-crates-for-potential-performance-gains-and-size-reduction">
    
    
     <a href="#enable-link-time-optimization-across-crates-for-potential-performance-gains-and-size-reduction">#</a><a href="#" aria-label="Back to top">Enable Link-Time Optimization across crates for potential performance gains and size reduction.</a>
        
    
  </h1>
      
<p>lto = true</p>
  <h1 id="maximize-optimization-opportunities-by-using-a-single-codegen-unit-can-significantly-increase-compile-times">
    
    
     <a href="#maximize-optimization-opportunities-by-using-a-single-codegen-unit-can-significantly-increase-compile-times">#</a><a href="#" aria-label="Back to top">Maximize optimization opportunities by using a single codegen unit (can significantly increase compile times).</a>
        
    
  </h1>
      
<p>codegen-units = 1</p>
  <h1 id="remove-symbols-from-the-binary-for-smaller-size">
    
    
     <a href="#remove-symbols-from-the-binary-for-smaller-size">#</a><a href="#" aria-label="Back to top">Remove symbols from the binary for smaller size.</a>
        
    
  </h1>
      
  <h1 id="alternatively-use-cargo-strip-requires-cargo-install-cargo-strip-or-set-debuginfo--0-removes-debug-symbols-only">
    
    
     <a href="#alternatively-use-cargo-strip-requires-cargo-install-cargo-strip-or-set-debuginfo--0-removes-debug-symbols-only">#</a><a href="#" aria-label="Back to top">Alternatively, use <code class="language-plaintext highlighter-rouge">cargo strip</code> (requires <code class="language-plaintext highlighter-rouge">cargo install cargo-strip</code>) or set <code class="language-plaintext highlighter-rouge">debuginfo = 0</code> (removes debug symbols only).</a>
        
    
  </h1>
      
<p>strip = true</p>
  <h1 id="abort-on-panic-instead-of-unwinding-the-stack-reduces-binary-size-but-prevents-catching-panics">
    
    
     <a href="#abort-on-panic-instead-of-unwinding-the-stack-reduces-binary-size-but-prevents-catching-panics">#</a><a href="#" aria-label="Back to top">Abort on panic instead of unwinding the stack. Reduces binary size but prevents catching panics.</a>
        
    
  </h1>
      
<p>panic = ‘abort’</p>

<p>{% endcodeblock %}</p>

<p>{% codeblock rust %}</p>

<p>// src/main.rs: Rust implementation of the file organizer utility.
// This version incorporates improvements based on self-critique:
// - Uses fern for flexible logging (console + optional file).
// - Uses anyhow for error handling with context.
// - Uses std lib for platform-specific hidden file checks.
// - Uses clap ValueEnum for argument validation.
// - Implements explicit –overwrite flag and robust duplicate handling.
// - Implements robust move operation with cross-device fallback.
// - Reports list of failed files WITH error context.
// - Includes more detailed comments.
// - Correctly calculates execution duration.
// - Safely excludes entries where hidden status check fails.
// - Clarified meaning of <code class="language-plaintext highlighter-rouge">total_scanned</code> statistic.</p>

<p>use anyhow::{bail, Context, Result}; // Use anyhow for convenient error handling
use clap::Parser; // For command-line argument parsing
use chrono::Local; // For generating timestamps
use fern::colors::{Color, ColoredLevelConfig}; // For colored logging output
use log::{debug, error, info, warn, LevelFilter}; // Logging facade
use serde::Deserialize; // For deserializing JSON config
use std::{
    collections::{HashMap, HashSet},
    env, // For CARGO_PKG_VERSION
    fs::{self, File}, // Standard file system operations
    io::{self, ErrorKind},
    path::{Path, PathBuf},
    time::Instant, // For accurate duration measurement
};
use walkdir::{DirEntry, WalkDir}; // For efficient directory traversal</p>

<p>// — Configuration Structures —</p>

<p>/// Represents the structure of the JSON configuration file for categories.
/// Using a tuple struct for better type safety than just HashMap directly.
#[derive(Deserialize, Debug, Clone)]
struct CategoriesConfig(HashMap&lt;String, Vec<String>&gt;);</String></p>

<p>/// Provides the default file categorization configuration.
/// This is used if no custom config file is provided or if loading fails.
fn default_categories() -&gt; CategoriesConfig {
    let mut map = HashMap::new();
    // Helper macro to reduce boilerplate when defining default categories
    macro_rules! add_category {
        ($map:expr, $name:expr, [$($ext:expr),* $(,)?]) =&gt; {
            // Inserts a category name and its associated list of lowercase extensions (including ‘.’)
            $map.insert($name.to_string(), vec![$($ext.to_string()),*]);
        };
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// Define standard categories and their common extensions
add_category!(map, "images", [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff", ".svg", ".ico"]);
add_category!(map, "documents", [".pdf", ".docx", ".doc", ".txt", ".rtf", ".odt", ".xlsx", ".xls", ".csv", ".pptx", ".ppt", ".md", ".tex", ".chm", ".epub"]);
add_category!(map, "videos", [".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm"]);
add_category!(map, "audio", [".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a"]);
add_category!(map, "archives", [".zip", ".rar", ".tar", ".gz", ".bz2", ".7z", ".iso"]);
add_category!(map, "code", [".py", ".java", ".c", ".cpp", ".h", ".cs", ".html", ".css", ".js", ".ts", ".jsx", ".tsx", ".xml", ".json", ".yaml", ".yml", ".sh", ".bat", ".ps1", ".rb", ".php", ".go", ".rs", ".swift", ".kt", ".ipynb", ".sql", ".toml"]);
add_category!(map, "apps", [".exe", ".msi", ".apk", ".dmg", ".deb", ".rpm", ".app"]);
add_category!(map, "fonts", [".ttf", ".otf", ".woff", ".woff2"]);
add_category!(map, "shortcuts", [".lnk", ".url"]);
// Ensure the essential "other" category exists for files that don't match any other category.
map.insert("other".to_string(), vec![]);
CategoriesConfig(map) }
</code></section></div></div>

<p>/// Loads category configuration from a specified JSON file path.
/// Falls back to default categories if the path is None, the file doesn’t exist,
/// or parsing fails. Ensures the ‘other’ category is present in the loaded config.
fn load_config_file(config_path: Option&lt;&amp;PathBuf&gt;) -&gt; Result<CategoriesConfig> {
    match config_path {
        Some(path) if path.is_file() =&gt; {
            // Attempt to load and parse the custom configuration file
            info!("Loading category configuration from: {}", path.display());
            let file_content = fs::read_to_string(path)
                .with_context(|| format!("Failed to read config file: {}", path.display()))?;
            let mut config: HashMap&lt;String, Vec<String>&gt; = serde_json::from_str(&amp;file_content)
                .with_context(|| format!("Failed to parse JSON config file: {}", path.display()))?;</String></CategoriesConfig></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>        // Ensure 'other' category exists for fallback mechanism.
        // If the user provided a config without 'other', add it automatically.
        config.entry("other".to_string()).or_insert_with(Vec::new);
        info!("Successfully loaded and validated custom configuration.");
        Ok(CategoriesConfig(config))
    }
    Some(path) =&gt; {
        // Path specified but it's not a file (or doesn't exist)
        warn!(
            "Config path '{}' provided but is not a valid file. Using default categories.",
            path.display()
        );
        Ok(default_categories())
    }
    None =&gt; {
        // No config path provided, use defaults
        info!("No config file specified. Using default category configuration.");
        Ok(default_categories())
    }
} }
</code></section></div></div>

<p>/// Determines the category name (String) for a given file based on its extension
/// and the provided category configuration.
fn categorize_file(filename: &amp;Path, categories_config: &amp;CategoriesConfig) -&gt; String {
    // Extract extension, prepend ‘.’, convert to lowercase for case-insensitive matching.
    let extension = filename
        .extension()
        .and_then(|s| s.to_str()) // Convert OsStr to &amp;str, returns None if not valid UTF-8
        .map(|s| format!(“.{}”, s.to_lowercase()))
        .unwrap_or_else(|| “no_extension”.to_string()); // Handle files with no extension or non-UTF8 extensions</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// Handle files with no extension explicitly
if extension == "no_extension" {
    return extension;
}

// Iterate through the configured categories and their associated extensions.
for (category, extensions) in &amp;categories_config.0 {
    // Check if the file's extension is present in the list for this category
    if extensions.contains(&amp;extension) {
        return category.clone(); // Return the matching category name
    }
}

// If no specific category matched, fallback to the "other" category.
// load_config_file ensures the "other" key exists in the HashMap.
"other".to_string() }
</code></section></div></div>

<p>// — Platform Specific —</p>

<p>/// Checks if a file or directory is hidden on Windows using standard library features.
#[cfg(windows)]
fn is_hidden(path: &amp;Path) -&gt; Result<bool> {
    use std::os::windows::fs::MetadataExt;
    // Use the standard library extension trait for a safer abstraction than raw Win32 calls
    let metadata = fs::metadata(path)
        .with_context(|| format!("Failed to get metadata for {}", path.display()))?;
    // Get the raw file attributes bitfield
    let attributes = metadata.file_attributes();
    // Check if the FILE_ATTRIBUTE_HIDDEN bit is set
    Ok((attributes &amp; std::os::windows::fs::FILE_ATTRIBUTE_HIDDEN) != 0)
}</bool></p>

<p>/// Checks if a file or directory is hidden on Unix-like systems (conventionally, starts with ‘.’).
#[cfg(not(windows))]
fn is_hidden(path: &amp;Path) -&gt; Result<bool> {
    // Standard check for hidden files/dirs on Unix-like systems.
    Ok(path
        .file_name()
        .and_then(|s| s.to_str()) // Get filename as string slice
        .map(|s| s.starts_with('.')) // Check if it starts with '.'
        .unwrap_or(false)) // If no filename or not UTF-8, assume not hidden by this convention
}</bool></p>

<p>/// Helper for walkdir filter_entry to check hidden status before descending into directories or processing files.
/// Logs errors but doesn’t stop the walk; returns <code class="language-plaintext highlighter-rouge">true</code> if entry should be kept (i.e., not hidden or check failed).
/// <strong>Improvement:</strong> Defaults to excluding (<code class="language-plaintext highlighter-rouge">false</code>) if the check fails, for safety.
fn should_keep_entry(entry: &amp;DirEntry, include_hidden: bool) -&gt; bool {
    if include_hidden {
        return true; // Keep everything if –include-hidden flag is set
    }
    // Otherwise, check the hidden status
    match is_hidden(entry.path()) {
        Ok(hidden) =&gt; !hidden, // Keep if NOT hidden
        Err(err) =&gt; {
            // Log the error but default to <em>excluding</em> the entry for safety if status is unknown
            warn!(
                “Could not determine hidden status for {}: {}. Excluding entry.”,
                entry.path().display(), err
            );
            false // Exclude if check fails
        }
    }
}</p>

<p>// — Command Line Arguments —</p>

<p>/// Enum defining the organization methods, used for clap validation.
/// This ensures only valid options are accepted via the command line.
#[derive(clap::ValueEnum, Clone, Debug, PartialEq, Eq)]
enum OrganizeMethod {
    Category,
    Extension,
}</p>

<p>/// Defines the command-line interface structure using clap derive macros.
/// Doc comments are used to generate help messages for the user.
#[derive(Parser, Debug)]
#[command(author, version, about = “Organize files by category or extension (Rust version).”,
    long_about = “A Rust utility for organizing files from source directories into categorized target folders based on file types or extensions.”,
    help_template = “{before-help}{name} {version}\n{author-with-newline}{about-with-newline}\n{usage-heading} {usage}\n\n{all-args}{after-help}” // Custom help format
)]
struct CliArgs {
    /// Source directory containing files to organize.
    #[arg(short, long, value_name = “DIR”)]
    source: PathBuf,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>/// Target directory where organized files will be placed.
#[arg(short, long, value_name = "DIR")]
target: PathBuf,

/// Path to JSON config file for custom file categories and extensions.
#[arg(short, long, value_name = "FILE")]
config: Option&lt;PathBuf&gt;,

/// Method for organizing files (category or extension).
#[arg(long, value_enum, default_value_t = OrganizeMethod::Category)]
organize_by: OrganizeMethod,

/// Move files instead of copying them (default is copy).
#[arg(long)]
move_files: bool,

/// Append timestamp+counter to duplicate filenames. Conflicts with --skip-existing and --overwrite.
#[arg(long, conflicts_with_all = ["skip_existing", "overwrite"])]
timestamp_duplicates: bool,

/// Skip processing if a file with the same name exists in the target. Conflicts with --timestamp-duplicates and --overwrite.
#[arg(long, short = 'k', conflicts_with_all = ["timestamp_duplicates", "overwrite"])]
skip_existing: bool,

/// Overwrite existing files in the target directory. Conflicts with --timestamp-duplicates and --skip-existing.
#[arg(long, conflicts_with_all = ["timestamp_duplicates", "skip_existing"])]
overwrite: bool, // Explicit overwrite flag

/// Include hidden files/folders (e.g., starting with '.') in processing.
#[arg(long, short = 'i')]
include_hidden: bool,

/// Follow symbolic links (process target, not link). Use with caution (potential loops).
#[arg(long, short = 'l')]
follow_links: bool,

/// After moving (--move must be enabled), attempt to remove empty source directories.
#[arg(long, requires = "move_files")]
remove_empty_source_dirs: bool,

/// Optional path to a file for logging progress and errors.
#[arg(long, value_name = "FILE")]
log_file: Option&lt;PathBuf&gt;,

/// Set the log level (e.g., error, warn, info, debug, trace).
#[arg(long, value_parser = clap::value_parser!(LevelFilter), default_value = "info")]
log_level: LevelFilter, }
</code></section></div></div>

<p>// — Core Logic —</p>

<p>/// Holds statistics about the file processing operation, including failed file paths and errors.
#[derive(Debug, Default)]
struct ProcessStats {
    /// Count of directory entries successfully yielded by the filtered WalkDir iterator (includes files, dirs, etc.).
    /// <strong>Clarification:</strong> This counts entries <em>before</em> filtering for files-only in the processing loop.
    total_scanned: u64,
    processed: u64,          // Count of files successfully copied/moved
    skipped: u64,            // Count of files skipped (e.g., duplicates, hidden, non-file)
    errors: u64,             // Count of files that failed during processing (copy/move/timestamp) or critical scan errors
    failed_files: Vec&lt;(PathBuf, String)&gt;, // Stores paths and error context of failed files
}</p>

<p>/// Scans the source directory to find all unique file extensions (lowercase, without dot).
/// This is primarily used when <code class="language-plaintext highlighter-rouge">organize_by</code> is <code class="language-plaintext highlighter-rouge">Extension</code> to pre-create necessary folders efficiently.
fn get_all_extensions(
    source_directory: &amp;Path,
    include_hidden: bool,
    follow_links: bool,
) -&gt; Result&lt;HashSet<String>&gt; {
    let mut extensions = HashSet::new();
    info!("Scanning source directory for all unique file extensions...");
    let walker = WalkDir::new(source_directory)
        .follow_links(follow_links) // Control whether to follow symlinks
        .into_iter();</String></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>let mut count = 0;
// Use filter_entry for more efficient hidden filtering during the scan
for entry_result in walker.filter_entry(|e| should_keep_entry(e, include_hidden)) {
    match entry_result {
        Ok(entry) =&gt; {
            let path = entry.path();
            // Process only files
            if path.is_file() {
                // No need to re-check is_hidden here, filter_entry handles it based on should_keep_entry logic.
                count += 1;
                // Extract extension if the file has one and it's valid UTF-8
                if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
                    extensions.insert(ext.to_lowercase()); // Store lowercase extension
                }
                // Log progress periodically for very large directories
                if count % 1000 == 0 {
                    debug!("Scanned {} files for extensions...", count);
                }
            }
        }
        Err(e) =&gt; warn!("Error accessing entry during extension scan: {}", e), // Log errors encountered during directory walk
    }
}
info!("Found {} unique extensions.", extensions.len());
Ok(extensions) }
</code></section></div></div>

<p>/// Creates necessary target subfolders based on the organization method.
/// Ensures the base target directory exists first.
fn create_target_folders(
    base_dir: &amp;Path,
    organize_by: &amp;OrganizeMethod,
    categories_config: Option&lt;&amp;CategoriesConfig&gt;,
    all_extensions: Option&lt;&amp;HashSet<String>&gt;,
) -&gt; Result&lt;()&gt; {
    info!("Ensuring target base directory exists: {}", base_dir.display());
    // Create the base target directory and any necessary parent directories
    fs::create_dir_all(base_dir)
        .with_context(|| format!("Failed to create base target directory: {}", base_dir.display()))?;</String></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// Determine the set of folders needed based on the organization strategy.
let folders_to_create: HashSet&lt;String&gt; = match organize_by {
    OrganizeMethod::Category =&gt; {
        // Collect all category names from the config
        let mut folders = categories_config
            .map(|cfg| cfg.0.keys().cloned().collect::&lt;HashSet&lt;String&gt;&gt;())
            .unwrap_or_default();
        // Ensure essential fallback folders exist for files without extensions or unmatched types
        folders.insert("other".to_string());
        folders.insert("no_extension".to_string());
        folders
    }
    OrganizeMethod::Extension =&gt; {
        // Collect all unique extensions found during scan
        let mut folders = all_extensions.cloned().unwrap_or_default();
        // Ensure essential fallback folder exists for files without extensions
        folders.insert("no_extension".to_string());
        folders
    }
};

info!(
    "Creating target subfolders (mode: {:?}). Total potential folders: {}",
    organize_by,
    folders_to_create.len()
);
let mut created_count = 0;
for folder_name in &amp;folders_to_create {
    // Avoid creating folders with potentially invalid names (e.g., empty string if an extension was just ".")
    if folder_name.is_empty() {
        warn!("Skipping creation of folder with empty name.");
        continue;
    }
    let folder_path = base_dir.join(folder_name);
    // Check if folder already exists before trying to create
    if !folder_path.exists() {
        // Create the folder and any necessary parents
        fs::create_dir_all(&amp;folder_path).with_context(|| {
            format!("Failed to create target folder '{}'", folder_path.display())
        })?;
        debug!("Created target folder: {}", folder_path.display());
        created_count += 1;
    }
}
info!("Created {} new target subfolders.", created_count);
Ok(()) }
</code></section></div></div>

<p>/// Attempts to move a file using <code class="language-plaintext highlighter-rouge">fs::rename</code>, falling back to copy-then-delete
/// if <code class="language-plaintext highlighter-rouge">fs::rename</code> fails (e.g., due to being on different filesystems/devices).
fn move_file_with_fallback(source: &amp;Path, target: &amp;Path) -&gt; io::Result&lt;()&gt; {
    // Attempt the efficient rename first, which is atomic on the same filesystem
    match fs::rename(source, target) {
        Ok(_) =&gt; Ok(()), // Rename succeeded
        Err(rename_error) =&gt; {
            // Check if the error is likely due to moving across different filesystems/devices.
            // This requires checking platform-specific OS error codes.
            // Note: Relies on platform-specific OS error codes (Windows: 17, Unix: 18/libc::EXDEV). Might be brittle.
            let is_cross_device = || -&gt; bool {
                #[cfg(windows)] { rename_error.raw_os_error() == Some(17) } // ERROR_NOT_SAME_DEVICE
                #[cfg(unix)] { rename_error.raw_os_error() == Some(18) } // libc::EXDEV
                #[cfg(not(any(windows, unix)))] { false } // Default for other platforms
            };</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>        if is_cross_device() {
            // If it's a cross-device error, attempt copy-then-delete fallback
            warn!("Rename failed (cross-device error detected), attempting copy+delete fallback for move: {} -&gt; {}", source.display(), target.display());
            // Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
            // For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
            fs::copy(source, target)?; // Attempt copy
            fs::remove_file(source)?; // Attempt delete original
            Ok(()) // Fallback succeeded
        } else {
            // If it was a different rename error (e.g., permissions), re-throw it.
            Err(rename_error)
        }
    }
} }
</code></section></div></div>

<p>/// Main function to perform the file organization based on parsed arguments.
/// Iterates through source files, determines target paths, handles duplicates,
/// performs copy/move operations, and collects statistics.
fn organize_files(args: &amp;CliArgs, categories_config: &amp;CategoriesConfig) -&gt; Result<ProcessStats> {
    // --- Initial Validation &amp; Setup ---
    if !args.source.is_dir() {
        bail!("Source directory '{}' is invalid or not found.", args.source.display());
    }
    // Ensure target directory exists or create it
    if !args.target.exists() {
        info!("Creating target directory: {}", args.target.display());
        fs::create_dir_all(&amp;args.target).with_context(|| {
            format!("Could not create target directory '{}'", args.target.display())
        })?;
    } else if !args.target.is_dir() {
        bail!("Target path '{}' exists but is not a directory.", args.target.display());
    }</ProcessStats></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// --- Pre-scan for Extensions (if needed) and Pre-create Folders ---
// This ensures target folders exist before we start moving/copying files into them.
info!("Preparing target folders...");
let extensions_for_folders = if args.organize_by == OrganizeMethod::Extension {
    Some(get_all_extensions(&amp;args.source, args.include_hidden, args.follow_links)?)
} else {
    None
};
create_target_folders(
    &amp;args.target,
    &amp;args.organize_by,
    Some(categories_config), // Pass config needed for category mode
    extensions_for_folders.as_ref(), // Pass extensions needed for extension mode
)?;

// --- Process Files ---
info!("Starting file processing...");
let mut stats = ProcessStats::default(); // Initialize statistics
let mut file_counter = 0u64; // Counter for progress reporting

// Use WalkDir again for the main processing loop, applying filters efficiently
let walker = WalkDir::new(&amp;args.source)
    .follow_links(args.follow_links) // Control symlink following
    .into_iter();

// filter_entry is used to efficiently skip hidden directories/files if requested
for entry_result in walker.filter_entry(|e| should_keep_entry(e, args.include_hidden)) {
    // Increment scan counter for every entry successfully yielded by the filtered iterator
    stats.total_scanned += 1;

    let entry = match entry_result {
        Ok(e) =&gt; e,
        Err(e) =&gt; {
            // Log errors encountered during directory traversal itself
            error!("Error scanning path {}: {}", e.path().unwrap_or(Path::new("?")).display(), e);
            stats.errors += 1; // Count scan errors towards total errors
            // Record scan error details
            stats.failed_files.push((
                e.path().unwrap_or_default().to_path_buf(),
                format!("Scan error: {:?}", e),
            ));
            continue; // Skip this problematic entry
        }
    };

    // We are only interested in processing files in this loop
    if !entry.file_type().is_file() {
        stats.skipped += 1; // Count skipped directories/symlinks etc.
        continue;
    }

    // If we reached here, it's a file we intend to process
    file_counter += 1;
    let source_path = entry.path();
    let progress_prefix = format!("[{}]", file_counter); // Simple counter for progress logging

    // --- Inner processing block to handle errors per file using anyhow ---
    // This allows logging an error for a single file and continuing with the next.
    let file_result: Result&lt;()&gt; = (|| {
        // No need to re-check is_hidden, filter_entry handles it.

        // Extract filename, handling potential errors (e.g., invalid path)
        let file_name = source_path.file_name()
            .with_context(|| format!("Could not get filename for path: {}", source_path.display()))?;

        // Determine target subfolder name based on organization strategy
        let target_subfolder_name = match args.organize_by {
            OrganizeMethod::Category =&gt; categorize_file(source_path, categories_config),
            OrganizeMethod::Extension =&gt; source_path
                .extension()
                .and_then(|s| s.to_str()) // Get extension as string
                .map(|s| s.to_lowercase()) // Convert to lowercase
                .unwrap_or_else(|| "no_extension".to_string()), // Handle no extension
        };
        let target_folder_path = args.target.join(&amp;target_subfolder_name);
        let mut target_file_path = target_folder_path.join(file_name);

        // --- Handle potential duplicate files in the target directory ---
        if target_file_path.exists() {
            if args.skip_existing {
                // User requested skipping duplicates
                info!(
                    "{} Skipping (target exists): {}",
                    progress_prefix,
                    target_file_path.display()
                );
                stats.skipped += 1;
                return Ok(()); // Successfully skipped this file
            } else if args.timestamp_duplicates {
                // User requested adding timestamps to duplicates
                let original_target_path_display = target_file_path.display().to_string();
                let mut counter = 1;
                // Safely get stem and extension, providing defaults if they don't exist
                let stem = source_path.file_stem().unwrap_or(file_name.as_os_str()); // Use original filename if no stem
                let ext = source_path.extension().unwrap_or_default(); // Empty OsStr if no extension
                const MAX_TIMESTAMP_ATTEMPTS: u32 = 1000; // Safety break for the loop

                loop {
                    let timestamp = Local::now().format("%Y%m%d_%H%M%S");
                    // Construct new filename using OsString to handle non-UTF8 filenames safely
                    let mut new_name_os = std::ffi::OsString::new();
                    new_name_os.push(stem);
                    new_name_os.push(format!("_{}_{}", timestamp, counter)); // Add timestamp and counter
                    if !ext.is_empty() {
                        new_name_os.push("."); // Add dot only if there was an extension
                        new_name_os.push(ext);
                    }
                    target_file_path = target_folder_path.join(&amp;new_name_os); // Update the target path

                    if !target_file_path.exists() {
                        break; // Found a unique name, exit the loop
                    }
                    counter += 1;
                    // Safety break to prevent potential infinite loops if unique names are hard to find
                    if counter &gt; MAX_TIMESTAMP_ATTEMPTS {
                        // Use bail! from anyhow to return an error directly from this inner block
                        bail!(
                            "Could not find unique timestamped name for {} after {} attempts. Skipping.",
                            original_target_path_display, MAX_TIMESTAMP_ATTEMPTS
                        );
                    }
                }
                // Log the renaming action
                info!(
                    "{} Target exists '{}'. Renaming duplicate to: {}",
                    progress_prefix,
                    original_target_path_display,
                    target_file_path.display()
                );
            } else if args.overwrite {
                 // Explicit overwrite flag is set
                 warn!(
                    "{} Overwriting existing target file: {}",
                    progress_prefix,
                    target_file_path.display()
                );
                 // Overwrite happens implicitly below by copy/move
            } else {
                // Default behavior if no specific duplicate handling flag is set: Overwrite
                 warn!(
                    "{} Overwriting existing target file (default): {}",
                    progress_prefix,
                    target_file_path.display()
                );
                 // Overwrite happens implicitly below by copy/move
            }
        } // End duplicate check block

        // Ensure target directory exists *just before* the operation (belt-and-suspenders approach)
        // This handles rare cases where the folder might have been deleted after the initial check.
        fs::create_dir_all(&amp;target_folder_path).with_context(|| format!("Failed to ensure target directory '{}' exists", target_folder_path.display()))?;

        // --- Perform the file operation (Copy or Move) ---
        let operation_desc = if args.move_files { "move" } else { "copy" };
        debug!(
            "{} Attempting to {} '{}' to '{}'",
            progress_prefix,
            operation_desc,
            source_path.display(),
            target_file_path.display()
        );

        if args.move_files {
            // Use the robust move function with fallback for cross-device errors
            move_file_with_fallback(source_path, &amp;target_file_path)
                .with_context(|| format!("Failed to move '{}' to '{}'", source_path.display(), target_file_path.display()))?;
        } else {
            // Standard copy.
            // Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
            // For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
            fs::copy(source_path, &amp;target_file_path)
                .map(|_| ()) // Discard the number of bytes copied (u64) result, returning () on success
                .with_context(|| format!("Failed to copy '{}' to '{}'", source_path.display(), target_file_path.display()))?;
        }
        stats.processed += 1; // Increment processed count only on success
        Ok(()) // Indicate success for this file's processing
    })(); // End of inner result block for per-file error handling

    // --- Handle result for this specific file ---
    if let Err(e) = file_result {
        // Log the detailed error using anyhow's Debug format
        error!("{} Failed to process '{}': {:?}", progress_prefix, source_path.display(), e);
        stats.errors += 1;
        // Store error context along with the path
        stats.failed_files.push((source_path.to_path_buf(), format!("{:?}", e)));
    }
} // End of main file processing loop

Ok(stats) // Return the final statistics }
</code></section></div></div>

<p>/// Recursively removes empty folders starting from the bottom up within a given directory.
/// This is typically used after a move operation to clean up the source directory.
/// Uses a collect-then-sort approach for simplicity and to avoid potential
/// issues with modifying the directory structure while iterating.
fn remove_empty_folders(directory: &amp;Path) -&gt; Result<u32> {
    let mut removed_count = 0u32;
    info!("Attempting to remove empty directories within: {}", directory.display());</u32></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// Collect directory paths first. This avoids borrow checker issues with WalkDir
// if we were to modify the directory structure while iterating (e.g., removing a dir).
let mut dirs_to_check = Vec::new();
// Start scan from depth 1 to avoid trying to remove the root directory itself.
for entry_result in WalkDir::new(directory).min_depth(1) {
    match entry_result {
        Ok(entry) if entry.file_type().is_dir() =&gt; {
            dirs_to_check.push(entry.into_path()); // Collect path if it's a directory
        }
        Ok(_) =&gt; {} // Ignore files
        Err(e) =&gt; warn!("Error accessing entry during empty dir scan: {}", e), // Log errors during scan
    }
}

// Sort paths by depth (longest paths first) to ensure bottom-up processing.
// This is crucial so we attempt to remove child directories before their parents.
dirs_to_check.sort_by(|a, b| b.components().count().cmp(&amp;a.components().count()));

for dir_path in dirs_to_check {
    // Check if directory still exists before trying to read/remove (it might have been removed in a previous step)
    if !dir_path.is_dir() {
        continue;
    }

    match fs::read_dir(&amp;dir_path) {
        Ok(mut read_dir) =&gt; {
            // Check if the directory is truly empty by trying to get the first entry.
            // read_dir.next().is_none() is true if the directory is empty.
            if read_dir.next().is_none() {
                // Directory is empty, attempt to remove it.
                match fs::remove_dir(&amp;dir_path) {
                    Ok(_) =&gt; {
                        info!("Removed empty directory: {}", dir_path.display());
                        removed_count += 1;
                    }
                    Err(e) =&gt; {
                        // Log warnings for common non-critical errors like permissions
                        // or race conditions where the dir became non-empty between read_dir and remove_dir.
                        // Don't treat NotFound as a warning if it was just removed by another process or race condition.
                        if e.kind() != ErrorKind::NotFound {
                            warn!(
                                "Could not remove presumably empty directory '{}': {}",
                                dir_path.display(), e
                            );
                        }
                    }
                }
            }
            // else: Directory is not empty, do nothing.
        }
        Err(e) =&gt; {
            // Don't warn if the directory was removed between listing and checking emptiness.
            if e.kind() != ErrorKind::NotFound {
                warn!(
                    "Could not read directory '{}' to check emptiness: {}",
                    dir_path.display(), e
                );
            }
        }
    }
}

info!("Finished removing empty directories. Removed: {}", removed_count);
Ok(removed_count) // Return the count of removed directories }
</code></section></div></div>

<p>// — Logging Setup —</p>

<p>/// Sets up logging using the fern crate to log to stderr and optionally a file.
/// Configures formatting, level filtering, and color output for the console.
fn setup_logging(log_level: LevelFilter, log_file: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;()&gt; {
    // Configure colors for terminal output levels for better readability
    let colors = ColoredLevelConfig::new()
        .error(Color::Red)
        .warn(Color::Yellow)
        .info(Color::Green)
        .debug(Color::Blue)
        .trace(Color::BrightBlack);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// Base dispatch configuration common to all loggers
let base_config = fern::Dispatch::new()
    // Format messages including timestamp (with milliseconds), colored level, target module, and message
    .format(move |out, message, record| {
        out.finish(format_args!(
            "[{} {} {}] {}",
            chrono::Local::now().format("%Y-%m-%d %H:%M:%S%.3f"), // Time format with ms
            colors.color(record.level()), // Apply color to level text
            record.target(), // Module path where log occurred (e.g., `rust_file_organizer::main`)
            message
        ))
    })
    // Apply the global log level filter passed from arguments (e.g., Info, Debug)
    .level(log_level)
    // Filter out overly verbose logs from common libraries unless explicitly requested at a higher level
    // This keeps the default output cleaner when running at Info level.
    .level_for("hyper", LevelFilter::Warn)
    .level_for("mio", LevelFilter::Warn)
    .level_for("want", LevelFilter::Warn)
    .level_for("reqwest", LevelFilter::Warn)
    .level_for("rustls", LevelFilter::Warn);


// Chain the stderr logger. By default, only show messages from our crate unless Debug/Trace is enabled.
let stderr_logger = fern::Dispatch::new()
    .filter(move |metadata| {
         // Show logs from our crate OR if the global level is Debug or Trace
         log_level &lt;= LevelFilter::Debug || metadata.target().starts_with(env!("CARGO_PKG_NAME"))
    })
    .chain(std::io::stderr()); // Chain to standard error output

// Start building the final dispatch configuration, always including stderr
let mut final_dispatch = base_config.chain(stderr_logger);

// Chain the file logger conditionally if a path is provided
let mut file_logger_ok = false; // Track if file logger setup succeeds
if let Some(log_path) = log_file {
    match fern::log_file(log_path) {
        Ok(file_output) =&gt; {
            // If file opened successfully, chain it to the dispatch
            final_dispatch = final_dispatch.chain(file_output);
            file_logger_ok = true;
        }
        Err(e) =&gt; {
            // If file creation fails, log error directly to stderr (logger not ready yet)
            // and proceed without file logging.
            eprintln!(
                "Error: Failed to create log file '{}': {}. Logging to console only.",
                log_path.display(), e
            );
        }
    }
}

// Apply the final combined logging configuration
final_dispatch.apply().context("Failed to set up logging")?;

// Log confirmation *after* apply() succeeds
if file_logger_ok {
    if let Some(path) = log_file {
        info!("File logging enabled to: {}", path.display());
    }
}

Ok(()) }
</code></section></div></div>

<p>// — Main Application Entry Point —</p>

<p>fn main() -&gt; Result&lt;()&gt; {
    // Record start time for overall duration calculation
    let overall_start_time = Instant::now();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>// Parse command-line arguments using clap
let args = CliArgs::parse();

// --- Setup Logging ---
// Initialize logging early based on args.log_level and optional args.log_file
// This allows logging during argument validation or config loading if needed.
setup_logging(args.log_level, args.log_file.as_ref())?;

// --- Log Startup Information ---
info!("Rust File Organizer (v{}) starting...", env!("CARGO_PKG_VERSION"));
// Log full arguments only if debug level is enabled
debug!("Arguments received: {:?}", args);
// Log key operational parameters at info level for traceability
info!("Source directory: {}", args.source.display());
info!("Target directory: {}", args.target.display());
info!("Organization mode: {:?}", args.organize_by); // Use Debug format for enum
info!("Operation: {}", if args.move_files { "Move" } else { "Copy" });
info!("Include hidden: {}", args.include_hidden);
info!("Follow links: {}", args.follow_links);
// Log duplicate handling strategy clearly based on flags
if args.skip_existing { info!("Duplicate handling: Skip existing"); }
else if args.timestamp_duplicates { info!("Duplicate handling: Timestamp duplicates"); }
else if args.overwrite { info!("Duplicate handling: Overwrite existing (explicitly)"); }
else { info!("Duplicate handling: Overwrite existing (default)"); } // Log default


// --- Load Configuration ---
// Load categories from JSON file or use defaults; ensures 'other' category exists.
let categories = load_config_file(args.config.as_ref())?;
// Optionally log loaded categories at debug level if needed for troubleshooting
// debug!("Using categories: {:?}", categories.0.keys());

// --- Execute Core Logic ---
// Call the main organization function and handle its result
let result = organize_files(&amp;args, &amp;categories);

// --- Handle Results and Optional Cleanup ---
match result {
    Ok(stats) =&gt; {
        // --- Optional Cleanup: Remove empty source directories after successful move ---
        if args.move_files &amp;&amp; args.remove_empty_source_dirs &amp;&amp; stats.processed &gt; 0 {
            // Attempt cleanup but log errors non-fatally, as the main task succeeded
            if let Err(e) = remove_empty_folders(&amp;args.source) {
                error!("Error during empty source directory removal: {:?}", e);
                // Note: Cleanup errors are logged but do not cause a non-zero exit code by default.
            }
        }

        // --- Final Summary ---
        let overall_duration = overall_start_time.elapsed(); // Calculate total duration correctly
        let summary = format!(
            "Operation completed in {:.2?}. Scanned Entries: {}, Processed Files: {}, Skipped: {}, Errors: {}",
            overall_duration, stats.total_scanned, stats.processed, stats.skipped, stats.errors
        );
        info!("{}", summary); // Log summary
        println!("\n{}", summary); // Print final summary to console (stdout)

        // If errors occurred during file processing, print the list of failed files and their errors to stderr
        if stats.errors &gt; 0 {
            eprintln!("\n--- Errors occurred during processing: ---"); // Print errors to stderr
            for (path, error_msg) in &amp;stats.failed_files {
                eprintln!(" - File: {}", path.display());
                eprintln!("   Error: {}", error_msg); // Show the captured error context
            }
            eprintln!("-----------------------------------------");
            eprintln!(
                "Warning: {} errors occurred. Please check logs (stderr/file) for full details.",
                stats.errors
            );
            // Consider exiting with a non-zero status code for scripting purposes if any errors occurred
            // std::process::exit(1);
        }
    }
    Err(e) =&gt; {
        // Log the critical error that stopped the organization process entirely
        error!("Critical error during file organization: {:?}", e); // Use Debug format for anyhow::Error chain
        eprintln!("\nError: File organization failed critically. Check logs (stderr/file) for details.");
        std::process::exit(1); // Exit with a non-zero code on critical failure
    }
}

info!("Rust File Organizer finished.");
Ok(()) // Indicate successful completion (even if non-critical file errors occurred) }
</code></section></div></div>

<p>// — Testing Notes —
// To properly test this application, consider using crates like:
// - <code class="language-plaintext highlighter-rouge">assert_fs</code>: For creating temporary file/directory structures for tests.
// - <code class="language-plaintext highlighter-rouge">predicates</code>: For making assertions about file system state (e.g., file exists, content matches).
// - <code class="language-plaintext highlighter-rouge">assert_cmd</code>: For testing the command-line interface behavior, arguments, exit codes, and output.
//
// Example Test Scenarios (Conceptual):
// - Test basic copy/move by category and extension.
// - Test duplicate handling flags (skip, timestamp, overwrite) work correctly.
// - Test hidden file handling with and without the –include-hidden flag.
// - Test symbolic link handling with and without the –follow-links flag.
// - Test behavior with empty source or target directories.
// - Test custom configuration loading and verify correct categorization (including missing ‘other’).
// - Test empty directory removal after a successful move operation.
// - Test error handling for scenarios like insufficient permissions (harder to automate reliably).
// - Test long path handling specifically on Windows (requires careful test setup).
// - Test cross-device move fallback behavior.
// - Test handling of filenames with non-UTF8 characters (requires OsStr handling).</p>

<p>{% endcodeblock %}</p>

        </div>
        
          URL: https://ib.bsb.br/files-by-type
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/tasks-mermaid/" title="Task Prioritization" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/dup-spotter/" title="Copy Spotter and Duplicate-File-Remover" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts>rust"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts-rust" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/files-by-type/" title="Organize files by type" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-04-07 18:21:46
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scripts-rust">
                  scripts>rust
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/files-by-type/"
        },
        "headline": "Organize files by type",
        "description": "",
        "datePublished": "2024-05-30T00:00:00+00:00",
        "dateModified": "2025-04-07T21:19:29+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
