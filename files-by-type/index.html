<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        Organize files by type - infoBAG
      
    </title>
    <meta name="title" content="Organize files by type - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/files-by-type/">
    <meta property="og:title" content="Organize files by type - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/files-by-type/">
    <meta name="twitter:title" content="Organize files by type - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/files-by-type/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scripts&gt;rust">
      
        <meta property="article:tag" content="scripts&gt;rust">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          Organize files by type
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2024-05-30T00:00:00+00:00" class="post-date">
          30 May 2024
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-04-07T20:30:03+00:00">
              07 Apr 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/files-by-type" class="tag">files-by-type</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scripts-rust" class="tag">scripts>rust</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        41163 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        5299 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2024-05-30-files-by-type.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2024-05-30-files-by-type.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#building-and-running-the-file-organizer-on-windows">Building and Running the File Organizer on Windows</a><ul><li><a href="#prerequisites">Prerequisites</a></li><li><a href="#creating-the-project">Creating the Project</a></li><li><a href="#building-the-project">Building the Project</a><ul><li><a href="#debug-build-for-development">Debug Build (For Development)</a></li><li><a href="#release-build-for-distribution">Release Build (For Distribution)</a></li></ul></li><li><a href="#running-the-tool">Running the Tool</a><ul><li><a href="#getting-help">Getting Help</a></li><li><a href="#usage-examples">Usage Examples</a><ul><li><a href="#basic-file-organization">Basic File Organization</a></li><li><a href="#moving-files-with-duplicate-handling">Moving Files with Duplicate Handling</a></li><li><a href="#organizing-by-file-extension">Organizing by File Extension</a></li><li><a href="#advanced-configuration">Advanced Configuration</a></li></ul></li></ul></li><li><a href="#common-options-reference">Common Options Reference</a></li><li><a href="#testing-your-installation">Testing Your Installation</a></li></ul></li></ul>
          <h1 id="building-and-running-the-file-organizer-on-windows">
    
    
     <a href="#building-and-running-the-file-organizer-on-windows">#</a><a href="#" aria-label="Back to top">Building and Running the File Organizer on Windows</a>
        
    
  </h1>
      
  <h2 id="prerequisites">
    
    
     <a href="#prerequisites">#</a><a href="#" aria-label="Back to top">Prerequisites</a>
        
    
  </h2>
      

<p>Before you begin, you need to install Rust:</p>

<ol>
  <li>Visit <a href="https://rustup.rs/">https://rustup.rs/</a> to download the Rust installer</li>
  <li>Run the installer to set up:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">rustc</code> (the compiler)</li>
      <li><code class="language-plaintext highlighter-rouge">cargo</code> (the build tool and package manager)</li>
    </ul>
  </li>
</ol>
  <h2 id="creating-the-project">
    
    
     <a href="#creating-the-project">#</a><a href="#" aria-label="Back to top">Creating the Project</a>
        
    
  </h2>
      

<p>Open a command prompt and run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c"># Create a new Rust project</span>
cargo new file_organizer_rs
<span class="nb">cd </span>file_organizer_rs

<span class="c"># Replace default files with project files</span>
<span class="c"># Replace the contents of Cargo.toml with the provided configuration</span>
<span class="c"># Replace the contents of src/main.rs with the provided source code</span>
</code></section></div></div>
  <h2 id="building-the-project">
    
    
     <a href="#building-the-project">#</a><a href="#" aria-label="Back to top">Building the Project</a>
        
    
  </h2>
      
  <h3 id="debug-build-for-development">
    
    
     <a href="#debug-build-for-development">#</a><a href="#" aria-label="Back to top">Debug Build (For Development)</a>
        
    
  </h3>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo build
</code></section></div></div>

<p>The executable will be created in the <code class="language-plaintext highlighter-rouge">target/debug/</code> directory.</p>
  <h3 id="release-build-for-distribution">
    
    
     <a href="#release-build-for-distribution">#</a><a href="#" aria-label="Back to top">Release Build (For Distribution)</a>
        
    
  </h3>
      

<p>For a smaller, optimized executable:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>cargo build <span class="nt">--release</span>
</code></section></div></div>

<p>The executable will be created in the <code class="language-plaintext highlighter-rouge">target/release/</code> directory.</p>
  <h2 id="running-the-tool">
    
    
     <a href="#running-the-tool">#</a><a href="#" aria-label="Back to top">Running the Tool</a>
        
    
  </h2>
      
  <h3 id="getting-help">
    
    
     <a href="#getting-help">#</a><a href="#" aria-label="Back to top">Getting Help</a>
        
    
  </h3>
      

<p>View all available options:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--help</span>
</code></section></div></div>
  <h3 id="usage-examples">
    
    
     <a href="#usage-examples">#</a><a href="#" aria-label="Back to top">Usage Examples</a>
        
    
  </h3>
      
  <h4 id="basic-file-organization">
    
    
     <a href="#basic-file-organization">#</a><a href="#" aria-label="Back to top">Basic File Organization</a>
        
    
  </h4>
      

<p>Copy files by category from Downloads to an organized folder:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--source</span> C:<span class="se">\U</span>sers<span class="se">\Y</span>ourUser<span class="se">\D</span>ownloads <span class="nt">--target</span> C:<span class="se">\O</span>rganizedFiles
</code></section></div></div>
  <h4 id="moving-files-with-duplicate-handling">
    
    
     <a href="#moving-files-with-duplicate-handling">#</a><a href="#" aria-label="Back to top">Moving Files with Duplicate Handling</a>
        
    
  </h4>
      

<p>Move files from Downloads, adding timestamps to duplicates:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">--source</span> C:<span class="se">\U</span>sers<span class="se">\Y</span>ourUser<span class="se">\D</span>ownloads <span class="nt">--target</span> C:<span class="se">\O</span>rganizedFiles <span class="nt">--move</span> <span class="nt">--timestamp-duplicates</span>
</code></section></div></div>
  <h4 id="organizing-by-file-extension">
    
    
     <a href="#organizing-by-file-extension">#</a><a href="#" aria-label="Back to top">Organizing by File Extension</a>
        
    
  </h4>
      

<p>Organize files by extension, including hidden files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> <span class="s2">"C:</span><span class="se">\P</span><span class="s2">ath</span><span class="se">\T</span><span class="s2">o</span><span class="se">\S</span><span class="s2">ource"</span> <span class="nt">-t</span> <span class="s2">"C:</span><span class="se">\P</span><span class="s2">ath</span><span class="se">\T</span><span class="s2">o</span><span class="se">\T</span><span class="s2">arget"</span> <span class="nt">--organize-by</span> extension <span class="nt">--include-hidden</span>
</code></section></div></div>
  <h4 id="advanced-configuration">
    
    
     <a href="#advanced-configuration">#</a><a href="#" aria-label="Back to top">Advanced Configuration</a>
        
    
  </h4>
      

<p>Use a custom configuration file and log all activity:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>.<span class="se">\t</span>arget<span class="se">\r</span>elease<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> .<span class="se">\i</span>nput <span class="nt">-t</span> .<span class="se">\o</span>utput <span class="nt">-c</span> .<span class="se">\m</span>y_config.json <span class="nt">--log-file</span> activity.log <span class="nt">--overwrite</span>
</code></section></div></div>
  <h2 id="common-options-reference">
    
    
     <a href="#common-options-reference">#</a><a href="#" aria-label="Back to top">Common Options Reference</a>
        
    
  </h2>
      

<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Short</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--source</code></td>
      <td><code class="language-plaintext highlighter-rouge">-s</code></td>
      <td>Source directory to organize files from</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--target</code></td>
      <td><code class="language-plaintext highlighter-rouge">-t</code></td>
      <td>Target directory to place organized files</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--move</code></td>
      <td> </td>
      <td>Move files instead of copying them</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--organize-by</code></td>
      <td> </td>
      <td>Organization method (extension or category)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--timestamp-duplicates</code></td>
      <td> </td>
      <td>Add timestamp to duplicate files</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--include-hidden</code></td>
      <td><code class="language-plaintext highlighter-rouge">-i</code></td>
      <td>Include hidden files and directories</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--overwrite</code></td>
      <td> </td>
      <td>Overwrite existing files in target</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--config</code></td>
      <td><code class="language-plaintext highlighter-rouge">-c</code></td>
      <td>Path to custom configuration file</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">--log-file</code></td>
      <td> </td>
      <td>Write logs to specified file</td>
    </tr>
  </tbody>
</table>
  <h2 id="testing-your-installation">
    
    
     <a href="#testing-your-installation">#</a><a href="#" aria-label="Back to top">Testing Your Installation</a>
        
    
  </h2>
      

<p>After building, verify your installation works by running a simple test:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c"># Create test directories</span>
<span class="nb">mkdir </span>test_source test_target

<span class="c"># Copy some test files to test_source</span>
<span class="c"># Then run the organizer</span>
.<span class="se">\t</span>arget<span class="se">\d</span>ebug<span class="se">\f</span>ile_organizer_rs.exe <span class="nt">-s</span> .<span class="se">\t</span>est_source <span class="nt">-t</span> .<span class="se">\t</span>est_target
</code></section></div></div>

<section data-filename="toml_code-block.txt" data-code="# Cargo.toml (Based on Approach 3, with updated comments)
[package]
name = &quot;rust_file_organizer&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;
description = &quot;A Rust utility for organizing files by category or extension.&quot;
authors = [&quot;AI Assistant&quot;] # Replace with actual author
license = &quot;MIT OR Apache-2.0&quot; # Choose appropriate license
[dependencies]
# Command-line argument parsing
clap = { version = &quot;4.5&quot;, features = [&quot;derive&quot;, &quot;cargo&quot;, &quot;env&quot;] } # cargo/env features allow reading from Cargo.toml/env vars
# Directory traversal
walkdir = &quot;2.5&quot;
# JSON parsing for configuration files
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
# Logging framework
log = &quot;0.4&quot;
# Using fern for flexible file/console logging setup
fern = &quot;0.6&quot;
# Date and time handling for timestamps
chrono = &quot;0.4&quot;
# Flexible error handling and context reporting
anyhow = &quot;1.0&quot;
# Optional: More robust file operations (especially cross-device move)
# fs_extra = &quot;1.3&quot; # Keep commented unless needed; std lib fallback implemented
# Windows-specific dependencies are NOT needed here as std lib is used for hidden check
# [target.'cfg(windows)'.dependencies]
# windows = { version = &quot;0.56&quot;, features = [...] }
# Release profile optimizations (optional but recommended for smaller/faster executables)
[profile.release]
# 'z' optimizes aggressively for size, potentially sacrificing some speed compared to 's' or '3'.
opt-level = 'z'
# Enable Link-Time Optimization across crates for potential performance gains and size reduction.
lto = true
# Maximize optimization opportunities by using a single codegen unit (can significantly increase compile times).
codegen-units = 1
# Remove symbols from the binary for smaller size.
# Alternatively, use `cargo strip` (requires `cargo install cargo-strip`) or set `debuginfo = 0` (removes debug symbols only).
strip = true
# Abort on panic instead of unwinding the stack. Reduces binary size but prevents catching panics.
panic = 'abort'" data-download-link="" data-download-link-label="Download Toml"><code class="language-toml"># Cargo.toml (Based on Approach 3, with updated comments)
[package]
name = "rust_file_organizer"
version = "0.1.0"
edition = "2021"
description = "A Rust utility for organizing files by category or extension."
authors = ["AI Assistant"] # Replace with actual author
license = "MIT OR Apache-2.0" # Choose appropriate license
[dependencies]
# Command-line argument parsing
clap = { version = "4.5", features = ["derive", "cargo", "env"] } # cargo/env features allow reading from Cargo.toml/env vars
# Directory traversal
walkdir = "2.5"
# JSON parsing for configuration files
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
# Logging framework
log = "0.4"
# Using fern for flexible file/console logging setup
fern = "0.6"
# Date and time handling for timestamps
chrono = "0.4"
# Flexible error handling and context reporting
anyhow = "1.0"
# Optional: More robust file operations (especially cross-device move)
# fs_extra = "1.3" # Keep commented unless needed; std lib fallback implemented
# Windows-specific dependencies are NOT needed here as std lib is used for hidden check
# [target.'cfg(windows)'.dependencies]
# windows = { version = "0.56", features = [...] }
# Release profile optimizations (optional but recommended for smaller/faster executables)
[profile.release]
# 'z' optimizes aggressively for size, potentially sacrificing some speed compared to 's' or '3'.
opt-level = 'z'
# Enable Link-Time Optimization across crates for potential performance gains and size reduction.
lto = true
# Maximize optimization opportunities by using a single codegen unit (can significantly increase compile times).
codegen-units = 1
# Remove symbols from the binary for smaller size.
# Alternatively, use `cargo strip` (requires `cargo install cargo-strip`) or set `debuginfo = 0` (removes debug symbols only).
strip = true
# Abort on panic instead of unwinding the stack. Reduces binary size but prevents catching panics.
panic = 'abort'


***

<section data-filename="rust_code-block.txt" data-code="// src/main.rs: Rust implementation of the file organizer utility.
// This version incorporates improvements based on self-critique:
// - Uses fern for flexible logging (console + optional file).
// - Uses anyhow for error handling with context.
// - Uses std lib for platform-specific hidden file checks.
// - Uses clap ValueEnum for argument validation.
// - Implements explicit --overwrite flag and robust duplicate handling.
// - Implements robust move operation with cross-device fallback.
// - Reports list of failed files WITH error context.
// - Includes more detailed comments.
// - Correctly calculates execution duration.
// - Safely excludes entries where hidden status check fails.
// - Clarified meaning of `total_scanned` statistic.
use anyhow::{bail, Context, Result}; // Use anyhow for convenient error handling
use clap::Parser; // For command-line argument parsing
use chrono::Local; // For generating timestamps
use fern::colors::{Color, ColoredLevelConfig}; // For colored logging output
use log::{debug, error, info, warn, LevelFilter}; // Logging facade
use serde::Deserialize; // For deserializing JSON config
use std::{
collections::{HashMap, HashSet},
env, // For CARGO_PKG_VERSION
fs::{self, File}, // Standard file system operations
io::{self, ErrorKind},
path::{Path, PathBuf},
time::Instant, // For accurate duration measurement
};
use walkdir::{DirEntry, WalkDir}; // For efficient directory traversal
// --- Configuration Structures ---
/// Represents the structure of the JSON configuration file for categories.
/// Using a tuple struct for better type safety than just HashMap directly.
#[derive(Deserialize, Debug, Clone)]
struct CategoriesConfig(HashMap&lt;String, Vec&lt;String&gt;&gt;);
/// Provides the default file categorization configuration.
/// This is used if no custom config file is provided or if loading fails.
fn default_categories() -&gt; CategoriesConfig {
let mut map = HashMap::new();
// Helper macro to reduce boilerplate when defining default categories
macro_rules! add_category {
($map:expr, $name:expr, [$($ext:expr),* $(,)?]) =&gt; {
// Inserts a category name and its associated list of lowercase extensions (including '.')
$map.insert($name.to_string(), vec![$($ext.to_string()),*]);
};
}
// Define standard categories and their common extensions
add_category!(map, &quot;images&quot;, [&quot;.jpg&quot;, &quot;.jpeg&quot;, &quot;.png&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.webp&quot;, &quot;.tiff&quot;, &quot;.svg&quot;, &quot;.ico&quot;]);
add_category!(map, &quot;documents&quot;, [&quot;.pdf&quot;, &quot;.docx&quot;, &quot;.doc&quot;, &quot;.txt&quot;, &quot;.rtf&quot;, &quot;.odt&quot;, &quot;.xlsx&quot;, &quot;.xls&quot;, &quot;.csv&quot;, &quot;.pptx&quot;, &quot;.ppt&quot;, &quot;.md&quot;, &quot;.tex&quot;, &quot;.chm&quot;, &quot;.epub&quot;]);
add_category!(map, &quot;videos&quot;, [&quot;.mp4&quot;, &quot;.avi&quot;, &quot;.mkv&quot;, &quot;.mov&quot;, &quot;.wmv&quot;, &quot;.flv&quot;, &quot;.webm&quot;]);
add_category!(map, &quot;audio&quot;, [&quot;.mp3&quot;, &quot;.wav&quot;, &quot;.flac&quot;, &quot;.aac&quot;, &quot;.ogg&quot;, &quot;.m4a&quot;]);
add_category!(map, &quot;archives&quot;, [&quot;.zip&quot;, &quot;.rar&quot;, &quot;.tar&quot;, &quot;.gz&quot;, &quot;.bz2&quot;, &quot;.7z&quot;, &quot;.iso&quot;]);
add_category!(map, &quot;code&quot;, [&quot;.py&quot;, &quot;.java&quot;, &quot;.c&quot;, &quot;.cpp&quot;, &quot;.h&quot;, &quot;.cs&quot;, &quot;.html&quot;, &quot;.css&quot;, &quot;.js&quot;, &quot;.ts&quot;, &quot;.jsx&quot;, &quot;.tsx&quot;, &quot;.xml&quot;, &quot;.json&quot;, &quot;.yaml&quot;, &quot;.yml&quot;, &quot;.sh&quot;, &quot;.bat&quot;, &quot;.ps1&quot;, &quot;.rb&quot;, &quot;.php&quot;, &quot;.go&quot;, &quot;.rs&quot;, &quot;.swift&quot;, &quot;.kt&quot;, &quot;.ipynb&quot;, &quot;.sql&quot;, &quot;.toml&quot;]);
add_category!(map, &quot;apps&quot;, [&quot;.exe&quot;, &quot;.msi&quot;, &quot;.apk&quot;, &quot;.dmg&quot;, &quot;.deb&quot;, &quot;.rpm&quot;, &quot;.app&quot;]);
add_category!(map, &quot;fonts&quot;, [&quot;.ttf&quot;, &quot;.otf&quot;, &quot;.woff&quot;, &quot;.woff2&quot;]);
add_category!(map, &quot;shortcuts&quot;, [&quot;.lnk&quot;, &quot;.url&quot;]);
// Ensure the essential &quot;other&quot; category exists for files that don't match any other category.
map.insert(&quot;other&quot;.to_string(), vec![]);
CategoriesConfig(map)
}
/// Loads category configuration from a specified JSON file path.
/// Falls back to default categories if the path is None, the file doesn't exist,
/// or parsing fails. Ensures the 'other' category is present in the loaded config.
fn load_config_file(config_path: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;CategoriesConfig&gt; {
match config_path {
Some(path) if path.is_file() =&gt; {
// Attempt to load and parse the custom configuration file
info!(&quot;Loading category configuration from: {}&quot;, path.display());
let file_content = fs::read_to_string(path)
.with_context(|| format!(&quot;Failed to read config file: {}&quot;, path.display()))?;
let mut config: HashMap&lt;String, Vec&lt;String&gt;&gt; = serde_json::from_str(&amp;file_content)
.with_context(|| format!(&quot;Failed to parse JSON config file: {}&quot;, path.display()))?;
// Ensure 'other' category exists for fallback mechanism.
// If the user provided a config without 'other', add it automatically.
config.entry(&quot;other&quot;.to_string()).or_insert_with(Vec::new);
info!(&quot;Successfully loaded and validated custom configuration.&quot;);
Ok(CategoriesConfig(config))
}
Some(path) =&gt; {
// Path specified but it's not a file (or doesn't exist)
warn!(
&quot;Config path '{}' provided but is not a valid file. Using default categories.&quot;,
path.display()
);
Ok(default_categories())
}
None =&gt; {
// No config path provided, use defaults
info!(&quot;No config file specified. Using default category configuration.&quot;);
Ok(default_categories())
}
}
}
/// Determines the category name (String) for a given file based on its extension
/// and the provided category configuration.
fn categorize_file(filename: &amp;Path, categories_config: &amp;CategoriesConfig) -&gt; String {
// Extract extension, prepend '.', convert to lowercase for case-insensitive matching.
let extension = filename
.extension()
.and_then(|s| s.to_str()) // Convert OsStr to &amp;str, returns None if not valid UTF-8
.map(|s| format!(&quot;.{}&quot;, s.to_lowercase()))
.unwrap_or_else(|| &quot;no_extension&quot;.to_string()); // Handle files with no extension or non-UTF8 extensions
// Handle files with no extension explicitly
if extension == &quot;no_extension&quot; {
return extension;
}
// Iterate through the configured categories and their associated extensions.
for (category, extensions) in &amp;categories_config.0 {
// Check if the file's extension is present in the list for this category
if extensions.contains(&amp;extension) {
return category.clone(); // Return the matching category name
}
}
// If no specific category matched, fallback to the &quot;other&quot; category.
// load_config_file ensures the &quot;other&quot; key exists in the HashMap.
&quot;other&quot;.to_string()
}
// --- Platform Specific ---
/// Checks if a file or directory is hidden on Windows using standard library features.
#[cfg(windows)]
fn is_hidden(path: &amp;Path) -&gt; Result&lt;bool&gt; {
use std::os::windows::fs::MetadataExt;
// Use the standard library extension trait for a safer abstraction than raw Win32 calls
let metadata = fs::metadata(path)
.with_context(|| format!(&quot;Failed to get metadata for {}&quot;, path.display()))?;
// Get the raw file attributes bitfield
let attributes = metadata.file_attributes();
// Check if the FILE_ATTRIBUTE_HIDDEN bit is set
Ok((attributes &amp; std::os::windows::fs::FILE_ATTRIBUTE_HIDDEN) != 0)
}
/// Checks if a file or directory is hidden on Unix-like systems (conventionally, starts with '.').
#[cfg(not(windows))]
fn is_hidden(path: &amp;Path) -&gt; Result&lt;bool&gt; {
// Standard check for hidden files/dirs on Unix-like systems.
Ok(path
.file_name()
.and_then(|s| s.to_str()) // Get filename as string slice
.map(|s| s.starts_with('.')) // Check if it starts with '.'
.unwrap_or(false)) // If no filename or not UTF-8, assume not hidden by this convention
}
/// Helper for walkdir filter_entry to check hidden status before descending into directories or processing files.
/// Logs errors but doesn't stop the walk; returns `true` if entry should be kept (i.e., not hidden or check failed).
/// **Improvement:** Defaults to excluding (`false`) if the check fails, for safety.
fn should_keep_entry(entry: &amp;DirEntry, include_hidden: bool) -&gt; bool {
if include_hidden {
return true; // Keep everything if --include-hidden flag is set
}
// Otherwise, check the hidden status
match is_hidden(entry.path()) {
Ok(hidden) =&gt; !hidden, // Keep if NOT hidden
Err(err) =&gt; {
// Log the error but default to *excluding* the entry for safety if status is unknown
warn!(
&quot;Could not determine hidden status for {}: {}. Excluding entry.&quot;,
entry.path().display(), err
);
false // Exclude if check fails
}
}
}
// --- Command Line Arguments ---
/// Enum defining the organization methods, used for clap validation.
/// This ensures only valid options are accepted via the command line.
#[derive(clap::ValueEnum, Clone, Debug, PartialEq, Eq)]
enum OrganizeMethod {
Category,
Extension,
}
/// Defines the command-line interface structure using clap derive macros.
/// Doc comments are used to generate help messages for the user.
#[derive(Parser, Debug)]
#[command(author, version, about = &quot;Organize files by category or extension (Rust version).&quot;,
long_about = &quot;A Rust utility for organizing files from source directories into categorized target folders based on file types or extensions.&quot;,
help_template = &quot;{before-help}{name} {version}\n{author-with-newline}{about-with-newline}\n{usage-heading} {usage}\n\n{all-args}{after-help}&quot; // Custom help format
)]
struct CliArgs {
/// Source directory containing files to organize.
#[arg(short, long, value_name = &quot;DIR&quot;)]
source: PathBuf,
/// Target directory where organized files will be placed.
#[arg(short, long, value_name = &quot;DIR&quot;)]
target: PathBuf,
/// Path to JSON config file for custom file categories and extensions.
#[arg(short, long, value_name = &quot;FILE&quot;)]
config: Option&lt;PathBuf&gt;,
/// Method for organizing files (category or extension).
#[arg(long, value_enum, default_value_t = OrganizeMethod::Category)]
organize_by: OrganizeMethod,
/// Move files instead of copying them (default is copy).
#[arg(long)]
move_files: bool,
/// Append timestamp+counter to duplicate filenames. Conflicts with --skip-existing and --overwrite.
#[arg(long, conflicts_with_all = [&quot;skip_existing&quot;, &quot;overwrite&quot;])]
timestamp_duplicates: bool,
/// Skip processing if a file with the same name exists in the target. Conflicts with --timestamp-duplicates and --overwrite.
#[arg(long, short = 'k', conflicts_with_all = [&quot;timestamp_duplicates&quot;, &quot;overwrite&quot;])]
skip_existing: bool,
/// Overwrite existing files in the target directory. Conflicts with --timestamp-duplicates and --skip-existing.
#[arg(long, conflicts_with_all = [&quot;timestamp_duplicates&quot;, &quot;skip_existing&quot;])]
overwrite: bool, // Explicit overwrite flag
/// Include hidden files/folders (e.g., starting with '.') in processing.
#[arg(long, short = 'i')]
include_hidden: bool,
/// Follow symbolic links (process target, not link). Use with caution (potential loops).
#[arg(long, short = 'l')]
follow_links: bool,
/// After moving (--move must be enabled), attempt to remove empty source directories.
#[arg(long, requires = &quot;move_files&quot;)]
remove_empty_source_dirs: bool,
/// Optional path to a file for logging progress and errors.
#[arg(long, value_name = &quot;FILE&quot;)]
log_file: Option&lt;PathBuf&gt;,
/// Set the log level (e.g., error, warn, info, debug, trace).
#[arg(long, value_parser = clap::value_parser!(LevelFilter), default_value = &quot;info&quot;)]
log_level: LevelFilter,
}
// --- Core Logic ---
/// Holds statistics about the file processing operation, including failed file paths and errors.
#[derive(Debug, Default)]
struct ProcessStats {
/// Count of directory entries successfully yielded by the filtered WalkDir iterator (includes files, dirs, etc.).
/// **Clarification:** This counts entries *before* filtering for files-only in the processing loop.
total_scanned: u64,
processed: u64,          // Count of files successfully copied/moved
skipped: u64,            // Count of files skipped (e.g., duplicates, hidden, non-file)
errors: u64,             // Count of files that failed during processing (copy/move/timestamp) or critical scan errors
failed_files: Vec&lt;(PathBuf, String)&gt;, // Stores paths and error context of failed files
}
/// Scans the source directory to find all unique file extensions (lowercase, without dot).
/// This is primarily used when `organize_by` is `Extension` to pre-create necessary folders efficiently.
fn get_all_extensions(
source_directory: &amp;Path,
include_hidden: bool,
follow_links: bool,
) -&gt; Result&lt;HashSet&lt;String&gt;&gt; {
let mut extensions = HashSet::new();
info!(&quot;Scanning source directory for all unique file extensions...&quot;);
let walker = WalkDir::new(source_directory)
.follow_links(follow_links) // Control whether to follow symlinks
.into_iter();
let mut count = 0;
// Use filter_entry for more efficient hidden filtering during the scan
for entry_result in walker.filter_entry(|e| should_keep_entry(e, include_hidden)) {
match entry_result {
Ok(entry) =&gt; {
let path = entry.path();
// Process only files
if path.is_file() {
// No need to re-check is_hidden here, filter_entry handles it based on should_keep_entry logic.
count += 1;
// Extract extension if the file has one and it's valid UTF-8
if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
extensions.insert(ext.to_lowercase()); // Store lowercase extension
}
// Log progress periodically for very large directories
if count % 1000 == 0 {
debug!(&quot;Scanned {} files for extensions...&quot;, count);
}
}
}
Err(e) =&gt; warn!(&quot;Error accessing entry during extension scan: {}&quot;, e), // Log errors encountered during directory walk
}
}
info!(&quot;Found {} unique extensions.&quot;, extensions.len());
Ok(extensions)
}
/// Creates necessary target subfolders based on the organization method.
/// Ensures the base target directory exists first.
fn create_target_folders(
base_dir: &amp;Path,
organize_by: &amp;OrganizeMethod,
categories_config: Option&lt;&amp;CategoriesConfig&gt;,
all_extensions: Option&lt;&amp;HashSet&lt;String&gt;&gt;,
) -&gt; Result&lt;()&gt; {
info!(&quot;Ensuring target base directory exists: {}&quot;, base_dir.display());
// Create the base target directory and any necessary parent directories
fs::create_dir_all(base_dir)
.with_context(|| format!(&quot;Failed to create base target directory: {}&quot;, base_dir.display()))?;
// Determine the set of folders needed based on the organization strategy.
let folders_to_create: HashSet&lt;String&gt; = match organize_by {
OrganizeMethod::Category =&gt; {
// Collect all category names from the config
let mut folders = categories_config
.map(|cfg| cfg.0.keys().cloned().collect::&lt;HashSet&lt;String&gt;&gt;())
.unwrap_or_default();
// Ensure essential fallback folders exist for files without extensions or unmatched types
folders.insert(&quot;other&quot;.to_string());
folders.insert(&quot;no_extension&quot;.to_string());
folders
}
OrganizeMethod::Extension =&gt; {
// Collect all unique extensions found during scan
let mut folders = all_extensions.cloned().unwrap_or_default();
// Ensure essential fallback folder exists for files without extensions
folders.insert(&quot;no_extension&quot;.to_string());
folders
}
};
info!(
&quot;Creating target subfolders (mode: {:?}). Total potential folders: {}&quot;,
organize_by,
folders_to_create.len()
);
let mut created_count = 0;
for folder_name in &amp;folders_to_create {
// Avoid creating folders with potentially invalid names (e.g., empty string if an extension was just &quot;.&quot;)
if folder_name.is_empty() {
warn!(&quot;Skipping creation of folder with empty name.&quot;);
continue;
}
let folder_path = base_dir.join(folder_name);
// Check if folder already exists before trying to create
if !folder_path.exists() {
// Create the folder and any necessary parents
fs::create_dir_all(&amp;folder_path).with_context(|| {
format!(&quot;Failed to create target folder '{}'&quot;, folder_path.display())
})?;
debug!(&quot;Created target folder: {}&quot;, folder_path.display());
created_count += 1;
}
}
info!(&quot;Created {} new target subfolders.&quot;, created_count);
Ok(())
}
/// Attempts to move a file using `fs::rename`, falling back to copy-then-delete
/// if `fs::rename` fails (e.g., due to being on different filesystems/devices).
fn move_file_with_fallback(source: &amp;Path, target: &amp;Path) -&gt; io::Result&lt;()&gt; {
// Attempt the efficient rename first, which is atomic on the same filesystem
match fs::rename(source, target) {
Ok(_) =&gt; Ok(()), // Rename succeeded
Err(rename_error) =&gt; {
// Check if the error is likely due to moving across different filesystems/devices.
// This requires checking platform-specific OS error codes.
// Note: Relies on platform-specific OS error codes (Windows: 17, Unix: 18/libc::EXDEV). Might be brittle.
let is_cross_device = || -&gt; bool {
#[cfg(windows)] { rename_error.raw_os_error() == Some(17) } // ERROR_NOT_SAME_DEVICE
#[cfg(unix)] { rename_error.raw_os_error() == Some(18) } // libc::EXDEV
#[cfg(not(any(windows, unix)))] { false } // Default for other platforms
};
if is_cross_device() {
// If it's a cross-device error, attempt copy-then-delete fallback
warn!(&quot;Rename failed (cross-device error detected), attempting copy+delete fallback for move: {} -&gt; {}&quot;, source.display(), target.display());
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source, target)?; // Attempt copy
fs::remove_file(source)?; // Attempt delete original
Ok(()) // Fallback succeeded
} else {
// If it was a different rename error (e.g., permissions), re-throw it.
Err(rename_error)
}
}
}
}
/// Main function to perform the file organization based on parsed arguments.
/// Iterates through source files, determines target paths, handles duplicates,
/// performs copy/move operations, and collects statistics.
fn organize_files(args: &amp;CliArgs, categories_config: &amp;CategoriesConfig) -&gt; Result&lt;ProcessStats&gt; {
// --- Initial Validation &amp; Setup ---
if !args.source.is_dir() {
bail!(&quot;Source directory '{}' is invalid or not found.&quot;, args.source.display());
}
// Ensure target directory exists or create it
if !args.target.exists() {
info!(&quot;Creating target directory: {}&quot;, args.target.display());
fs::create_dir_all(&amp;args.target).with_context(|| {
format!(&quot;Could not create target directory '{}'&quot;, args.target.display())
})?;
} else if !args.target.is_dir() {
bail!(&quot;Target path '{}' exists but is not a directory.&quot;, args.target.display());
}
// --- Pre-scan for Extensions (if needed) and Pre-create Folders ---
// This ensures target folders exist before we start moving/copying files into them.
info!(&quot;Preparing target folders...&quot;);
let extensions_for_folders = if args.organize_by == OrganizeMethod::Extension {
Some(get_all_extensions(&amp;args.source, args.include_hidden, args.follow_links)?)
} else {
None
};
create_target_folders(
&amp;args.target,
&amp;args.organize_by,
Some(categories_config), // Pass config needed for category mode
extensions_for_folders.as_ref(), // Pass extensions needed for extension mode
)?;
// --- Process Files ---
info!(&quot;Starting file processing...&quot;);
let mut stats = ProcessStats::default(); // Initialize statistics
let mut file_counter = 0u64; // Counter for progress reporting
// Use WalkDir again for the main processing loop, applying filters efficiently
let walker = WalkDir::new(&amp;args.source)
.follow_links(args.follow_links) // Control symlink following
.into_iter();
// filter_entry is used to efficiently skip hidden directories/files if requested
for entry_result in walker.filter_entry(|e| should_keep_entry(e, args.include_hidden)) {
// Increment scan counter for every entry successfully yielded by the filtered iterator
stats.total_scanned += 1;
let entry = match entry_result {
Ok(e) =&gt; e,
Err(e) =&gt; {
// Log errors encountered during directory traversal itself
error!(&quot;Error scanning path {}: {}&quot;, e.path().unwrap_or(Path::new(&quot;?&quot;)).display(), e);
stats.errors += 1; // Count scan errors towards total errors
// Record scan error details
stats.failed_files.push((
e.path().unwrap_or_default().to_path_buf(),
format!(&quot;Scan error: {:?}&quot;, e),
));
continue; // Skip this problematic entry
}
};
// We are only interested in processing files in this loop
if !entry.file_type().is_file() {
stats.skipped += 1; // Count skipped directories/symlinks etc.
continue;
}
// If we reached here, it's a file we intend to process
file_counter += 1;
let source_path = entry.path();
let progress_prefix = format!(&quot;[{}]&quot;, file_counter); // Simple counter for progress logging
// --- Inner processing block to handle errors per file using anyhow ---
// This allows logging an error for a single file and continuing with the next.
let file_result: Result&lt;()&gt; = (|| {
// No need to re-check is_hidden, filter_entry handles it.
// Extract filename, handling potential errors (e.g., invalid path)
let file_name = source_path.file_name()
.with_context(|| format!(&quot;Could not get filename for path: {}&quot;, source_path.display()))?;
// Determine target subfolder name based on organization strategy
let target_subfolder_name = match args.organize_by {
OrganizeMethod::Category =&gt; categorize_file(source_path, categories_config),
OrganizeMethod::Extension =&gt; source_path
.extension()
.and_then(|s| s.to_str()) // Get extension as string
.map(|s| s.to_lowercase()) // Convert to lowercase
.unwrap_or_else(|| &quot;no_extension&quot;.to_string()), // Handle no extension
};
let target_folder_path = args.target.join(&amp;target_subfolder_name);
let mut target_file_path = target_folder_path.join(file_name);
// --- Handle potential duplicate files in the target directory ---
if target_file_path.exists() {
if args.skip_existing {
// User requested skipping duplicates
info!(
&quot;{} Skipping (target exists): {}&quot;,
progress_prefix,
target_file_path.display()
);
stats.skipped += 1;
return Ok(()); // Successfully skipped this file
} else if args.timestamp_duplicates {
// User requested adding timestamps to duplicates
let original_target_path_display = target_file_path.display().to_string();
let mut counter = 1;
// Safely get stem and extension, providing defaults if they don't exist
let stem = source_path.file_stem().unwrap_or(file_name.as_os_str()); // Use original filename if no stem
let ext = source_path.extension().unwrap_or_default(); // Empty OsStr if no extension
const MAX_TIMESTAMP_ATTEMPTS: u32 = 1000; // Safety break for the loop
loop {
let timestamp = Local::now().format(&quot;%Y%m%d_%H%M%S&quot;);
// Construct new filename using OsString to handle non-UTF8 filenames safely
let mut new_name_os = std::ffi::OsString::new();
new_name_os.push(stem);
new_name_os.push(format!(&quot;_{}_{}&quot;, timestamp, counter)); // Add timestamp and counter
if !ext.is_empty() {
new_name_os.push(&quot;.&quot;); // Add dot only if there was an extension
new_name_os.push(ext);
}
target_file_path = target_folder_path.join(&amp;new_name_os); // Update the target path
if !target_file_path.exists() {
break; // Found a unique name, exit the loop
}
counter += 1;
// Safety break to prevent potential infinite loops if unique names are hard to find
if counter &gt; MAX_TIMESTAMP_ATTEMPTS {
// Use bail! from anyhow to return an error directly from this inner block
bail!(
&quot;Could not find unique timestamped name for {} after {} attempts. Skipping.&quot;,
original_target_path_display, MAX_TIMESTAMP_ATTEMPTS
);
}
}
// Log the renaming action
info!(
&quot;{} Target exists '{}'. Renaming duplicate to: {}&quot;,
progress_prefix,
original_target_path_display,
target_file_path.display()
);
} else if args.overwrite {
// Explicit overwrite flag is set
warn!(
&quot;{} Overwriting existing target file: {}&quot;,
progress_prefix,
target_file_path.display()
);
// Overwrite happens implicitly below by copy/move
} else {
// Default behavior if no specific duplicate handling flag is set: Overwrite
warn!(
&quot;{} Overwriting existing target file (default): {}&quot;,
progress_prefix,
target_file_path.display()
);
// Overwrite happens implicitly below by copy/move
}
} // End duplicate check block
// Ensure target directory exists *just before* the operation (belt-and-suspenders approach)
// This handles rare cases where the folder might have been deleted after the initial check.
fs::create_dir_all(&amp;target_folder_path).with_context(|| format!(&quot;Failed to ensure target directory '{}' exists&quot;, target_folder_path.display()))?;
// --- Perform the file operation (Copy or Move) ---
let operation_desc = if args.move_files { &quot;move&quot; } else { &quot;copy&quot; };
debug!(
&quot;{} Attempting to {} '{}' to '{}'&quot;,
progress_prefix,
operation_desc,
source_path.display(),
target_file_path.display()
);
if args.move_files {
// Use the robust move function with fallback for cross-device errors
move_file_with_fallback(source_path, &amp;target_file_path)
.with_context(|| format!(&quot;Failed to move '{}' to '{}'&quot;, source_path.display(), target_file_path.display()))?;
} else {
// Standard copy.
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source_path, &amp;target_file_path)
.map(|_| ()) // Discard the number of bytes copied (u64) result, returning () on success
.with_context(|| format!(&quot;Failed to copy '{}' to '{}'&quot;, source_path.display(), target_file_path.display()))?;
}
stats.processed += 1; // Increment processed count only on success
Ok(()) // Indicate success for this file's processing
})(); // End of inner result block for per-file error handling
// --- Handle result for this specific file ---
if let Err(e) = file_result {
// Log the detailed error using anyhow's Debug format
error!(&quot;{} Failed to process '{}': {:?}&quot;, progress_prefix, source_path.display(), e);
stats.errors += 1;
// Store error context along with the path
stats.failed_files.push((source_path.to_path_buf(), format!(&quot;{:?}&quot;, e)));
}
} // End of main file processing loop
Ok(stats) // Return the final statistics
}
/// Recursively removes empty folders starting from the bottom up within a given directory.
/// This is typically used after a move operation to clean up the source directory.
/// Uses a collect-then-sort approach for simplicity and to avoid potential
/// issues with modifying the directory structure while iterating.
fn remove_empty_folders(directory: &amp;Path) -&gt; Result&lt;u32&gt; {
let mut removed_count = 0u32;
info!(&quot;Attempting to remove empty directories within: {}&quot;, directory.display());
// Collect directory paths first. This avoids borrow checker issues with WalkDir
// if we were to modify the directory structure while iterating (e.g., removing a dir).
let mut dirs_to_check = Vec::new();
// Start scan from depth 1 to avoid trying to remove the root directory itself.
for entry_result in WalkDir::new(directory).min_depth(1) {
match entry_result {
Ok(entry) if entry.file_type().is_dir() =&gt; {
dirs_to_check.push(entry.into_path()); // Collect path if it's a directory
}
Ok(_) =&gt; {} // Ignore files
Err(e) =&gt; warn!(&quot;Error accessing entry during empty dir scan: {}&quot;, e), // Log errors during scan
}
}
// Sort paths by depth (longest paths first) to ensure bottom-up processing.
// This is crucial so we attempt to remove child directories before their parents.
dirs_to_check.sort_by(|a, b| b.components().count().cmp(&amp;a.components().count()));
for dir_path in dirs_to_check {
// Check if directory still exists before trying to read/remove (it might have been removed in a previous step)
if !dir_path.is_dir() {
continue;
}
match fs::read_dir(&amp;dir_path) {
Ok(mut read_dir) =&gt; {
// Check if the directory is truly empty by trying to get the first entry.
// read_dir.next().is_none() is true if the directory is empty.
if read_dir.next().is_none() {
// Directory is empty, attempt to remove it.
match fs::remove_dir(&amp;dir_path) {
Ok(_) =&gt; {
info!(&quot;Removed empty directory: {}&quot;, dir_path.display());
removed_count += 1;
}
Err(e) =&gt; {
// Log warnings for common non-critical errors like permissions
// or race conditions where the dir became non-empty between read_dir and remove_dir.
// Don't treat NotFound as a warning if it was just removed by another process or race condition.
if e.kind() != ErrorKind::NotFound {
warn!(
&quot;Could not remove presumably empty directory '{}': {}&quot;,
dir_path.display(), e
);
}
}
}
}
// else: Directory is not empty, do nothing.
}
Err(e) =&gt; {
// Don't warn if the directory was removed between listing and checking emptiness.
if e.kind() != ErrorKind::NotFound {
warn!(
&quot;Could not read directory '{}' to check emptiness: {}&quot;,
dir_path.display(), e
);
}
}
}
}
info!(&quot;Finished removing empty directories. Removed: {}&quot;, removed_count);
Ok(removed_count) // Return the count of removed directories
}
// --- Logging Setup ---
/// Sets up logging using the fern crate to log to stderr and optionally a file.
/// Configures formatting, level filtering, and color output for the console.
fn setup_logging(log_level: LevelFilter, log_file: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;()&gt; {
// Configure colors for terminal output levels for better readability
let colors = ColoredLevelConfig::new()
.error(Color::Red)
.warn(Color::Yellow)
.info(Color::Green)
.debug(Color::Blue)
.trace(Color::BrightBlack);
// Base dispatch configuration common to all loggers
let base_config = fern::Dispatch::new()
// Format messages including timestamp (with milliseconds), colored level, target module, and message
.format(move |out, message, record| {
out.finish(format_args!(
&quot;[{} {} {}] {}&quot;,
chrono::Local::now().format(&quot;%Y-%m-%d %H:%M:%S%.3f&quot;), // Time format with ms
colors.color(record.level()), // Apply color to level text
record.target(), // Module path where log occurred (e.g., `rust_file_organizer::main`)
message
))
})
// Apply the global log level filter passed from arguments (e.g., Info, Debug)
.level(log_level)
// Filter out overly verbose logs from common libraries unless explicitly requested at a higher level
// This keeps the default output cleaner when running at Info level.
.level_for(&quot;hyper&quot;, LevelFilter::Warn)
.level_for(&quot;mio&quot;, LevelFilter::Warn)
.level_for(&quot;want&quot;, LevelFilter::Warn)
.level_for(&quot;reqwest&quot;, LevelFilter::Warn)
.level_for(&quot;rustls&quot;, LevelFilter::Warn);
// Chain the stderr logger. By default, only show messages from our crate unless Debug/Trace is enabled.
let stderr_logger = fern::Dispatch::new()
.filter(move |metadata| {
// Show logs from our crate OR if the global level is Debug or Trace
log_level &lt;= LevelFilter::Debug || metadata.target().starts_with(env!(&quot;CARGO_PKG_NAME&quot;))
})
.chain(std::io::stderr()); // Chain to standard error output
// Start building the final dispatch configuration, always including stderr
let mut final_dispatch = base_config.chain(stderr_logger);
// Chain the file logger conditionally if a path is provided
let mut file_logger_ok = false; // Track if file logger setup succeeds
if let Some(log_path) = log_file {
match fern::log_file(log_path) {
Ok(file_output) =&gt; {
// If file opened successfully, chain it to the dispatch
final_dispatch = final_dispatch.chain(file_output);
file_logger_ok = true;
}
Err(e) =&gt; {
// If file creation fails, log error directly to stderr (logger not ready yet)
// and proceed without file logging.
eprintln!(
&quot;Error: Failed to create log file '{}': {}. Logging to console only.&quot;,
log_path.display(), e
);
}
}
}
// Apply the final combined logging configuration
final_dispatch.apply().context(&quot;Failed to set up logging&quot;)?;
// Log confirmation *after* apply() succeeds
if file_logger_ok {
if let Some(path) = log_file {
info!(&quot;File logging enabled to: {}&quot;, path.display());
}
}
Ok(())
}
// --- Main Application Entry Point ---
fn main() -&gt; Result&lt;()&gt; {
// Record start time for overall duration calculation
let overall_start_time = Instant::now();
// Parse command-line arguments using clap
let args = CliArgs::parse();
// --- Setup Logging ---
// Initialize logging early based on args.log_level and optional args.log_file
// This allows logging during argument validation or config loading if needed.
setup_logging(args.log_level, args.log_file.as_ref())?;
// --- Log Startup Information ---
info!(&quot;Rust File Organizer (v{}) starting...&quot;, env!(&quot;CARGO_PKG_VERSION&quot;));
// Log full arguments only if debug level is enabled
debug!(&quot;Arguments received: {:?}&quot;, args);
// Log key operational parameters at info level for traceability
info!(&quot;Source directory: {}&quot;, args.source.display());
info!(&quot;Target directory: {}&quot;, args.target.display());
info!(&quot;Organization mode: {:?}&quot;, args.organize_by); // Use Debug format for enum
info!(&quot;Operation: {}&quot;, if args.move_files { &quot;Move&quot; } else { &quot;Copy&quot; });
info!(&quot;Include hidden: {}&quot;, args.include_hidden);
info!(&quot;Follow links: {}&quot;, args.follow_links);
// Log duplicate handling strategy clearly based on flags
if args.skip_existing { info!(&quot;Duplicate handling: Skip existing&quot;); }
else if args.timestamp_duplicates { info!(&quot;Duplicate handling: Timestamp duplicates&quot;); }
else if args.overwrite { info!(&quot;Duplicate handling: Overwrite existing (explicitly)&quot;); }
else { info!(&quot;Duplicate handling: Overwrite existing (default)&quot;); } // Log default
// --- Load Configuration ---
// Load categories from JSON file or use defaults; ensures 'other' category exists.
let categories = load_config_file(args.config.as_ref())?;
// Optionally log loaded categories at debug level if needed for troubleshooting
// debug!(&quot;Using categories: {:?}&quot;, categories.0.keys());
// --- Execute Core Logic ---
// Call the main organization function and handle its result
let result = organize_files(&amp;args, &amp;categories);
// --- Handle Results and Optional Cleanup ---
match result {
Ok(stats) =&gt; {
// --- Optional Cleanup: Remove empty source directories after successful move ---
if args.move_files &amp;&amp; args.remove_empty_source_dirs &amp;&amp; stats.processed &gt; 0 {
// Attempt cleanup but log errors non-fatally, as the main task succeeded
if let Err(e) = remove_empty_folders(&amp;args.source) {
error!(&quot;Error during empty source directory removal: {:?}&quot;, e);
// Note: Cleanup errors are logged but do not cause a non-zero exit code by default.
}
}
// --- Final Summary ---
let overall_duration = overall_start_time.elapsed(); // Calculate total duration correctly
let summary = format!(
&quot;Operation completed in {:.2?}. Scanned Entries: {}, Processed Files: {}, Skipped: {}, Errors: {}&quot;,
overall_duration, stats.total_scanned, stats.processed, stats.skipped, stats.errors
);
info!(&quot;{}&quot;, summary); // Log summary
println!(&quot;\n{}&quot;, summary); // Print final summary to console (stdout)
// If errors occurred during file processing, print the list of failed files and their errors to stderr
if stats.errors &gt; 0 {
eprintln!(&quot;\n--- Errors occurred during processing: ---&quot;); // Print errors to stderr
for (path, error_msg) in &amp;stats.failed_files {
eprintln!(&quot; - File: {}&quot;, path.display());
eprintln!(&quot;   Error: {}&quot;, error_msg); // Show the captured error context
}
eprintln!(&quot;-----------------------------------------&quot;);
eprintln!(
&quot;Warning: {} errors occurred. Please check logs (stderr/file) for full details.&quot;,
stats.errors
);
// Consider exiting with a non-zero status code for scripting purposes if any errors occurred
// std::process::exit(1);
}
}
Err(e) =&gt; {
// Log the critical error that stopped the organization process entirely
error!(&quot;Critical error during file organization: {:?}&quot;, e); // Use Debug format for anyhow::Error chain
eprintln!(&quot;\nError: File organization failed critically. Check logs (stderr/file) for details.&quot;);
std::process::exit(1); // Exit with a non-zero code on critical failure
}
}
info!(&quot;Rust File Organizer finished.&quot;);
Ok(()) // Indicate successful completion (even if non-critical file errors occurred)
}
// --- Testing Notes ---
// To properly test this application, consider using crates like:
// - `assert_fs`: For creating temporary file/directory structures for tests.
// - `predicates`: For making assertions about file system state (e.g., file exists, content matches).
// - `assert_cmd`: For testing the command-line interface behavior, arguments, exit codes, and output.
//
// Example Test Scenarios (Conceptual):
// - Test basic copy/move by category and extension.
// - Test duplicate handling flags (skip, timestamp, overwrite) work correctly.
// - Test hidden file handling with and without the --include-hidden flag.
// - Test symbolic link handling with and without the --follow-links flag.
// - Test behavior with empty source or target directories.
// - Test custom configuration loading and verify correct categorization (including missing 'other').
// - Test empty directory removal after a successful move operation.
// - Test error handling for scenarios like insufficient permissions (harder to automate reliably).
// - Test long path handling specifically on Windows (requires careful test setup).
// - Test cross-device move fallback behavior.
// - Test handling of filenames with non-UTF8 characters (requires OsStr handling)." data-download-link="" data-download-link-label="Download Rust"><code class="language-rust">// src/main.rs: Rust implementation of the file organizer utility.
// This version incorporates improvements based on self-critique:
// - Uses fern for flexible logging (console + optional file).
// - Uses anyhow for error handling with context.
// - Uses std lib for platform-specific hidden file checks.
// - Uses clap ValueEnum for argument validation.
// - Implements explicit --overwrite flag and robust duplicate handling.
// - Implements robust move operation with cross-device fallback.
// - Reports list of failed files WITH error context.
// - Includes more detailed comments.
// - Correctly calculates execution duration.
// - Safely excludes entries where hidden status check fails.
// - Clarified meaning of `total_scanned` statistic.
use anyhow::{bail, Context, Result}; // Use anyhow for convenient error handling
use clap::Parser; // For command-line argument parsing
use chrono::Local; // For generating timestamps
use fern::colors::{Color, ColoredLevelConfig}; // For colored logging output
use log::{debug, error, info, warn, LevelFilter}; // Logging facade
use serde::Deserialize; // For deserializing JSON config
use std::{
collections::{HashMap, HashSet},
env, // For CARGO_PKG_VERSION
fs::{self, File}, // Standard file system operations
io::{self, ErrorKind},
path::{Path, PathBuf},
time::Instant, // For accurate duration measurement
};
use walkdir::{DirEntry, WalkDir}; // For efficient directory traversal
// --- Configuration Structures ---
/// Represents the structure of the JSON configuration file for categories.
/// Using a tuple struct for better type safety than just HashMap directly.
#[derive(Deserialize, Debug, Clone)]
struct CategoriesConfig(HashMap&lt;String, Vec<String>&gt;);
/// Provides the default file categorization configuration.
/// This is used if no custom config file is provided or if loading fails.
fn default_categories() -&gt; CategoriesConfig {
let mut map = HashMap::new();
// Helper macro to reduce boilerplate when defining default categories
macro_rules! add_category {
($map:expr, $name:expr, [$($ext:expr),* $(,)?]) =&gt; {
// Inserts a category name and its associated list of lowercase extensions (including '.')
$map.insert($name.to_string(), vec![$($ext.to_string()),*]);
};
}
// Define standard categories and their common extensions
add_category!(map, "images", [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff", ".svg", ".ico"]);
add_category!(map, "documents", [".pdf", ".docx", ".doc", ".txt", ".rtf", ".odt", ".xlsx", ".xls", ".csv", ".pptx", ".ppt", ".md", ".tex", ".chm", ".epub"]);
add_category!(map, "videos", [".mp4", ".avi", ".mkv", ".mov", ".wmv", ".flv", ".webm"]);
add_category!(map, "audio", [".mp3", ".wav", ".flac", ".aac", ".ogg", ".m4a"]);
add_category!(map, "archives", [".zip", ".rar", ".tar", ".gz", ".bz2", ".7z", ".iso"]);
add_category!(map, "code", [".py", ".java", ".c", ".cpp", ".h", ".cs", ".html", ".css", ".js", ".ts", ".jsx", ".tsx", ".xml", ".json", ".yaml", ".yml", ".sh", ".bat", ".ps1", ".rb", ".php", ".go", ".rs", ".swift", ".kt", ".ipynb", ".sql", ".toml"]);
add_category!(map, "apps", [".exe", ".msi", ".apk", ".dmg", ".deb", ".rpm", ".app"]);
add_category!(map, "fonts", [".ttf", ".otf", ".woff", ".woff2"]);
add_category!(map, "shortcuts", [".lnk", ".url"]);
// Ensure the essential "other" category exists for files that don't match any other category.
map.insert("other".to_string(), vec![]);
CategoriesConfig(map)
}
/// Loads category configuration from a specified JSON file path.
/// Falls back to default categories if the path is None, the file doesn't exist,
/// or parsing fails. Ensures the 'other' category is present in the loaded config.
fn load_config_file(config_path: Option&lt;&amp;PathBuf&gt;) -&gt; Result<CategoriesConfig> {
match config_path {
Some(path) if path.is_file() =&gt; {
// Attempt to load and parse the custom configuration file
info!("Loading category configuration from: {}", path.display());
let file_content = fs::read_to_string(path)
.with_context(|| format!("Failed to read config file: {}", path.display()))?;
let mut config: HashMap&lt;String, Vec<String>&gt; = serde_json::from_str(&amp;file_content)
.with_context(|| format!("Failed to parse JSON config file: {}", path.display()))?;
// Ensure 'other' category exists for fallback mechanism.
// If the user provided a config without 'other', add it automatically.
config.entry("other".to_string()).or_insert_with(Vec::new);
info!("Successfully loaded and validated custom configuration.");
Ok(CategoriesConfig(config))
}
Some(path) =&gt; {
// Path specified but it's not a file (or doesn't exist)
warn!(
"Config path '{}' provided but is not a valid file. Using default categories.",
path.display()
);
Ok(default_categories())
}
None =&gt; {
// No config path provided, use defaults
info!("No config file specified. Using default category configuration.");
Ok(default_categories())
}
}
}
/// Determines the category name (String) for a given file based on its extension
/// and the provided category configuration.
fn categorize_file(filename: &amp;Path, categories_config: &amp;CategoriesConfig) -&gt; String {
// Extract extension, prepend '.', convert to lowercase for case-insensitive matching.
let extension = filename
.extension()
.and_then(|s| s.to_str()) // Convert OsStr to &amp;str, returns None if not valid UTF-8
.map(|s| format!(".{}", s.to_lowercase()))
.unwrap_or_else(|| "no_extension".to_string()); // Handle files with no extension or non-UTF8 extensions
// Handle files with no extension explicitly
if extension == "no_extension" {
return extension;
}
// Iterate through the configured categories and their associated extensions.
for (category, extensions) in &amp;categories_config.0 {
// Check if the file's extension is present in the list for this category
if extensions.contains(&amp;extension) {
return category.clone(); // Return the matching category name
}
}
// If no specific category matched, fallback to the "other" category.
// load_config_file ensures the "other" key exists in the HashMap.
"other".to_string()
}
// --- Platform Specific ---
/// Checks if a file or directory is hidden on Windows using standard library features.
#[cfg(windows)]
fn is_hidden(path: &amp;Path) -&gt; Result<bool> {
use std::os::windows::fs::MetadataExt;
// Use the standard library extension trait for a safer abstraction than raw Win32 calls
let metadata = fs::metadata(path)
.with_context(|| format!("Failed to get metadata for {}", path.display()))?;
// Get the raw file attributes bitfield
let attributes = metadata.file_attributes();
// Check if the FILE_ATTRIBUTE_HIDDEN bit is set
Ok((attributes &amp; std::os::windows::fs::FILE_ATTRIBUTE_HIDDEN) != 0)
}
/// Checks if a file or directory is hidden on Unix-like systems (conventionally, starts with '.').
#[cfg(not(windows))]
fn is_hidden(path: &amp;Path) -&gt; Result<bool> {
// Standard check for hidden files/dirs on Unix-like systems.
Ok(path
.file_name()
.and_then(|s| s.to_str()) // Get filename as string slice
.map(|s| s.starts_with('.')) // Check if it starts with '.'
.unwrap_or(false)) // If no filename or not UTF-8, assume not hidden by this convention
}
/// Helper for walkdir filter_entry to check hidden status before descending into directories or processing files.
/// Logs errors but doesn't stop the walk; returns `true` if entry should be kept (i.e., not hidden or check failed).
/// **Improvement:** Defaults to excluding (`false`) if the check fails, for safety.
fn should_keep_entry(entry: &amp;DirEntry, include_hidden: bool) -&gt; bool {
if include_hidden {
return true; // Keep everything if --include-hidden flag is set
}
// Otherwise, check the hidden status
match is_hidden(entry.path()) {
Ok(hidden) =&gt; !hidden, // Keep if NOT hidden
Err(err) =&gt; {
// Log the error but default to *excluding* the entry for safety if status is unknown
warn!(
"Could not determine hidden status for {}: {}. Excluding entry.",
entry.path().display(), err
);
false // Exclude if check fails
}
}
}
// --- Command Line Arguments ---
/// Enum defining the organization methods, used for clap validation.
/// This ensures only valid options are accepted via the command line.
#[derive(clap::ValueEnum, Clone, Debug, PartialEq, Eq)]
enum OrganizeMethod {
Category,
Extension,
}
/// Defines the command-line interface structure using clap derive macros.
/// Doc comments are used to generate help messages for the user.
#[derive(Parser, Debug)]
#[command(author, version, about = "Organize files by category or extension (Rust version).",
long_about = "A Rust utility for organizing files from source directories into categorized target folders based on file types or extensions.",
help_template = "{before-help}{name} {version}\n{author-with-newline}{about-with-newline}\n{usage-heading} {usage}\n\n{all-args}{after-help}" // Custom help format
)]
struct CliArgs {
/// Source directory containing files to organize.
#[arg(short, long, value_name = "DIR")]
source: PathBuf,
/// Target directory where organized files will be placed.
#[arg(short, long, value_name = "DIR")]
target: PathBuf,
/// Path to JSON config file for custom file categories and extensions.
#[arg(short, long, value_name = "FILE")]
config: Option<PathBuf>,
/// Method for organizing files (category or extension).
#[arg(long, value_enum, default_value_t = OrganizeMethod::Category)]
organize_by: OrganizeMethod,
/// Move files instead of copying them (default is copy).
#[arg(long)]
move_files: bool,
/// Append timestamp+counter to duplicate filenames. Conflicts with --skip-existing and --overwrite.
#[arg(long, conflicts_with_all = ["skip_existing", "overwrite"])]
timestamp_duplicates: bool,
/// Skip processing if a file with the same name exists in the target. Conflicts with --timestamp-duplicates and --overwrite.
#[arg(long, short = 'k', conflicts_with_all = ["timestamp_duplicates", "overwrite"])]
skip_existing: bool,
/// Overwrite existing files in the target directory. Conflicts with --timestamp-duplicates and --skip-existing.
#[arg(long, conflicts_with_all = ["timestamp_duplicates", "skip_existing"])]
overwrite: bool, // Explicit overwrite flag
/// Include hidden files/folders (e.g., starting with '.') in processing.
#[arg(long, short = 'i')]
include_hidden: bool,
/// Follow symbolic links (process target, not link). Use with caution (potential loops).
#[arg(long, short = 'l')]
follow_links: bool,
/// After moving (--move must be enabled), attempt to remove empty source directories.
#[arg(long, requires = "move_files")]
remove_empty_source_dirs: bool,
/// Optional path to a file for logging progress and errors.
#[arg(long, value_name = "FILE")]
log_file: Option<PathBuf>,
/// Set the log level (e.g., error, warn, info, debug, trace).
#[arg(long, value_parser = clap::value_parser!(LevelFilter), default_value = "info")]
log_level: LevelFilter,
}
// --- Core Logic ---
/// Holds statistics about the file processing operation, including failed file paths and errors.
#[derive(Debug, Default)]
struct ProcessStats {
/// Count of directory entries successfully yielded by the filtered WalkDir iterator (includes files, dirs, etc.).
/// **Clarification:** This counts entries *before* filtering for files-only in the processing loop.
total_scanned: u64,
processed: u64,          // Count of files successfully copied/moved
skipped: u64,            // Count of files skipped (e.g., duplicates, hidden, non-file)
errors: u64,             // Count of files that failed during processing (copy/move/timestamp) or critical scan errors
failed_files: Vec&lt;(PathBuf, String)&gt;, // Stores paths and error context of failed files
}
/// Scans the source directory to find all unique file extensions (lowercase, without dot).
/// This is primarily used when `organize_by` is `Extension` to pre-create necessary folders efficiently.
fn get_all_extensions(
source_directory: &amp;Path,
include_hidden: bool,
follow_links: bool,
) -&gt; Result&lt;HashSet<String>&gt; {
let mut extensions = HashSet::new();
info!("Scanning source directory for all unique file extensions...");
let walker = WalkDir::new(source_directory)
.follow_links(follow_links) // Control whether to follow symlinks
.into_iter();
let mut count = 0;
// Use filter_entry for more efficient hidden filtering during the scan
for entry_result in walker.filter_entry(|e| should_keep_entry(e, include_hidden)) {
match entry_result {
Ok(entry) =&gt; {
let path = entry.path();
// Process only files
if path.is_file() {
// No need to re-check is_hidden here, filter_entry handles it based on should_keep_entry logic.
count += 1;
// Extract extension if the file has one and it's valid UTF-8
if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
extensions.insert(ext.to_lowercase()); // Store lowercase extension
}
// Log progress periodically for very large directories
if count % 1000 == 0 {
debug!("Scanned {} files for extensions...", count);
}
}
}
Err(e) =&gt; warn!("Error accessing entry during extension scan: {}", e), // Log errors encountered during directory walk
}
}
info!("Found {} unique extensions.", extensions.len());
Ok(extensions)
}
/// Creates necessary target subfolders based on the organization method.
/// Ensures the base target directory exists first.
fn create_target_folders(
base_dir: &amp;Path,
organize_by: &amp;OrganizeMethod,
categories_config: Option&lt;&amp;CategoriesConfig&gt;,
all_extensions: Option&lt;&amp;HashSet<String>&gt;,
) -&gt; Result&lt;()&gt; {
info!("Ensuring target base directory exists: {}", base_dir.display());
// Create the base target directory and any necessary parent directories
fs::create_dir_all(base_dir)
.with_context(|| format!("Failed to create base target directory: {}", base_dir.display()))?;
// Determine the set of folders needed based on the organization strategy.
let folders_to_create: HashSet<String> = match organize_by {
OrganizeMethod::Category =&gt; {
// Collect all category names from the config
let mut folders = categories_config
.map(|cfg| cfg.0.keys().cloned().collect::&lt;HashSet<String>&gt;())
.unwrap_or_default();
// Ensure essential fallback folders exist for files without extensions or unmatched types
folders.insert("other".to_string());
folders.insert("no_extension".to_string());
folders
}
OrganizeMethod::Extension =&gt; {
// Collect all unique extensions found during scan
let mut folders = all_extensions.cloned().unwrap_or_default();
// Ensure essential fallback folder exists for files without extensions
folders.insert("no_extension".to_string());
folders
}
};
info!(
"Creating target subfolders (mode: {:?}). Total potential folders: {}",
organize_by,
folders_to_create.len()
);
let mut created_count = 0;
for folder_name in &amp;folders_to_create {
// Avoid creating folders with potentially invalid names (e.g., empty string if an extension was just ".")
if folder_name.is_empty() {
warn!("Skipping creation of folder with empty name.");
continue;
}
let folder_path = base_dir.join(folder_name);
// Check if folder already exists before trying to create
if !folder_path.exists() {
// Create the folder and any necessary parents
fs::create_dir_all(&amp;folder_path).with_context(|| {
format!("Failed to create target folder '{}'", folder_path.display())
})?;
debug!("Created target folder: {}", folder_path.display());
created_count += 1;
}
}
info!("Created {} new target subfolders.", created_count);
Ok(())
}
/// Attempts to move a file using `fs::rename`, falling back to copy-then-delete
/// if `fs::rename` fails (e.g., due to being on different filesystems/devices).
fn move_file_with_fallback(source: &amp;Path, target: &amp;Path) -&gt; io::Result&lt;()&gt; {
// Attempt the efficient rename first, which is atomic on the same filesystem
match fs::rename(source, target) {
Ok(_) =&gt; Ok(()), // Rename succeeded
Err(rename_error) =&gt; {
// Check if the error is likely due to moving across different filesystems/devices.
// This requires checking platform-specific OS error codes.
// Note: Relies on platform-specific OS error codes (Windows: 17, Unix: 18/libc::EXDEV). Might be brittle.
let is_cross_device = || -&gt; bool {
#[cfg(windows)] { rename_error.raw_os_error() == Some(17) } // ERROR_NOT_SAME_DEVICE
#[cfg(unix)] { rename_error.raw_os_error() == Some(18) } // libc::EXDEV
#[cfg(not(any(windows, unix)))] { false } // Default for other platforms
};
if is_cross_device() {
// If it's a cross-device error, attempt copy-then-delete fallback
warn!("Rename failed (cross-device error detected), attempting copy+delete fallback for move: {} -&gt; {}", source.display(), target.display());
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source, target)?; // Attempt copy
fs::remove_file(source)?; // Attempt delete original
Ok(()) // Fallback succeeded
} else {
// If it was a different rename error (e.g., permissions), re-throw it.
Err(rename_error)
}
}
}
}
/// Main function to perform the file organization based on parsed arguments.
/// Iterates through source files, determines target paths, handles duplicates,
/// performs copy/move operations, and collects statistics.
fn organize_files(args: &amp;CliArgs, categories_config: &amp;CategoriesConfig) -&gt; Result<ProcessStats> {
// --- Initial Validation &amp; Setup ---
if !args.source.is_dir() {
bail!("Source directory '{}' is invalid or not found.", args.source.display());
}
// Ensure target directory exists or create it
if !args.target.exists() {
info!("Creating target directory: {}", args.target.display());
fs::create_dir_all(&amp;args.target).with_context(|| {
format!("Could not create target directory '{}'", args.target.display())
})?;
} else if !args.target.is_dir() {
bail!("Target path '{}' exists but is not a directory.", args.target.display());
}
// --- Pre-scan for Extensions (if needed) and Pre-create Folders ---
// This ensures target folders exist before we start moving/copying files into them.
info!("Preparing target folders...");
let extensions_for_folders = if args.organize_by == OrganizeMethod::Extension {
Some(get_all_extensions(&amp;args.source, args.include_hidden, args.follow_links)?)
} else {
None
};
create_target_folders(
&amp;args.target,
&amp;args.organize_by,
Some(categories_config), // Pass config needed for category mode
extensions_for_folders.as_ref(), // Pass extensions needed for extension mode
)?;
// --- Process Files ---
info!("Starting file processing...");
let mut stats = ProcessStats::default(); // Initialize statistics
let mut file_counter = 0u64; // Counter for progress reporting
// Use WalkDir again for the main processing loop, applying filters efficiently
let walker = WalkDir::new(&amp;args.source)
.follow_links(args.follow_links) // Control symlink following
.into_iter();
// filter_entry is used to efficiently skip hidden directories/files if requested
for entry_result in walker.filter_entry(|e| should_keep_entry(e, args.include_hidden)) {
// Increment scan counter for every entry successfully yielded by the filtered iterator
stats.total_scanned += 1;
let entry = match entry_result {
Ok(e) =&gt; e,
Err(e) =&gt; {
// Log errors encountered during directory traversal itself
error!("Error scanning path {}: {}", e.path().unwrap_or(Path::new("?")).display(), e);
stats.errors += 1; // Count scan errors towards total errors
// Record scan error details
stats.failed_files.push((
e.path().unwrap_or_default().to_path_buf(),
format!("Scan error: {:?}", e),
));
continue; // Skip this problematic entry
}
};
// We are only interested in processing files in this loop
if !entry.file_type().is_file() {
stats.skipped += 1; // Count skipped directories/symlinks etc.
continue;
}
// If we reached here, it's a file we intend to process
file_counter += 1;
let source_path = entry.path();
let progress_prefix = format!("[{}]", file_counter); // Simple counter for progress logging
// --- Inner processing block to handle errors per file using anyhow ---
// This allows logging an error for a single file and continuing with the next.
let file_result: Result&lt;()&gt; = (|| {
// No need to re-check is_hidden, filter_entry handles it.
// Extract filename, handling potential errors (e.g., invalid path)
let file_name = source_path.file_name()
.with_context(|| format!("Could not get filename for path: {}", source_path.display()))?;
// Determine target subfolder name based on organization strategy
let target_subfolder_name = match args.organize_by {
OrganizeMethod::Category =&gt; categorize_file(source_path, categories_config),
OrganizeMethod::Extension =&gt; source_path
.extension()
.and_then(|s| s.to_str()) // Get extension as string
.map(|s| s.to_lowercase()) // Convert to lowercase
.unwrap_or_else(|| "no_extension".to_string()), // Handle no extension
};
let target_folder_path = args.target.join(&amp;target_subfolder_name);
let mut target_file_path = target_folder_path.join(file_name);
// --- Handle potential duplicate files in the target directory ---
if target_file_path.exists() {
if args.skip_existing {
// User requested skipping duplicates
info!(
"{} Skipping (target exists): {}",
progress_prefix,
target_file_path.display()
);
stats.skipped += 1;
return Ok(()); // Successfully skipped this file
} else if args.timestamp_duplicates {
// User requested adding timestamps to duplicates
let original_target_path_display = target_file_path.display().to_string();
let mut counter = 1;
// Safely get stem and extension, providing defaults if they don't exist
let stem = source_path.file_stem().unwrap_or(file_name.as_os_str()); // Use original filename if no stem
let ext = source_path.extension().unwrap_or_default(); // Empty OsStr if no extension
const MAX_TIMESTAMP_ATTEMPTS: u32 = 1000; // Safety break for the loop
loop {
let timestamp = Local::now().format("%Y%m%d_%H%M%S");
// Construct new filename using OsString to handle non-UTF8 filenames safely
let mut new_name_os = std::ffi::OsString::new();
new_name_os.push(stem);
new_name_os.push(format!("_{}_{}", timestamp, counter)); // Add timestamp and counter
if !ext.is_empty() {
new_name_os.push("."); // Add dot only if there was an extension
new_name_os.push(ext);
}
target_file_path = target_folder_path.join(&amp;new_name_os); // Update the target path
if !target_file_path.exists() {
break; // Found a unique name, exit the loop
}
counter += 1;
// Safety break to prevent potential infinite loops if unique names are hard to find
if counter &gt; MAX_TIMESTAMP_ATTEMPTS {
// Use bail! from anyhow to return an error directly from this inner block
bail!(
"Could not find unique timestamped name for {} after {} attempts. Skipping.",
original_target_path_display, MAX_TIMESTAMP_ATTEMPTS
);
}
}
// Log the renaming action
info!(
"{} Target exists '{}'. Renaming duplicate to: {}",
progress_prefix,
original_target_path_display,
target_file_path.display()
);
} else if args.overwrite {
// Explicit overwrite flag is set
warn!(
"{} Overwriting existing target file: {}",
progress_prefix,
target_file_path.display()
);
// Overwrite happens implicitly below by copy/move
} else {
// Default behavior if no specific duplicate handling flag is set: Overwrite
warn!(
"{} Overwriting existing target file (default): {}",
progress_prefix,
target_file_path.display()
);
// Overwrite happens implicitly below by copy/move
}
} // End duplicate check block
// Ensure target directory exists *just before* the operation (belt-and-suspenders approach)
// This handles rare cases where the folder might have been deleted after the initial check.
fs::create_dir_all(&amp;target_folder_path).with_context(|| format!("Failed to ensure target directory '{}' exists", target_folder_path.display()))?;
// --- Perform the file operation (Copy or Move) ---
let operation_desc = if args.move_files { "move" } else { "copy" };
debug!(
"{} Attempting to {} '{}' to '{}'",
progress_prefix,
operation_desc,
source_path.display(),
target_file_path.display()
);
if args.move_files {
// Use the robust move function with fallback for cross-device errors
move_file_with_fallback(source_path, &amp;target_file_path)
.with_context(|| format!("Failed to move '{}' to '{}'", source_path.display(), target_file_path.display()))?;
} else {
// Standard copy.
// Note: std::fs::copy preserves permissions but not other metadata like modification time (unlike Python's shutil.copy2).
// For full metadata preservation, consider crates like `fs_extra` or platform-specific APIs.
fs::copy(source_path, &amp;target_file_path)
.map(|_| ()) // Discard the number of bytes copied (u64) result, returning () on success
.with_context(|| format!("Failed to copy '{}' to '{}'", source_path.display(), target_file_path.display()))?;
}
stats.processed += 1; // Increment processed count only on success
Ok(()) // Indicate success for this file's processing
})(); // End of inner result block for per-file error handling
// --- Handle result for this specific file ---
if let Err(e) = file_result {
// Log the detailed error using anyhow's Debug format
error!("{} Failed to process '{}': {:?}", progress_prefix, source_path.display(), e);
stats.errors += 1;
// Store error context along with the path
stats.failed_files.push((source_path.to_path_buf(), format!("{:?}", e)));
}
} // End of main file processing loop
Ok(stats) // Return the final statistics
}
/// Recursively removes empty folders starting from the bottom up within a given directory.
/// This is typically used after a move operation to clean up the source directory.
/// Uses a collect-then-sort approach for simplicity and to avoid potential
/// issues with modifying the directory structure while iterating.
fn remove_empty_folders(directory: &amp;Path) -&gt; Result<u32> {
let mut removed_count = 0u32;
info!("Attempting to remove empty directories within: {}", directory.display());
// Collect directory paths first. This avoids borrow checker issues with WalkDir
// if we were to modify the directory structure while iterating (e.g., removing a dir).
let mut dirs_to_check = Vec::new();
// Start scan from depth 1 to avoid trying to remove the root directory itself.
for entry_result in WalkDir::new(directory).min_depth(1) {
match entry_result {
Ok(entry) if entry.file_type().is_dir() =&gt; {
dirs_to_check.push(entry.into_path()); // Collect path if it's a directory
}
Ok(_) =&gt; {} // Ignore files
Err(e) =&gt; warn!("Error accessing entry during empty dir scan: {}", e), // Log errors during scan
}
}
// Sort paths by depth (longest paths first) to ensure bottom-up processing.
// This is crucial so we attempt to remove child directories before their parents.
dirs_to_check.sort_by(|a, b| b.components().count().cmp(&amp;a.components().count()));
for dir_path in dirs_to_check {
// Check if directory still exists before trying to read/remove (it might have been removed in a previous step)
if !dir_path.is_dir() {
continue;
}
match fs::read_dir(&amp;dir_path) {
Ok(mut read_dir) =&gt; {
// Check if the directory is truly empty by trying to get the first entry.
// read_dir.next().is_none() is true if the directory is empty.
if read_dir.next().is_none() {
// Directory is empty, attempt to remove it.
match fs::remove_dir(&amp;dir_path) {
Ok(_) =&gt; {
info!("Removed empty directory: {}", dir_path.display());
removed_count += 1;
}
Err(e) =&gt; {
// Log warnings for common non-critical errors like permissions
// or race conditions where the dir became non-empty between read_dir and remove_dir.
// Don't treat NotFound as a warning if it was just removed by another process or race condition.
if e.kind() != ErrorKind::NotFound {
warn!(
"Could not remove presumably empty directory '{}': {}",
dir_path.display(), e
);
}
}
}
}
// else: Directory is not empty, do nothing.
}
Err(e) =&gt; {
// Don't warn if the directory was removed between listing and checking emptiness.
if e.kind() != ErrorKind::NotFound {
warn!(
"Could not read directory '{}' to check emptiness: {}",
dir_path.display(), e
);
}
}
}
}
info!("Finished removing empty directories. Removed: {}", removed_count);
Ok(removed_count) // Return the count of removed directories
}
// --- Logging Setup ---
/// Sets up logging using the fern crate to log to stderr and optionally a file.
/// Configures formatting, level filtering, and color output for the console.
fn setup_logging(log_level: LevelFilter, log_file: Option&lt;&amp;PathBuf&gt;) -&gt; Result&lt;()&gt; {
// Configure colors for terminal output levels for better readability
let colors = ColoredLevelConfig::new()
.error(Color::Red)
.warn(Color::Yellow)
.info(Color::Green)
.debug(Color::Blue)
.trace(Color::BrightBlack);
// Base dispatch configuration common to all loggers
let base_config = fern::Dispatch::new()
// Format messages including timestamp (with milliseconds), colored level, target module, and message
.format(move |out, message, record| {
out.finish(format_args!(
"[{} {} {}] {}",
chrono::Local::now().format("%Y-%m-%d %H:%M:%S%.3f"), // Time format with ms
colors.color(record.level()), // Apply color to level text
record.target(), // Module path where log occurred (e.g., `rust_file_organizer::main`)
message
))
})
// Apply the global log level filter passed from arguments (e.g., Info, Debug)
.level(log_level)
// Filter out overly verbose logs from common libraries unless explicitly requested at a higher level
// This keeps the default output cleaner when running at Info level.
.level_for("hyper", LevelFilter::Warn)
.level_for("mio", LevelFilter::Warn)
.level_for("want", LevelFilter::Warn)
.level_for("reqwest", LevelFilter::Warn)
.level_for("rustls", LevelFilter::Warn);
// Chain the stderr logger. By default, only show messages from our crate unless Debug/Trace is enabled.
let stderr_logger = fern::Dispatch::new()
.filter(move |metadata| {
// Show logs from our crate OR if the global level is Debug or Trace
log_level &lt;= LevelFilter::Debug || metadata.target().starts_with(env!("CARGO_PKG_NAME"))
})
.chain(std::io::stderr()); // Chain to standard error output
// Start building the final dispatch configuration, always including stderr
let mut final_dispatch = base_config.chain(stderr_logger);
// Chain the file logger conditionally if a path is provided
let mut file_logger_ok = false; // Track if file logger setup succeeds
if let Some(log_path) = log_file {
match fern::log_file(log_path) {
Ok(file_output) =&gt; {
// If file opened successfully, chain it to the dispatch
final_dispatch = final_dispatch.chain(file_output);
file_logger_ok = true;
}
Err(e) =&gt; {
// If file creation fails, log error directly to stderr (logger not ready yet)
// and proceed without file logging.
eprintln!(
"Error: Failed to create log file '{}': {}. Logging to console only.",
log_path.display(), e
);
}
}
}
// Apply the final combined logging configuration
final_dispatch.apply().context("Failed to set up logging")?;
// Log confirmation *after* apply() succeeds
if file_logger_ok {
if let Some(path) = log_file {
info!("File logging enabled to: {}", path.display());
}
}
Ok(())
}
// --- Main Application Entry Point ---
fn main() -&gt; Result&lt;()&gt; {
// Record start time for overall duration calculation
let overall_start_time = Instant::now();
// Parse command-line arguments using clap
let args = CliArgs::parse();
// --- Setup Logging ---
// Initialize logging early based on args.log_level and optional args.log_file
// This allows logging during argument validation or config loading if needed.
setup_logging(args.log_level, args.log_file.as_ref())?;
// --- Log Startup Information ---
info!("Rust File Organizer (v{}) starting...", env!("CARGO_PKG_VERSION"));
// Log full arguments only if debug level is enabled
debug!("Arguments received: {:?}", args);
// Log key operational parameters at info level for traceability
info!("Source directory: {}", args.source.display());
info!("Target directory: {}", args.target.display());
info!("Organization mode: {:?}", args.organize_by); // Use Debug format for enum
info!("Operation: {}", if args.move_files { "Move" } else { "Copy" });
info!("Include hidden: {}", args.include_hidden);
info!("Follow links: {}", args.follow_links);
// Log duplicate handling strategy clearly based on flags
if args.skip_existing { info!("Duplicate handling: Skip existing"); }
else if args.timestamp_duplicates { info!("Duplicate handling: Timestamp duplicates"); }
else if args.overwrite { info!("Duplicate handling: Overwrite existing (explicitly)"); }
else { info!("Duplicate handling: Overwrite existing (default)"); } // Log default
// --- Load Configuration ---
// Load categories from JSON file or use defaults; ensures 'other' category exists.
let categories = load_config_file(args.config.as_ref())?;
// Optionally log loaded categories at debug level if needed for troubleshooting
// debug!("Using categories: {:?}", categories.0.keys());
// --- Execute Core Logic ---
// Call the main organization function and handle its result
let result = organize_files(&amp;args, &amp;categories);
// --- Handle Results and Optional Cleanup ---
match result {
Ok(stats) =&gt; {
// --- Optional Cleanup: Remove empty source directories after successful move ---
if args.move_files &amp;&amp; args.remove_empty_source_dirs &amp;&amp; stats.processed &gt; 0 {
// Attempt cleanup but log errors non-fatally, as the main task succeeded
if let Err(e) = remove_empty_folders(&amp;args.source) {
error!("Error during empty source directory removal: {:?}", e);
// Note: Cleanup errors are logged but do not cause a non-zero exit code by default.
}
}
// --- Final Summary ---
let overall_duration = overall_start_time.elapsed(); // Calculate total duration correctly
let summary = format!(
"Operation completed in {:.2?}. Scanned Entries: {}, Processed Files: {}, Skipped: {}, Errors: {}",
overall_duration, stats.total_scanned, stats.processed, stats.skipped, stats.errors
);
info!("{}", summary); // Log summary
println!("\n{}", summary); // Print final summary to console (stdout)
// If errors occurred during file processing, print the list of failed files and their errors to stderr
if stats.errors &gt; 0 {
eprintln!("\n--- Errors occurred during processing: ---"); // Print errors to stderr
for (path, error_msg) in &amp;stats.failed_files {
eprintln!(" - File: {}", path.display());
eprintln!("   Error: {}", error_msg); // Show the captured error context
}
eprintln!("-----------------------------------------");
eprintln!(
"Warning: {} errors occurred. Please check logs (stderr/file) for full details.",
stats.errors
);
// Consider exiting with a non-zero status code for scripting purposes if any errors occurred
// std::process::exit(1);
}
}
Err(e) =&gt; {
// Log the critical error that stopped the organization process entirely
error!("Critical error during file organization: {:?}", e); // Use Debug format for anyhow::Error chain
eprintln!("\nError: File organization failed critically. Check logs (stderr/file) for details.");
std::process::exit(1); // Exit with a non-zero code on critical failure
}
}
info!("Rust File Organizer finished.");
Ok(()) // Indicate successful completion (even if non-critical file errors occurred)
}
// --- Testing Notes ---
// To properly test this application, consider using crates like:
// - `assert_fs`: For creating temporary file/directory structures for tests.
// - `predicates`: For making assertions about file system state (e.g., file exists, content matches).
// - `assert_cmd`: For testing the command-line interface behavior, arguments, exit codes, and output.
//
// Example Test Scenarios (Conceptual):
// - Test basic copy/move by category and extension.
// - Test duplicate handling flags (skip, timestamp, overwrite) work correctly.
// - Test hidden file handling with and without the --include-hidden flag.
// - Test symbolic link handling with and without the --follow-links flag.
// - Test behavior with empty source or target directories.
// - Test custom configuration loading and verify correct categorization (including missing 'other').
// - Test empty directory removal after a successful move operation.
// - Test error handling for scenarios like insufficient permissions (harder to automate reliably).
// - Test long path handling specifically on Windows (requires careful test setup).
// - Test cross-device move fallback behavior.
// - Test handling of filenames with non-UTF8 characters (requires OsStr handling).

</u32></ProcessStats></String></String></String></String></PathBuf></PathBuf></bool></bool></String></CategoriesConfig></String></code></section></code></section>

        </div>
        
          URL: https://ib.bsb.br/files-by-type
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/tasks-mermaid/" title="Task Prioritization" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/dup-spotter/" title="Copy Spotter and Duplicate-File-Remover" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scripts>rust"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scripts-rust" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/files-by-type/" title="Organize files by type" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="javascript:void(0)" class="disabled" aria-disabled="true" title="No next in tag">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="No next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-04-07 17:32:41
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scripts-rust">
                  scripts>rust
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/files-by-type/"
        },
        "headline": "Organize files by type",
        "description": "",
        "datePublished": "2024-05-30T00:00:00+00:00",
        "dateModified": "2025-04-07T20:30:03+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
