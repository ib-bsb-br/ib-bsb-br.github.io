<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        autorandr and bash script to collect and setup monitor data for xrandr - infoBAG
      
    </title>
    <meta name="title" content="autorandr and bash script to collect and setup monitor data for xrandr - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/xrandr/">
    <meta property="og:title" content="autorandr and bash script to collect and setup monitor data for xrandr - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/xrandr/">
    <meta name="twitter:title" content="autorandr and bash script to collect and setup monitor data for xrandr - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/xrandr/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scratchpad">
      
        <meta property="article:tag" content="scratchpad">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          autorandr and bash script to collect and setup monitor data for xrandr
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-04-03T00:00:00+00:00" class="post-date">
          03 Apr 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-05-08T15:04:47+00:00">
              08 May 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/xrandr" class="tag">xrandr</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scratchpad" class="tag">scratchpad</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        68421 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        8626 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-04-03-xrandr.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-04-03-xrandr.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#why-use-autorandr"><strong>Why Use autorandr?</strong></a></li><li><a href="#prerequisites-raspberry-pi-4b-specific"><strong>Prerequisites (Raspberry Pi 4B Specific)</strong></a></li><li><a href="#installation-on-opensuse-tumbleweed"><strong>Installation on openSUSE Tumbleweed</strong></a></li><li><a href="#basic-configuration-creating-and-managing-profiles"><strong>Basic Configuration: Creating and Managing Profiles</strong></a></li><li><a href="#applying-configurations"><strong>Applying Configurations</strong></a></li><li><a href="#automation-recommended"><strong>Automation (Recommended)</strong></a></li><li><a href="#setting-a-default-fallback-profile"><strong>Setting a Default Fallback Profile</strong></a></li><li><a href="#advanced-usage"><strong>Advanced Usage</strong></a></li><li><a href="#troubleshooting"><strong>Troubleshooting</strong></a></li><li><a href="#alternative-hardware-hdmi-edid-emulator"><strong>Alternative: Hardware HDMI EDID Emulator</strong></a></li><li><a href="#resources"><strong>Resources</strong></a></li><li><a href="#a-monitor-infosh-bash-script-to-collect-monitor-data">A. <code class="language-plaintext highlighter-rouge">monitor-info.sh</code> (Bash script to collect monitor data)</a></li><li><a href="#b-improved-temporary-xrandr-configuration-script">B. “Improved Temporary Xrandr configuration script”</a></li></ul>
          <h3 id="why-use-autorandr">
    
    
     <a href="#why-use-autorandr">#</a><a href="#" aria-label="Back to top"><strong>Why Use autorandr?</strong></a>
        
    
  </h3>
      

<p>autorandr is a highly effective, Python-based utility specifically designed to automate and simplify the management of multiple display configurations on Linux systems. Its core strength lies in its ability to automatically detect which displays (like projectors, external monitors, or ultrawide screens) are currently connected to your system and then apply a pre-saved configuration (“profile”) that matches that specific hardware setup. This eliminates the need to manually execute commands with xrandr (a command-line tool for configuring display settings) every time you connect or disconnect a display.</p>

<p>This automation is particularly beneficial in your scenario as a professor using a Raspberry Pi 4B with openSUSE Tumbleweed. Imagine moving between different lecture halls, each potentially having a projector with a unique native resolution (1024x768, 1280x800, etc.), then returning to your office to connect to an ultrawide monitor (e.g., 3440x1440), and perhaps later connecting to a standard monitor in a departmental meeting room. Without autorandr, each transition would require manual reconfiguration. With autorandr, once you’ve saved a profile for each setup, the system adapts automatically upon connection. Furthermore, on a modern system like openSUSE Tumbleweed, autorandr integrates seamlessly with the systemd init system. This means it can leverage udev events (the system’s way of detecting hardware changes like plugging in a monitor) to trigger the profile switching automatically in the background, offering a truly hands-off experience after the initial setup.</p>

<p><strong>Key Benefits Elaborated:</strong></p>

<ul>
  <li><strong>Automatic Detection &amp; Application:</strong> autorandr intelligently identifies connected displays, often using their unique EDID information, and compares this against its library of saved profiles to find the best match, applying it instantly.</li>
  <li><strong>Ease of Use:</strong> The “save once, use anywhere” philosophy drastically reduces complexity. Instead of remembering complex xrandr commands or navigating display settings repeatedly, you perform the setup once per unique display combination and save it with a memorable name.</li>
  <li><strong>Flexibility:</strong> It excels at managing numerous distinct profiles. You can have profiles for single displays, dual displays in different arrangements (extended desktop, mirrored), displays with specific resolutions or refresh rates, covering virtually any common scenario you encounter.</li>
  <li><strong>Robustness:</strong> It gracefully handles situations where display EDID information might be missing, corrupt, or ambiguous – common issues with older projectors or certain adapters. Instead of failing outright or requiring manual intervention like raw xrandr might, autorandr can use other detected properties or fall back to a predefined default profile, ensuring you usually get a usable display state.</li>
</ul>
  <h3 id="prerequisites-raspberry-pi-4b-specific">
    
    
     <a href="#prerequisites-raspberry-pi-4b-specific">#</a><a href="#" aria-label="Back to top"><strong>Prerequisites (Raspberry Pi 4B Specific)</strong></a>
        
    
  </h3>
      

<p>Before diving into autorandr installation, optimizing your Raspberry Pi 4B environment is crucial for smooth display operation, especially given its shared memory architecture:</p>

<ul>
  <li><strong>GPU Memory (gpu_mem):</strong> The Raspberry Pi dynamically allocates system RAM between the CPU and the VideoCore GPU. Insufficient memory allocated to the GPU can lead to various graphical issues, such as visual glitches, screen tearing, an inability to drive displays at their native (especially high) resolutions (like 4K), or even completely blank screens. While the default allocation might be sufficient for basic desktop use, connecting multiple monitors or high-resolution displays often requires more. Check your current allocation and consider increasing it if you face issues. You can adjust this by editing the /boot/efi/extraconfig.txt file (the path might vary slightly depending on the exact Tumbleweed Pi image setup) and adding or modifying a line like gpu_mem=256 or gpu_mem=512 (allocating 256MB or 512MB respectively). A reboot is required for this change to be applied by the system.</li>
  <li><strong>Firmware &amp; System Updates:</strong> The Raspberry Pi’s firmware and the Linux kernel’s graphics drivers (like V3D DRM) are continually updated to improve hardware compatibility, fix bugs, and enhance performance. These updates often include improved handling of display detection protocols like EDID. Keeping your openSUSE Tumbleweed system fully updated is the best way to ensure you have the latest fixes and broadest compatibility. Use the standard Tumbleweed update command, sudo zypper dup (which performs a full system upgrade). Regularly running this ensures you benefit from the latest improvements relevant to display handling.</li>
</ul>
  <h3 id="installation-on-opensuse-tumbleweed">
    
    
     <a href="#installation-on-opensuse-tumbleweed">#</a><a href="#" aria-label="Back to top"><strong>Installation on openSUSE Tumbleweed</strong></a>
        
    
  </h3>
      

<p>You have several avenues to install autorandr on your system:</p>

<ol>
  <li>
    <p><strong>Check Standard Repositories (Try First):</strong> OpenSUSE Tumbleweed might already include autorandr in its main repositories. You can check its availability and install it if found:<br />
# Check if the package exists<br />
zypper info autorandr<br />
# If available, install it<br />
sudo zypper refresh<br />
sudo zypper install autorandr</p>
  </li>
  <li>
    <p><strong>Recommended Method (openSUSE Build Service - OBS):</strong> The autorandr author often maintains a more up-to-date version in a dedicated OBS repository. This is generally the preferred method if the package isn’t in the main repos or if you need the latest features/fixes:<br />
# Add the repository<br />
sudo zypper addrepo https://download.opensuse.org/repositories/home:phillipberndt/openSUSE_Tumbleweed/home:phillipberndt.repo<br />
# Refresh repository metadata<br />
sudo zypper refresh<br />
# Install autorandr from the new repo<br />
sudo zypper install autorandr</p>
  </li>
  <li>
    <p><strong>Alternative Method (pip):</strong> You can install autorandr using Python’s package installer, pip. However, be aware that this method might install it only for the current user, might not integrate as seamlessly with system-wide services like systemd/udev, and might require manual handling of non-Python dependencies. It can also lead to conflicts if system packages also provide parts of the dependencies.<br />
# Ensure pip is installed, then install autorandr<br />
sudo zypper install python3-pip<br />
sudo pip install autorandr</p>
  </li>
  <li>
    <p><strong>Alternative Method (From Source):</strong> For developers or those needing the absolute latest code, you can clone the autorandr Git repository and install it manually. This typically requires development tools like gcc and make, and you’ll need to manage dependencies yourself. Consult the README file in the repository for specific instructions.<br />
# Example (dependencies might vary)<br />
sudo zypper install git make python3-devel<br />
git clone https://github.com/phillipberndt/autorandr.git<br />
cd autorandr<br />
sudo make install</p>
  </li>
</ol>
  <h3 id="basic-configuration-creating-and-managing-profiles">
    
    
     <a href="#basic-configuration-creating-and-managing-profiles">#</a><a href="#" aria-label="Back to top"><strong>Basic Configuration: Creating and Managing Profiles</strong></a>
        
    
  </h3>
      

<p>The fundamental workflow for using autorandr revolves around capturing the state of your display setup for each unique configuration you use:</p>

<ol>
  <li><strong>Connect:</strong> Physically connect your Raspberry Pi to the specific combination of displays (e.g., a single classroom projector, your dual monitors at the office).</li>
  <li><strong>Configure Manually (Once):</strong> Use your preferred method to arrange the displays exactly how you want them <em>for this specific setup</em>. This could be:
    <ul>
      <li><strong>Desktop Environment Tools:</strong> Use the graphical display settings panel provided by your desktop environment (e.g., xfce4-display-settings in Xfce, the ‘Displays’ panel in GNOME Settings). Here you can typically enable/disable monitors, set resolutions, refresh rates, orientation, and define primary displays and relative positions in an extended desktop.</li>
      <li><strong>Manual xrandr Commands:</strong> For more fine-grained control or scripting, use xrandr directly in the terminal. For example: xrandr --output HDMI-1 --mode 1920x1080 --primary --output DisplayPort-1 --mode 2560x1440 --rotate left --right-of HDMI-1.</li>
    </ul>
  </li>
  <li>
    <p><strong>Save Profile:</strong> Once the displays are configured correctly, save this entire state as an autorandr profile using a descriptive name. Choosing a consistent naming convention can be helpful, e.g., location-displaytype-resolution or setup_description.<br />
# Example for a specific lecture hall projector<br />
autorandr --save lecturehallB-projector-1280x800</p>

    <p># Example for your office ultrawide setup<br />
autorandr --save office-ultrawide-3440x1440</p>

    <p># Example for a standard 1080p monitor used for testing<br />
autorandr --save lab-monitor-1080p</p>

    <p>It’s a good idea to back up this directory periodically, especially if you have complex or finely-tuned profiles.</p>
  </li>
  <li><strong>List Profiles:</strong> To review the profiles you have saved:<br />
autorandr --list</li>
</ol>
  <h3 id="applying-configurations">
    
    
     <a href="#applying-configurations">#</a><a href="#" aria-label="Back to top"><strong>Applying Configurations</strong></a>
        
    
  </h3>
      

<ul>
  <li>
    <p><strong>Manual Application:</strong> You can manually trigger autorandr to detect the currently connected displays and apply the best-matching profile from your saved library. This is useful for testing or if automation isn’t set up.<br />
autorandr --change</p>

    <p>Behind the scenes, autorandr --change performs several steps: it detects all connected displays and their properties (like EDID, which is data that allows a display to communicate its capabilities to the graphics card), compares this information against the data stored in each of your saved profiles, calculates a “match score” for each profile based on how well it fits the current hardware, and then automatically executes the xrandr commands stored within the highest-scoring profile (if the score exceeds a certain threshold). If no profile matches well enough, it might load the designated default profile or leave the configuration unchanged, depending on your setup.</p>
  </li>
</ul>
  <h3 id="automation-recommended">
    
    
     <a href="#automation-recommended">#</a><a href="#" aria-label="Back to top"><strong>Automation (Recommended)</strong></a>
        
    
  </h3>
      

<p>For the most convenient experience, configure autorandr to react automatically whenever you connect or disconnect a display:</p>

<ul>
  <li>
    <p><strong>Using systemd Service:</strong> This is generally the most robust and manageable method on modern Linux systems like openSUSE Tumbleweed. The autorandr.service unit, when enabled, typically integrates with udev to monitor for display-related hardware events (specifically from the Direct Rendering Manager or DRM subsystem). Upon detecting such an event (e.g., an HDMI cable being plugged in), systemd activates the service, which in turn usually runs autorandr --change to apply the appropriate profile.<br />
# Enable the service to start on boot and start it immediately<br />
sudo systemctl enable --now autorandr.service<br />
# You can check its status later with: systemctl status autorandr.service</p>
  </li>
  <li>
    <p><strong>Using udev Rules:</strong> autorandr packages often include udev rules (e.g., in /lib/udev/rules.d/) that directly trigger autorandr --change when specific kernel events related to display hardware occur. While this works, managing services through systemd often provides better control, logging, and dependency management. If you installed manually or suspect the rules aren’t active, you might need to reload them:<br />
sudo udevadm control --reload-rules &amp;&amp; sudo udevadm trigger</p>

    <p>With either automation method properly configured, plugging in a known projector or monitor should automatically result in your saved configuration being applied, although there might be a brief delay (a few seconds) while autorandr detects the display and applies the profile.</p>
  </li>
</ul>
  <h3 id="setting-a-default-fallback-profile">
    
    
     <a href="#setting-a-default-fallback-profile">#</a><a href="#" aria-label="Back to top"><strong>Setting a Default Fallback Profile</strong></a>
        
    
  </h3>
      

<p>It’s highly recommended to define a “fallback” or “default” profile. This profile will be automatically applied by autorandr --change (and thus by the automated services) if you connect a display configuration that doesn’t closely match any of your specifically saved profiles. The primary purpose is to prevent being left with an unusable or awkward display state (like a very low resolution, incorrect mirroring, or only the laptop’s internal display active when an external one is connected but unrecognized).</p>

<ol>
  <li>
    <p><strong>Choose and Save a Safe Profile:</strong> Configure your display(s) to a very common and widely supported resolution, like 1920x1080@60Hz or perhaps 1280x720@60Hz, which most monitors and projectors should handle without issue. Save this configuration:<br />
# Example: Configure for 1920x1080 manually first, then save<br />
autorandr --save fallback-1080p</p>
  </li>
  <li>
    <p><strong>Set as Default:</strong> Tell autorandr to use this profile as the default:<br />
autorandr --default fallback-1080p</p>

    <p>Now, when connecting an unknown display, autorandr will attempt to apply this safe configuration, maximizing the chances of getting a usable picture.</p>
  </li>
</ol>
  <h3 id="advanced-usage">
    
    
     <a href="#advanced-usage">#</a><a href="#" aria-label="Back to top"><strong>Advanced Usage</strong></a>
        
    
  </h3>
      

<p>autorandr offers features beyond basic profile switching:</p>

<ul>
  <li>
    <p>Wildcard EDID Matching: Sometimes you might have several projectors or monitors of the same model series. Their EDIDs might be very similar but differ slightly (e.g., in serial number fields). To create a single profile that matches all of them, you can edit the config file within the profile directory (e.g., ~/.config/autorandr/classroom-projectors/config). Find the line(s) specifying the EDID for the relevant output(s) and replace the differing parts (or less critical parts) with an asterisk (*).<br />
Example snippet from ~/.config/autorandr/some_profile/config:*<br />
output HDMI-1<br />
  # edid 00ffffffffffff001e6d[…] # Original specific EDID<br />
  edid 00ffffffffffff001e6d* # Matches any EDID starting with this prefix</p>

    <p><em>Caution:</em> Be careful not to make the wildcard too broad, or it might incorrectly match unintended displays.</p>
  </li>
  <li><strong>Hook Scripts:</strong> You can automate actions that should occur whenever a specific profile is loaded or unloaded. Create executable scripts (e.g., using bash or python) named preswitch (runs before switching <em>to</em> this profile), postswitch (runs after switching <em>to</em> this profile), predetect (runs before detection), or postdetect (runs after detection) inside a profile’s directory (~/.config/autorandr/&lt;profile_name&gt;/) or the global config directory (~/.config/autorandr/). Common uses for postswitch include:
    <ul>
      <li>Setting a specific desktop wallpaper: feh --bg-scale /path/to/wallpaper.jpg</li>
      <li>Restarting desktop panels if they don’t resize correctly: xfce4-panel -r</li>
      <li>Changing the default audio output sink.<br />
Remember to make the scripts executable: chmod +x ~/.config/autorandr/&lt;profile_name&gt;/postswitch.</li>
    </ul>
  </li>
  <li><strong>Forcing Matches (–match-edid):</strong> In rare troubleshooting scenarios where display properties other than EDID might be causing incorrect profile matching, you can experiment with options like autorandr --change --match-edid to force matching based primarily or solely on the EDID information. Consult man autorandr for details.</li>
</ul>
  <h3 id="troubleshooting">
    
    
     <a href="#troubleshooting">#</a><a href="#" aria-label="Back to top"><strong>Troubleshooting</strong></a>
        
    
  </h3>
      

<p>If autorandr doesn’t behave as expected:</p>

<ul>
  <li>
    <p><strong>Check Detected Profiles &amp; Scores:</strong> See what autorandr currently detects and how well it matches known profiles. The output shows detected profiles and their calculated match scores.<br />
autorandr --detected</p>
  </li>
  <li>
    <p><strong>Use Debug Mode:</strong> This provides highly detailed output about the detection process, including EDIDs read, profiles considered, matching scores, and the exact xrandr commands being generated and executed. This is invaluable for diagnosing why a specific profile isn’t being selected.<br />
autorandr --change --debug</p>
  </li>
  <li>
    <p><strong>Check System Logs:</strong> Look for errors or warnings related to the graphics driver (DRM) or EDID processing in the system journal. This can reveal underlying hardware or driver issues.<br />
# View live logs (press Ctrl+C to stop)<br />
journalctl -f | grep -i -E “drm|edid|autorandr”<br />
# View logs from the current boot<br />
journalctl -b | grep -i -E “drm|edid|autorandr”</p>
  </li>
  <li><strong>Ensure System Updates:</strong> Reiterate the importance of sudo zypper dup to ensure you have the latest kernel, graphics drivers, and potentially autorandr fixes.</li>
  <li><strong>Check Physical Connections:</strong> Sometimes the simplest solution is overlooked. Ensure HDMI or DisplayPort cables are securely plugged in at both the Raspberry Pi and the display ends. Try a different cable if problems persist.</li>
</ul>
  <h3 id="alternative-hardware-hdmi-edid-emulator">
    
    
     <a href="#alternative-hardware-hdmi-edid-emulator">#</a><a href="#" aria-label="Back to top"><strong>Alternative: Hardware HDMI EDID Emulator</strong></a>
        
    
  </h3>
      

<p>For displays that consistently cause problems due to missing, corrupt, or non-standard EDID information, a hardware <strong>HDMI EDID Emulator</strong> (also known as an EDID ghost or dummy plug) can be a viable workaround. This small device plugs into an HDMI port on the Pi and contains a chip pre-programmed with standard EDID data (e.g., for a 1080p monitor). The Raspberry Pi’s operating system reads the EDID from the emulator instead of the actual connected display. This effectively forces the Pi to “see” a standard display, often resolving issues with problematic hardware like some older projectors or KVM switches. While it provides consistency, it lacks the dynamic flexibility of autorandr – it forces one specific configuration regardless of what display (if any) is actually connected downstream. It’s a targeted solution for specific problematic hardware, not a replacement for general-purpose profile management.</p>
  <h3 id="resources">
    
    
     <a href="#resources">#</a><a href="#" aria-label="Back to top"><strong>Resources</strong></a>
        
    
  </h3>
      

<ul>
  <li><strong>autorandr</strong> GitHub Repository: The primary source for code, detailed documentation (README), and reporting issues. Check the Issues page here for existing bug reports or troubleshooting discussions. <a href="https://github.com/phillipberndt/autorandr">https://github.com/phillipberndt/autorandr</a></li>
  <li><strong>openSUSE Build Service Package:</strong> Link to the specific package page for the OBS repository, useful for checking versions and build status. <a href="https://build.opensuse.org/package/show/home:phillipberndt/autorandr">https://build.opensuse.org/package/show/home:phillipberndt/autorandr</a></li>
</ul>

<p>By carefully configuring autorandr and leveraging its automation features, you can significantly streamline the process of using your Raspberry Pi 4B with diverse display setups, making your transitions between classroom, office, and other locations much smoother and less prone to technical interruptions.</p>
  <h1 id="bash-script-to-collect-monitor-data-on-debian">
    
    
     <a href="#bash-script-to-collect-monitor-data-on-debian">#</a><a href="#" aria-label="Back to top">bash script to collect monitor data on Debian</a>
        
    
  </h1>
      

<p>• Installs all required tools (including optional edid-decode).<br />
• Detects every DRM connector (VGA, HDMI, DP, DVI, etc.), whether EDID-capable or not.<br />
• Enumerates connected and disconnected outputs via xrandr.<br />
• Logs EDID (sysfs, get-edid, DDC/CI), general hardware info (hwinfo, inxi, lshw), and udev data.<br />
• Provides a summary and guidance on extracting modeline parameters.<br />
• Offers an optional CVT-based modeline generator/applicator.</p>

<p>Save as <code class="language-plaintext highlighter-rouge">~/monitor-info.sh</code>, then:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="nb">chmod</span> +x ~/monitor-info.sh
<span class="nb">sudo</span> ~/monitor-info.sh
</code></section></div></div>

<p>Script:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/usr/bin/env bash</span>
<span class="c">#</span>
<span class="c"># monitor-info.sh</span>
<span class="c"># Collect comprehensive monitor info for xrandr configuration on Debian Bullseye+.</span>
<span class="c"># Usage: sudo bash ~/monitor-info.sh</span>
<span class="c">#</span>

<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: ensure_root</span>
<span class="c">#   Abort if not running as root.</span>
<span class="c"># ------------------------------------------------------------</span>
ensure_root<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nv">$EUID</span> <span class="nt">-ne</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ERROR: Must be run as root."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
  <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: install_tools</span>
<span class="c">#   Installs required packages in one apt command.</span>
<span class="c"># ------------------------------------------------------------</span>
install_tools<span class="o">()</span> <span class="o">{</span>
  apt update
  apt <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
    read-edid <span class="se">\</span>
    ddcutil <span class="se">\</span>
    hwinfo <span class="se">\</span>
    inxi <span class="se">\</span>
    lshw <span class="se">\</span>
    x11-xserver-utils <span class="se">\</span>
    edid-decode <span class="o">||</span> <span class="nb">true</span>  <span class="c"># optional</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: setup_outdir</span>
<span class="c">#   Creates a timestamped output directory.</span>
<span class="c"># ------------------------------------------------------------</span>
setup_outdir<span class="o">()</span> <span class="o">{</span>
  <span class="nv">OUTDIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span><span class="s2">/monitor-info-</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d-%H%M%S<span class="si">)</span><span class="s2">"</span>
  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">"</span>
  <span class="nb">echo</span> <span class="s2">"Output directory: </span><span class="nv">$OUTDIR</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: log_cmd</span>
<span class="c">#   Runs a command, logs stdout/stderr to a file, does not exit on error.</span>
<span class="c">#   Usage: log_cmd logfile command [args...]</span>
<span class="c"># ------------------------------------------------------------</span>
log_cmd<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">logfile</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="p">;</span> <span class="nb">shift</span>
  <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"===== </span><span class="si">$(</span><span class="nb">date</span> <span class="s1">'+%F %T'</span><span class="si">)</span><span class="s2"> : </span><span class="nv">$*</span><span class="s2"> ====="</span>
    <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span> 2&gt;&amp;1 <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"(ERROR: '</span><span class="nv">$*</span><span class="s2">' failed with exit code </span><span class="nv">$?</span><span class="s2">)"</span>
    <span class="nb">echo</span>
  <span class="o">}</span> <span class="o">&gt;&gt;</span><span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/</span><span class="nv">$logfile</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: detect_connectors</span>
<span class="c">#   Populates arrays: DRM_ALL (all connectors), DRM_EDID (with edid),</span>
<span class="c">#   XRANDR_CONNECTED, XRANDR_ALL.</span>
<span class="c"># ------------------------------------------------------------</span>
detect_connectors<span class="o">()</span> <span class="o">{</span>
  <span class="c"># DRM: all dirs under /sys/class/drm matching *-*</span>
  <span class="k">for </span>path <span class="k">in</span> /sys/class/drm/<span class="k">*</span>-<span class="k">*</span><span class="p">;</span> <span class="k">do</span>
    <span class="o">[[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">||</span> <span class="k">continue
    </span><span class="nb">local </span><span class="nv">name</span><span class="o">=</span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span>
    DRM_ALL+<span class="o">=(</span><span class="s2">"</span><span class="nv">$name</span><span class="s2">"</span><span class="o">)</span>
    <span class="o">[[</span> <span class="nt">-r</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">/edid"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> DRM_EDID+<span class="o">=(</span><span class="s2">"</span><span class="nv">$name</span><span class="s2">"</span><span class="o">)</span>
  <span class="k">done</span>

  <span class="c"># xrandr: all outputs and connected ones</span>
  <span class="k">while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> line<span class="p">;</span> <span class="k">do
    </span><span class="nb">local </span><span class="nv">out</span><span class="o">=</span><span class="si">$(</span><span class="nb">awk</span> <span class="s1">'/ connected/{print $1} / disconnected/{print $1}'</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span><span class="si">)</span>
    <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> XRANDR_ALL+<span class="o">=(</span><span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span><span class="o">)</span>
    <span class="o">[[</span> <span class="nv">$line</span> <span class="o">==</span> <span class="k">*</span><span class="s2">" connected"</span><span class="k">*</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> XRANDR_CONNECTED+<span class="o">=(</span><span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span><span class="o">)</span>
  <span class="k">done</span> &lt; &lt;<span class="o">(</span>xrandr 2&gt;/dev/null<span class="o">)</span>

  <span class="c"># Summary print</span>
  <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"All DRM connectors: </span><span class="k">${</span><span class="nv">DRM_ALL</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"DRM connectors with EDID: </span><span class="k">${</span><span class="nv">DRM_EDID</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"xrandr outputs: </span><span class="k">${</span><span class="nv">XRANDR_ALL</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"Connected outputs: </span><span class="k">${</span><span class="nv">XRANDR_CONNECTED</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
  <span class="o">}</span> | <span class="nb">tee</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/summary.txt"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_sysfs_edid</span>
<span class="c">#   Parses EDID from sysfs for connectors in DRM_EDID.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_sysfs_edid<span class="o">()</span> <span class="o">{</span>
  <span class="k">for </span>CON <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DRM_EDID</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    </span>log_cmd <span class="s2">"edid_sysfs_</span><span class="k">${</span><span class="nv">CON</span><span class="k">}</span><span class="s2">.log"</span> parse-edid &lt;<span class="s2">"/sys/class/drm/</span><span class="k">${</span><span class="nv">CON</span><span class="k">}</span><span class="s2">/edid"</span>
  <span class="k">done</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_getedid</span>
<span class="c">#   Parses EDID via get-edid (ISA bus fallback).</span>
<span class="c"># ------------------------------------------------------------</span>
collect_getedid<span class="o">()</span> <span class="o">{</span>
  log_cmd <span class="s2">"edid_getedid.log"</span> get-edid | parse-edid
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_ddc</span>
<span class="c">#   Runs ddcutil detect, get-edid, and capabilities once.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_ddc<span class="o">()</span> <span class="o">{</span>
  log_cmd <span class="s2">"ddcutil_detect.log"</span> ddcutil detect
  log_cmd <span class="s2">"ddcutil_edid.log"</span>   ddcutil get-edid | parse-edid
  log_cmd <span class="s2">"ddcutil_caps.log"</span>   ddcutil capabilities
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_general_info</span>
<span class="c">#   Captures xrandr verbose, hwinfo, inxi, lshw.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_general_info<span class="o">()</span> <span class="o">{</span>
  log_cmd <span class="s2">"xrandr_verbose.log"</span> xrandr <span class="nt">--verbose</span>
  log_cmd <span class="s2">"hwinfo_monitor.log"</span> hwinfo <span class="nt">--monitor</span>
  log_cmd <span class="s2">"inxi_Gxx.log"</span>       inxi <span class="nt">-Gxx</span>
  log_cmd <span class="s2">"lshw_display.log"</span>   lshw <span class="nt">-C</span> display
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_udev</span>
<span class="c">#   Gathers udevadm info for all DRM_ALL connectors.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_udev<span class="o">()</span> <span class="o">{</span>
  <span class="k">for </span>CON <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DRM_ALL</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">local </span><span class="nv">path</span><span class="o">=</span><span class="s2">"/sys/class/drm/</span><span class="k">${</span><span class="nv">CON</span><span class="k">}</span><span class="s2">"</span>
    log_cmd <span class="s2">"udevadm_</span><span class="k">${</span><span class="nv">CON</span><span class="k">}</span><span class="s2">.log"</span> udevadm info <span class="nt">--query</span><span class="o">=</span>all <span class="nt">--path</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">readlink</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>
  <span class="k">done</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: generate_cvt</span>
<span class="c">#   Prompts user, generates and optionally applies a CVT modeline.</span>
<span class="c"># ------------------------------------------------------------</span>
generate_cvt<span class="o">()</span> <span class="o">{</span>
  <span class="nb">read</span> <span class="nt">-rp</span> <span class="s2">"Enter width height refresh (e.g. 1920 1080 60), or ENTER to skip: "</span> W H R
  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$W$H$R</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">local </span>MODELINE
    <span class="nv">MODELINE</span><span class="o">=</span><span class="si">$(</span>cvt <span class="s2">"</span><span class="nv">$W</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$H</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$R</span><span class="s2">"</span> 2&gt;/dev/null | <span class="nb">tail</span> <span class="nt">-n1</span><span class="si">)</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$MODELINE</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
      </span><span class="nb">local </span><span class="nv">NAME</span><span class="o">=</span><span class="si">$(</span><span class="nb">awk</span> <span class="s1">'{print $2}'</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">"</span><span class="nv">$MODELINE</span><span class="s2">"</span><span class="si">)</span>
      <span class="nb">echo</span> <span class="s2">"Modeline: </span><span class="nv">$MODELINE</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
      <span class="nb">local </span><span class="nv">TARGET</span><span class="o">=</span><span class="k">${</span><span class="nv">XRANDR_CONNECTED</span><span class="p">[0]</span><span class="k">:-}</span>
      <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$TARGET</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span>xrandr <span class="nt">--newmode</span> <span class="nv">$MODELINE</span> <span class="se">\</span>
          <span class="o">&amp;&amp;</span> xrandr <span class="nt">--addmode</span> <span class="s2">"</span><span class="nv">$TARGET</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$NAME</span><span class="s2">"</span> <span class="se">\</span>
          <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="s2">"Applied to </span><span class="nv">$TARGET</span><span class="s2">; use 'xrandr --output </span><span class="nv">$TARGET</span><span class="s2"> --mode </span><span class="nv">$NAME</span><span class="s2">'"</span>
      <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"No connected output to apply mode; saved under cvt_modeline.log."</span>
      <span class="k">fi
    else
      </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to generate modeline."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
    <span class="k">fi
  fi</span>
<span class="o">}</span>

<span class="c"># ------------------- Main Execution -------------------</span>
ensure_root
install_tools

<span class="c"># Arrays for connectors</span>
<span class="nb">declare</span> <span class="nt">-a</span> DRM_ALL DRM_EDID XRANDR_ALL XRANDR_CONNECTED

setup_outdir
detect_connectors
collect_sysfs_edid
collect_getedid
collect_ddc
collect_general_info
collect_udev
generate_cvt

<span class="nb">echo
echo</span> <span class="s2">"Done. Review logs and summary.txt in </span><span class="nv">$OUTDIR</span><span class="s2">."</span>
<span class="nb">echo</span> <span class="s2">"To craft an xrandr modeline manually, inspect 'Detailed Timing Descriptors' in the EDID logs."</span>
</code></section></div></div>

<p>Next Steps:</p>
<ol>
  <li>Open <code class="language-plaintext highlighter-rouge">$OUTDIR/summary.txt</code> to see detected connectors and outputs.</li>
  <li>Inspect <code class="language-plaintext highlighter-rouge">edid_sysfs_*.log</code> and <code class="language-plaintext highlighter-rouge">edid_getedid.log</code> for Detailed Timing Descriptors (pixel clock, hsync/vsync, porches).</li>
  <li>Enclose those values within this <code class="language-plaintext highlighter-rouge">bash</code> script:
```
#!/bin/bash</li>
</ol>
  <h1 id="improved-temporary-xrandr-configuration-script">
    
    
     <a href="#improved-temporary-xrandr-configuration-script">#</a><a href="#" aria-label="Back to top">Improved Temporary Xrandr configuration script</a>
        
    
  </h1>
      
  <h1 id="these-settings-will-only-apply-to-the-current-x-session-and">
    
    
     <a href="#these-settings-will-only-apply-to-the-current-x-session-and">#</a><a href="#" aria-label="Back to top">These settings will only apply to the current X session and</a>
        
    
  </h1>
      
  <h1 id="will-not-persist-after-a-reboot-or-x-server-restart">
    
    
     <a href="#will-not-persist-after-a-reboot-or-x-server-restart">#</a><a href="#" aria-label="Back to top">will not persist after a reboot or X server restart.</a>
        
    
  </h1>
      
  <h1 id="ensure-this-script-is-run-from-within-an-active-x-window-system-session">
    
    
     <a href="#ensure-this-script-is-run-from-within-an-active-x-window-system-session">#</a><a href="#" aria-label="Back to top">Ensure this script is run from within an active X Window System session.</a>
        
    
  </h1>
      
<p>#</p>
  <h1 id="this-script-now-checks-the-connection-status-of-hdmi-1-and-dp-1">
    
    
     <a href="#this-script-now-checks-the-connection-status-of-hdmi-1-and-dp-1">#</a><a href="#" aria-label="Back to top">This script now checks the connection status of HDMI-1 and DP-1</a>
        
    
  </h1>
      
  <h1 id="before-attempting-to-configure-them-based-on-live-xrandr-output">
    
    
     <a href="#before-attempting-to-configure-them-based-on-live-xrandr-output">#</a><a href="#" aria-label="Back to top">before attempting to configure them, based on live ‘xrandr’ output.</a>
        
    
  </h1>
      
  <h1 id="if-dp-1-is-the-only-connected-monitor-it-attempts-to-set-screen-dpi">
    
    
     <a href="#if-dp-1-is-the-only-connected-monitor-it-attempts-to-set-screen-dpi">#</a><a href="#" aria-label="Back to top">If DP-1 is the only connected monitor, it attempts to set screen DPI</a>
        
    
  </h1>
      
  <h1 id="based-on-its-physical-dimensions">
    
    
     <a href="#based-on-its-physical-dimensions">#</a><a href="#" aria-label="Back to top">based on its physical dimensions.</a>
        
    
  </h1>
      
  <h1 id="check-if-xrandr-command-is-available">
    
    
     <a href="#check-if-xrandr-command-is-available">#</a><a href="#" aria-label="Back to top">Check if xrandr command is available</a>
        
    
  </h1>
      
<p>if ! command -v xrandr &amp;&gt; /dev/null; then
    echo “Error: xrandr command not found. Please ensure it is installed and in your PATH.”
    exit 1
fi</p>
  <h1 id="check-if-bc-command-is-available-for-dpi-calculations">
    
    
     <a href="#check-if-bc-command-is-available-for-dpi-calculations">#</a><a href="#" aria-label="Back to top">Check if bc command is available (for DPI calculations)</a>
        
    
  </h1>
      
<p>BC_AVAILABLE=false
if ! command -v bc &amp;&gt; /dev/null; then
    echo “Warning: bc command not found. DPI calculation for DP-1 will be skipped.”
    echo “Please install ‘bc’ if you want to enable automatic DPI setting.”
else
    BC_AVAILABLE=true
fi</p>

<p>echo “Applying temporary xrandr settings…”
echo “This script will check current display connection statuses.”
echo “Verify your display identifiers (e.g., HDMI-1, DP-1) by running ‘xrandr’ in a terminal.”</p>
  <h1 id="define-mode-names-and-modelines">
    
    
     <a href="#define-mode-names-and-modelines">#</a><a href="#" aria-label="Back to top">Define mode names and modelines</a>
        
    
  </h1>
      
<p>MODE_NAME_1=”1152x864_60.00” # For DP-1
MODELINE_1=”81.75  1152 1216 1336 1520  864 867 871 897 -hsync +vsync”
MODE_1_WIDTH_PX=1152
MODE_1_HEIGHT_PX=864</p>

<p>MODE_NAME_2=”2560x1080_60.00” # For HDMI-1
MODELINE_2=”230.00  2560 2720 2992 3424  1080 1083 1093 1120 -hsync +vsync”</p>
  <h1 id="define-output-names">
    
    
     <a href="#define-output-names">#</a><a href="#" aria-label="Back to top">Define output names</a>
        
    
  </h1>
      
<p>OUTPUT_DP=”DP-1”    # DisplayPort output
OUTPUT_HDMI=”HDMI-1” # HDMI output</p>
  <h1 id="physical-dimensions-for-dp-1-in-mm">
    
    
     <a href="#physical-dimensions-for-dp-1-in-mm">#</a><a href="#" aria-label="Back to top">Physical dimensions for DP-1 (in mm)</a>
        
    
  </h1>
      
<p>DP_WIDTH_MM=419
DP_HEIGHT_MM=236</p>
  <h1 id="-define-new-modes-always-attempt-this-">
    
    
     <a href="#-define-new-modes-always-attempt-this-">#</a><a href="#" aria-label="Back to top">— Define New Modes (always attempt this) —</a>
        
    
  </h1>
      
<p>echo “”
echo “Defining new mode: $MODE_NAME_1”
xrandr –newmode “$MODE_NAME_1” $MODELINE_1
if [ $? -ne 0 ]; then
    echo “Warning: Could not define mode $MODE_NAME_1.”
    echo “Possible issues: mode already exists (use ‘xrandr’ to check), incorrect modeline parameters, or xrandr limitations.”
fi</p>

<p>echo “Defining new mode: $MODE_NAME_2”
xrandr –newmode “$MODE_NAME_2” $MODELINE_2
if [ $? -ne 0 ]; then
    echo “Warning: Could not define mode $MODE_NAME_2.”
    echo “Possible issues: mode already exists (use ‘xrandr’ to check), incorrect modeline parameters, or xrandr limitations.”
fi</p>
  <h1 id="-check-current-connection-status-of-displays-">
    
    
     <a href="#-check-current-connection-status-of-displays-">#</a><a href="#" aria-label="Back to top">— Check current connection status of displays —</a>
        
    
  </h1>
      
<p>echo “”
echo “Checking current display connection status…”
IS_DP_CONNECTED=false
if xrandr | grep -q “^${OUTPUT_DP} connected”; then
    IS_DP_CONNECTED=true
    echo “- $OUTPUT_DP is detected as connected.”
else
    echo “- $OUTPUT_DP is detected as disconnected.”
fi</p>

<p>IS_HDMI_CONNECTED=false
if xrandr | grep -q “^${OUTPUT_HDMI} connected”; then
    IS_HDMI_CONNECTED=true
    echo “- $OUTPUT_HDMI is detected as connected.”
else
    echo “- $OUTPUT_HDMI is detected as disconnected.”
fi</p>
  <h1 id="-initial-positioning-command-if-both-displays-are-connected-">
    
    
     <a href="#-initial-positioning-command-if-both-displays-are-connected-">#</a><a href="#" aria-label="Back to top">— Initial Positioning Command (if both displays are connected) —</a>
        
    
  </h1>
      
<p>echo “”
if $IS_HDMI_CONNECTED &amp;&amp; $IS_DP_CONNECTED; then
    echo “Attempting to set $OUTPUT_HDMI –auto –above $OUTPUT_DP…”
    xrandr –output “$OUTPUT_HDMI” –auto –above “$OUTPUT_DP”
    if [ $? -ne 0 ]; then
        echo “Warning: Could not set $OUTPUT_HDMI –auto –above $OUTPUT_DP.”
    else
        echo “Successfully attempted to position $OUTPUT_HDMI above $OUTPUT_DP.”
    fi
elif ! $IS_HDMI_CONNECTED &amp;&amp; $IS_DP_CONNECTED; then
    echo “Skipping initial positioning: $OUTPUT_HDMI is disconnected. $OUTPUT_DP is primary.”
elif $IS_HDMI_CONNECTED &amp;&amp; ! $IS_DP_CONNECTED; then
     echo “Skipping initial positioning: $OUTPUT_DP is disconnected. $OUTPUT_HDMI is primary.”
else
    echo “Skipping initial positioning: Both $OUTPUT_HDMI and $OUTPUT_DP appear to be disconnected.”
fi</p>
  <h1 id="-configure-dp-output-output_dp-">
    
    
     <a href="#-configure-dp-output-output_dp-">#</a><a href="#" aria-label="Back to top">— Configure DP Output ($OUTPUT_DP) —</a>
        
    
  </h1>
      
<p>echo “”
if $IS_DP_CONNECTED; then
    echo “Configuring $OUTPUT_DP…”
    echo “Adding mode $MODE_NAME_1 to $OUTPUT_DP”
    xrandr –addmode “$OUTPUT_DP” “$MODE_NAME_1”
    if [ $? -ne 0 ]; then
        echo “Error adding mode $MODE_NAME_1 to $OUTPUT_DP.”
        echo “Ensure $OUTPUT_DP is truly connected, the mode was defined, and supports this mode.”
    else
        echo “Setting $OUTPUT_DP to mode $MODE_NAME_1”
        xrandr –output “$OUTPUT_DP” –mode “$MODE_NAME_1”
        if [ $? -ne 0 ]; then
            echo “Error setting $OUTPUT_DP to mode $MODE_NAME_1.”
        else
            # If DP-1 is the only connected monitor, try to set screen DPI
            if ! $IS_HDMI_CONNECTED &amp;&amp; $BC_AVAILABLE; then
                echo “”
                echo “DP-1 ($OUTPUT_DP) appears to be the only connected display and ‘bc’ is available.”
                echo “Calculating DPI for screen based on DP-1 physical dimensions ($DP_WIDTH_MM mm x $DP_HEIGHT_MM mm) and mode $MODE_NAME_1 ($MODE_1_WIDTH_PX x $MODE_1_HEIGHT_PX).”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>            # Calculate DPI_H and DPI_V using bc for floating point arithmetic
            # scale=2 sets precision for bc output
            # Ensure dimensions are not zero to prevent division by zero, though hardcoded here
            if [ "$DP_WIDTH_MM" -gt 0 ] &amp;&amp; [ "$DP_HEIGHT_MM" -gt 0 ]; then
                DPI_H_CALC=$(bc -l &lt;&lt;&lt; "scale=2; $MODE_1_WIDTH_PX / ($DP_WIDTH_MM / 25.4)")
                DPI_V_CALC=$(bc -l &lt;&lt;&lt; "scale=2; $MODE_1_HEIGHT_PX / ($DP_HEIGHT_MM / 25.4)")

                # Check if bc calculations were successful and returned valid numbers
                if [[ -n "$DPI_H_CALC" &amp;&amp; -n "$DPI_V_CALC" &amp;&amp; "$DPI_H_CALC" =~ ^[0-9]+([.][0-9]+)?$ &amp;&amp; "$DPI_V_CALC" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
                    # Calculate average DPI and round to nearest integer
                    AVG_DPI=$(printf "%.0f" "$(bc -l &lt;&lt;&lt; "($DPI_H_CALC + $DPI_V_CALC) / 2")")

                    echo "Calculated average DPI: $AVG_DPI (H: $DPI_H_CALC, V: $DPI_V_CALC)"
                    echo "Attempting to set screen DPI to $AVG_DPI..."
                    # Note: 'xrandr --dpi' typically applies to the entire X screen.
                    xrandr --dpi "$AVG_DPI"
                    if [ $? -ne 0 ]; then
                        echo "Warning: Could not set screen DPI to $AVG_DPI. Your X server or driver might not support this or the value might be out of range."
                    else
                        echo "Screen DPI successfully set to $AVG_DPI. This may improve font rendering."
                    fi
                else
                    echo "Warning: DPI calculation failed or produced non-numeric results. Skipping DPI setting."
                    echo "DPI_H_CALC raw output: '$DPI_H_CALC'"
                    echo "DPI_V_CALC raw output: '$DPI_V_CALC'"
                fi
            else
                echo "Warning: DP-1 physical dimensions (DP_WIDTH_MM or DP_HEIGHT_MM) are zero. Cannot calculate DPI."
            fi
        elif ! $IS_HDMI_CONNECTED &amp;&amp; ! $BC_AVAILABLE; then
             echo "DP-1 ($OUTPUT_DP) is the only display, but 'bc' is not available. Skipping DPI calculation."
        fi
    fi
fi else
echo "Skipping configuration for $OUTPUT_DP as it is disconnected." fi
</code></section></div></div>
  <h1 id="-configure-hdmi-output-output_hdmi-">
    
    
     <a href="#-configure-hdmi-output-output_hdmi-">#</a><a href="#" aria-label="Back to top">— Configure HDMI Output ($OUTPUT_HDMI) —</a>
        
    
  </h1>
      
<p>echo “”
if $IS_HDMI_CONNECTED; then
    echo “Configuring $OUTPUT_HDMI…”
    echo “Adding mode $MODE_NAME_2 to $OUTPUT_HDMI”
    xrandr –addmode “$OUTPUT_HDMI” “$MODE_NAME_2”
    if [ $? -ne 0 ]; then
        echo “Error adding mode $MODE_NAME_2 to $OUTPUT_HDMI.”
        echo “Ensure $OUTPUT_HDMI is truly connected, the mode was defined, and supports this mode.”
    else
        echo “Setting $OUTPUT_HDMI to mode $MODE_NAME_2”
        xrandr –output “$OUTPUT_HDMI” –mode “$MODE_NAME_2”
        if [ $? -ne 0 ]; then
            echo “Error setting $OUTPUT_HDMI to mode $MODE_NAME_2.”
        fi
    fi
else
    echo “Skipping configuration for $OUTPUT_HDMI as it is disconnected.”
fi</p>

<p>echo “”
echo “Temporary xrandr settings applied (or attempted for connected displays).”
echo “Current screen configuration (relevant connected displays):”
xrandr | grep “ connected”</p>

<p>echo “”
echo “If you encounter issues, please check:”
echo “1. Your display output names ($OUTPUT_DP, $OUTPUT_HDMI) are correct (use ‘xrandr’ to verify).”
echo “2. Your displays are properly connected and powered on.”
echo “3. The modelines are compatible with your hardware.”
echo “4. Review any error messages above from xrandr.”
echo “5. If DPI was set, verify with ‘xdpyinfo | grep resolution’.”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><section><code>
# setting up as a system service

This process involves several stages:
1.  **One-Time System Preparation:** Installing necessary software and performing initial configurations.
2.  **Understanding and Using the Provided Scripts:** Detailing the roles of `monitor-info.sh` and the "Improved Temporary Xrandr configuration script."
3.  **Configuring `autorandr`:** Manually defining display profiles for your different setups, incorporating logic from the provided scripts.
4.  **Automating `autorandr`:** Ensuring `autorandr` applies these profiles automatically when an X session starts and responds to hardware changes.
5.  **Advanced `autorandr` Features and Troubleshooting.**

Here's a comprehensive, step-by-step guide:

## Phase 1: One-Time System Preparation

You'll need to run these commands once as root to prepare your system. You can save this as a script (e.g., `debian_display_setup_prep.sh`) and execute it, or run commands individually.

```bash
#!/bin/bash
#
# debian_display_setup_prep.sh
# One-time preparation script for display management on Debian Bullseye.
# Run this script as root: sudo bash debian_display_setup_prep.sh
#

set -euo pipefail

echo "&gt;&gt;&gt; Starting one-time system preparation for display management..."

# Ensure running as root
if [[ $EUID -ne 0 ]]; then
  echo "ERROR: This script must be run as root." &gt;&amp;2
  exit 1
fi

echo "&gt;&gt;&gt; Updating package lists..."
apt update

echo "&gt;&gt;&gt; Installing autorandr..."
# autorandr is in Debian Bullseye repositories.
# Debian's package typically includes necessary Python dependencies.
# python3-pip is included as the blog post mentions it and it can be useful.
apt install -y autorandr python3-pip

echo "&gt;&gt;&gt; Installing tools for display information gathering and configuration..."
# These tools are used by monitor-info.sh or for manual xrandr setup.
# 'bc' is needed for DPI calculations if you use that part of the example script.
apt install -y read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc

echo "&gt;&gt;&gt; System Updates Recommendation..."
echo "It's highly recommended to keep your system updated."
echo "You can do this by running: sudo apt update &amp;&amp; sudo apt full-upgrade -y"
# Consider uncommenting the following to perform a full upgrade now:
# apt full-upgrade -y

echo "&gt;&gt;&gt; GPU Memory Configuration (Conditional - Primarily for Raspberry Pi or similar SBCs)..."
# If your Debian Bullseye system is a Raspberry Pi, ensure sufficient GPU memory.
# Edit /boot/config.txt (NOT /boot/efi/extraconfig.txt).
# Example: Add or modify 'gpu_mem=256' or 'gpu_mem=512'.
# A reboot is required for this change.
# This step is generally not applicable for standard PCs with dedicated GPUs.
echo "If using a Raspberry Pi, check/adjust GPU memory in /boot/config.txt if needed (e.g., gpu_mem=256)."

echo "&gt;&gt;&gt; Enabling and starting autorandr systemd services..."
# The Debian autorandr package includes autorandr.service (for udev/DRM events like hotplug)
# and often autorandr-resume.service (for system resume).
# Enabling these provides robust, system-level display management.
if systemctl list-unit-files | grep -q autorandr.service; then
    systemctl enable --now autorandr.service
    echo "autorandr.service has been enabled and started."
    # Also enable the resume service if it exists
    if systemctl list-unit-files | grep -q autorandr-resume.service; then
        systemctl enable --now autorandr-resume.service
        echo "autorandr-resume.service has been enabled and started."
    fi
else
    echo "WARNING: autorandr.service not found. This is unexpected for the Debian Bullseye package."
    echo "Automatic hotplug detection via systemd might not function as described."
fi

echo "&gt;&gt;&gt; One-time system preparation script finished."
echo "Please REBOOT if you made changes like GPU memory configuration."
echo "Next, understand the provided scripts and then manually configure autorandr profiles."
</code></section></div></div>

<p><strong>To use this script:</strong></p>
<ol>
  <li>Save it as <code class="language-plaintext highlighter-rouge">debian_display_setup_prep.sh</code>.</li>
  <li>Make it executable: <code class="language-plaintext highlighter-rouge">chmod +x debian_display_setup_prep.sh</code>.</li>
  <li>Run it as root: <code class="language-plaintext highlighter-rouge">sudo ./debian_display_setup_prep.sh</code>.</li>
  <li>Reboot if you made changes to critical system configurations like GPU memory.</li>
</ol>
  <h2 id="phase-2-understanding-and-using-the-provided-scripts">
    
    
     <a href="#phase-2-understanding-and-using-the-provided-scripts">#</a><a href="#" aria-label="Back to top">Phase 2: Understanding and Using the Provided Scripts</a>
        
    
  </h2>
      

<p>Your original query included two scripts from a blog post. Here’s how they fit into the setup:</p>
  <h3 id="a-monitor-infosh-bash-script-to-collect-monitor-data">
    
    
     <a href="#a-monitor-infosh-bash-script-to-collect-monitor-data">#</a><a href="#" aria-label="Back to top">A. <code class="language-plaintext highlighter-rouge">monitor-info.sh</code> (Bash script to collect monitor data)</a>
        
    
  </h3>
      

<ul>
  <li><strong>Purpose:</strong> This script is a <strong>diagnostic and information-gathering tool</strong>. It is <strong>not</strong> meant to run automatically every time an X session starts. Its purpose is to help you understand your display hardware, especially when configuring new or problematic monitors. The data it gathers (EDID, timings) is crucial for crafting manual <code class="language-plaintext highlighter-rouge">xrandr</code> commands if needed.</li>
  <li><strong>“Enclosing” this script:</strong>
    <ol>
      <li>The “One-Time System Preparation Script” (Phase 1) already installed all the command-line tools <code class="language-plaintext highlighter-rouge">monitor-info.sh</code> uses.</li>
      <li>Below is the script content. Save it to a file in your home directory (e.g., <code class="language-plaintext highlighter-rouge">~/monitor-info.sh</code>).</li>
      <li>Make it executable: <code class="language-plaintext highlighter-rouge">chmod +x ~/monitor-info.sh</code>.</li>
      <li>Run it manually with <code class="language-plaintext highlighter-rouge">sudo ~/monitor-info.sh</code> <em>when you need to diagnose a display setup before creating an <code class="language-plaintext highlighter-rouge">autorandr</code> profile for it</em>.</li>
    </ol>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/usr/bin/env bash</span>
<span class="c">#</span>
<span class="c"># monitor-info.sh</span>
<span class="c"># Collect comprehensive monitor info for xrandr configuration on Debian Bullseye+.</span>
<span class="c"># Usage: sudo bash ~/monitor-info.sh</span>
<span class="c">#</span>

<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: ensure_root</span>
<span class="c">#   Abort if not running as root.</span>
<span class="c"># ------------------------------------------------------------</span>
ensure_root<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nv">$EUID</span> <span class="nt">-ne</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"ERROR: Must be run as root."</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">exit </span>1
  <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: install_tools_explicit_check</span>
<span class="c">#   Checks if tools are installed (they should be by the prep script).</span>
<span class="c"># ------------------------------------------------------------</span>
install_tools_explicit_check<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">missing_pkgs</span><span class="o">=</span><span class="s2">""</span>
  <span class="k">for </span>pkg <span class="k">in </span>read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode<span class="p">;</span> <span class="k">do
    if</span> <span class="o">!</span> dpkg <span class="nt">-s</span> <span class="s2">"</span><span class="nv">$pkg</span><span class="s2">"</span> &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
      </span><span class="nv">missing_pkgs</span><span class="o">=</span><span class="s2">"</span><span class="nv">$missing_pkgs</span><span class="s2"> </span><span class="nv">$pkg</span><span class="s2">"</span>
    <span class="k">fi
  done
  if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$missing_pkgs</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"WARNING: Some required packages are missing: </span><span class="nv">$missing_pkgs</span><span class="s2">"</span> <span class="o">&gt;</span>&amp;2
    <span class="nb">echo</span> <span class="s2">"Please run the main preparation script or 'sudo apt install </span><span class="nv">$missing_pkgs</span><span class="s2">'"</span> <span class="o">&gt;</span>&amp;2
    <span class="c"># Optionally, exit here if you want to be strict: exit 1</span>
  <span class="k">fi</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: setup_outdir</span>
<span class="c">#   Creates a timestamped output directory.</span>
<span class="c"># ------------------------------------------------------------</span>
setup_outdir<span class="o">()</span> <span class="o">{</span>
  <span class="c"># Try to create in user's home directory if sudo is used from a user context</span>
  <span class="nv">REAL_USER</span><span class="o">=</span><span class="si">$(</span><span class="nb">logname </span>2&gt;/dev/null <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$SUDO_USER</span><span class="s2">"</span><span class="si">)</span>
  <span class="nv">USER_HOME</span><span class="o">=</span><span class="si">$(</span>getent passwd <span class="s2">"</span><span class="nv">$REAL_USER</span><span class="s2">"</span> | <span class="nb">cut</span> <span class="nt">-d</span>: <span class="nt">-f6</span><span class="si">)</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$USER_HOME</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$USER_HOME</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">OUTDIR_BASE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$USER_HOME</span><span class="s2">"</span>
  <span class="k">else
    </span><span class="nv">OUTDIR_BASE</span><span class="o">=</span><span class="s2">"/root"</span> <span class="c"># Fallback to /root if user home not found</span>
  <span class="k">fi

  </span><span class="nv">OUTDIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">OUTDIR_BASE</span><span class="k">}</span><span class="s2">/monitor-info-</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d-%H%M%S<span class="si">)</span><span class="s2">"</span>
  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">"</span>
  <span class="c"># If run as root, ensure the user can access it if OUTDIR_BASE was user's home</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$SUDO_USER</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$OUTDIR_BASE</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"</span><span class="nv">$USER_HOME</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">chown</span> <span class="nt">-R</span> <span class="s2">"</span><span class="nv">$SUDO_USER</span><span class="s2">:</span><span class="nv">$SUDO_USER</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true
  </span><span class="k">fi
  </span><span class="nb">echo</span> <span class="s2">"Output directory: </span><span class="nv">$OUTDIR</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: log_cmd</span>
<span class="c">#   Runs a command, logs stdout/stderr to a file, does not exit on error.</span>
<span class="c">#   Usage: log_cmd logfile command [args...]</span>
<span class="c"># ------------------------------------------------------------</span>
log_cmd<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">logfile</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="p">;</span> <span class="nb">shift</span>
  <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"===== </span><span class="si">$(</span><span class="nb">date</span> <span class="s1">'+%F %T'</span><span class="si">)</span><span class="s2"> : </span><span class="nv">$*</span><span class="s2"> ====="</span>
    <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span> 2&gt;&amp;1 <span class="o">||</span> <span class="nb">echo</span> <span class="s2">"(ERROR: '</span><span class="nv">$*</span><span class="s2">' failed with exit code </span><span class="nv">$?</span><span class="s2">)"</span>
    <span class="nb">echo</span>
  <span class="o">}</span> <span class="o">&gt;&gt;</span><span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/</span><span class="nv">$logfile</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: detect_connectors</span>
<span class="c">#   Populates arrays: DRM_ALL (all connectors), DRM_EDID (with edid),</span>
<span class="c">#   XRANDR_CONNECTED, XRANDR_ALL.</span>
<span class="c"># ------------------------------------------------------------</span>
detect_connectors<span class="o">()</span> <span class="o">{</span>
  <span class="nv">DRM_ALL</span><span class="o">=()</span>
  <span class="nv">DRM_EDID</span><span class="o">=()</span>
  <span class="nv">XRANDR_ALL</span><span class="o">=()</span>
  <span class="nv">XRANDR_CONNECTED</span><span class="o">=()</span>

  <span class="c"># DRM: all dirs under /sys/class/drm matching card*-* (more specific)</span>
  <span class="k">for </span>card_path <span class="k">in</span> /sys/class/drm/card<span class="k">*</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">[[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$card_path</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        for </span>path <span class="k">in</span> <span class="s2">"</span><span class="nv">$card_path</span><span class="s2">"</span>/<span class="k">*</span><span class="p">;</span> <span class="k">do
            if</span> <span class="o">[[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span> <span class="o">=</span>~ ^[A-Z]+-[0-9]+<span class="nv">$|</span>^[a-z]+-[0-9]+<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then</span> <span class="c"># Matches like HDMI-A-1 or DP-1</span>
                <span class="nb">local </span><span class="nv">name</span><span class="o">=</span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span>
                DRM_ALL+<span class="o">=(</span><span class="s2">"</span><span class="nv">$name</span><span class="s2">"</span><span class="o">)</span>
                <span class="o">[[</span> <span class="nt">-r</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">/edid"</span> <span class="o">&amp;&amp;</span> <span class="nt">-s</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">/edid"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> DRM_EDID+<span class="o">=(</span><span class="s2">"</span><span class="nv">$name</span><span class="s2">"</span><span class="o">)</span> <span class="c"># Check if EDID file is readable and not empty</span>
            <span class="k">fi
        done
    fi
  done</span>


  <span class="c"># xrandr: all outputs and connected ones</span>
  <span class="c"># Ensure X is running for xrandr, otherwise skip</span>
  <span class="k">if </span><span class="nb">command</span> <span class="nt">-v</span> xrandr &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> xhost <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    while </span><span class="nv">IFS</span><span class="o">=</span> <span class="nb">read</span> <span class="nt">-r</span> line<span class="p">;</span> <span class="k">do
      </span><span class="nb">local </span><span class="nv">out</span><span class="o">=</span><span class="si">$(</span><span class="nb">awk</span> <span class="s1">'/ connected/{print $1} / disconnected/{print $1}'</span> <span class="o">&lt;&lt;&lt;</span><span class="s2">"</span><span class="nv">$line</span><span class="s2">"</span><span class="si">)</span>
      <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> XRANDR_ALL+<span class="o">=(</span><span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span><span class="o">)</span>
      <span class="o">[[</span> <span class="nv">$line</span> <span class="o">==</span> <span class="k">*</span><span class="s2">" connected"</span><span class="k">*</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> XRANDR_CONNECTED+<span class="o">=(</span><span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span><span class="o">)</span>
    <span class="k">done</span> &lt; &lt;<span class="o">(</span>xrandr 2&gt;/dev/null<span class="o">)</span>
  <span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"NOTE: xrandr queries skipped (X server not accessible or xrandr not found)."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/summary.txt"</span>
  <span class="k">fi</span>

  <span class="c"># Summary print</span>
  <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">"All DRM connectors found: </span><span class="k">${</span><span class="nv">DRM_ALL</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"DRM connectors with readable EDID: </span><span class="k">${</span><span class="nv">DRM_EDID</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"xrandr outputs (if X session active): </span><span class="k">${</span><span class="nv">XRANDR_ALL</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
    <span class="nb">echo</span> <span class="s2">"Connected outputs via xrandr (if X session active): </span><span class="k">${</span><span class="nv">XRANDR_CONNECTED</span><span class="p">[*]</span><span class="k">:-</span><span class="nv">none</span><span class="k">}</span><span class="s2">"</span>
  <span class="o">}</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/summary.txt"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_sysfs_edid</span>
<span class="c">#   Parses EDID from sysfs for connectors in DRM_EDID.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_sysfs_edid<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> parse-edid &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> <span class="nb">command</span> <span class="nt">-v</span> edid-decode &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping sysfs EDID parsing: neither parse-edid nor edid-decode found."</span>
    <span class="k">return
  fi
  </span><span class="nb">local </span>parser_cmd
  <span class="nv">parser_cmd</span><span class="o">=</span><span class="si">$(</span><span class="nb">command</span> <span class="nt">-v</span> edid-decode <span class="o">||</span> <span class="nb">command</span> <span class="nt">-v</span> parse-edid<span class="si">)</span>

  <span class="k">for </span>CON_BASENAME <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DRM_EDID</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do</span>
    <span class="c"># Find full path for CON_BASENAME under /sys/class/drm/card*</span>
    <span class="nb">local </span><span class="nv">edid_path</span><span class="o">=</span><span class="s2">""</span>
    <span class="k">for </span>card_path <span class="k">in</span> /sys/class/drm/card<span class="k">*</span><span class="p">;</span> <span class="k">do
        if</span> <span class="o">[[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$card_path</span><span class="s2">/</span><span class="nv">$CON_BASENAME</span><span class="s2">/edid"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">edid_path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$card_path</span><span class="s2">/</span><span class="nv">$CON_BASENAME</span><span class="s2">/edid"</span>
            <span class="nb">break
        </span><span class="k">fi
    done

    if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$edid_path</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-r</span> <span class="s2">"</span><span class="nv">$edid_path</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span>log_cmd <span class="s2">"edid_sysfs_</span><span class="k">${</span><span class="nv">CON_BASENAME</span><span class="k">}</span><span class="s2">.log"</span> <span class="s2">"</span><span class="nv">$parser_cmd</span><span class="s2">"</span> &lt;<span class="s2">"</span><span class="nv">$edid_path</span><span class="s2">"</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"Could not read EDID for </span><span class="nv">$CON_BASENAME</span><span class="s2"> from </span><span class="nv">$edid_path</span><span class="s2">"</span> <span class="o">&gt;&gt;</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/summary.txt"</span>
    <span class="k">fi
  done</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_getedid</span>
<span class="c">#   Parses EDID via get-edid (ISA bus fallback, part of read-edid package).</span>
<span class="c"># ------------------------------------------------------------</span>
collect_getedid<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> get-edid &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping get-edid: command not found."</span>
    <span class="k">return
  fi
  if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> parse-edid &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> <span class="nb">command</span> <span class="nt">-v</span> edid-decode &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping get-edid parsing: no EDID parser found."</span>
    <span class="k">return
  fi
  </span><span class="nb">local </span>parser_cmd
  <span class="nv">parser_cmd</span><span class="o">=</span><span class="si">$(</span><span class="nb">command</span> <span class="nt">-v</span> edid-decode <span class="o">||</span> <span class="nb">command</span> <span class="nt">-v</span> parse-edid<span class="si">)</span>

  <span class="c"># get-edid often needs I2C modules loaded, like i2c-dev</span>
  <span class="c"># Ensure modules are loaded, if possible (might require reboot or manual modprobe)</span>
  <span class="k">if</span> <span class="o">!</span> lsmod | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"i2c_dev"</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"INFO: i2c_dev module not loaded. get-edid might fail. Consider 'sudo modprobe i2c_dev'."</span>
  <span class="k">fi
  </span>log_cmd <span class="s2">"edid_getedid.log"</span> bash <span class="nt">-c</span> <span class="s2">"get-edid 2&gt;/dev/null | </span><span class="nv">$parser_cmd</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_ddc</span>
<span class="c">#   Runs ddcutil detect and other commands.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_ddc<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> ddcutil &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping ddcutil: command not found."</span>
    <span class="k">return
  fi</span>
  <span class="c"># ddcutil often needs I2C modules loaded, like i2c-dev</span>
  <span class="k">if</span> <span class="o">!</span> lsmod | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"i2c_dev"</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"INFO: i2c_dev module not loaded. ddcutil might fail. Consider 'sudo modprobe i2c_dev'."</span>
  <span class="k">fi
  </span>log_cmd <span class="s2">"ddcutil_detect.log"</span> ddcutil detect <span class="nt">--verbose</span>
  <span class="c"># The following might be too much or redundant if sysfs EDID works well</span>
  <span class="c"># log_cmd "ddcutil_edid.log"  ddcutil get-edid --verbose | edid-decode # or parse-edid</span>
  <span class="c"># log_cmd "ddcutil_caps.log"  ddcutil capabilities --verbose</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_general_info</span>
<span class="c">#   Captures xrandr verbose, hwinfo, inxi, lshw.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_general_info<span class="o">()</span> <span class="o">{</span>
  <span class="k">if </span><span class="nb">command</span> <span class="nt">-v</span> xrandr &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> xhost <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    </span>log_cmd <span class="s2">"xrandr_verbose.log"</span> xrandr <span class="nt">--verbose</span>
  <span class="k">fi
  </span><span class="nb">command</span> <span class="nt">-v</span> hwinfo &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> log_cmd <span class="s2">"hwinfo_monitor.log"</span> hwinfo <span class="nt">--monitor</span> <span class="nt">--verbose</span>
  <span class="nb">command</span> <span class="nt">-v</span> inxi &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> log_cmd <span class="s2">"inxi_Gxx.log"</span> inxi <span class="nt">-Gxx</span> <span class="nt">--display</span>
  <span class="nb">command</span> <span class="nt">-v</span> lshw &amp;&gt; /dev/null <span class="o">&amp;&amp;</span> log_cmd <span class="s2">"lshw_display.log"</span> lshw <span class="nt">-C</span> display <span class="nt">-sanitize</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: collect_udev</span>
<span class="c">#   Gathers udevadm info for all DRM_ALL connectors.</span>
<span class="c"># ------------------------------------------------------------</span>
collect_udev<span class="o">()</span> <span class="o">{</span>
  <span class="k">for </span>CON_BASENAME <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DRM_ALL</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    </span><span class="nb">local </span><span class="nv">sys_path</span><span class="o">=</span><span class="s2">""</span>
    <span class="k">for </span>card_path <span class="k">in</span> /sys/class/drm/card<span class="k">*</span><span class="p">;</span> <span class="k">do
        if</span> <span class="o">[[</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$card_path</span><span class="s2">/</span><span class="nv">$CON_BASENAME</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">sys_path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$card_path</span><span class="s2">/</span><span class="nv">$CON_BASENAME</span><span class="s2">"</span>
            <span class="nb">break
        </span><span class="k">fi
    done

    if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$sys_path</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span>log_cmd <span class="s2">"udevadm_</span><span class="k">${</span><span class="nv">CON_BASENAME</span><span class="k">}</span><span class="s2">.log"</span> udevadm info <span class="nt">--query</span><span class="o">=</span>all <span class="nt">--path</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">readlink</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$sys_path</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>
    <span class="k">fi
  done</span>
<span class="o">}</span>

<span class="c"># ------------------------------------------------------------</span>
<span class="c"># Function: generate_cvt_interactive</span>
<span class="c">#   Prompts user, generates and optionally applies a CVT modeline.</span>
<span class="c">#   (Note: applying modes should be done carefully and typically within an X session)</span>
<span class="c"># ------------------------------------------------------------</span>
generate_cvt_interactive<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> cvt &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping CVT modeline generation: cvt command not found (part of x11-xserver-utils)."</span>
    <span class="k">return
  fi
  if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> xrandr &amp;&gt; /dev/null <span class="o">||</span> <span class="o">!</span> xhost <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping CVT modeline application: xrandr not available or X session not active."</span>
    <span class="nb">read</span> <span class="nt">-rp</span> <span class="s2">"Enter width height refresh (e.g. 1920 1080 60) to generate modeline, or ENTER to skip: "</span> W H R
    <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$W</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$H</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$R</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">local </span>MODELINE
        <span class="nv">MODELINE</span><span class="o">=</span><span class="si">$(</span>cvt <span class="s2">"</span><span class="nv">$W</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$H</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$R</span><span class="s2">"</span> 2&gt;/dev/null | <span class="nb">grep </span>Modeline | <span class="nb">sed</span> <span class="s1">'s/Modeline //'</span><span class="si">)</span>
        <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$MODELINE</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">echo</span> <span class="s2">"Generated Modeline: </span><span class="nv">$MODELINE</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
        <span class="k">else
            </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to generate modeline with cvt </span><span class="nv">$W</span><span class="s2"> </span><span class="nv">$H</span><span class="s2"> </span><span class="nv">$R</span><span class="s2">."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
        <span class="k">fi
    fi
    return
  fi

  </span><span class="nb">read</span> <span class="nt">-rp</span> <span class="s2">"Enter width height refresh (e.g. 1920 1080 60), or ENTER to skip CVT modeline generation: "</span> W H R
  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$W</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$H</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$R</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">local </span>MODELINE_FULL MODELINE_PARAMS NAME
    <span class="nv">MODELINE_FULL</span><span class="o">=</span><span class="si">$(</span>cvt <span class="s2">"</span><span class="nv">$W</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$H</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$R</span><span class="s2">"</span> 2&gt;/dev/null | <span class="nb">grep </span>Modeline<span class="si">)</span>

    <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$MODELINE_FULL</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
      </span><span class="nv">MODELINE_PARAMS</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$MODELINE_FULL</span><span class="s2">"</span> | <span class="nb">sed</span> <span class="s1">'s/Modeline //; s/^"[^"]*" //'</span><span class="si">)</span> <span class="c"># Remove "Modeline" and the name part</span>
      <span class="nv">NAME</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$MODELINE_FULL</span><span class="s2">"</span> | <span class="nb">awk</span> <span class="s1">'{print $2}'</span> | <span class="nb">tr</span> <span class="nt">-d</span> <span class="s1">'"'</span><span class="si">)</span> <span class="c"># Extract the mode name</span>

      <span class="nb">echo</span> <span class="s2">"Generated Modeline: </span><span class="nv">$MODELINE_FULL</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
      <span class="nb">echo</span> <span class="s2">"Parameters for xrandr --newmode: </span><span class="nv">$NAME</span><span class="s2"> </span><span class="nv">$MODELINE_PARAMS</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>

      <span class="nb">local </span><span class="nv">TARGET</span><span class="o">=</span><span class="k">${</span><span class="nv">XRANDR_CONNECTED</span><span class="p">[0]</span><span class="k">:-}</span> <span class="c"># Use first connected output as example</span>
      <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$TARGET</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">read</span> <span class="nt">-rp</span> <span class="s2">"Attempt to apply this to </span><span class="nv">$TARGET</span><span class="s2"> (requires X session)? (y/N): "</span> APPLY_CVT
        <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$APPLY_CVT</span><span class="s2">"</span> <span class="o">=</span>~ ^[Yy]<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
          </span><span class="nb">echo</span> <span class="s2">"Applying: xrandr --newmode </span><span class="nv">$NAME</span><span class="s2"> </span><span class="nv">$MODELINE_PARAMS</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
          xrandr <span class="nt">--newmode</span> <span class="s2">"</span><span class="nv">$NAME</span><span class="s2">"</span> <span class="nv">$MODELINE_PARAMS</span>
          <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">echo</span> <span class="s2">"Applying: xrandr --addmode </span><span class="nv">$TARGET</span><span class="s2"> </span><span class="nv">$NAME</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
            xrandr <span class="nt">--addmode</span> <span class="s2">"</span><span class="nv">$TARGET</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$NAME</span><span class="s2">"</span>
            <span class="k">if</span> <span class="o">[[</span> <span class="nv">$?</span> <span class="nt">-eq</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
              </span><span class="nb">echo</span> <span class="s2">"To activate, run: xrandr --output </span><span class="nv">$TARGET</span><span class="s2"> --mode </span><span class="nv">$NAME</span><span class="s2">"</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
              <span class="nb">read</span> <span class="nt">-rp</span> <span class="s2">"Attempt to set mode </span><span class="nv">$NAME</span><span class="s2"> on </span><span class="nv">$TARGET</span><span class="s2"> now? (y/N): "</span> SET_MODE
              <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$SET_MODE</span><span class="s2">"</span> <span class="o">=</span>~ ^[Yy]<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
                </span>xrandr <span class="nt">--output</span> <span class="s2">"</span><span class="nv">$TARGET</span><span class="s2">"</span> <span class="nt">--mode</span> <span class="s2">"</span><span class="nv">$NAME</span><span class="s2">"</span>
                <span class="nb">echo</span> <span class="s2">"Mode set attempt completed."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
              <span class="k">fi
            else
              </span><span class="nb">echo</span> <span class="s2">"ERROR: xrandr --addmode failed."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
            <span class="k">fi
          else
            </span><span class="nb">echo</span> <span class="s2">"ERROR: xrandr --newmode failed (mode might already exist or be invalid)."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
          <span class="k">fi
        fi
      else
        </span><span class="nb">echo</span> <span class="s2">"No connected xrandr output detected to suggest application."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
      <span class="k">fi
    else
      </span><span class="nb">echo</span> <span class="s2">"ERROR: Failed to generate modeline with cvt </span><span class="nv">$W</span><span class="s2"> </span><span class="nv">$H</span><span class="s2"> </span><span class="nv">$R</span><span class="s2">."</span> | <span class="nb">tee</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$OUTDIR</span><span class="s2">/cvt_modeline.log"</span>
    <span class="k">fi
  fi</span>
<span class="o">}</span>

<span class="c"># ------------------- Main Execution -------------------</span>
ensure_root
install_tools_explicit_check <span class="c"># Verify tools, prep script should have installed them</span>

<span class="c"># Arrays for connectors</span>
<span class="nb">declare</span> <span class="nt">-a</span> DRM_ALL DRM_EDID XRANDR_ALL XRANDR_CONNECTED

setup_outdir
detect_connectors <span class="c"># Call this after setup_outdir so summary.txt goes into $OUTDIR</span>
collect_sysfs_edid
collect_getedid
collect_ddc
collect_general_info
collect_udev
generate_cvt_interactive

<span class="nb">echo
echo</span> <span class="s2">"Done. Review logs and summary.txt in </span><span class="nv">$OUTDIR</span><span class="s2">."</span>
<span class="nb">echo</span> <span class="s2">"To craft an xrandr modeline manually, inspect 'Detailed Timing Descriptors' or 'Established Timings' in the EDID logs (edid_sysfs_*.log or edid_getedid.log)."</span>
</code></section></div></div>
  <h3 id="b-improved-temporary-xrandr-configuration-script">
    
    
     <a href="#b-improved-temporary-xrandr-configuration-script">#</a><a href="#" aria-label="Back to top">B. “Improved Temporary Xrandr configuration script”</a>
        
    
  </h3>
      

<ul>
  <li><strong>Purpose:</strong> This script provides a template of <code class="language-plaintext highlighter-rouge">xrandr</code> commands for a specific dual-monitor setup (DP-1 and HDMI-1) including custom modelines and DPI settings.</li>
  <li><strong>“Enclosing” this script:</strong>
    <ol>
      <li>It is <strong>not</strong> meant to be run automatically on every X session start if you are using <code class="language-plaintext highlighter-rouge">autorandr</code> as the primary display manager. Doing so could conflict with <code class="language-plaintext highlighter-rouge">autorandr</code>.</li>
      <li>Instead, its <strong><code class="language-plaintext highlighter-rouge">xrandr</code> commands and logic</strong> should be used as a reference or template when you are <em>manually configuring your displays once</em> before saving an <code class="language-plaintext highlighter-rouge">autorandr</code> profile (Phase 3, Step 2).</li>
      <li>The <strong>DPI setting</strong> part is more dynamic and, if desired for a specific <code class="language-plaintext highlighter-rouge">autorandr</code> profile, should be placed into an <code class="language-plaintext highlighter-rouge">autorandr</code> hook script (see Phase 3, Step 7).</li>
      <li>Below is the script content for your reference during manual configuration:</li>
    </ol>
  </li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/bash</span>

<span class="c"># This is the "Improved Temporary Xrandr configuration script" from the blog post.</span>
<span class="c"># Use its xrandr commands as a TEMPLATE when manually setting up your displays</span>
<span class="c"># BEFORE saving an autorandr profile.</span>
<span class="c"># Do NOT run this script directly on every X startup if using autorandr.</span>
<span class="c"># The DPI calculation part can be adapted into an autorandr postswitch hook.</span>

<span class="c"># Check if xrandr command is available</span>
<span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> xrandr &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Error: xrandr command not found. Please ensure it is installed and in your PATH."</span>
    <span class="nb">exit </span>1
<span class="k">fi</span>

<span class="c"># Check if bc command is available (for DPI calculations)</span>
<span class="nv">BC_AVAILABLE</span><span class="o">=</span><span class="nb">false
</span><span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> bc &amp;&gt; /dev/null<span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Warning: bc command not found. DPI calculation for DP-1 will be skipped."</span>
    <span class="nb">echo</span> <span class="s2">"Please install 'bc' if you want to enable automatic DPI setting."</span>
<span class="k">else
    </span><span class="nv">BC_AVAILABLE</span><span class="o">=</span><span class="nb">true
</span><span class="k">fi

</span><span class="nb">echo</span> <span class="s2">"Applying temporary xrandr settings (REFERENCE SCRIPT)..."</span>
<span class="nb">echo</span> <span class="s2">"This script will check current display connection statuses."</span>
<span class="nb">echo</span> <span class="s2">"Verify your display identifiers (e.g., HDMI-1, DP-1) by running 'xrandr' in a terminal."</span>

<span class="c"># Define mode names and modelines</span>
<span class="nv">MODE_NAME_1</span><span class="o">=</span><span class="s2">"1152x864_60.00"</span> <span class="c"># For DP-1</span>
<span class="nv">MODELINE_1</span><span class="o">=</span><span class="s2">"81.75  1152 1216 1336 1520  864 867 871 897 -hsync +vsync"</span>
<span class="nv">MODE_1_WIDTH_PX</span><span class="o">=</span>1152
<span class="nv">MODE_1_HEIGHT_PX</span><span class="o">=</span>864

<span class="nv">MODE_NAME_2</span><span class="o">=</span><span class="s2">"2560x1080_60.00"</span> <span class="c"># For HDMI-1</span>
<span class="nv">MODELINE_2</span><span class="o">=</span><span class="s2">"230.00  2560 2720 2992 3424  1080 1083 1093 1120 -hsync +vsync"</span>

<span class="c"># Define output names</span>
<span class="nv">OUTPUT_DP</span><span class="o">=</span><span class="s2">"DP-1"</span>     <span class="c"># DisplayPort output</span>
<span class="nv">OUTPUT_HDMI</span><span class="o">=</span><span class="s2">"HDMI-1"</span> <span class="c"># HDMI output</span>

<span class="c"># Physical dimensions for DP-1 (in mm) - FOR DPI CALCULATION</span>
<span class="nv">DP_WIDTH_MM</span><span class="o">=</span>419
<span class="nv">DP_HEIGHT_MM</span><span class="o">=</span>236

<span class="c"># --- Define New Modes (always attempt this if using these modes) ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Defining new mode: </span><span class="nv">$MODE_NAME_1</span><span class="s2">"</span>
xrandr <span class="nt">--newmode</span> <span class="s2">"</span><span class="nv">$MODE_NAME_1</span><span class="s2">"</span> <span class="nv">$MODELINE_1</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Warning: Could not define mode </span><span class="nv">$MODE_NAME_1</span><span class="s2">."</span>
    <span class="nb">echo</span> <span class="s2">"Possible issues: mode already exists (use 'xrandr' to check), incorrect modeline parameters, or xrandr limitations."</span>
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">"Defining new mode: </span><span class="nv">$MODE_NAME_2</span><span class="s2">"</span>
xrandr <span class="nt">--newmode</span> <span class="s2">"</span><span class="nv">$MODE_NAME_2</span><span class="s2">"</span> <span class="nv">$MODELINE_2</span>
<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Warning: Could not define mode </span><span class="nv">$MODE_NAME_2</span><span class="s2">."</span>
<span class="k">fi</span>

<span class="c"># --- Check current connection status of displays ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Checking current display connection status..."</span>
<span class="nv">IS_DP_CONNECTED</span><span class="o">=</span><span class="nb">false
</span><span class="k">if </span>xrandr | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">OUTPUT_DP</span><span class="k">}</span><span class="s2"> connected"</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">IS_DP_CONNECTED</span><span class="o">=</span><span class="nb">true
    echo</span> <span class="s2">"- </span><span class="nv">$OUTPUT_DP</span><span class="s2"> is detected as connected."</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"- </span><span class="nv">$OUTPUT_DP</span><span class="s2"> is detected as disconnected."</span>
<span class="k">fi

</span><span class="nv">IS_HDMI_CONNECTED</span><span class="o">=</span><span class="nb">false
</span><span class="k">if </span>xrandr | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">OUTPUT_HDMI</span><span class="k">}</span><span class="s2"> connected"</span><span class="p">;</span> <span class="k">then
    </span><span class="nv">IS_HDMI_CONNECTED</span><span class="o">=</span><span class="nb">true
    echo</span> <span class="s2">"- </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> is detected as connected."</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"- </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> is detected as disconnected."</span>
<span class="k">fi</span>

<span class="c"># --- Initial Positioning Command (if both displays are connected) ---</span>
<span class="c"># Example: xrandr --output HDMI-1 --auto --above DP-1</span>
<span class="c"># This needs to be adapted to your desired layout.</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="k">if</span> <span class="nv">$IS_HDMI_CONNECTED</span> <span class="o">&amp;&amp;</span> <span class="nv">$IS_DP_CONNECTED</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Attempting to set </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> --auto --above </span><span class="nv">$OUTPUT_DP</span><span class="s2">..."</span>
    <span class="c"># Replace with your desired layout command, e.g.:</span>
    <span class="c"># xrandr --output "$OUTPUT_HDMI" --mode "$MODE_NAME_2" --output "$OUTPUT_DP" --mode "$MODE_NAME_1" --primary --right-of "$OUTPUT_HDMI"</span>
    xrandr <span class="nt">--output</span> <span class="s2">"</span><span class="nv">$OUTPUT_HDMI</span><span class="s2">"</span> <span class="nt">--auto</span> <span class="nt">--above</span> <span class="s2">"</span><span class="nv">$OUTPUT_DP</span><span class="s2">"</span> <span class="c"># Example from script</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"Warning: Could not set initial positioning."</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"Successfully attempted to position </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> above </span><span class="nv">$OUTPUT_DP</span><span class="s2">."</span>
    <span class="k">fi
elif</span> <span class="o">!</span> <span class="nv">$IS_HDMI_CONNECTED</span> <span class="o">&amp;&amp;</span> <span class="nv">$IS_DP_CONNECTED</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping initial positioning: </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> is disconnected. </span><span class="nv">$OUTPUT_DP</span><span class="s2"> is primary."</span>
    xrandr <span class="nt">--output</span> <span class="s2">"</span><span class="nv">$OUTPUT_DP</span><span class="s2">"</span> <span class="nt">--mode</span> <span class="s2">"</span><span class="nv">$MODE_NAME_1</span><span class="s2">"</span> <span class="nt">--primary</span> <span class="nt">--auto</span>
<span class="k">elif</span> <span class="nv">$IS_HDMI_CONNECTED</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="nv">$IS_DP_CONNECTED</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Skipping initial positioning: </span><span class="nv">$OUTPUT_DP</span><span class="s2"> is disconnected. </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> is primary."</span>
    xrandr <span class="nt">--output</span> <span class="s2">"</span><span class="nv">$OUTPUT_HDMI</span><span class="s2">"</span> <span class="nt">--mode</span> <span class="s2">"</span><span class="nv">$MODE_NAME_2</span><span class="s2">"</span> <span class="nt">--primary</span> <span class="nt">--auto</span>
<span class="k">else
    </span><span class="nb">echo</span> <span class="s2">"Skipping initial positioning: Both </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> and </span><span class="nv">$OUTPUT_DP</span><span class="s2"> appear to be disconnected."</span>
<span class="k">fi</span>


<span class="c"># --- Configure DP Output ($OUTPUT_DP) ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="k">if</span> <span class="nv">$IS_DP_CONNECTED</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Configuring </span><span class="nv">$OUTPUT_DP</span><span class="s2">..."</span>
    <span class="nb">echo</span> <span class="s2">"Adding mode </span><span class="nv">$MODE_NAME_1</span><span class="s2"> to </span><span class="nv">$OUTPUT_DP</span><span class="s2">"</span>
    xrandr <span class="nt">--addmode</span> <span class="s2">"</span><span class="nv">$OUTPUT_DP</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$MODE_NAME_1</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"Error adding mode </span><span class="nv">$MODE_NAME_1</span><span class="s2"> to </span><span class="nv">$OUTPUT_DP</span><span class="s2">."</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"Setting </span><span class="nv">$OUTPUT_DP</span><span class="s2"> to mode </span><span class="nv">$MODE_NAME_1</span><span class="s2">"</span>
        <span class="c"># This command would typically be part of the comprehensive layout command above</span>
        <span class="c"># xrandr --output "$OUTPUT_DP" --mode "$MODE_NAME_1"</span>
        <span class="c"># (Potentially redundant if already set in positioning)</span>
        <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">echo</span> <span class="s2">"Error setting </span><span class="nv">$OUTPUT_DP</span><span class="s2"> to mode </span><span class="nv">$MODE_NAME_1</span><span class="s2">."</span>
        <span class="k">else</span>
            <span class="c"># If DP-1 is the only connected monitor, try to set screen DPI</span>
            <span class="k">if</span> <span class="o">!</span> <span class="nv">$IS_HDMI_CONNECTED</span> <span class="o">&amp;&amp;</span> <span class="nv">$BC_AVAILABLE</span><span class="p">;</span> <span class="k">then
                </span><span class="nb">echo</span> <span class="s2">""</span>
                <span class="nb">echo</span> <span class="s2">"DP-1 (</span><span class="nv">$OUTPUT_DP</span><span class="s2">) appears to be the only connected display and 'bc' is available."</span>
                <span class="nb">echo</span> <span class="s2">"Calculating DPI for screen based on DP-1 physical dimensions (</span><span class="nv">$DP_WIDTH_MM</span><span class="s2"> mm x </span><span class="nv">$DP_HEIGHT_MM</span><span class="s2"> mm) and mode </span><span class="nv">$MODE_NAME_1</span><span class="s2"> (</span><span class="nv">$MODE_1_WIDTH_PX</span><span class="s2"> x </span><span class="nv">$MODE_1_HEIGHT_PX</span><span class="s2">)."</span>

                <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$DP_WIDTH_MM</span><span class="s2">"</span> <span class="nt">-gt</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$DP_HEIGHT_MM</span><span class="s2">"</span> <span class="nt">-gt</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
                    </span><span class="nv">DPI_H_CALC</span><span class="o">=</span><span class="si">$(</span>bc <span class="nt">-l</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"scale=2; </span><span class="nv">$MODE_1_WIDTH_PX</span><span class="s2"> / (</span><span class="nv">$DP_WIDTH_MM</span><span class="s2"> / 25.4)"</span><span class="si">)</span>
                    <span class="nv">DPI_V_CALC</span><span class="o">=</span><span class="si">$(</span>bc <span class="nt">-l</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"scale=2; </span><span class="nv">$MODE_1_HEIGHT_PX</span><span class="s2"> / (</span><span class="nv">$DP_HEIGHT_MM</span><span class="s2"> / 25.4)"</span><span class="si">)</span>

                    <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$DPI_H_CALC</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$DPI_V_CALC</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$DPI_H_CALC</span><span class="s2">"</span> <span class="o">=</span>~ ^[0-9]+<span class="o">([</span>.][0-9]+<span class="o">)</span>?<span class="nv">$ </span><span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$DPI_V_CALC</span><span class="s2">"</span> <span class="o">=</span>~ ^[0-9]+<span class="o">([</span>.][0-9]+<span class="o">)</span>?<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
                        </span><span class="nv">AVG_DPI</span><span class="o">=</span><span class="si">$(</span><span class="nb">printf</span> <span class="s2">"%.0f"</span> <span class="s2">"</span><span class="si">$(</span>bc <span class="nt">-l</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"(</span><span class="nv">$DPI_H_CALC</span><span class="s2"> + </span><span class="nv">$DPI_V_CALC</span><span class="s2">) / 2"</span><span class="si">)</span><span class="s2">"</span><span class="si">)</span>
                        <span class="nb">echo</span> <span class="s2">"Calculated average DPI: </span><span class="nv">$AVG_DPI</span><span class="s2"> (H: </span><span class="nv">$DPI_H_CALC</span><span class="s2">, V: </span><span class="nv">$DPI_V_CALC</span><span class="s2">)"</span>
                        <span class="nb">echo</span> <span class="s2">"Attempting to set screen DPI to </span><span class="nv">$AVG_DPI</span><span class="s2">..."</span>
                        xrandr <span class="nt">--dpi</span> <span class="s2">"</span><span class="nv">$AVG_DPI</span><span class="s2">"</span>
                        <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
                            </span><span class="nb">echo</span> <span class="s2">"Warning: Could not set screen DPI to </span><span class="nv">$AVG_DPI</span><span class="s2">."</span>
                        <span class="k">else
                            </span><span class="nb">echo</span> <span class="s2">"Screen DPI successfully set to </span><span class="nv">$AVG_DPI</span><span class="s2">."</span>
                        <span class="k">fi
                    else
                        </span><span class="nb">echo</span> <span class="s2">"Warning: DPI calculation failed or produced non-numeric results."</span>
                    <span class="k">fi
                else
                    </span><span class="nb">echo</span> <span class="s2">"Warning: DP-1 physical dimensions are zero. Cannot calculate DPI."</span>
                <span class="k">fi
            elif</span> <span class="o">!</span> <span class="nv">$IS_HDMI_CONNECTED</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="nv">$BC_AVAILABLE</span><span class="p">;</span> <span class="k">then
                </span><span class="nb">echo</span> <span class="s2">"DP-1 (</span><span class="nv">$OUTPUT_DP</span><span class="s2">) is the only display, but 'bc' is not available. Skipping DPI calculation."</span>
            <span class="k">fi
        fi
    fi
else
    </span><span class="nb">echo</span> <span class="s2">"Skipping configuration for </span><span class="nv">$OUTPUT_DP</span><span class="s2"> as it is disconnected."</span>
<span class="k">fi</span>

<span class="c"># --- Configure HDMI Output ($OUTPUT_HDMI) ---</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="k">if</span> <span class="nv">$IS_HDMI_CONNECTED</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"Configuring </span><span class="nv">$OUTPUT_HDMI</span><span class="s2">..."</span>
    <span class="nb">echo</span> <span class="s2">"Adding mode </span><span class="nv">$MODE_NAME_2</span><span class="s2"> to </span><span class="nv">$OUTPUT_HDMI</span><span class="s2">"</span>
    xrandr <span class="nt">--addmode</span> <span class="s2">"</span><span class="nv">$OUTPUT_HDMI</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$MODE_NAME_2</span><span class="s2">"</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="s2">"Error adding mode </span><span class="nv">$MODE_NAME_2</span><span class="s2"> to </span><span class="nv">$OUTPUT_HDMI</span><span class="s2">."</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="s2">"Setting </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> to mode </span><span class="nv">$MODE_NAME_2</span><span class="s2">"</span>
        <span class="c"># This command would typically be part of the comprehensive layout command above</span>
        <span class="c"># xrandr --output "$OUTPUT_HDMI" --mode "$MODE_NAME_2"</span>
        <span class="c"># (Potentially redundant if already set in positioning)</span>
        <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span><span class="nb">echo</span> <span class="s2">"Error setting </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> to mode </span><span class="nv">$MODE_NAME_2</span><span class="s2">."</span>
        <span class="k">fi
    fi
else
    </span><span class="nb">echo</span> <span class="s2">"Skipping configuration for </span><span class="nv">$OUTPUT_HDMI</span><span class="s2"> as it is disconnected."</span>
<span class="k">fi

</span><span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Temporary xrandr settings (REFERENCE SCRIPT) applied (or attempted for connected displays)."</span>
<span class="nb">echo</span> <span class="s2">"Current screen configuration (relevant connected displays):"</span>
xrandr | <span class="nb">grep</span> <span class="s2">" connected"</span>
</code></section></div></div>
  <h2 id="phase-3-configuring-autorandr-manual-steps-for-each-user-and-setup">
    
    
     <a href="#phase-3-configuring-autorandr-manual-steps-for-each-user-and-setup">#</a><a href="#" aria-label="Back to top">Phase 3: Configuring <code class="language-plaintext highlighter-rouge">autorandr</code> (Manual Steps for Each User and Setup)</a>
        
    
  </h2>
      

<p><code class="language-plaintext highlighter-rouge">autorandr</code> works by saving your current display configuration into a “profile.” This needs to be done by the user (root or normal user) within their own X session for each unique display setup.</p>

<p><strong>Steps to create profiles:</strong></p>

<ol>
  <li><strong>Connect Displays:</strong> Attach your specific combination of monitors, projectors, etc.</li>
  <li><strong>Manually Configure Displays:</strong> Use your desktop environment’s display settings tool or manual <code class="language-plaintext highlighter-rouge">xrandr</code> commands in a terminal to arrange your displays <em>exactly</em> as desired.
    <ul>
      <li>Refer to the <code class="language-plaintext highlighter-rouge">xrandr</code> commands in the “Improved Temporary Xrandr configuration script” above as a <strong>template</strong> for defining modelines (<code class="language-plaintext highlighter-rouge">xrandr --newmode ...</code>), adding modes (<code class="language-plaintext highlighter-rouge">xrandr --addmode ...</code>), and setting outputs (<code class="language-plaintext highlighter-rouge">xrandr --output &lt;name&gt; --mode &lt;mode&gt; --pos &lt;XxY&gt; --primary --rotate &lt;normal|left|right|inverted&gt; --output &lt;other_name&gt; ...</code>).</li>
      <li>For example, to set up two monitors, <code class="language-plaintext highlighter-rouge">HDMI-1</code> (2560x1080) to the left of <code class="language-plaintext highlighter-rouge">DP-1</code> (1920x1080, primary):
        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>  <span class="c"># (Assuming modelines for these resolutions are already supported or added via --newmode)</span>
  xrandr <span class="nt">--output</span> HDMI-1 <span class="nt">--mode</span> 2560x1080 <span class="nt">--pos</span> 0x0 <span class="nt">--rotate</span> normal <span class="se">\</span>
         <span class="nt">--output</span> DP-1 <span class="nt">--mode</span> 1920x1080 <span class="nt">--pos</span> 2560x0 <span class="nt">--rotate</span> normal <span class="nt">--primary</span>
</code></section></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Save the <code class="language-plaintext highlighter-rouge">autorandr</code> Profile:</strong> Once displays are perfectly configured, save this state:
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>autorandr <span class="nt">--save</span> &lt;profile_name&gt;
</code></section></div>    </div>
    <p>Use descriptive names (e.g., <code class="language-plaintext highlighter-rouge">office_dual_monitors</code>, <code class="language-plaintext highlighter-rouge">lecture_projector_1024x768</code>).</p>
  </li>
  <li><strong>Profile Locations and User Context:</strong>
    <ul>
      <li>Profiles are saved in <code class="language-plaintext highlighter-rouge">~/.config/autorandr/</code> (e.g., <code class="language-plaintext highlighter-rouge">/root/.config/autorandr/</code> for root, <code class="language-plaintext highlighter-rouge">/home/youruser/.config/autorandr/</code> for <code class="language-plaintext highlighter-rouge">youruser</code>).</li>
      <li><strong>For common profiles accessible by both root and normal users (if no user-specific one matches):</strong> You can manually copy or create profile directories in <code class="language-plaintext highlighter-rouge">/etc/xdg/autorandr/</code>. <code class="language-plaintext highlighter-rouge">autorandr</code> checks user-specific paths first. This is useful if root and a normal user often encounter the same display setups.</li>
    </ul>
  </li>
  <li><strong>Repeat for Other Setups:</strong> Repeat steps 1-3 for every different display configuration.</li>
  <li><strong>List and Set Default Profile:</strong>
    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>autorandr <span class="nt">--list</span> <span class="c"># Review saved profiles</span>
<span class="c"># Configure a very safe, common display setup (e.g., single monitor 1920x1080)</span>
<span class="c"># Then save it and set it as default:</span>
autorandr <span class="nt">--save</span> fallback_safe_1080p
autorandr <span class="nt">--default</span> fallback_safe_1080p
</code></section></div>    </div>
    <p>This default profile is crucial if an unknown display setup is detected.</p>
  </li>
  <li><strong>Implementing DPI Settings via Hooks (Optional):</strong>
If you want the DPI calculation from the “Improved Temporary Xrandr configuration script” to apply when a specific <code class="language-plaintext highlighter-rouge">autorandr</code> profile is loaded, create a <code class="language-plaintext highlighter-rouge">postswitch</code> hook script within that profile’s directory.
    <ul>
      <li>
        <p>For a profile named <code class="language-plaintext highlighter-rouge">my_specific_setup</code> (directory: <code class="language-plaintext highlighter-rouge">~/.config/autorandr/my_specific_setup/</code> or <code class="language-plaintext highlighter-rouge">/etc/xdg/autorandr/my_specific_setup/</code>), create an executable script: <code class="language-plaintext highlighter-rouge">.../my_specific_setup/postswitch</code></p>

        <div class="language-bash highlighter-rouge"><div class="highlight"><section><code>  <span class="c">#!/bin/sh</span>
  <span class="c">#</span>
  <span class="c"># postswitch hook for profile 'my_specific_setup' to set DPI.</span>
  <span class="c"># IMPORTANT: Customize all variables below (OUTPUT_NAME, MODE_WIDTH_PX, etc.)</span>
  <span class="c"># to match the specifics of THIS 'my_specific_setup' profile.</span>
  <span class="c">#</span>

  <span class="c"># For debugging hooks, you can use logger or write to a temp file:</span>
  <span class="c"># echo "Running postswitch for my_specific_setup at $(date)" &gt;&gt; /tmp/autorandr_hook_debug.log</span>

  <span class="k">if</span> <span class="o">!</span> <span class="nb">command</span> <span class="nt">-v</span> bc <span class="o">&gt;</span> /dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then</span>
      <span class="c"># echo "postswitch_dpi: bc command not found, skipping DPI." &gt;&gt; /tmp/autorandr_hook_debug.log</span>
      <span class="nb">exit </span>0
  <span class="k">fi</span>

  <span class="c"># --- START CUSTOMIZATION for 'my_specific_setup' profile ---</span>
  <span class="nv">OUTPUT_NAME</span><span class="o">=</span><span class="s2">"DP-1"</span>        <span class="c"># The actual output name (e.g., DP-1, HDMI-A-0) for this profile's main display</span>
  <span class="nv">MODE_WIDTH_PX</span><span class="o">=</span>1152        <span class="c"># Horizontal resolution of OUTPUT_NAME in this profile</span>
  <span class="nv">MODE_HEIGHT_PX</span><span class="o">=</span>864        <span class="c"># Vertical resolution of OUTPUT_NAME in this profile</span>
  <span class="nv">PHYS_WIDTH_MM</span><span class="o">=</span>419         <span class="c"># Physical width in mm of the monitor connected to OUTPUT_NAME</span>
  <span class="nv">PHYS_HEIGHT_MM</span><span class="o">=</span>236        <span class="c"># Physical height in mm of the monitor connected to OUTPUT_NAME</span>
  <span class="c"># --- END CUSTOMIZATION ---</span>

  <span class="c"># Check if the relevant display is configured as expected by autorandr for this profile</span>
  <span class="c"># This grep is a basic check; more robust checks might be needed for complex setups.</span>
  <span class="k">if </span>xrandr | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s2">"^</span><span class="k">${</span><span class="nv">OUTPUT_NAME</span><span class="k">}</span><span class="s2"> connected.*</span><span class="k">${</span><span class="nv">MODE_WIDTH_PX</span><span class="k">}</span><span class="s2">x</span><span class="k">${</span><span class="nv">MODE_HEIGHT_PX</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
      if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$PHYS_WIDTH_MM</span><span class="s2">"</span> <span class="nt">-gt</span> 0 <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$PHYS_HEIGHT_MM</span><span class="s2">"</span> <span class="nt">-gt</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
          </span><span class="nv">DPI_H_CALC</span><span class="o">=</span><span class="si">$(</span>bc <span class="nt">-l</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"scale=2; </span><span class="nv">$MODE_WIDTH_PX</span><span class="s2"> / (</span><span class="nv">$PHYS_WIDTH_MM</span><span class="s2"> / 25.4)"</span><span class="si">)</span>
          <span class="nv">DPI_V_CALC</span><span class="o">=</span><span class="si">$(</span>bc <span class="nt">-l</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"scale=2; </span><span class="nv">$MODE_HEIGHT_PX</span><span class="s2"> / (</span><span class="nv">$PHYS_HEIGHT_MM</span><span class="s2"> / 25.4)"</span><span class="si">)</span>

          <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$DPI_H_CALC</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$DPI_V_CALC</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$DPI_H_CALC</span><span class="s2">"</span> <span class="o">=</span>~ ^[0-9]+<span class="o">([</span>.][0-9]+<span class="o">)</span>?<span class="nv">$ </span><span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$DPI_V_CALC</span><span class="s2">"</span> <span class="o">=</span>~ ^[0-9]+<span class="o">([</span>.][0-9]+<span class="o">)</span>?<span class="nv">$ </span><span class="o">]]</span><span class="p">;</span> <span class="k">then
              </span><span class="nv">AVG_DPI</span><span class="o">=</span><span class="si">$(</span><span class="nb">printf</span> <span class="s2">"%.0f"</span> <span class="s2">"</span><span class="si">$(</span>bc <span class="nt">-l</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">"(</span><span class="nv">$DPI_H_CALC</span><span class="s2"> + </span><span class="nv">$DPI_V_CALC</span><span class="s2">) / 2"</span><span class="si">)</span><span class="s2">"</span><span class="si">)</span>
              <span class="c"># echo "postswitch_dpi: Setting screen DPI to $AVG_DPI for $OUTPUT_NAME." &gt;&gt; /tmp/autorandr_hook_debug.log</span>
              xrandr <span class="nt">--dpi</span> <span class="s2">"</span><span class="nv">$AVG_DPI</span><span class="s2">"</span>
          <span class="c"># else</span>
              <span class="c"># echo "postswitch_dpi: DPI calculation failed." &gt;&gt; /tmp/autorandr_hook_debug.log</span>
          <span class="k">fi</span>
      <span class="c"># else</span>
          <span class="c"># echo "postswitch_dpi: Physical dimensions for $OUTPUT_NAME are zero." &gt;&gt; /tmp/autorandr_hook_debug.log</span>
      <span class="k">fi</span>
  <span class="c"># else</span>
      <span class="c"># echo "postswitch_dpi: Expected display $OUTPUT_NAME not found or not in expected mode." &gt;&gt; /tmp/autorandr_hook_debug.log</span>
  <span class="k">fi
  </span><span class="nb">exit </span>0
</code></section></div>        </div>
      </li>
      <li>
        <p>Make the hook script executable: <code class="language-plaintext highlighter-rouge">chmod +x .../my_specific_setup/postswitch</code>. Repeat for other profiles if needed, customizing variables each time.</p>
      </li>
    </ul>
  </li>
</ol>
  <h2 id="phase-4-automating-autorandr">
    
    
     <a href="#phase-4-automating-autorandr">#</a><a href="#" aria-label="Back to top">Phase 4: Automating <code class="language-plaintext highlighter-rouge">autorandr</code></a>
        
    
  </h2>
      

<p>This ensures <code class="language-plaintext highlighter-rouge">autorandr</code> acts on display changes and at X session startup.</p>

<ol>
  <li>
    <p><strong>Systemd Service (for hotplugging and system events):</strong>
The <code class="language-plaintext highlighter-rouge">autorandr.service</code> (enabled in Phase 1) handles display changes detected by <code class="language-plaintext highlighter-rouge">udev</code> (e.g., plugging/unplugging monitors). This works system-wide, even outside or during an X session. It’s the primary mechanism for dynamic changes.</p>
  </li>
  <li>
    <p><strong>X Session Startup Script (for <code class="language-plaintext highlighter-rouge">startx</code>):</strong>
To explicitly trigger <code class="language-plaintext highlighter-rouge">autorandr</code> when an X session is initiated via <code class="language-plaintext highlighter-rouge">startx</code> (by root or any normal user), create:
File: <code class="language-plaintext highlighter-rouge">/etc/X11/Xsession.d/50-autorandr-load-profile</code></p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/bin/sh</span>
<span class="c">#</span>
<span class="c"># /etc/X11/Xsession.d/50-autorandr-load-profile</span>
<span class="c"># Load autorandr profile on X session start (for startx users).</span>
<span class="c"># This script runs as the user starting the X session.</span>
<span class="c">#</span>

<span class="k">if </span><span class="nb">command</span> <span class="nt">-v</span> xrandr <span class="o">&gt;</span>/dev/null 2&gt;&amp;1 <span class="o">&amp;&amp;</span> <span class="nb">command</span> <span class="nt">-v</span> autorandr <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="k">then</span>
    <span class="c"># --change: detects displays, loads best profile.</span>
    <span class="c"># --batch: implies --force, suppresses xrandr output unless error. Good for scripts.</span>
    autorandr <span class="nt">--change</span> <span class="nt">--batch</span>

    <span class="c"># For debugging, you could log:</span>
    <span class="c"># LOG_DIR="/tmp/autorandr_logs"</span>
    <span class="c"># mkdir -p "$LOG_DIR"</span>
    <span class="c"># echo "Xsession autorandr trigger for $(whoami) at $(date)" &gt;&gt; "$LOG_DIR/xsession_trigger.log"</span>
    <span class="c"># autorandr --change --debug &gt;&gt; "$LOG_DIR/autorandr_xsession_$(whoami)_$(date +%Y%m%d-%H%M%S).log" 2&gt;&amp;1</span>
<span class="k">fi

</span><span class="nb">exit </span>0
</code></section></div>    </div>
    <ul>
      <li><strong>Activate:</strong> Save and make executable: <code class="language-plaintext highlighter-rouge">sudo chmod +x /etc/X11/Xsession.d/50-autorandr-load-profile</code>.</li>
      <li><strong>Interplay:</strong> The <code class="language-plaintext highlighter-rouge">autorandr.service</code> provides continuous monitoring. This Xsession script ensures that when <code class="language-plaintext highlighter-rouge">startx</code> is explicitly run, <code class="language-plaintext highlighter-rouge">autorandr</code> evaluates the display situation at that specific moment, respecting the current user’s profiles.</li>
    </ul>
  </li>
</ol>
  <h2 id="phase-5-advanced-autorandr-features-and-troubleshooting">
    
    
     <a href="#phase-5-advanced-autorandr-features-and-troubleshooting">#</a><a href="#" aria-label="Back to top">Phase 5: Advanced <code class="language-plaintext highlighter-rouge">autorandr</code> Features and Troubleshooting</a>
        
    
  </h2>
      

<ul>
  <li><strong>Advanced Features (from blog post):</strong>
    <ul>
      <li><strong>Wildcard EDID Matching:</strong> Edit <code class="language-plaintext highlighter-rouge">config</code> file in profile dirs (e.g., <code class="language-plaintext highlighter-rouge">~/.config/autorandr/&lt;profile&gt;/config</code>) to use <code class="language-plaintext highlighter-rouge">*</code> in EDID strings for flexibility with similar monitors.</li>
      <li><strong>Other Hook Scripts:</strong> <code class="language-plaintext highlighter-rouge">preswitch</code>, <code class="language-plaintext highlighter-rouge">predetect</code>, <code class="language-plaintext highlighter-rouge">postdetect</code> for more automation (e.g., restarting panels, changing audio sinks). Remember <code class="language-plaintext highlighter-rouge">chmod +x</code> for all hook scripts.</li>
    </ul>
  </li>
  <li><strong>Troubleshooting (from blog post):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">autorandr --detected</code>: See current detection and scores.</li>
      <li><code class="language-plaintext highlighter-rouge">autorandr --change --debug</code>: Verbose output for manual diagnosis in an X session.</li>
      <li><code class="language-plaintext highlighter-rouge">journalctl -f | grep -i -E "drm|edid|autorandr"</code>: Live system logs.</li>
      <li><code class="language-plaintext highlighter-rouge">journalctl -b | grep -i -E "drm|edid|autorandr"</code>: Logs from current boot.</li>
      <li>Ensure system is updated: <code class="language-plaintext highlighter-rouge">sudo apt update &amp;&amp; sudo apt full-upgrade -y</code>.</li>
      <li>Check physical cable connections.</li>
    </ul>
  </li>
</ul>

<p>By following these phases, you’ll have a robust system where <code class="language-plaintext highlighter-rouge">autorandr</code> manages your display configurations automatically when displays are connected/disconnected or when you start an X session with <code class="language-plaintext highlighter-rouge">startx</code>, leveraging the specific configurations and logic from the provided scripts. Remember to adapt profile names and hook script details to your exact hardware and preferences.</p>

        </div>
        
          URL: https://ib.bsb.br/xrandr
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/refactor2/" title="refactor2" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/aot-3/" title="AoT 3" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scratchpad"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scratchpad" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/refactor1/" title="refactor1" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="/to-enable-video-acceleration-on-rpi4/" title="to enable video acceleration on RPI4" rel="next">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-05-08 13:10:24
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scratchpad">
                  scratchpad
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/xrandr/"
        },
        "headline": "autorandr and bash script to collect and setup monitor data for xrandr",
        "description": "",
        "datePublished": "2025-04-03T00:00:00+00:00",
        "dateModified": "2025-05-08T15:04:47+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
