<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        xrandr display-toolkit setup - infoBAG
      
    </title>
    <meta name="title" content="xrandr display-toolkit setup - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/xrandr/">
    <meta property="og:title" content="xrandr display-toolkit setup - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/xrandr/">
    <meta name="twitter:title" content="xrandr display-toolkit setup - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/xrandr/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scratchpad">
      
        <meta property="article:tag" content="scratchpad">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          xrandr display-toolkit setup
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-04-03T00:00:00+00:00" class="post-date">
          03 Apr 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-12-19T22:55:34+00:00">
              19 Dec 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/xrandr" class="tag">xrandr</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scratchpad" class="tag">scratchpad</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        115623 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        12841 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-04-03-xrandr.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-04-03-xrandr.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#recommended-flow">Recommended flow:</a><ul><li><a href="#optional-baseline-audit">Optional: baseline audit</a></li><li><a href="#install-display-tools--collect-info--create-custom-xrandr--save-autorandr-profile">Install display tools / collect info / create custom xrandr / save autorandr profile</a></li><li><a href="#in-x-session-safe-interactive-mode-picking">In X session: safe interactive mode picking</a></li><li><a href="#if-you-have-the-specific-hdmidp-low-mode-issue">If you have the specific HDMI+DP low-mode issue</a></li><li><a href="#wire-autorandr-persistence-at-loginresume">Wire autorandr persistence at login/resume</a></li></ul></li><li><a href="#homelinarork3588-display-toolkitbindebian_display_setupsh">/home/linaro/rk3588-display-toolkit/bin/debian_display_setup.sh</a></li><li><a href="#homelinarork3588-display-toolkitbinmonitor_setup_interactivesh">/home/linaro/rk3588-display-toolkit/bin/monitor_setup_interactive.sh</a></li><li><a href="#homelinarork3588-display-toolkitbinpwsh_monitor_setupps1">/home/linaro/rk3588-display-toolkit/bin/pwsh_monitor_setup.ps1</a></li><li><a href="#homelinarork3588-display-toolkitbinrk3588_auditsh">/home/linaro/rk3588-display-toolkit/bin/rk3588_audit.sh</a></li><li><a href="#homelinarork3588-display-toolkitbinrk3588_autorandr_bootstrapsh">/home/linaro/rk3588-display-toolkit/bin/rk3588_autorandr_bootstrap.sh</a></li><li><a href="#homelinarork3588-display-toolkitbinrk3588_dual_display_setupsh">/home/linaro/rk3588-display-toolkit/bin/rk3588_dual_display_setup.sh</a></li><li><a href="#homelinaromy_custom_display_configsh">/home/linaro/my_custom_display_config.sh</a></li></ul>
          <table>
  <thead>
    <tr>
      <th style="text-align: center"><strong>Resolution (Width x Height)</strong></th>
      <th style="text-align: center"><strong>Aspect Ratio</strong></th>
      <th style="text-align: center"><strong>Common Name(s)</strong></th>
      <th style="text-align: center"><strong>Total Pixels</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">3840x1080</td>
      <td style="text-align: center">32:9</td>
      <td style="text-align: center">DFHD (Dual Full HD)</td>
      <td style="text-align: center">4,147,200</td>
    </tr>
    <tr>
      <td style="text-align: center">5120x1440</td>
      <td style="text-align: center">32:9</td>
      <td style="text-align: center">DQHD (Dual QHD)</td>
      <td style="text-align: center">7,372,800</td>
    </tr>
    <tr>
      <td style="text-align: center">2560x1080</td>
      <td style="text-align: center">21:9</td>
      <td style="text-align: center">UltraWide FHD</td>
      <td style="text-align: center">2,764,800</td>
    </tr>
    <tr>
      <td style="text-align: center">3440x1440</td>
      <td style="text-align: center">21:9</td>
      <td style="text-align: center">UltraWide QHD</td>
      <td style="text-align: center">4,953,600</td>
    </tr>
    <tr>
      <td style="text-align: center">3840x1600</td>
      <td style="text-align: center">21:9</td>
      <td style="text-align: center">UWQHD+</td>
      <td style="text-align: center">6,144,000</td>
    </tr>
    <tr>
      <td style="text-align: center">5120x2160</td>
      <td style="text-align: center">21:9</td>
      <td style="text-align: center">5K Ultrawide (UW5K)</td>
      <td style="text-align: center">11,059,200</td>
    </tr>
    <tr>
      <td style="text-align: center">2048x1080</td>
      <td style="text-align: center">17:9</td>
      <td style="text-align: center">2K</td>
      <td style="text-align: center">2,211,840</td>
    </tr>
    <tr>
      <td style="text-align: center">4096x2160</td>
      <td style="text-align: center">17:9</td>
      <td style="text-align: center">DCI 4K</td>
      <td style="text-align: center">8,847,360</td>
    </tr>
    <tr>
      <td style="text-align: center">1280x800</td>
      <td style="text-align: center">16:10</td>
      <td style="text-align: center">WXGA</td>
      <td style="text-align: center">1,024,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1440x900</td>
      <td style="text-align: center">16:10</td>
      <td style="text-align: center">WXGA+</td>
      <td style="text-align: center">1,296,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1680x1050</td>
      <td style="text-align: center">16:10</td>
      <td style="text-align: center">WSXGA+</td>
      <td style="text-align: center">1,764,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1920x1200</td>
      <td style="text-align: center">16:10</td>
      <td style="text-align: center">WUXGA</td>
      <td style="text-align: center">2,304,000</td>
    </tr>
    <tr>
      <td style="text-align: center">2560x1600</td>
      <td style="text-align: center">16:10</td>
      <td style="text-align: center">WQXGA</td>
      <td style="text-align: center">4,096,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1280x720</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">HD, 720p</td>
      <td style="text-align: center">921,600</td>
    </tr>
    <tr>
      <td style="text-align: center">1360x768</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">HD</td>
      <td style="text-align: center">1,044,480</td>
    </tr>
    <tr>
      <td style="text-align: center">1366x768</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">HD</td>
      <td style="text-align: center">1,049,088</td>
    </tr>
    <tr>
      <td style="text-align: center">1536x864</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1,327,104</td>
    </tr>
    <tr>
      <td style="text-align: center">1600x900</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">HD+</td>
      <td style="text-align: center">1,440,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1920x1080</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">Full HD, FHD, 1080p</td>
      <td style="text-align: center">2,073,600</td>
    </tr>
    <tr>
      <td style="text-align: center">2048x1152</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">QWXGA</td>
      <td style="text-align: center">2,359,296</td>
    </tr>
    <tr>
      <td style="text-align: center">2560x1440</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">QHD, WQHD, 1440p</td>
      <td style="text-align: center">3,686,400</td>
    </tr>
    <tr>
      <td style="text-align: center">3840x2160</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">4K UHD</td>
      <td style="text-align: center">8,294,400</td>
    </tr>
    <tr>
      <td style="text-align: center">5120x2880</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">5K</td>
      <td style="text-align: center">14,745,600</td>
    </tr>
    <tr>
      <td style="text-align: center">7680x4320</td>
      <td style="text-align: center">16:9</td>
      <td style="text-align: center">8K UHD</td>
      <td style="text-align: center">33,177,600</td>
    </tr>
    <tr>
      <td style="text-align: center">1280x1024</td>
      <td style="text-align: center">5:4</td>
      <td style="text-align: center">SXGA</td>
      <td style="text-align: center">1,310,720</td>
    </tr>
    <tr>
      <td style="text-align: center">1280x768</td>
      <td style="text-align: center">5:3</td>
      <td style="text-align: center">WXGA</td>
      <td style="text-align: center">983,040</td>
    </tr>
    <tr>
      <td style="text-align: center">640x480</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">VGA</td>
      <td style="text-align: center">307,200</td>
    </tr>
    <tr>
      <td style="text-align: center">800x600</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">SVGA</td>
      <td style="text-align: center">480,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1024x768</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">XGA</td>
      <td style="text-align: center">786,432</td>
    </tr>
    <tr>
      <td style="text-align: center">1152x864</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">XGA+</td>
      <td style="text-align: center">995,328</td>
    </tr>
    <tr>
      <td style="text-align: center">1280x960</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">SXGA-</td>
      <td style="text-align: center">1,228,800</td>
    </tr>
    <tr>
      <td style="text-align: center">1400x1050</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">SXGA+</td>
      <td style="text-align: center">1,470,000</td>
    </tr>
    <tr>
      <td style="text-align: center">1600x1200</td>
      <td style="text-align: center">4:3</td>
      <td style="text-align: center">UXGA</td>
      <td style="text-align: center">1,920,000</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail
<span class="nv">IFS</span><span class="o">=</span><span class="s1">$'</span><span class="se">\n\t</span><span class="s1">'</span>

<span class="c"># rk3588-bullseye-display-toolkit-setup-integrated.sh</span>
<span class="c">#</span>
<span class="c"># Target: Debian 11 (Bullseye) on ARM64 (aarch64) RK3588 Rockchip bare-metal</span>
<span class="c"># Run as: normal user with sudo privileges (recommended from within ~)</span>
<span class="c">#</span>
<span class="c"># Purpose:</span>
<span class="c">#   - Install a small baseline of dependencies (idempotent)</span>
<span class="c">#   - Generate a display/audit toolkit under ~/rk3588-display-toolkit</span>
<span class="c">#   - Keep changes safe and explicit: scripts that modify display settings require confirmation</span>
<span class="c">#</span>
<span class="c"># This integrated build combines:</span>
<span class="c">#   - Installer safety (atomic writes + backups + explicit overwrite confirm)</span>
<span class="c">#   - Deeper audit capabilities (optional, confirmed actions; broader subsystem coverage)</span>
<span class="c">#   - Safer interactive display picking (SafeMode-first candidates, connector ordering)</span>
<span class="c">#   - Optional autorandr persistence wiring (user-level systemd/XDG autostart)</span>
<span class="c">#   - Optional PowerShell (pwsh) configurator (written to disk; requires pwsh installed separately)</span>

<span class="nv">VERSION</span><span class="o">=</span><span class="s2">"2025-12-18-integrated"</span>

<span class="c"># -----------------------------</span>
<span class="c"># Globals / configuration</span>
<span class="c"># -----------------------------</span>

<span class="nv">TOOLKIT_DIR_DEFAULT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/rk3588-display-toolkit"</span>
<span class="nv">TOOLKIT_DIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">TOOLKIT_DIR</span><span class="k">:-</span><span class="nv">$TOOLKIT_DIR_DEFAULT</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">BIN_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLKIT_DIR</span><span class="s2">/bin"</span>
<span class="nv">LOG_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLKIT_DIR</span><span class="s2">/logs"</span>
<span class="nv">STATE_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TOOLKIT_DIR</span><span class="s2">/state"</span>

<span class="nv">AUDIT_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">/rk3588_audit.sh"</span>
<span class="nv">MENU_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">/debian_display_setup.sh"</span>
<span class="nv">INTERACTIVE_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">/monitor_setup_interactive.sh"</span>
<span class="nv">DUAL_FIX_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">/rk3588_dual_display_setup.sh"</span>
<span class="nv">BOOTSTRAP_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">/rk3588_autorandr_bootstrap.sh"</span>
<span class="nv">PWSH_SCRIPT</span><span class="o">=</span><span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">/pwsh_monitor_setup.ps1"</span>

<span class="nv">CONFIRM_TOKEN</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">CONFIRM_TOKEN</span><span class="k">:-</span><span class="nv">yes</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">NONINTERACTIVE</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">NONINTERACTIVE</span><span class="k">:-</span><span class="nv">0</span><span class="k">}</span><span class="s2">"</span>     <span class="c"># if 1, will NOT overwrite existing files</span>
<span class="nv">AUTO_CONFIRM_OVERWRITE</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">AUTO_CONFIRM_OVERWRITE</span><span class="k">:-</span><span class="nv">0</span><span class="k">}</span><span class="s2">"</span> <span class="c"># if 1, auto-confirms overwrites (still makes backups)</span>

<span class="nv">TMPDIR_CREATED</span><span class="o">=</span><span class="s2">""</span>
cleanup<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-n</span> <span class="s2">"</span><span class="k">${</span><span class="nv">TMPDIR_CREATED</span><span class="k">:-}</span><span class="s2">"</span> <span class="o">&amp;&amp;</span> <span class="nt">-d</span> <span class="s2">"</span><span class="nv">$TMPDIR_CREATED</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">rm</span> <span class="nt">-rf</span> <span class="s2">"</span><span class="nv">$TMPDIR_CREATED</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true
  </span><span class="k">fi</span>
<span class="o">}</span>
<span class="nb">trap </span>cleanup EXIT SIGINT SIGTERM

<span class="c"># -----------------------------</span>
<span class="c"># Helper functions</span>
<span class="c"># -----------------------------</span>

log<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s1">'[%(%F %T)T] %s\n'</span> <span class="nt">-1</span> <span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span><span class="p">;</span> <span class="o">}</span>
err<span class="o">()</span> <span class="o">{</span> <span class="nb">printf</span> <span class="s1">'[%(%F %T)T] ERROR: %s\n'</span> <span class="nt">-1</span> <span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span> <span class="o">&gt;</span>&amp;2<span class="p">;</span> <span class="o">}</span>
die<span class="o">()</span> <span class="o">{</span> err <span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span><span class="p">;</span> <span class="nb">exit </span>1<span class="p">;</span> <span class="o">}</span>

have_cmd<span class="o">()</span> <span class="o">{</span> <span class="nb">command</span> <span class="nt">-v</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="o">}</span>

require_home_context<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"</span><span class="nv">$HOME</span><span class="s2">"</span><span class="k">*</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span>err <span class="s2">"This script is intended to be run from within your home directory (~). Current PWD: </span><span class="nv">$PWD</span><span class="s2">"</span>
    err <span class="s2">"Continuing anyway, but generated files will be written to: </span><span class="nv">$TOOLKIT_DIR</span><span class="s2">"</span>
  <span class="k">fi</span>
<span class="o">}</span>

check_platform<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span>debver <span class="nb">arch
  </span><span class="nv">debver</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">cut</span> <span class="nt">-d</span><span class="s1">'.'</span> <span class="nt">-f1</span> &lt; /etc/debian_version 2&gt;/dev/null <span class="o">||</span> <span class="nb">echo </span>unknown<span class="si">)</span><span class="s2">"</span>
  <span class="nb">arch</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span> 2&gt;/dev/null <span class="o">||</span> <span class="nb">echo </span>unknown<span class="si">)</span><span class="s2">"</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$debver</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"11"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span>err <span class="s2">"Detected Debian major version '</span><span class="nv">$debver</span><span class="s2">' (expected 11/Bullseye). Continuing, but packages may differ."</span>
  <span class="k">fi

  if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$arch</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"aarch64"</span> <span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$arch</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"arm64"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span>err <span class="s2">"Detected architecture '</span><span class="nv">$arch</span><span class="s2">' (expected ARM64/aarch64). Continuing, but this is tuned for ARM64."</span>
  <span class="k">fi</span>
<span class="o">}</span>

need_sudo<span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">!</span> have_cmd <span class="nb">sudo</span><span class="p">;</span> <span class="k">then
    </span>die <span class="s2">"sudo is required. Install sudo or run as root (not recommended for X tooling)."</span>
  <span class="k">fi
  if</span> <span class="o">!</span> <span class="nb">sudo</span> <span class="nt">-v</span><span class="p">;</span> <span class="k">then
    </span>die <span class="s2">"sudo authentication failed."</span>
  <span class="k">fi</span>
<span class="o">}</span>

apt_update<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Updating APT package lists..."</span>
  <span class="nb">sudo </span>apt-get update
<span class="o">}</span>

pkg_installed<span class="o">()</span> <span class="o">{</span> dpkg <span class="nt">-s</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1<span class="p">;</span> <span class="o">}</span>

package_available<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">pkg</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  apt-cache policy <span class="s2">"</span><span class="nv">$pkg</span><span class="s2">"</span> 2&gt;/dev/null | <span class="nb">awk</span> <span class="s1">'/Candidate:/ {print $2}'</span> | <span class="nb">grep</span> <span class="nt">-vq</span> <span class="s2">"(none)"</span>
<span class="o">}</span>

apt_install_pkgs<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">pkgs</span><span class="o">=(</span><span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span><span class="o">)</span>
  <span class="nb">local </span><span class="nv">to_install</span><span class="o">=()</span>

  <span class="k">for </span>p <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">pkgs</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    if </span>pkg_installed <span class="s2">"</span><span class="nv">$p</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
      </span>log <span class="s2">"Package already installed: </span><span class="nv">$p</span><span class="s2">"</span>
      <span class="k">continue
    fi
    if</span> <span class="o">!</span> package_available <span class="s2">"</span><span class="nv">$p</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
      </span>err <span class="s2">"Package not available in APT sources (skipping): </span><span class="nv">$p</span><span class="s2">"</span>
      <span class="k">continue
    fi
    </span>to_install+<span class="o">=(</span><span class="s2">"</span><span class="nv">$p</span><span class="s2">"</span><span class="o">)</span>
  <span class="k">done

  if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">to_install</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span><span class="p">;</span> <span class="k">then
    </span>log <span class="s2">"All requested packages are already installed (or unavailable and skipped)."</span>
    <span class="k">return </span>0
  <span class="k">fi

  </span>log <span class="s2">"Installing packages: </span><span class="k">${</span><span class="nv">to_install</span><span class="p">[*]</span><span class="k">}</span><span class="s2">"</span>
  <span class="nb">sudo </span>apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="nt">--no-install-recommends</span> <span class="s2">"</span><span class="k">${</span><span class="nv">to_install</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span>
<span class="o">}</span>

confirm_high_risk<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">message</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$AUTO_CONFIRM_OVERWRITE</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"1"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span>log <span class="s2">"AUTO_CONFIRM_OVERWRITE=1 set; proceeding without prompt: </span><span class="nv">$message</span><span class="s2">"</span>
    <span class="k">return </span>0
  <span class="k">fi

  if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$NONINTERACTIVE</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"1"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span>err <span class="s2">"NONINTERACTIVE=1 set; refusing interactive confirmation for: </span><span class="nv">$message</span><span class="s2">"</span>
    <span class="k">return </span>1
  <span class="k">fi

  </span><span class="nb">echo
  echo</span> <span class="s2">"WARNING: </span><span class="nv">$message</span><span class="s2">"</span>
  <span class="nb">read</span> <span class="nt">-r</span> <span class="nt">-p</span> <span class="s2">"Type '</span><span class="nv">$CONFIRM_TOKEN</span><span class="s2">' to continue, anything else to cancel: "</span> ans
  <span class="o">[[</span> <span class="s2">"</span><span class="nv">$ans</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"</span><span class="nv">$CONFIRM_TOKEN</span><span class="s2">"</span> <span class="o">]]</span> <span class="o">||</span> <span class="o">{</span> err <span class="s2">"Cancelled by user."</span><span class="p">;</span> <span class="k">return </span>1<span class="p">;</span> <span class="o">}</span>
<span class="o">}</span>

backup_if_exists<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">local </span>ts bak
    <span class="nv">ts</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="si">)</span><span class="s2">"</span>
    <span class="nv">bak</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">path</span><span class="k">}</span><span class="s2">.bak.</span><span class="k">${</span><span class="nv">ts</span><span class="k">}</span><span class="s2">"</span>
    log <span class="s2">"Backing up existing file: </span><span class="nv">$path</span><span class="s2"> -&gt; </span><span class="nv">$bak</span><span class="s2">"</span>
    <span class="nb">cp</span> <span class="nt">-a</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$bak</span><span class="s2">"</span>
  <span class="k">fi</span>
<span class="o">}</span>

safe_write_file<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span><span class="nv">path</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span>
  <span class="nb">local </span><span class="nv">mode</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">2</span><span class="k">:-</span><span class="nv">644</span><span class="k">}</span><span class="s2">"</span>

  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">dirname</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="nt">-e</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$NONINTERACTIVE</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">"1"</span> <span class="o">&amp;&amp;</span> <span class="s2">"</span><span class="nv">$AUTO_CONFIRM_OVERWRITE</span><span class="s2">"</span> <span class="o">!=</span> <span class="s2">"1"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
      </span>err <span class="s2">"File exists and NONINTERACTIVE=1. Skipping: </span><span class="nv">$path</span><span class="s2">"</span>
      <span class="k">return </span>0
    <span class="k">fi
    if</span> <span class="o">!</span> confirm_high_risk <span class="s2">"This will overwrite: </span><span class="nv">$path</span><span class="s2"> (a backup will be created)."</span><span class="p">;</span> <span class="k">then
      </span>err <span class="s2">"Skipping write to </span><span class="nv">$path</span><span class="s2">"</span>
      <span class="k">return </span>0
    <span class="k">fi
    </span>backup_if_exists <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span>
  <span class="k">fi

  </span><span class="nv">TMPDIR_CREATED</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span><span class="nb">mktemp</span> <span class="nt">-d</span><span class="si">)</span><span class="s2">"</span>
  <span class="nb">local </span><span class="nv">tmpfile</span><span class="o">=</span><span class="s2">"</span><span class="nv">$TMPDIR_CREATED</span><span class="s2">/tmp.out"</span>
  <span class="nb">cat</span> <span class="o">&gt;</span> <span class="s2">"</span><span class="nv">$tmpfile</span><span class="s2">"</span>
  <span class="nb">install</span> <span class="nt">-m</span> <span class="s2">"</span><span class="nv">$mode</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$tmpfile</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$path</span><span class="s2">"</span>
  <span class="nb">rm</span> <span class="nt">-rf</span> <span class="s2">"</span><span class="nv">$TMPDIR_CREATED</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true
  </span><span class="nv">TMPDIR_CREATED</span><span class="o">=</span><span class="s2">""</span>

  log <span class="s2">"Wrote: </span><span class="nv">$path</span><span class="s2">"</span>
<span class="o">}</span>

<span class="c"># -----------------------------</span>
<span class="c"># Step 1: Install baseline dependencies</span>
<span class="c"># -----------------------------</span>

install_dependencies<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"=== Step 1/4: Installing baseline dependencies ==="</span>
  need_sudo
  apt_update

  apt_install_pkgs <span class="se">\</span>
    ca-certificates curl wget <span class="se">\</span>
    x11-xserver-utils xrandr <span class="se">\</span>
    autorandr <span class="se">\</span>
    python3 python3-tk <span class="se">\</span>
    coreutils gawk bc jq <span class="se">\</span>
    procps pciutils usbutils

  apt_install_pkgs edid-decode read-edid ddcutil inxi lshw hwinfo

  <span class="k">if</span> <span class="o">!</span> have_cmd <span class="nb">timeout</span><span class="p">;</span> <span class="k">then
    </span>die <span class="s2">"'timeout' command not found after installing coreutils; unexpected."</span>
  <span class="k">fi

  </span>log <span class="s2">"Dependencies installed/verified."</span>
<span class="o">}</span>

<span class="c"># -----------------------------</span>
<span class="c"># Step 2: Generate toolkit scripts</span>
<span class="c"># -----------------------------</span>

generate_audit_script<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Generating: </span><span class="nv">$AUDIT_SCRIPT</span><span class="s2">"</span>

  safe_write_file <span class="s2">"</span><span class="nv">$AUDIT_SCRIPT</span><span class="s2">"</span> 755 <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
#!/usr/bin/env bash
set -euo pipefail
set -o errtrace
IFS=</span><span class="nv">$'</span><span class="se">\n\t</span><span class="sh">'
trap 'echo "Error on or near line </span><span class="k">${</span><span class="nv">LINENO</span><span class="k">}</span><span class="sh">; command exited with status </span><span class="nv">$?</span><span class="sh">" &gt;&amp;2' ERR

# rk3588_audit.sh
#
# Purpose:
#   - Create a timestamped audit directory under ~/rk3588_audit_&lt;timestamp&gt;/
#   - Collect system/display/GPU/VPU/network/storage snapshots
#   - Install diagnostic packages idempotently (skips missing packages)
#   - Avoid destructive actions; optional actions require explicit confirmation

START_TS="</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="si">)</span><span class="sh">"
AUDIT_DIR="</span><span class="nv">$HOME</span><span class="sh">/rk3588_audit_</span><span class="k">${</span><span class="nv">START_TS</span><span class="k">}</span><span class="sh">"
LOG_DIR="</span><span class="nv">$AUDIT_DIR</span><span class="sh">/logs"
OUT_DIR="</span><span class="nv">$AUDIT_DIR</span><span class="sh">/out"
REPORT_MD="</span><span class="nv">$AUDIT_DIR</span><span class="sh">/REPORT.md"
LOG_FILE="</span><span class="nv">$LOG_DIR</span><span class="sh">/audit.log"
ENV_FILE="</span><span class="nv">$LOG_DIR</span><span class="sh">/env.txt"
DMESG_FILE="</span><span class="nv">$LOG_DIR</span><span class="sh">/dmesg.txt"

CMD_FAIL_HINT="Check </span><span class="k">${</span><span class="nv">LOG_FILE</span><span class="k">}</span><span class="sh"> and </span><span class="k">${</span><span class="nv">REPORT_MD</span><span class="k">}</span><span class="sh"> for details."

: "</span><span class="k">${</span><span class="nv">NET_TIMEOUT</span>:<span class="p">=5</span><span class="k">}</span><span class="sh">"
: "</span><span class="k">${</span><span class="nv">FIO_SIZE_MB</span>:<span class="p">=512</span><span class="k">}</span><span class="sh">"
: "</span><span class="k">${</span><span class="nv">FIO_BS</span>:<span class="p">=1M</span><span class="k">}</span><span class="sh">"
: "</span><span class="k">${</span><span class="nv">FIO_IODEPTH</span>:<span class="p">=16</span><span class="k">}</span><span class="sh">"
: "</span><span class="k">${</span><span class="nv">RUN_COLORS</span>:<span class="p">=1</span><span class="k">}</span><span class="sh">"

TMPDIR_CREATED=""
cleanup() {
  if [[ -n "</span><span class="k">${</span><span class="nv">TMPDIR_CREATED</span><span class="k">:-}</span><span class="sh">" &amp;&amp; -d "</span><span class="nv">$TMPDIR_CREATED</span><span class="sh">" ]]; then
    rm -rf "</span><span class="nv">$TMPDIR_CREATED</span><span class="sh">" || true
  fi
}
trap cleanup EXIT SIGINT SIGTERM

if [[ -t 1 &amp;&amp; "</span><span class="nv">$RUN_COLORS</span><span class="sh">" -eq 1 ]] &amp;&amp; command -v tput &gt;/dev/null 2&gt;&amp;1; then
  GREEN="</span><span class="si">$(</span>tput setaf 2<span class="si">)</span><span class="sh">"; YELLOW="</span><span class="si">$(</span>tput setaf 3<span class="si">)</span><span class="sh">"; RED="</span><span class="si">$(</span>tput setaf 1<span class="si">)</span><span class="sh">"; BLUE="</span><span class="si">$(</span>tput setaf 4<span class="si">)</span><span class="sh">"; BOLD="</span><span class="si">$(</span>tput bold<span class="si">)</span><span class="sh">"; RESET="</span><span class="si">$(</span>tput sgr0<span class="si">)</span><span class="sh">"
else
  GREEN=""; YELLOW=""; RED=""; BLUE=""; BOLD=""; RESET=""
fi

log() { echo -e "</span><span class="nv">$*</span><span class="sh">" | tee -a "</span><span class="nv">$LOG_FILE</span><span class="sh">"; }
section() { log "</span><span class="se">\n</span><span class="k">${</span><span class="nv">BOLD</span><span class="k">}${</span><span class="nv">BLUE</span><span class="k">}</span><span class="sh">==&gt; </span><span class="nv">$1</span><span class="k">${</span><span class="nv">RESET</span><span class="k">}</span><span class="sh">"; }

ensure_dir() { [[ -d "</span><span class="nv">$1</span><span class="sh">" ]] || mkdir -p "</span><span class="nv">$1</span><span class="sh">"; }

ask_yes() {
  local prompt="</span><span class="nv">$1</span><span class="sh">" ans
  echo
  read -r -p "</span><span class="k">${</span><span class="nv">YELLOW</span><span class="k">}${</span><span class="nv">prompt</span><span class="k">}${</span><span class="nv">RESET</span><span class="k">}</span><span class="sh"> (type 'yes' to continue, anything else to cancel): " ans
  [[ "</span><span class="nv">$ans</span><span class="sh">" == "yes" ]] || { echo "Cancelled by user."; return 1; }
}

need_sudo() {
  command -v sudo &gt;/dev/null 2&gt;&amp;1 || { echo "Error: sudo required." &gt;&amp;2; exit 1; }
  sudo -v || { echo "Error: sudo auth failed." &gt;&amp;2; exit 1; }
}

package_available() {
  local pkg="</span><span class="nv">$1</span><span class="sh">"
  apt-cache policy "</span><span class="nv">$pkg</span><span class="sh">" 2&gt;/dev/null | awk '/Candidate:/ {print </span><span class="nv">$2</span><span class="sh">}' | grep -vq "(none)"
}

is_installed() { dpkg -s "</span><span class="nv">$1</span><span class="sh">" &gt;/dev/null 2&gt;&amp;1; }

ensure_package() {
  local pkg="</span><span class="nv">$1</span><span class="sh">"
  if is_installed "</span><span class="nv">$pkg</span><span class="sh">"; then
    log "Package already installed: </span><span class="k">${</span><span class="nv">GREEN</span><span class="k">}${</span><span class="nv">pkg</span><span class="k">}${</span><span class="nv">RESET</span><span class="k">}</span><span class="sh">"
    return 0
  fi
  if ! package_available "</span><span class="nv">$pkg</span><span class="sh">"; then
    log "Package not available (skipping): </span><span class="k">${</span><span class="nv">YELLOW</span><span class="k">}${</span><span class="nv">pkg</span><span class="k">}${</span><span class="nv">RESET</span><span class="k">}</span><span class="sh">"
    return 0
  fi
  log "Installing package: </span><span class="k">${</span><span class="nv">GREEN</span><span class="k">}${</span><span class="nv">pkg</span><span class="k">}${</span><span class="nv">RESET</span><span class="k">}</span><span class="sh">"
  sudo apt-get install -y --no-install-recommends "</span><span class="nv">$pkg</span><span class="sh">" &gt;&gt;"</span><span class="nv">$LOG_FILE</span><span class="sh">" 2&gt;&amp;1 || {
    echo "Error: Failed to install '</span><span class="nv">$pkg</span><span class="sh">'. </span><span class="k">${</span><span class="nv">CMD_FAIL_HINT</span><span class="k">}</span><span class="sh">" &gt;&amp;2
    exit 1
  }
}

ensure_packages() { for pkg in "</span><span class="nv">$@</span><span class="sh">"; do ensure_package "</span><span class="nv">$pkg</span><span class="sh">"; done; }

run_continue() {
  local title="</span><span class="nv">$1</span><span class="sh">"; shift
  log "</span><span class="se">\n</span><span class="sh">--- </span><span class="nv">$title</span><span class="sh"> ---"
  "</span><span class="nv">$@</span><span class="sh">" &gt;&gt;"</span><span class="nv">$LOG_FILE</span><span class="sh">" 2&gt;&amp;1 || log "  (Command failed but continuing): </span><span class="nv">$*</span><span class="sh">"
}

run_fail() {
  local title="</span><span class="nv">$1</span><span class="sh">"; shift
  log "</span><span class="se">\n</span><span class="sh">&gt;&gt;&gt; </span><span class="nv">$title</span><span class="sh">"
  "</span><span class="nv">$@</span><span class="sh">" &gt;&gt;"</span><span class="nv">$LOG_FILE</span><span class="sh">" 2&gt;&amp;1 || { echo "Error: </span><span class="nv">$title</span><span class="sh"> failed. </span><span class="k">${</span><span class="nv">CMD_FAIL_HINT</span><span class="k">}</span><span class="sh">" &gt;&amp;2; exit 1; }
}

quick_net_check() {
  section "Quick network check"
  if command -v ping &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ping -c1 -W "</span><span class="nv">$NET_TIMEOUT</span><span class="sh">" deb.debian.org &gt;/dev/null 2&gt;&amp;1; then
    log "Network reachable."
    return 0
  fi
  log "Network check failed; installs/downloads may be limited."
  return 1
}

check_platform() {
  section "Platform checks"
  local debver arch
  debver="</span><span class="si">$(</span><span class="nb">cut</span> <span class="nt">-d</span><span class="s1">'.'</span> <span class="nt">-f1</span> &lt; /etc/debian_version 2&gt;/dev/null <span class="o">||</span> <span class="nb">echo </span>unknown<span class="si">)</span><span class="sh">"
  arch="</span><span class="si">$(</span><span class="nb">uname</span> <span class="nt">-m</span> 2&gt;/dev/null <span class="o">||</span> <span class="nb">echo </span>unknown<span class="si">)</span><span class="sh">"
  log "Debian major: </span><span class="nv">$debver</span><span class="sh">"
  log "Arch        : </span><span class="nv">$arch</span><span class="sh">"
  [[ "</span><span class="nv">$debver</span><span class="sh">" == "11" ]] || log "WARNING: tuned for Debian 11 (Bullseye)."
  [[ "</span><span class="nv">$arch</span><span class="sh">" == "aarch64" || "</span><span class="nv">$arch</span><span class="sh">" == "arm64" ]] || log "WARNING: tuned for ARM64."
}

enable_nonfree_optional() {
  section "Optional: Enable contrib/non-free (Bullseye)"
  if ! ask_yes "Enable 'contrib non-free' in /etc/apt/sources.list (backup + apt update)?"; then
    log "Skipped enabling contrib/non-free."
    return 0
  fi

  local src="/etc/apt/sources.list"
  if [[ ! -f "</span><span class="nv">$src</span><span class="sh">" ]]; then
    log "No </span><span class="nv">$src</span><span class="sh"> found; skipping."
    return 0
  fi

  sudo cp -a "</span><span class="nv">$src</span><span class="sh">" "</span><span class="k">${</span><span class="nv">src</span><span class="k">}</span><span class="sh">.bak.</span><span class="k">${</span><span class="nv">START_TS</span><span class="k">}</span><span class="sh">"

  TMPDIR_CREATED="</span><span class="si">$(</span><span class="nb">mktemp</span> <span class="nt">-d</span><span class="si">)</span><span class="sh">"
  local tmp="</span><span class="nv">$TMPDIR_CREATED</span><span class="sh">/sources.list"

  sudo awk '{
    if (</span><span class="nv">$1</span><span class="sh">=="deb" || </span><span class="nv">$1</span><span class="sh">=="deb-src") {
      line=</span><span class="nv">$0</span><span class="sh">
      has_contrib=match(line,/(^| )contrib( |</span><span class="nv">$)</span><span class="sh">/)
      has_nonfree=match(line,/(^| )non-free( |</span><span class="nv">$)</span><span class="sh">/)
      if (!has_contrib) line=line" contrib"
      if (!has_nonfree) line=line" non-free"
      print line
    } else {
      print
    }
  }' "</span><span class="nv">$src</span><span class="sh">" | sudo tee "</span><span class="nv">$tmp</span><span class="sh">" &gt;/dev/null

  sudo mv "</span><span class="nv">$tmp</span><span class="sh">" "</span><span class="nv">$src</span><span class="sh">"
  run_fail "apt-get update (after enabling contrib/non-free)" sudo apt-get update
  rm -rf "</span><span class="nv">$TMPDIR_CREATED</span><span class="sh">" || true
  TMPDIR_CREATED=""
}

main() {
  ensure_dir "</span><span class="nv">$AUDIT_DIR</span><span class="sh">"; ensure_dir "</span><span class="nv">$LOG_DIR</span><span class="sh">"; ensure_dir "</span><span class="nv">$OUT_DIR</span><span class="sh">"
  : &gt;"</span><span class="nv">$LOG_FILE</span><span class="sh">"

  section "Start"
  log "Audit directory: </span><span class="nv">$AUDIT_DIR</span><span class="sh">"
  log "Log file       : </span><span class="nv">$LOG_FILE</span><span class="sh">"

  need_sudo

  {
    echo "===== ENVIRONMENT ====="
    echo "Timestamp: </span><span class="nv">$START_TS</span><span class="sh">"
    uname -a || true
    echo
    echo "----- /etc/os-release -----"
    cat /etc/os-release 2&gt;/dev/null || true
    echo
    echo "----- /proc/cmdline -----"
    cat /proc/cmdline 2&gt;/dev/null || true
    echo
    echo "----- CPU -----"
    lscpu 2&gt;/dev/null || true
    echo
    echo "----- Memory/CMA -----"
    grep -E 'CmaTotal|CmaFree|MemTotal|MemFree|HugePages' /proc/meminfo 2&gt;/dev/null || true
  } &gt;"</span><span class="nv">$ENV_FILE</span><span class="sh">"

  run_continue "Collect dmesg" bash -lc "sudo dmesg -T &gt; '</span><span class="nv">$DMESG_FILE</span><span class="sh">'"

  check_platform
  quick_net_check || true

  section "APT update"
  run_fail "apt-get update" sudo apt-get update

  enable_nonfree_optional || true

  section "Install baseline diagnostic tools (idempotent; skips unavailable)"
  ensure_packages </span><span class="se">\</span><span class="sh">
    curl wget ca-certificates </span><span class="se">\</span><span class="sh">
    pciutils usbutils lshw hwinfo inxi </span><span class="se">\</span><span class="sh">
    ethtool iproute2 net-tools jq </span><span class="se">\</span><span class="sh">
    i2c-tools lm-sensors </span><span class="se">\</span><span class="sh">
    v4l-utils </span><span class="se">\</span><span class="sh">
    gstreamer1.0-tools gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly </span><span class="se">\</span><span class="sh">
    ffmpeg alsa-utils </span><span class="se">\</span><span class="sh">
    vulkan-tools mesa-utils kmscube </span><span class="se">\</span><span class="sh">
    xrandr x11-xserver-utils autorandr </span><span class="se">\</span><span class="sh">
    edid-decode read-edid ddcutil </span><span class="se">\</span><span class="sh">
    fio hdparm nvme-cli smartmontools </span><span class="se">\</span><span class="sh">
    iw wireless-tools bluez can-utils

  section "System overview"
  run_continue "lshw (short)" sudo lshw -short
  run_continue "lsblk -O" lsblk -O
  run_continue "df -hT" df -hT
  run_continue "lsusb -t" lsusb -t
  run_continue "lspci -nnk" lspci -nnk
  run_continue "Kernel warnings/errors (last 200)" bash -lc 'dmesg -T --level=err,warn | tail -n 200'

  section "GPU &amp; Display"
  run_continue "GPU modules loaded" bash -lc "lsmod | egrep -i 'panthor|panfrost|mali|kbase' || true"
  run_continue "GPU-related dmesg" bash -lc "dmesg -T | egrep -i 'mali|panthor|panfrost|csf|gpu' || true"
  run_continue "DRM connectors (modetest -c)" modetest -c
  run_continue "kmscube smoke test" bash -lc "kmscube -i 100 &gt;/dev/null 2&gt;&amp;1 || true"
  run_continue "Vulkan summary" vulkaninfo --summary
  run_continue "xrandr --props (if X running)" bash -lc "DISPLAY=</span><span class="se">\$</span><span class="sh">{DISPLAY:-:0} xrandr --props 2&gt;/dev/null || true"

  section "Video / V4L2 / Codecs"
  run_continue "List V4L2 devices" v4l2-ctl --list-devices
  run_continue "FFmpeg hwaccels" ffmpeg -hide_banner -hwaccels
  run_continue "GStreamer rockchip-ish plugins" bash -lc "gst-inspect-1.0 | egrep -i 'v4l2|rkv|hantro|rockchip' || true"

  section "Audio"
  run_continue "ALSA playback" aplay -l
  run_continue "ALSA capture" arecord -l

  section "Network"
  run_continue "ip -details addr" ip -details address
  run_continue "iw dev" iw dev

  section "Storage"
  run_continue "lsblk (model/serial)" lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,MODEL,SERIAL,TRAN
  run_continue "SATA/NVMe/PCIe dmesg" bash -lc "dmesg -T | egrep -i 'sata|ahci|nvme|pcie' || true"
  run_continue "nvme list (if any)" bash -lc "ls /dev/nvme*n1 &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo nvme list || true"

  section "Optional actions"
  if ask_yes "Run powertop --auto-tune (changes power tunables until reboot)?"; then
    run_fail "powertop --auto-tune" sudo powertop --auto-tune
  fi
  if ask_yes "Run sensors-detect (interactive; may load modules)?"; then
    run_fail "sensors-detect" sudo sensors-detect
  fi
  if ask_yes "Run quick fio seq read/write in </span><span class="nv">$HOME</span><span class="sh"> (~</span><span class="k">${</span><span class="nv">FIO_SIZE_MB</span><span class="k">}</span><span class="sh">MB temp file, then removed)?"; then
    TMPDIR_CREATED="</span><span class="si">$(</span><span class="nb">mktemp</span> <span class="nt">-d</span><span class="si">)</span><span class="sh">"
    local fiofile="</span><span class="nv">$TMPDIR_CREATED</span><span class="sh">/fio_test.dat"
    run_fail "dd create file" dd if=/dev/zero of="</span><span class="nv">$fiofile</span><span class="sh">" bs=1M count="</span><span class="nv">$FIO_SIZE_MB</span><span class="sh">" status=none
    run_fail "fio seq rw" fio --name=seqrw --filename="</span><span class="nv">$fiofile</span><span class="sh">" --rw=readwrite --bs="</span><span class="nv">$FIO_BS</span><span class="sh">" --direct=1 --numjobs=1 --iodepth="</span><span class="nv">$FIO_IODEPTH</span><span class="sh">" --size="</span><span class="k">${</span><span class="nv">FIO_SIZE_MB</span><span class="k">}</span><span class="sh">M" --group_reporting
    rm -rf "</span><span class="nv">$TMPDIR_CREATED</span><span class="sh">" || true
    TMPDIR_CREATED=""
  fi

  section "REPORT.md"
  {
    echo "# RK3588 Capability Audit — </span><span class="nv">$START_TS</span><span class="sh">"
    echo
    echo "Audit directory: </span><span class="nv">$AUDIT_DIR</span><span class="sh">"
    echo "Log file: </span><span class="nv">$LOG_FILE</span><span class="sh">"
    echo "Env snapshot: </span><span class="nv">$ENV_FILE</span><span class="sh">"
    echo "dmesg: </span><span class="nv">$DMESG_FILE</span><span class="sh">"
  } &gt;"</span><span class="nv">$REPORT_MD</span><span class="sh">"

  ( cd "</span><span class="nv">$HOME</span><span class="sh">" &amp;&amp; tar czf "</span><span class="k">${</span><span class="nv">AUDIT_DIR</span><span class="k">}</span><span class="sh">.tar.gz" "</span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$AUDIT_DIR</span><span class="s2">"</span><span class="si">)</span><span class="sh">" )

  section "Done"
  log "Report : </span><span class="nv">$REPORT_MD</span><span class="sh">"
  log "Archive: </span><span class="k">${</span><span class="nv">AUDIT_DIR</span><span class="k">}</span><span class="sh">.tar.gz"
}

main "</span><span class="nv">$@</span><span class="sh">"
</span><span class="no">EOF
</span><span class="o">}</span>

generate_menu_script<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Generating: </span><span class="nv">$MENU_SCRIPT</span><span class="s2">"</span>

  safe_write_file <span class="s2">"</span><span class="nv">$MENU_SCRIPT</span><span class="s2">"</span> 755 <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
#!/usr/bin/env bash
set -euo pipefail
IFS=</span><span class="nv">$'</span><span class="se">\n\t</span><span class="sh">'

# debian_display_setup.sh
# Menu-driven helper for:
#   - One-time package install
#   - Monitor info collection (xrandr + sysfs EDID + optional root-only tools)
#   - Custom xrandr script template
#   - Autorandr profile save

MONITOR_INFO_OUTDIR=""
CUSTOM_XRANDR_SCRIPT_PATH="</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span><span class="sh">/my_custom_display_config.sh"
TOOLKIT_HOME="</span><span class="k">${</span><span class="nv">HOME</span><span class="k">}</span><span class="sh">/rk3588-display-toolkit"
CONFIG_DIR="</span><span class="k">${</span><span class="nv">TOOLKIT_HOME</span><span class="k">}</span><span class="sh">/state/debian_display_master"
PREP_DONE_FLAG="</span><span class="k">${</span><span class="nv">CONFIG_DIR</span><span class="k">}</span><span class="sh">/system_prep_done.flag"

log() { printf '[%(%F %T)T] %s</span><span class="se">\n</span><span class="sh">' -1 "</span><span class="nv">$*</span><span class="sh">"; }

ensure_config_dir() {
  mkdir -p "</span><span class="nv">$CONFIG_DIR</span><span class="sh">"
  if [[ </span><span class="nv">$EUID</span><span class="sh"> -eq 0 &amp;&amp; -n "</span><span class="k">${</span><span class="nv">SUDO_USER</span><span class="k">:-}</span><span class="sh">" &amp;&amp; "</span><span class="k">${</span><span class="nv">SUDO_USER</span><span class="k">}</span><span class="sh">" != "root" ]]; then
    chown -R "</span><span class="nv">$SUDO_USER</span><span class="sh">:</span><span class="si">$(</span><span class="nb">id</span> <span class="nt">-gn</span> <span class="s2">"</span><span class="nv">$SUDO_USER</span><span class="s2">"</span><span class="si">)</span><span class="sh">" "</span><span class="nv">$CONFIG_DIR</span><span class="sh">" 2&gt;/dev/null || true
  fi
}

require_root_or_return() {
  if [[ </span><span class="nv">$EUID</span><span class="sh"> -ne 0 ]]; then
    echo "ERROR: This step must be run with sudo/root." &gt;&amp;2
    echo "Re-run with: sudo bash </span><span class="nv">$0</span><span class="sh">" &gt;&amp;2
    return 1
  fi
  return 0
}

system_prep() {
  echo
  echo "--- Stage 1: One-Time System Preparation (sudo required) ---"
  require_root_or_return || return 1

  echo "&gt;&gt;&gt; Updating apt lists..."
  apt-get update

  echo "&gt;&gt;&gt; Installing autorandr + tools..."
  apt-get install -y --no-install-recommends </span><span class="se">\</span><span class="sh">
    autorandr xrandr x11-xserver-utils python3 python3-tk </span><span class="se">\</span><span class="sh">
    read-edid ddcutil hwinfo inxi lshw edid-decode bc

  if systemctl list-unit-files | grep -q '^autorandr</span><span class="se">\.</span><span class="sh">service'; then
    systemctl enable --now autorandr.service || true
  fi
  if systemctl list-unit-files | grep -q '^autorandr-resume</span><span class="se">\.</span><span class="sh">service'; then
    systemctl enable --now autorandr-resume.service || true
  fi

  ensure_config_dir
  date &gt; "</span><span class="nv">$PREP_DONE_FLAG</span><span class="sh">"
  echo "&gt;&gt;&gt; System preparation complete."
}

_mi_setup_outdir() {
  local real_user home_base
  if [[ </span><span class="nv">$EUID</span><span class="sh"> -eq 0 &amp;&amp; -n "</span><span class="k">${</span><span class="nv">SUDO_USER</span><span class="k">:-}</span><span class="sh">" &amp;&amp; "</span><span class="nv">$SUDO_USER</span><span class="sh">" != "root" ]]; then
    real_user="</span><span class="nv">$SUDO_USER</span><span class="sh">"
  else
    real_user="</span><span class="si">$(</span><span class="nb">whoami</span><span class="si">)</span><span class="sh">"
  fi
  home_base="</span><span class="si">$(</span>getent passwd <span class="s2">"</span><span class="nv">$real_user</span><span class="s2">"</span> | <span class="nb">cut</span> <span class="nt">-d</span>: <span class="nt">-f6</span><span class="si">)</span><span class="sh">"
  [[ -n "</span><span class="nv">$home_base</span><span class="sh">" &amp;&amp; -d "</span><span class="nv">$home_base</span><span class="sh">" ]] || home_base="/tmp"

  MONITOR_INFO_OUTDIR="</span><span class="k">${</span><span class="nv">home_base</span><span class="k">}</span><span class="sh">/monitor-info-</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d-%H%M%S<span class="si">)</span><span class="sh">"
  mkdir -p "</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">"
  : &gt;"</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt"

  if [[ </span><span class="nv">$EUID</span><span class="sh"> -eq 0 &amp;&amp; -n "</span><span class="k">${</span><span class="nv">SUDO_USER</span><span class="k">:-}</span><span class="sh">" ]]; then
    chown -R "</span><span class="nv">$SUDO_USER</span><span class="sh">:</span><span class="si">$(</span><span class="nb">id</span> <span class="nt">-gn</span> <span class="s2">"</span><span class="nv">$SUDO_USER</span><span class="s2">"</span><span class="si">)</span><span class="sh">" "</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">" 2&gt;/dev/null || true
  fi
}

_mi_log_cmd() {
  local logfile="</span><span class="nv">$1</span><span class="sh">"; shift
  {
    echo "===== </span><span class="si">$(</span><span class="nb">date</span> <span class="s1">'+%F %T'</span><span class="si">)</span><span class="sh"> : </span><span class="nv">$*</span><span class="sh"> ====="
    "</span><span class="nv">$@</span><span class="sh">" 2&gt;&amp;1 || echo "(ERROR: '</span><span class="nv">$*</span><span class="sh">' failed code </span><span class="nv">$?</span><span class="sh">)"
    echo
  } &gt;&gt;"</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/</span><span class="nv">$logfile</span><span class="sh">"
}

_mi_detect_connectors_sysfs() {
  local regex='^[a-zA-Z]+(-[a-zA-Z0-9]+)*-[0-9]+</span><span class="nv">$'</span><span class="sh">
  echo "--- DRM connectors (sysfs) ---" &gt;&gt;"</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt"
  for card in /sys/class/drm/card*; do
    [[ -d "</span><span class="nv">$card</span><span class="sh">" ]] || continue
    for p in "</span><span class="nv">$card</span><span class="sh">"/*; do
      [[ -d "</span><span class="nv">$p</span><span class="sh">" ]] || continue
      local name
      name="</span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$p</span><span class="s2">"</span><span class="si">)</span><span class="sh">"
      if [[ "</span><span class="nv">$name</span><span class="sh">" =~ </span><span class="nv">$regex</span><span class="sh"> ]]; then
        echo "DRM connector: </span><span class="nv">$name</span><span class="sh">" &gt;&gt;"</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt"
      fi
    done
  done
}

_mi_collect_sysfs_edid() {
  command -v edid-decode &gt;/dev/null 2&gt;&amp;1 || return 0
  echo "--- EDID decode (sysfs) ---" &gt;&gt;"</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt"
  while IFS= read -r edid; do
    [[ -s "</span><span class="nv">$edid</span><span class="sh">" ]] || continue
    _mi_log_cmd "edid_sysfs.log" edid-decode "</span><span class="nv">$edid</span><span class="sh">"
  done &lt; &lt;(find /sys/class/drm -name edid 2&gt;/dev/null || true)
}

_mi_generate_cvt_interactive() {
  if ! command -v cvt &gt;/dev/null 2&gt;&amp;1; then
    echo "Note: 'cvt' not found; skipping modeline generator." &gt;&gt;"</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt"
    return 0
  fi
  echo
  read -r -p "Generate a modeline via cvt? Enter 'width height refresh' (or Enter to skip): " W H R
  if [[ -n "</span><span class="k">${</span><span class="nv">W</span><span class="k">:-}</span><span class="sh">" &amp;&amp; -n "</span><span class="k">${</span><span class="nv">H</span><span class="k">:-}</span><span class="sh">" &amp;&amp; -n "</span><span class="k">${</span><span class="nv">R</span><span class="k">:-}</span><span class="sh">" ]]; then
    cvt "</span><span class="nv">$W</span><span class="sh">" "</span><span class="nv">$H</span><span class="sh">" "</span><span class="nv">$R</span><span class="sh">" | tee -a "</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/cvt_modeline.log" &gt;/dev/null
    echo "Wrote: </span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/cvt_modeline.log"
  fi
}

monitor_info() {
  echo
  echo "--- Stage 2: Collect Monitor Information ---"
  _mi_setup_outdir
  echo "Collecting monitor information into: </span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">"

  _mi_detect_connectors_sysfs

  if command -v xrandr &gt;/dev/null 2&gt;&amp;1; then
    _mi_log_cmd "xrandr_verbose.log" xrandr --verbose
    xrandr | tee -a "</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt" &gt;/dev/null || true
  else
    echo "xrandr not found. Run Stage 1 first." | tee -a "</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt" &gt;/dev/null
  fi

  _mi_collect_sysfs_edid

  if [[ </span><span class="nv">$EUID</span><span class="sh"> -eq 0 ]]; then
    command -v ddcutil &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd "ddcutil_detect.log" ddcutil detect --verbose || true
    command -v get-edid &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd "get_edid.log" get-edid || true
    command -v hwinfo &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd "hwinfo_monitor.log" hwinfo --monitor || true
    command -v lshw &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd "lshw_display.log" lshw -C display || true
  else
    echo "Note: root-only tools (ddcutil, get-edid, hwinfo, lshw) are skipped unless run with sudo." | tee -a "</span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt" &gt;/dev/null
  fi

  _mi_generate_cvt_interactive

  echo "Done. Summary: </span><span class="nv">$MONITOR_INFO_OUTDIR</span><span class="sh">/summary.txt"
}

create_or_edit_custom_xrandr() {
  echo
  echo "--- Stage 3: Create/Edit Custom Xrandr Configuration Script ---"

  if [[ ! -f "</span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">" ]]; then
    cat &gt;"</span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">" &lt;&lt;'SH'
#!/usr/bin/env bash
set -euo pipefail

# Custom Xrandr Configuration Script
# Edit this file to match your connector names and desired modes.

command -v xrandr &gt;/dev/null 2&gt;&amp;1 || { echo "Error: xrandr not found" &gt;&amp;2; exit 1; }

echo "Applying custom xrandr settings..."

# Example:
# OUTPUT_1_NAME="HDMI-1"
# MODE_1_NAME="1920x1080"
# xrandr --output "</span><span class="nv">$OUTPUT_1_NAME</span><span class="sh">" --mode "</span><span class="nv">$MODE_1_NAME</span><span class="sh">" --primary

# Safe fallback:
xrandr --auto
SH
    chmod +x "</span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">"
    echo "Created template: </span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">"
  else
    echo "Custom script exists: </span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">"
  fi

  read -r -p "Open with nano now? (y/N): " ans
  if [[ "</span><span class="nv">$ans</span><span class="sh">" =~ ^[Yy]</span><span class="nv">$ </span><span class="sh">]]; then
    nano "</span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">"
  fi
}

test_custom_xrandr() {
  echo
  echo "--- Stage 4: Test Custom Xrandr Script (must be in X session) ---"
  if [[ -z "</span><span class="k">${</span><span class="nv">DISPLAY</span><span class="k">:-}</span><span class="sh">" ]]; then
    echo "ERROR: DISPLAY is not set. Run from an active X session." &gt;&amp;2
    return 1
  fi
  if [[ </span><span class="nv">$EUID</span><span class="sh"> -eq 0 ]]; then
    echo "WARNING: Running xrandr as root is not recommended. Prefer running as your user." &gt;&amp;2
  fi
  if ! bash "</span><span class="nv">$CUSTOM_XRANDR_SCRIPT_PATH</span><span class="sh">"; then
    echo "Error: custom xrandr script failed." &gt;&amp;2
    echo "Recovery hint: switch to a TTY (Ctrl+Alt+F2), then try: DISPLAY=:0 xrandr --auto (if possible), or reboot." &gt;&amp;2
    return 1
  fi
  echo "Custom xrandr script executed."
}

save_autorandr_profile() {
  echo
  echo "--- Stage 5: Save Autorandr Profile (run in X session) ---"
  command -v autorandr &gt;/dev/null 2&gt;&amp;1 || { echo "Error: autorandr not found. Run Stage 1." &gt;&amp;2; return 1; }
  read -r -p "Enter profile name: " pname
  pname="</span><span class="si">$(</span><span class="nb">echo</span> <span class="s2">"</span><span class="nv">$pname</span><span class="s2">"</span> | <span class="nb">tr</span> <span class="nt">-s</span> <span class="s1">' /\:&amp;?'</span> <span class="s1">'_'</span><span class="si">)</span><span class="sh">"
  [[ -n "</span><span class="nv">$pname</span><span class="sh">" ]] || { echo "No profile name provided." &gt;&amp;2; return 1; }
  autorandr --save "</span><span class="nv">$pname</span><span class="sh">"
  echo "Saved autorandr profile: </span><span class="nv">$pname</span><span class="sh">"
}

main_menu() {
  ensure_config_dir
  echo
  echo "Debian Bullseye Display Setup &amp; Management Utility"
  echo "=================================================="
  echo "NOTE: Some actions require sudo, others require an active X session."

  PS3="Choose an option: "
  local options=(
    "1) One-time system preparation (sudo required)"
    "2) Collect monitor information"
    "3) Create/edit custom xrandr script"
    "4) Test custom xrandr script (X session)"
    "5) Save autorandr profile (X session)"
    "6) Exit"
  )

  select opt in "</span><span class="k">${</span><span class="nv">options</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
    case "</span><span class="nv">$REPLY</span><span class="sh">" in
      1) system_prep ;;
      2) monitor_info ;;
      3) create_or_edit_custom_xrandr ;;
      4) test_custom_xrandr ;;
      5) save_autorandr_profile ;;
      6) echo "Exiting."; exit 0 ;;
      *) echo "Invalid option." ;;
    esac
    echo
    read -r -p "Press Enter to return to the menu..." _
  done
}

main_menu
</span><span class="no">EOF
</span><span class="o">}</span>

generate_interactive_script<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Generating: </span><span class="nv">$INTERACTIVE_SCRIPT</span><span class="s2">"</span>

  safe_write_file <span class="s2">"</span><span class="nv">$INTERACTIVE_SCRIPT</span><span class="s2">"</span> 755 <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
#!/usr/bin/env bash
set -Eeuo pipefail
IFS=</span><span class="nv">$'</span><span class="se">\n\t</span><span class="sh">'

# monitor_setup_interactive.sh
#
# Safer interactive mode picker with visual verification:
#   - SafeMode-first: tries a short list of common resolutions first
#   - Output ordering: HDMI/DP/DVI/eDP/VGA then the rest
#   - Tk overlay: draws a red border on the active monitor
#
# WARNING: This script changes display modes.
# Recovery: switch to a TTY (Ctrl+Alt+F2) and run: DISPLAY=:0 xrandr --auto (if possible) or reboot.

LOGF="</span><span class="k">${</span><span class="nv">LOGF</span><span class="k">:-</span><span class="p">/tmp/monitor-setup.log</span><span class="k">}</span><span class="sh">"
exec &gt; &gt;(tee -a "</span><span class="nv">$LOGF</span><span class="sh">") 2&gt;&amp;1

log() { printf '[%(%F %T)T] %s</span><span class="se">\n</span><span class="sh">' -1 "</span><span class="nv">$*</span><span class="sh">"; }
fail() { log "ERROR: </span><span class="nv">$*</span><span class="sh">"; exit 1; }
need() { command -v "</span><span class="nv">$1</span><span class="sh">" &gt;/dev/null 2&gt;&amp;1 || fail "</span><span class="nv">$1</span><span class="sh"> not found"; }

need xrandr
need python3
need timeout

python3 - &lt;&lt;'PY' 2&gt;/dev/null || fail "python3-tk not available. Install python3-tk."
import tkinter
PY

[[ -n "</span><span class="k">${</span><span class="nv">DISPLAY</span><span class="k">:-}</span><span class="sh">" ]] || fail "DISPLAY is not set. Run from an active X session."

SAFEMODES=(
  1920x1080 1680x1050 1600x900 1440x900 1366x768 1280x1024 1280x960
  1280x800 1280x720 1024x768 800x600 640x480
)

get_outputs() { xrandr --query | awk '/ connected/{print </span><span class="nv">$1</span><span class="sh">}'; }

sort_outputs() {
  local -a outs
  mapfile -t outs &lt; &lt;(get_outputs)
  local prefs=(HDMI DP DVI eDP VGA)
  for p in "</span><span class="k">${</span><span class="nv">prefs</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
    for o in "</span><span class="k">${</span><span class="nv">outs</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do [[ "</span><span class="nv">$o</span><span class="sh">" == </span><span class="k">${</span><span class="nv">p</span><span class="k">}</span><span class="sh">* ]] &amp;&amp; echo "</span><span class="nv">$o</span><span class="sh">"; done
  done
  for o in "</span><span class="k">${</span><span class="nv">outs</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
    local hit=0
    for p in "</span><span class="k">${</span><span class="nv">prefs</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do [[ "</span><span class="nv">$o</span><span class="sh">" == </span><span class="k">${</span><span class="nv">p</span><span class="k">}</span><span class="sh">* ]] &amp;&amp; hit=1; done
    ((hit==0)) &amp;&amp; echo "</span><span class="nv">$o</span><span class="sh">"
  done
}

get_modes_for_output() {
  local out="</span><span class="nv">$1</span><span class="sh">"
  xrandr --query | awk -v o="</span><span class="nv">$out</span><span class="sh">" '
    </span><span class="nv">$1</span><span class="sh">==o {inblock=1; next}
    /^[A-Z]/ {inblock=0}
    inblock &amp;&amp; </span><span class="nv">$1</span><span class="sh"> ~ /^[0-9]+x[0-9]+/ {print </span><span class="nv">$1</span><span class="sh">}
  ' | awk '!seen[</span><span class="nv">$0</span><span class="sh">]++'
}

current_mode_for_output() {
  local out="</span><span class="nv">$1</span><span class="sh">"
  xrandr --query | awk -v o="</span><span class="nv">$out</span><span class="sh">" '
    </span><span class="nv">$1</span><span class="sh">==o {inblock=1; next}
    /^[A-Z]/ {inblock=0}
    inblock &amp;&amp; </span><span class="nv">$1</span><span class="sh"> ~ /^[0-9]+x[0-9]+/ {
      if (</span><span class="nv">$0</span><span class="sh"> ~ /</span><span class="se">\*</span><span class="sh">/) {print </span><span class="nv">$1</span><span class="sh">; exit}
    }
  '
}

pick_safelist() {
  local -a avail=()
  mapfile -t avail
  local -a picked=()
  for safe in "</span><span class="k">${</span><span class="nv">SAFEMODES</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
    for m in "</span><span class="k">${</span><span class="nv">avail</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
      [[ "</span><span class="nv">$m</span><span class="sh">" == "</span><span class="nv">$safe</span><span class="sh">" ]] &amp;&amp; { picked+=("</span><span class="nv">$m</span><span class="sh">"); break; }
    done
    (( </span><span class="k">${#</span><span class="nv">picked</span><span class="p">[@]</span><span class="k">}</span><span class="sh"> &gt;= 4 )) &amp;&amp; break
  done
  if (( </span><span class="k">${#</span><span class="nv">picked</span><span class="p">[@]</span><span class="k">}</span><span class="sh"> &gt; 0 )); then
    printf '%s</span><span class="se">\n</span><span class="sh">' "</span><span class="k">${</span><span class="nv">picked</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"
  else
    printf '%s</span><span class="se">\n</span><span class="sh">' "</span><span class="k">${</span><span class="nv">avail</span><span class="p">[@]</span><span class="k">}</span><span class="sh">" | head -n 4
  fi
}

current_geometry() {
  local out="</span><span class="nv">$1</span><span class="sh">"
  xrandr --query | awk -v o="</span><span class="nv">$out</span><span class="sh">" '
    </span><span class="nv">$1</span><span class="sh">==o { if (match(</span><span class="nv">$0</span><span class="sh">, /[0-9]+x[0-9]+</span><span class="se">\+</span><span class="sh">[0-9]+</span><span class="se">\+</span><span class="sh">[0-9]+/)) { print substr(</span><span class="nv">$0</span><span class="sh">, RSTART, RLENGTH) } }
  '
}

show_rectangle() {
  local W="</span><span class="nv">$1</span><span class="sh">" H="</span><span class="nv">$2</span><span class="sh">" X="</span><span class="nv">$3</span><span class="sh">" Y="</span><span class="nv">$4</span><span class="sh">"
  log "   overlay </span><span class="k">${</span><span class="nv">W</span><span class="k">}</span><span class="sh">x</span><span class="k">${</span><span class="nv">H</span><span class="k">}</span><span class="sh">+</span><span class="k">${</span><span class="nv">X</span><span class="k">}</span><span class="sh">+</span><span class="k">${</span><span class="nv">Y</span><span class="k">}</span><span class="sh"> for 5s"
  timeout 7s python3 - "</span><span class="nv">$W</span><span class="sh">" "</span><span class="nv">$H</span><span class="sh">" "</span><span class="nv">$X</span><span class="sh">" "</span><span class="nv">$Y</span><span class="sh">" &lt;&lt;'PY'
import sys, tkinter as t
W,H,X,Y = map(int, sys.argv[1:])
root = t.Tk()
root.overrideredirect(True)
root.geometry(f"{W}x{H}+{X}+{Y}")
frame = t.Frame(root, width=W, height=H, highlightbackground='red', highlightthickness=8)
frame.pack()
root.attributes('-topmost', True)
root.after(5000, root.quit)
root.mainloop()
try:
    root.destroy()
except Exception:
    pass
PY
}

ask_ynq() {
  local prompt="</span><span class="nv">$1</span><span class="sh">" ch
  while true; do
    printf '%s' "</span><span class="nv">$prompt</span><span class="sh">" &gt; /dev/tty
    IFS= read -r -n1 ch &lt; /dev/tty || ch=""
    printf '</span><span class="se">\n</span><span class="sh">' &gt; /dev/tty
    case "</span><span class="nv">$ch</span><span class="sh">" in
      y|Y) return 0;;
      n|N) return 1;;
      q|Q) return 2;;
      *) prompt="Please type y (accept), n (next), or q (quit): ";;
    esac
  done
}

restore_mode_best_effort() {
  local out="</span><span class="nv">$1</span><span class="sh">" prev="</span><span class="nv">$2</span><span class="sh">"
  if [[ -n "</span><span class="nv">$prev</span><span class="sh">" ]]; then
    xrandr --output "</span><span class="nv">$out</span><span class="sh">" --mode "</span><span class="nv">$prev</span><span class="sh">" &gt;/dev/null 2&gt;&amp;1 || true
  else
    xrandr --output "</span><span class="nv">$out</span><span class="sh">" --auto &gt;/dev/null 2&gt;&amp;1 || true
  fi
}

try_modes_for_output() {
  local out="</span><span class="nv">$1</span><span class="sh">"; shift
  local -a modes=("</span><span class="nv">$@</span><span class="sh">")
  local prev
  prev="</span><span class="si">$(</span>current_mode_for_output <span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true</span><span class="si">)</span><span class="sh">"

  for mode in "</span><span class="k">${</span><span class="nv">modes</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
    log "Trying </span><span class="nv">$out</span><span class="sh"> -&gt; </span><span class="nv">$mode</span><span class="sh">"
    if ! xrandr --output "</span><span class="nv">$out</span><span class="sh">" --mode "</span><span class="nv">$mode</span><span class="sh">"; then
      log "Failed to set </span><span class="nv">$mode</span><span class="sh"> on </span><span class="nv">$out</span><span class="sh">"
      continue
    fi

    sleep 0.4
    local geom
    geom="</span><span class="si">$(</span>current_geometry <span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span> <span class="o">||</span> <span class="nb">true</span><span class="si">)</span><span class="sh">"
    if [[ "</span><span class="nv">$geom</span><span class="sh">" =~ ([0-9]+)x([0-9]+)</span><span class="se">\+</span><span class="sh">([0-9]+)</span><span class="se">\+</span><span class="sh">([0-9]+) ]]; then
      show_rectangle "</span><span class="k">${</span><span class="nv">BASH_REMATCH</span><span class="p">[1]</span><span class="k">}</span><span class="sh">" "</span><span class="k">${</span><span class="nv">BASH_REMATCH</span><span class="p">[2]</span><span class="k">}</span><span class="sh">" "</span><span class="k">${</span><span class="nv">BASH_REMATCH</span><span class="p">[3]</span><span class="k">}</span><span class="sh">" "</span><span class="k">${</span><span class="nv">BASH_REMATCH</span><span class="p">[4]</span><span class="k">}</span><span class="sh">"
      if ask_ynq "Keep </span><span class="nv">$mode</span><span class="sh"> for </span><span class="nv">$out</span><span class="sh">? [y/n/q] "; then
        log "Accepted </span><span class="nv">$mode</span><span class="sh"> for </span><span class="nv">$out</span><span class="sh">"
        return 0
      else
        local rc=</span><span class="nv">$?</span><span class="sh">
        if ((rc==2)); then
          restore_mode_best_effort "</span><span class="nv">$out</span><span class="sh">" "</span><span class="nv">$prev</span><span class="sh">"
          return 2
        fi
      fi
    else
      log "Could not parse geometry for </span><span class="nv">$out</span><span class="sh"> after applying </span><span class="nv">$mode</span><span class="sh"> (continuing)."
    fi
  done

  restore_mode_best_effort "</span><span class="nv">$out</span><span class="sh">" "</span><span class="nv">$prev</span><span class="sh">"
  return 1
}

log "Starting interactive monitor configuration..."
mapfile -t outputs &lt; &lt;(sort_outputs)

(( </span><span class="k">${#</span><span class="nv">outputs</span><span class="p">[@]</span><span class="k">}</span><span class="sh"> &gt; 0 )) || fail "No connected outputs detected by xrandr."

for out in "</span><span class="k">${</span><span class="nv">outputs</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; do
  log "Configuring </span><span class="nv">$out</span><span class="sh">..."
  mapfile -t avail &lt; &lt;(get_modes_for_output "</span><span class="nv">$out</span><span class="sh">")
  (( </span><span class="k">${#</span><span class="nv">avail</span><span class="p">[@]</span><span class="k">}</span><span class="sh"> &gt; 0 )) || { log "No modes found for </span><span class="nv">$out</span><span class="sh"> (skipping)."; continue; }

  mapfile -t testlist &lt; &lt;(printf '%s</span><span class="se">\n</span><span class="sh">' "</span><span class="k">${</span><span class="nv">avail</span><span class="p">[@]</span><span class="k">}</span><span class="sh">" | pick_safelist)
  if try_modes_for_output "</span><span class="nv">$out</span><span class="sh">" "</span><span class="k">${</span><span class="nv">testlist</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; then
    continue
  else
    rc=</span><span class="nv">$?</span><span class="sh">
    ((rc==2)) &amp;&amp; { log "Quit requested."; exit 0; }
  fi

  if ask_ynq "No SafeMode accepted for </span><span class="nv">$out</span><span class="sh">. Try ALL modes (riskier)? [y/n/q] "; then
    if try_modes_for_output "</span><span class="nv">$out</span><span class="sh">" "</span><span class="k">${</span><span class="nv">avail</span><span class="p">[@]</span><span class="k">}</span><span class="sh">"; then
      continue
    fi
  else
    rc=</span><span class="nv">$?</span><span class="sh">
    ((rc==2)) &amp;&amp; { log "Quit requested."; exit 0; }
  fi

done

log "Done. For persistence, save an autorandr profile using debian_display_setup.sh."
</span><span class="no">EOF
</span><span class="o">}</span>

generate_dual_fix_script<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Generating: </span><span class="nv">$DUAL_FIX_SCRIPT</span><span class="s2">"</span>

  safe_write_file <span class="s2">"</span><span class="nv">$DUAL_FIX_SCRIPT</span><span class="s2">"</span> 755 <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
#!/usr/bin/env bash
set -euo pipefail
IFS=</span><span class="nv">$'</span><span class="se">\n\t</span><span class="sh">'

# rk3588_dual_display_setup.sh
#
# Hard-coded dual-monitor fix (HDMI + DP) with autorandr persistence.
#
# OUT1 (default HDMI-1): 800x600@60 primary
# OUT2 (default DP-1)  : 640x480@60 right-of OUT1
# Includes VGA fallback timing for OUT2.
#
# WARNING: This script changes display modes.

OUT1="</span><span class="k">${</span><span class="nv">OUT1</span><span class="k">:-</span><span class="nv">HDMI</span><span class="p">-1</span><span class="k">}</span><span class="sh">"
OUT2="</span><span class="k">${</span><span class="nv">OUT2</span><span class="k">:-</span><span class="nv">DP</span><span class="p">-1</span><span class="k">}</span><span class="sh">"

MODE1_NAME="800x600_60.00"
MODE1_LINE="38.25  800 832 912 1024  600 603 607 624 -hsync +vsync"

MODE2_CVT_NAME="640x480_60.00"
MODE2_CVT_LINE="23.75  640 664 720 800  480 483 487 500 -hsync +vsync"

MODE2_VGA_NAME="640x480_60_std"
MODE2_VGA_LINE="25.175 640 656 752 800 480 490 492 525 -hsync -vsync"

AR_PROFILE="rk3588_dual"

log() { printf '[INFO ] %s</span><span class="se">\n</span><span class="sh">' "</span><span class="nv">$*</span><span class="sh">"; }
err() { printf '[ERROR] %s</span><span class="se">\n</span><span class="sh">' "</span><span class="nv">$*</span><span class="sh">" &gt;&amp;2; }

need_x() {
  [[ -n "</span><span class="k">${</span><span class="nv">DISPLAY</span><span class="k">:-}</span><span class="sh">" ]] || { err "DISPLAY not set. Run from an active X session."; exit 1; }
}

need_cmd() {
  command -v "</span><span class="nv">$1</span><span class="sh">" &gt;/dev/null 2&gt;&amp;1 || { err "Missing command: </span><span class="nv">$1</span><span class="sh">"; exit 1; }
}

confirm_yes() {
  local msg="</span><span class="nv">$1</span><span class="sh">" ans
  echo
  echo "WARNING: </span><span class="nv">$msg</span><span class="sh">"
  read -r -p "Type 'yes' to continue, anything else to cancel: " ans
  [[ "</span><span class="nv">$ans</span><span class="sh">" == "yes" ]] || { err "Cancelled by user."; exit 1; }
}

apply_layout() {
  local right_mode="</span><span class="nv">$1</span><span class="sh">"
  xrandr </span><span class="se">\</span><span class="sh">
    --output "</span><span class="nv">$OUT1</span><span class="sh">" --mode "</span><span class="nv">$MODE1_NAME</span><span class="sh">" --primary </span><span class="se">\</span><span class="sh">
    --output "</span><span class="nv">$OUT2</span><span class="sh">" --mode "</span><span class="nv">$right_mode</span><span class="sh">" --right-of "</span><span class="nv">$OUT1</span><span class="sh">"
}

main() {
  need_x
  need_cmd xrandr
  need_cmd autorandr

  confirm_yes "This will change active display modes for </span><span class="nv">$OUT1</span><span class="sh"> and </span><span class="nv">$OUT2</span><span class="sh">. Ensure you can recover via TTY."

  log "Defining modelines (best-effort)..."
  xrandr --newmode "</span><span class="nv">$MODE1_NAME</span><span class="sh">" </span><span class="nv">$MODE1_LINE</span><span class="sh"> 2&gt;/dev/null || true
  xrandr --newmode "</span><span class="nv">$MODE2_CVT_NAME</span><span class="sh">" </span><span class="nv">$MODE2_CVT_LINE</span><span class="sh"> 2&gt;/dev/null || true
  xrandr --newmode "</span><span class="nv">$MODE2_VGA_NAME</span><span class="sh">" </span><span class="nv">$MODE2_VGA_LINE</span><span class="sh"> 2&gt;/dev/null || true

  xrandr --addmode "</span><span class="nv">$OUT1</span><span class="sh">" "</span><span class="nv">$MODE1_NAME</span><span class="sh">" 2&gt;/dev/null || true
  xrandr --addmode "</span><span class="nv">$OUT2</span><span class="sh">" "</span><span class="nv">$MODE2_CVT_NAME</span><span class="sh">" 2&gt;/dev/null || true
  xrandr --addmode "</span><span class="nv">$OUT2</span><span class="sh">" "</span><span class="nv">$MODE2_VGA_NAME</span><span class="sh">" 2&gt;/dev/null || true

  log "Applying layout (try CVT timing first)..."
  if ! apply_layout "</span><span class="nv">$MODE2_CVT_NAME</span><span class="sh">"; then
    log "CVT timing failed; trying VGA fallback..."
    apply_layout "</span><span class="nv">$MODE2_VGA_NAME</span><span class="sh">"
  fi

  log "Creating autorandr preswitch hook for persistence..."
  local ar_dir="</span><span class="nv">$HOME</span><span class="sh">/.config/autorandr/</span><span class="nv">$AR_PROFILE</span><span class="sh">"
  mkdir -p "</span><span class="nv">$ar_dir</span><span class="sh">"

  cat &gt;"</span><span class="nv">$ar_dir</span><span class="sh">/preswitch" &lt;&lt;SH
#!/bin/sh
xrandr --newmode "</span><span class="nv">$MODE1_NAME</span><span class="sh">" </span><span class="nv">$MODE1_LINE</span><span class="sh"> 2&gt;/dev/null || true
xrandr --newmode "</span><span class="nv">$MODE2_CVT_NAME</span><span class="sh">" </span><span class="nv">$MODE2_CVT_LINE</span><span class="sh"> 2&gt;/dev/null || true
xrandr --newmode "</span><span class="nv">$MODE2_VGA_NAME</span><span class="sh">" </span><span class="nv">$MODE2_VGA_LINE</span><span class="sh"> 2&gt;/dev/null || true
xrandr --addmode "</span><span class="nv">$OUT1</span><span class="sh">" "</span><span class="nv">$MODE1_NAME</span><span class="sh">" 2&gt;/dev/null || true
xrandr --addmode "</span><span class="nv">$OUT2</span><span class="sh">" "</span><span class="nv">$MODE2_CVT_NAME</span><span class="sh">" 2&gt;/dev/null || true
xrandr --addmode "</span><span class="nv">$OUT2</span><span class="sh">" "</span><span class="nv">$MODE2_VGA_NAME</span><span class="sh">" 2&gt;/dev/null || true
SH
  chmod +x "</span><span class="nv">$ar_dir</span><span class="sh">/preswitch"

  log "Saving autorandr profile '</span><span class="nv">$AR_PROFILE</span><span class="sh">' (forced)..."
  autorandr --save "</span><span class="nv">$AR_PROFILE</span><span class="sh">" --force

  log "Done. Profile saved: </span><span class="nv">$AR_PROFILE</span><span class="sh">"
}

main "</span><span class="nv">$@</span><span class="sh">"
</span><span class="no">EOF
</span><span class="o">}</span>

generate_bootstrap_script<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Generating: </span><span class="nv">$BOOTSTRAP_SCRIPT</span><span class="s2">"</span>

  safe_write_file <span class="s2">"</span><span class="nv">$BOOTSTRAP_SCRIPT</span><span class="s2">"</span> 755 <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
#!/usr/bin/env bash
set -euo pipefail
IFS=</span><span class="nv">$'</span><span class="se">\n\t</span><span class="sh">'

# rk3588_autorandr_bootstrap.sh
#
# Purpose:
#   - Ensure autorandr/xrandr tooling exists
#   - Help select a profile
#   - Install a preswitch hook template
#   - Optionally enable autorandr at login via:
#       * XDG autostart (desktop environments)
#       * systemd user unit
#   - Optionally enable system-wide autorandr services if present

AUTORANDR_PROFILE="</span><span class="k">${</span><span class="nv">AUTORANDR_PROFILE</span><span class="k">:-}</span><span class="sh">"
TOOLKIT_HOME="</span><span class="k">${</span><span class="nv">TOOLKIT_HOME</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/rk3588-display-toolkit</span><span class="k">}</span><span class="sh">"

log() { printf '[%(%F %T)T] %s</span><span class="se">\n</span><span class="sh">' -1 "</span><span class="nv">$*</span><span class="sh">"; }
err() { printf '[%(%F %T)T] ERROR: %s</span><span class="se">\n</span><span class="sh">' -1 "</span><span class="nv">$*</span><span class="sh">" &gt;&amp;2; }

have_cmd() { command -v "</span><span class="nv">$1</span><span class="sh">" &gt;/dev/null 2&gt;&amp;1; }

confirm_yes() {
  local msg="</span><span class="nv">$1</span><span class="sh">" ans
  echo
  echo "WARNING: </span><span class="nv">$msg</span><span class="sh">"
  read -r -p "Type 'yes' to continue, anything else to cancel: " ans
  [[ "</span><span class="nv">$ans</span><span class="sh">" == "yes" ]] || { err "Cancelled by user."; return 1; }
}

pkg_installed() { dpkg -s "</span><span class="nv">$1</span><span class="sh">" &gt;/dev/null 2&gt;&amp;1; }
package_available() { apt-cache policy "</span><span class="nv">$1</span><span class="sh">" 2&gt;/dev/null | awk '/Candidate:/ {print </span><span class="nv">$2</span><span class="sh">}' | grep -vq "(none)"; }

apt_install_if_missing() {
  local pkg="</span><span class="nv">$1</span><span class="sh">"
  if pkg_installed "</span><span class="nv">$pkg</span><span class="sh">"; then
    log "Package already installed: </span><span class="nv">$pkg</span><span class="sh">"
    return 0
  fi
  if ! package_available "</span><span class="nv">$pkg</span><span class="sh">"; then
    err "Package not available in APT sources (skipping): </span><span class="nv">$pkg</span><span class="sh">"
    return 0
  fi
  log "Installing package: </span><span class="nv">$pkg</span><span class="sh">"
  sudo apt-get install -y --no-install-recommends "</span><span class="nv">$pkg</span><span class="sh">"
}

ensure_deps() {
  log "Ensuring dependencies..."
  sudo apt-get update
  apt_install_if_missing autorandr
  apt_install_if_missing x11-xserver-utils
  apt_install_if_missing xrandr
}

choose_profile() {
  if [[ -n "</span><span class="nv">$AUTORANDR_PROFILE</span><span class="sh">" ]]; then
    return 0
  fi

  have_cmd autorandr || { err "autorandr not installed"; exit 1; }

  log "Available autorandr profiles:"
  local profiles
  profiles="</span><span class="si">$(</span>autorandr <span class="nt">--list</span> 2&gt;/dev/null <span class="o">||</span> <span class="nb">true</span><span class="si">)</span><span class="sh">"

  if [[ -z "</span><span class="nv">$profiles</span><span class="sh">" ]]; then
    err "No autorandr profiles found. Create one first (e.g., using debian_display_setup.sh Stage 5)."
    exit 1
  fi

  echo "</span><span class="nv">$profiles</span><span class="sh">" | sed 's/^/ - /'
  read -r -p "Enter the profile name to use: " AUTORANDR_PROFILE
  [[ -n "</span><span class="nv">$AUTORANDR_PROFILE</span><span class="sh">" ]] || { err "No profile provided"; exit 1; }
}

install_preswitch_hook() {
  log "Installing preswitch hook template for profile: </span><span class="nv">$AUTORANDR_PROFILE</span><span class="sh">"
  local ar_dir="</span><span class="nv">$HOME</span><span class="sh">/.config/autorandr/</span><span class="nv">$AUTORANDR_PROFILE</span><span class="sh">"
  mkdir -p "</span><span class="nv">$ar_dir</span><span class="sh">"

  local hook="</span><span class="nv">$ar_dir</span><span class="sh">/preswitch"

  cat &gt;"</span><span class="nv">$hook</span><span class="sh">" &lt;&lt;'SH'
#!/bin/sh

# autorandr preswitch hook (template)
# Runs before switching to the profile.
# Use this to (re-)add custom modelines if your hardware/firmware forgets them.

# Example:
# xrandr --newmode "1920x1080_60.00" ... || true
# xrandr --addmode HDMI-1 "1920x1080_60.00" || true

exit 0
SH
  chmod +x "</span><span class="nv">$hook</span><span class="sh">"
  log "Hook installed: </span><span class="nv">$hook</span><span class="sh">"
}

install_xdg_autostart() {
  local auto_dir="</span><span class="nv">$HOME</span><span class="sh">/.config/autostart"
  local desktop_file="</span><span class="nv">$auto_dir</span><span class="sh">/autorandr-change.desktop"

  mkdir -p "</span><span class="nv">$auto_dir</span><span class="sh">"

  if [[ -f "</span><span class="nv">$desktop_file</span><span class="sh">" ]]; then
    if ! confirm_yes "This will overwrite </span><span class="nv">$desktop_file</span><span class="sh"> (a backup will be created). Proceed?"; then
      log "Skipped XDG autostart."
      return 0
    fi
    cp -a "</span><span class="nv">$desktop_file</span><span class="sh">" "</span><span class="k">${</span><span class="nv">desktop_file</span><span class="k">}</span><span class="sh">.bak.</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="si">)</span><span class="sh">" || true
  fi

  cat &gt;"</span><span class="nv">$desktop_file</span><span class="sh">" &lt;&lt;'SH'
[Desktop Entry]
Type=Application
Name=Autorandr Apply
Comment=Apply autorandr profile at login
Exec=autorandr --change
X-GNOME-Autostart-enabled=true
SH

  log "Installed XDG autostart: </span><span class="nv">$desktop_file</span><span class="sh">"
}

install_systemd_user_unit() {
  local unit_dir="</span><span class="nv">$HOME</span><span class="sh">/.config/systemd/user"
  local unit_file="</span><span class="nv">$unit_dir</span><span class="sh">/autorandr-change.service"

  mkdir -p "</span><span class="nv">$unit_dir</span><span class="sh">"

  if [[ -f "</span><span class="nv">$unit_file</span><span class="sh">" ]]; then
    if ! confirm_yes "This will overwrite </span><span class="nv">$unit_file</span><span class="sh"> (a backup will be created). Proceed?"; then
      log "Skipped systemd user unit."
      return 0
    fi
    cp -a "</span><span class="nv">$unit_file</span><span class="sh">" "</span><span class="k">${</span><span class="nv">unit_file</span><span class="k">}</span><span class="sh">.bak.</span><span class="si">$(</span><span class="nb">date</span> +%Y%m%d_%H%M%S<span class="si">)</span><span class="sh">" || true
  fi

  cat &gt;"</span><span class="nv">$unit_file</span><span class="sh">" &lt;&lt;'UNIT'
[Unit]
Description=Apply autorandr profile
After=graphical-session.target

[Service]
Type=oneshot
ExecStart=/usr/bin/autorandr --change

[Install]
WantedBy=default.target
UNIT

  systemctl --user daemon-reload
  systemctl --user enable autorandr-change.service

  log "Installed and enabled systemd user unit: </span><span class="nv">$unit_file</span><span class="sh">"
}

enable_system_services_if_present() {
  if systemctl list-unit-files | grep -q '^autorandr</span><span class="se">\.</span><span class="sh">service'; then
    if confirm_yes "Enable system-wide autorandr.service now?"; then
      sudo systemctl enable --now autorandr.service || true
    fi
  fi
  if systemctl list-unit-files | grep -q '^autorandr-resume</span><span class="se">\.</span><span class="sh">service'; then
    if confirm_yes "Enable system-wide autorandr-resume.service now?"; then
      sudo systemctl enable --now autorandr-resume.service || true
    fi
  fi
}

try_apply_now() {
  if [[ -n "</span><span class="k">${</span><span class="nv">DISPLAY</span><span class="k">:-}</span><span class="sh">" ]]; then
    log "DISPLAY is set; attempting autorandr --change now..."
    if ! autorandr --change; then
      err "autorandr --change failed in-session (you can run it manually later)."
      return 0
    fi
    log "autorandr applied."
  else
    log "DISPLAY not set; skipping immediate autorandr apply."
  fi
}

main() {
  have_cmd sudo || { err "sudo required"; exit 1; }
  sudo -v || { err "sudo auth failed"; exit 1; }

  ensure_deps
  choose_profile
  install_preswitch_hook

  if confirm_yes "Enable system-wide autorandr services (if present)?"; then
    enable_system_services_if_present
  fi

  if confirm_yes "Install XDG autostart entry to run 'autorandr --change' at login?"; then
    install_xdg_autostart
  fi

  if confirm_yes "Install a systemd user unit to run 'autorandr --change' at login?"; then
    install_systemd_user_unit
  fi

  try_apply_now

  log "Done. Profile selected: </span><span class="nv">$AUTORANDR_PROFILE</span><span class="sh">"
  log "Profile config path: ~/.config/autorandr/</span><span class="nv">$AUTORANDR_PROFILE</span><span class="sh">"
}

main "</span><span class="nv">$@</span><span class="sh">"
</span><span class="no">EOF
</span><span class="o">}</span>

generate_pwsh_script<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"Generating (optional): </span><span class="nv">$PWSH_SCRIPT</span><span class="s2">"</span>

  safe_write_file <span class="s2">"</span><span class="nv">$PWSH_SCRIPT</span><span class="s2">"</span> 755 <span class="o">&lt;&lt;</span><span class="sh">'</span><span class="no">EOF</span><span class="sh">'
#!/usr/bin/env pwsh
&lt;###
Pwsh Monitor Setup — Integrated, Optimized Build
TARGET: Linux + X11 (xrandr), PowerShell Core (pwsh)

Highlights:
- Dependency detection + optional auto-install (supports apt/dnf/zypper/pacman).
- X session readiness checks.
- Tkinter overlay verification.
- Interactive mode selection per output, with ordering prompt.
- Saves layout to JSON for reuse.

NOTE: This script is generated by the RK3588 toolkit installer.
###&gt;

[CmdletBinding()]
param(
  [switch] </span><span class="nv">$DebugMode</span><span class="sh">,
  [switch] </span><span class="nv">$AutoInstall</span><span class="sh">,
  [switch] </span><span class="nv">$NoInstall</span><span class="sh">,
  [int] </span><span class="nv">$OverlaySeconds</span><span class="sh"> = 5,
  [string] </span><span class="nv">$ConfigPath</span><span class="sh">
)

Set-StrictMode -Version Latest
</span><span class="nv">$ErrorActionPreference</span><span class="sh"> = 'Stop'
if (</span><span class="nv">$DebugMode</span><span class="sh">) { </span><span class="nv">$VerbosePreference</span><span class="sh"> = 'Continue' }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }
</span><span class="nv">$tsFile</span><span class="sh"> = "/tmp/pwsh_monitor_setup-</span><span class="si">$(</span>Get-Date <span class="nt">-Format</span> <span class="s1">'yyyyMMdd-HHmmss'</span><span class="si">)</span><span class="sh">.log"
try { Start-Transcript -Path </span><span class="nv">$tsFile</span><span class="sh"> -Force | Out-Null } catch {}

function Test-Cmd([string]</span><span class="nv">$Name</span><span class="sh">) { </span><span class="nv">$null</span><span class="sh"> -ne (Get-Command -Name </span><span class="nv">$Name</span><span class="sh"> -ErrorAction SilentlyContinue) }
function Test-IsRoot { try { ((&amp; id '-u' 2&gt;</span><span class="nv">$null</span><span class="sh">) -eq 0) } catch { </span><span class="nv">$false</span><span class="sh"> } }

function Detect-PackageManager {
  if (Test-Cmd 'apt-get') { return 'apt' }
  if (Test-Cmd 'dnf') { return 'dnf' }
  if (Test-Cmd 'zypper') { return 'zypper' }
  if (Test-Cmd 'pacman') { return 'pacman' }
  return </span><span class="nv">$null</span><span class="sh">
}

function Install-Dep([string]</span><span class="nv">$pkg</span><span class="sh">) {
  </span><span class="nv">$pm</span><span class="sh"> = Detect-PackageManager
  if (-not </span><span class="nv">$pm</span><span class="sh">) { throw 'No supported package manager found.' }
  if (-not (Test-IsRoot)) { throw 'Auto-install requires root.' }
  switch (</span><span class="nv">$pm</span><span class="sh">) {
    'apt' { &amp; apt-get update; &amp; apt-get install -y </span><span class="nv">$pkg</span><span class="sh"> }
    'dnf' { &amp; dnf install -y </span><span class="nv">$pkg</span><span class="sh"> }
    'zypper' { &amp; zypper -n install </span><span class="nv">$pkg</span><span class="sh"> }
    'pacman' { &amp; pacman -Sy --noconfirm </span><span class="nv">$pkg</span><span class="sh"> }
  }
}

function Ensure-DepMapped([string]</span><span class="nv">$cmd</span><span class="sh">, [hashtable]</span><span class="nv">$pkgMap</span><span class="sh">, [string]</span><span class="nv">$friendly</span><span class="sh">) {
  if (Test-Cmd </span><span class="nv">$cmd</span><span class="sh">) { return }
  if (</span><span class="nv">$NoInstall</span><span class="sh">) { throw "Missing dependency '</span><span class="nv">$friendly</span><span class="sh">' and -NoInstall specified." }
  if (-not </span><span class="nv">$AutoInstall</span><span class="sh">) { throw "Missing dependency '</span><span class="nv">$friendly</span><span class="sh">'. Rerun with -AutoInstall." }
  </span><span class="nv">$pm</span><span class="sh"> = Detect-PackageManager
  if (-not </span><span class="nv">$pkgMap</span><span class="sh">.ContainsKey(</span><span class="nv">$pm</span><span class="sh">)) { throw "Unsupported PM for '</span><span class="nv">$friendly</span><span class="sh">'." }
  Install-Dep </span><span class="nv">$pkgMap</span><span class="sh">[</span><span class="nv">$pm</span><span class="sh">]
  if (-not (Test-Cmd </span><span class="nv">$cmd</span><span class="sh">)) { throw "Dependency '</span><span class="nv">$friendly</span><span class="sh">' missing after install." }
}

function Test-PythonTk {
@'
import sys
try:
  import tkinter as t
  root=t.Tk(); root.withdraw()
  print('OK')
except Exception:
  sys.exit(1)
'@ | Set-Content -Path (</span><span class="nv">$tmp</span><span class="sh"> = [IO.Path]::GetTempFileName() + '.py') -Encoding UTF8
  try {
    </span><span class="nv">$p</span><span class="sh"> = Start-Process -FilePath 'python3' -ArgumentList @(</span><span class="nv">$tmp</span><span class="sh">) -PassThru -NoNewWindow -Wait
    return (</span><span class="nv">$p</span><span class="sh">.ExitCode -eq 0)
  } finally {
    try { Remove-Item </span><span class="nv">$tmp</span><span class="sh"> -Force -ErrorAction SilentlyContinue } catch {}
  }
}

function Assert-XSessionOrExit {
  if (-not </span><span class="nv">$env</span><span class="sh">:DISPLAY) { </span><span class="nv">$env</span><span class="sh">:DISPLAY = ':0' }
  for (</span><span class="nv">$i</span><span class="sh">=0; </span><span class="nv">$i</span><span class="sh"> -lt 6; </span><span class="nv">$i</span><span class="sh">++) {
    try { &amp; xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
  }
  Write-Error 'No X11 display/xrandr available.'
  Stop-TranscriptSafe
  exit 20
}

try {
  Ensure-DepMapped 'xrandr'  @{ apt='xrandr'; dnf='xrandr'; zypper='xrandr'; pacman='xorg-xrandr' } 'xrandr'
  Ensure-DepMapped 'python3' @{ apt='python3'; dnf='python3'; zypper='python3'; pacman='python' }  'python3'
} catch {
  Write-Error </span><span class="nv">$_</span><span class="sh">.Exception.Message
  Stop-TranscriptSafe
  exit 2
}

Assert-XSessionOrExit
if (-not (Test-PythonTk)) {
  Write-Error "python3-tk check failed. Install tkinter (python3-tk)."
  Stop-TranscriptSafe
  exit 2
}

function Get-XrandrLines { (&amp; xrandr --query | Out-String) -split "`n" }
function Get-ConnectedOutputs { Get-XrandrLines | ForEach-Object { if (</span><span class="nv">$_</span><span class="sh"> -match '^</span><span class="se">\s</span><span class="sh">*(</span><span class="se">\S</span><span class="sh">+)</span><span class="se">\s</span><span class="sh">+connected') { </span><span class="nv">$Matches</span><span class="sh">[1] } } }
function Invoke-Xrandr([string[]]</span><span class="nv">$XRArgs</span><span class="sh">) {
  </span><span class="nv">$p</span><span class="sh"> = Start-Process -FilePath 'xrandr' -ArgumentList </span><span class="nv">$XRArgs</span><span class="sh"> -PassThru -NoNewWindow -Wait
  if (</span><span class="nv">$DebugMode</span><span class="sh">) { Write-Verbose ("xrandr " + (</span><span class="nv">$XRArgs</span><span class="sh"> -join ' ') + " =&gt; " + </span><span class="nv">$p</span><span class="sh">.ExitCode) }
  </span><span class="nv">$p</span><span class="sh">.ExitCode
}

function Get-OutputModeCandidates([string]</span><span class="nv">$Output</span><span class="sh">) {
  </span><span class="nv">$lines</span><span class="sh"> = Get-XrandrLines
  </span><span class="nv">$in</span><span class="sh"> = </span><span class="nv">$false</span><span class="sh">
  </span><span class="nv">$cands</span><span class="sh"> = New-Object 'System.Collections.Generic.List[object]'
  foreach (</span><span class="nv">$ln</span><span class="sh"> in </span><span class="nv">$lines</span><span class="sh">) {
    if (-not </span><span class="nv">$in</span><span class="sh">) {
      if (</span><span class="nv">$ln</span><span class="sh"> -match "^</span><span class="se">\s</span><span class="sh">*</span><span class="si">$(</span><span class="o">[</span>Regex]::Escape<span class="o">(</span><span class="nv">$Output</span><span class="o">)</span><span class="si">)</span><span class="se">\s</span><span class="sh">+connected") { </span><span class="nv">$in</span><span class="sh"> = </span><span class="nv">$true</span><span class="sh"> }
    } else {
      if (</span><span class="nv">$ln</span><span class="sh"> -match '^</span><span class="se">\S</span><span class="sh">+</span><span class="se">\s</span><span class="sh">+(connected|disconnected)') { break }
      if (</span><span class="nv">$ln</span><span class="sh"> -match '^</span><span class="se">\s</span><span class="sh">+((</span><span class="se">\d</span><span class="sh">{3,5}x</span><span class="se">\d</span><span class="sh">{3,5})(i)?</span><span class="se">\S</span><span class="sh">*)</span><span class="se">\s</span><span class="sh">+(.+)</span><span class="nv">$'</span><span class="sh">) {
        </span><span class="nv">$tok</span><span class="sh">=</span><span class="nv">$Matches</span><span class="sh">[1]; </span><span class="nv">$res</span><span class="sh">=</span><span class="nv">$Matches</span><span class="sh">[2]; </span><span class="nv">$rest</span><span class="sh">=</span><span class="nv">$Matches</span><span class="sh">[4]
        </span><span class="nv">$w</span><span class="sh">=[int](</span><span class="nv">$res</span><span class="sh"> -split 'x')[0]; </span><span class="nv">$h</span><span class="sh">=[int](</span><span class="nv">$res</span><span class="sh"> -split 'x')[1]
        </span><span class="nv">$mAll</span><span class="sh"> = [regex]::Matches(</span><span class="nv">$rest</span><span class="sh">, '(</span><span class="se">\d</span><span class="sh">+(?:</span><span class="se">\.\d</span><span class="sh">+)?)([*+]{0,2})')
        foreach (</span><span class="nv">$m</span><span class="sh"> in </span><span class="nv">$mAll</span><span class="sh">) {
          </span><span class="nv">$hz</span><span class="sh">=</span><span class="nv">$m</span><span class="sh">.Groups[1].Value
          if ([string]::IsNullOrWhiteSpace(</span><span class="nv">$hz</span><span class="sh">)) { continue }
          </span><span class="nv">$cands</span><span class="sh">.Add([pscustomobject]@{Output=</span><span class="nv">$Output</span><span class="sh">; ModeToken=</span><span class="nv">$tok</span><span class="sh">; W=</span><span class="nv">$w</span><span class="sh">; H=</span><span class="nv">$h</span><span class="sh">; Rate=[double]</span><span class="nv">$hz</span><span class="sh">; Label="</span><span class="nv">$tok</span><span class="sh">@</span><span class="nv">$hz</span><span class="sh">"; Prefer=</span><span class="nv">$m</span><span class="sh">.Groups[2].Value -match '</span><span class="se">\+</span><span class="sh">'; Current=</span><span class="nv">$m</span><span class="sh">.Groups[2].Value -match '</span><span class="se">\*</span><span class="sh">'})
        }
      }
    }
  }
  return </span><span class="nv">$cands</span><span class="sh"> | Sort-Object @{e={</span><span class="nv">$_</span><span class="sh">.W*</span><span class="nv">$_</span><span class="sh">.H};d=</span><span class="nv">$true</span><span class="sh">}, @{e={</span><span class="nv">$_</span><span class="sh">.Rate};d=</span><span class="nv">$true</span><span class="sh">}
}

function Show-OverlayTk([int]</span><span class="nv">$W</span><span class="sh">,[int]</span><span class="nv">$H</span><span class="sh">,[int]</span><span class="nv">$X</span><span class="sh">,[int]</span><span class="nv">$Y</span><span class="sh">,[int]</span><span class="nv">$Seconds</span><span class="sh">) {
</span><span class="nv">$py</span><span class="sh"> = @'
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk(); root.overrideredirect(1); root.attributes("-topmost", True)
root.geometry(f"{w}x{h}+{x}+{y}")
t.Frame(root, width=w, height=h, highlightbackground="red", highlightthickness=8).pack()
root.after(sec*1000, root.destroy); root.mainloop()
'@
  </span><span class="nv">$tmp</span><span class="sh"> = [IO.Path]::GetTempFileName() + '.py'
  [IO.File]::WriteAllText(</span><span class="nv">$tmp</span><span class="sh">, </span><span class="nv">$py</span><span class="sh">)
  </span><span class="nv">$p</span><span class="sh"> = Start-Process -FilePath 'python3' -ArgumentList @(</span><span class="nv">$tmp</span><span class="sh">, </span><span class="nv">$W</span><span class="sh">, </span><span class="nv">$H</span><span class="sh">, </span><span class="nv">$X</span><span class="sh">, </span><span class="nv">$Y</span><span class="sh">, </span><span class="nv">$Seconds</span><span class="sh">) -PassThru -NoNewWindow
  try { Wait-Process -Id </span><span class="nv">$p</span><span class="sh">.Id -Timeout ([Math]::Max(</span><span class="nv">$Seconds</span><span class="sh">+3, 8)) } catch { try { Stop-Process -Id </span><span class="nv">$p</span><span class="sh">.Id -Force } catch {} }
  try { Remove-Item </span><span class="nv">$tmp</span><span class="sh"> -Force -ErrorAction SilentlyContinue } catch {}
}

</span><span class="nv">$outs</span><span class="sh"> = Get-ConnectedOutputs
if (-not </span><span class="nv">$outs</span><span class="sh">) {
  Write-Error 'No connected monitors detected.'
  Stop-TranscriptSafe
  exit 21
}

</span><span class="nv">$ordered</span><span class="sh"> = New-Object 'System.Collections.Generic.List[string]'
if (</span><span class="nv">$outs</span><span class="sh">.Count -gt 1) {
  Write-Host "Monitors: </span><span class="si">$(</span><span class="nv">$outs</span> <span class="nt">-join</span> <span class="s1">', '</span><span class="si">)</span><span class="sh">" -ForegroundColor Cyan
  </span><span class="nv">$rem</span><span class="sh"> = [System.Collections.Generic.List[string]]::new(); </span><span class="nv">$rem</span><span class="sh">.AddRange([string[]]</span><span class="nv">$outs</span><span class="sh">)
  while (</span><span class="nv">$rem</span><span class="sh">.Count -gt 0) {
    </span><span class="nv">$q</span><span class="sh"> = if (</span><span class="nv">$ordered</span><span class="sh">.Count -eq 0) { 'Leftmost monitor?' } else { "Right of </span><span class="si">$(</span><span class="nv">$ordered</span><span class="o">[</span><span class="nt">-1</span><span class="o">]</span><span class="si">)</span><span class="sh">?" }
    for (</span><span class="nv">$i</span><span class="sh">=0; </span><span class="nv">$i</span><span class="sh"> -lt </span><span class="nv">$rem</span><span class="sh">.Count; </span><span class="nv">$i</span><span class="sh">++) { Write-Host " [</span><span class="si">$(</span><span class="nv">$i</span>+1<span class="si">)</span><span class="sh">] </span><span class="si">$(</span><span class="nv">$rem</span><span class="o">[</span><span class="nv">$i</span><span class="o">]</span><span class="si">)</span><span class="sh">" }
    </span><span class="nv">$ans</span><span class="sh"> = Read-Host "</span><span class="nv">$q</span><span class="sh"> (1-</span><span class="si">$(</span><span class="nv">$rem</span>.Count<span class="si">)</span><span class="sh">)"
    if (</span><span class="nv">$ans</span><span class="sh"> -match '^</span><span class="se">\d</span><span class="sh">+</span><span class="nv">$'</span><span class="sh"> -and [int]</span><span class="nv">$ans</span><span class="sh"> -ge 1 -and [int]</span><span class="nv">$ans</span><span class="sh"> -le </span><span class="nv">$rem</span><span class="sh">.Count) {
      </span><span class="nv">$idx</span><span class="sh">=[int]</span><span class="nv">$ans</span><span class="sh">-1; </span><span class="nv">$ordered</span><span class="sh">.Add(</span><span class="nv">$rem</span><span class="sh">[</span><span class="nv">$idx</span><span class="sh">]); </span><span class="nv">$rem</span><span class="sh">.RemoveAt(</span><span class="nv">$idx</span><span class="sh">)
    }
  }
} else { </span><span class="nv">$ordered</span><span class="sh">.Add(</span><span class="nv">$outs</span><span class="sh">[0]) }

</span><span class="nv">$all</span><span class="sh"> = @{}; foreach (</span><span class="nv">$o</span><span class="sh"> in </span><span class="nv">$ordered</span><span class="sh">) { </span><span class="nv">$all</span><span class="sh">[</span><span class="nv">$o</span><span class="sh">] = Get-OutputModeCandidates </span><span class="nv">$o</span><span class="sh"> }
</span><span class="nv">$chosen</span><span class="sh"> = [ordered]@{}; foreach (</span><span class="nv">$o</span><span class="sh"> in </span><span class="nv">$ordered</span><span class="sh">) { </span><span class="nv">$chosen</span><span class="sh">[</span><span class="nv">$o</span><span class="sh">] = </span><span class="nv">$null</span><span class="sh"> }

foreach (</span><span class="nv">$current</span><span class="sh"> in </span><span class="nv">$ordered</span><span class="sh">) {
  Write-Host "Select mode for </span><span class="nv">$current</span><span class="sh">" -ForegroundColor Cyan
  </span><span class="nv">$cands</span><span class="sh"> = @(</span><span class="nv">$all</span><span class="sh">[</span><span class="nv">$current</span><span class="sh">])
  if (-not </span><span class="nv">$cands</span><span class="sh"> -or </span><span class="nv">$cands</span><span class="sh">.Count -lt 1) { continue }

  </span><span class="nv">$idx</span><span class="sh">=1
  foreach (</span><span class="nv">$c</span><span class="sh"> in </span><span class="nv">$cands</span><span class="sh">) { Write-Host (" [{0}] {1} ({2}x{3})" -f </span><span class="nv">$idx</span><span class="sh">++, </span><span class="nv">$c</span><span class="sh">.Label, </span><span class="nv">$c</span><span class="sh">.W, </span><span class="nv">$c</span><span class="sh">.H) }
  </span><span class="nv">$ans</span><span class="sh"> = Read-Host "Choice (1-</span><span class="si">$(</span><span class="nv">$cands</span>.Count<span class="si">)</span><span class="sh">), or Enter to keep current"
  if (</span><span class="nv">$ans</span><span class="sh"> -match '^</span><span class="se">\d</span><span class="sh">+</span><span class="nv">$'</span><span class="sh"> -and [int]</span><span class="nv">$ans</span><span class="sh"> -ge 1 -and [int]</span><span class="nv">$ans</span><span class="sh"> -le </span><span class="nv">$cands</span><span class="sh">.Count) {
    </span><span class="nv">$c</span><span class="sh"> = </span><span class="nv">$cands</span><span class="sh">[[int]</span><span class="nv">$ans</span><span class="sh">-1]
    </span><span class="nv">$x</span><span class="sh">=0
    foreach (</span><span class="nv">$o</span><span class="sh"> in </span><span class="nv">$ordered</span><span class="sh">) {
      </span><span class="nv">$tgt</span><span class="sh"> = if (</span><span class="nv">$o</span><span class="sh"> -eq </span><span class="nv">$current</span><span class="sh">) { </span><span class="nv">$c</span><span class="sh"> } else { </span><span class="nv">$chosen</span><span class="sh">[</span><span class="nv">$o</span><span class="sh">] ?? </span><span class="nv">$all</span><span class="sh">[</span><span class="nv">$o</span><span class="sh">][0] }
      if (</span><span class="nv">$tgt</span><span class="sh">) {
        </span><span class="nv">$args</span><span class="sh"> = @('--output', </span><span class="nv">$o</span><span class="sh">, '--mode', </span><span class="nv">$tgt</span><span class="sh">.ModeToken, '--pos', "</span><span class="k">${</span><span class="nv">x</span><span class="k">}</span><span class="sh">x0")
        if (</span><span class="nv">$tgt</span><span class="sh">.Rate) { </span><span class="nv">$args</span><span class="sh"> += @('--rate', ("{0:0.##}" -f </span><span class="nv">$tgt</span><span class="sh">.Rate)) }
        Invoke-Xrandr </span><span class="nv">$args</span><span class="sh"> | Out-Null
        </span><span class="nv">$x</span><span class="sh"> += </span><span class="nv">$tgt</span><span class="sh">.W
      }
    }
    Show-OverlayTk </span><span class="nv">$c</span><span class="sh">.W </span><span class="nv">$c</span><span class="sh">.H 0 0 </span><span class="nv">$OverlaySeconds</span><span class="sh">
    if ((Read-Host 'Keep? (y/n)') -eq 'y') { </span><span class="nv">$chosen</span><span class="sh">[</span><span class="nv">$current</span><span class="sh">] = </span><span class="nv">$c</span><span class="sh"> }
  }
}

</span><span class="nv">$persist</span><span class="sh"> = [ordered]@{}
foreach (</span><span class="nv">$o</span><span class="sh"> in </span><span class="nv">$ordered</span><span class="sh">) {
  </span><span class="nv">$c</span><span class="sh"> = </span><span class="nv">$chosen</span><span class="sh">[</span><span class="nv">$o</span><span class="sh">]
  if (</span><span class="nv">$null</span><span class="sh"> -eq </span><span class="nv">$c</span><span class="sh">) { continue }
  </span><span class="nv">$persist</span><span class="sh">[</span><span class="nv">$o</span><span class="sh">] = [ordered]@{ mode=</span><span class="nv">$c</span><span class="sh">.ModeToken; rate=</span><span class="si">$(</span><span class="k">if</span><span class="o">(</span><span class="nv">$c</span>.Rate<span class="o">){[</span>double]<span class="nv">$c</span>.Rate<span class="o">}</span><span class="k">else</span><span class="o">{</span><span class="nv">$null</span><span class="o">}</span><span class="si">)</span><span class="sh"> }
}

</span><span class="nv">$target</span><span class="sh"> = </span><span class="nv">$ConfigPath</span><span class="sh">
if ([string]::IsNullOrWhiteSpace(</span><span class="nv">$target</span><span class="sh">)) { </span><span class="nv">$target</span><span class="sh"> = "</span><span class="nv">$HOME</span><span class="sh">/.config/pwsh-monitor-layout.json" }
</span><span class="nv">$dir</span><span class="sh"> = Split-Path -Parent </span><span class="nv">$target</span><span class="sh">
if (-not (Test-Path </span><span class="nv">$dir</span><span class="sh">)) { New-Item -ItemType Directory -Force -Path </span><span class="nv">$dir</span><span class="sh"> | Out-Null }
(</span><span class="nv">$persist</span><span class="sh"> | ConvertTo-Json) | Set-Content -Path </span><span class="nv">$target</span><span class="sh">
Write-Host "Saved layout to: </span><span class="nv">$target</span><span class="sh">" -ForegroundColor Green

Stop-TranscriptSafe
exit 0
</span><span class="no">EOF
</span><span class="o">}</span>

generate_toolkit_scripts<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"=== Step 2/4: Generating toolkit scripts under: </span><span class="nv">$TOOLKIT_DIR</span><span class="s2"> ==="</span>

  <span class="nb">mkdir</span> <span class="nt">-p</span> <span class="s2">"</span><span class="nv">$BIN_DIR</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$LOG_DIR</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$STATE_DIR</span><span class="s2">"</span>

  generate_audit_script
  generate_menu_script
  generate_interactive_script
  generate_dual_fix_script
  generate_bootstrap_script
  generate_pwsh_script

  log <span class="s2">"Toolkit scripts generated successfully."</span>
<span class="o">}</span>

<span class="c"># -----------------------------</span>
<span class="c"># Step 3: Self-tests (syntax / presence)</span>
<span class="c"># -----------------------------</span>

run_self_tests<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"=== Step 3/4: Running basic self-tests (syntax checks) ==="</span>

  <span class="nb">local </span><span class="nv">failed</span><span class="o">=</span>0

  <span class="k">for </span>f <span class="k">in</span> <span class="s2">"</span><span class="nv">$AUDIT_SCRIPT</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$MENU_SCRIPT</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$INTERACTIVE_SCRIPT</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$DUAL_FIX_SCRIPT</span><span class="s2">"</span> <span class="s2">"</span><span class="nv">$BOOTSTRAP_SCRIPT</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    if</span> <span class="o">[[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$f</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
      if </span>bash <span class="nt">-n</span> <span class="s2">"</span><span class="nv">$f</span><span class="s2">"</span><span class="p">;</span> <span class="k">then
        </span>log <span class="s2">"OK: bash -n </span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$f</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>
      <span class="k">else
        </span>err <span class="s2">"FAIL: bash -n </span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$f</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>
        <span class="nv">failed</span><span class="o">=</span>1
      <span class="k">fi
    else
      </span>err <span class="s2">"Missing generated file: </span><span class="nv">$f</span><span class="s2">"</span>
      <span class="nv">failed</span><span class="o">=</span>1
    <span class="k">fi
  done

  if</span> <span class="o">[[</span> <span class="nt">-f</span> <span class="s2">"</span><span class="nv">$PWSH_SCRIPT</span><span class="s2">"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
    if </span><span class="nb">head</span> <span class="nt">-n</span> 1 <span class="s2">"</span><span class="nv">$PWSH_SCRIPT</span><span class="s2">"</span> | <span class="nb">grep</span> <span class="nt">-q</span> <span class="s1">'pwsh'</span><span class="p">;</span> <span class="k">then
      </span>log <span class="s2">"OK: pwsh script present (pwsh not validated here): </span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="nv">$PWSH_SCRIPT</span><span class="s2">"</span><span class="si">)</span><span class="s2">"</span>
    <span class="k">else
      </span>err <span class="s2">"WARN: pwsh script shebang unexpected: </span><span class="nv">$PWSH_SCRIPT</span><span class="s2">"</span>
    <span class="k">fi
  fi

  if</span> <span class="o">[[</span> <span class="s2">"</span><span class="nv">$failed</span><span class="s2">"</span> <span class="nt">-ne</span> 0 <span class="o">]]</span><span class="p">;</span> <span class="k">then
    </span>err <span class="s2">"One or more self-tests failed. Review logs above."</span>
    <span class="k">return </span>1
  <span class="k">fi

  </span>log <span class="s2">"Self-tests passed."</span>
<span class="o">}</span>

<span class="c"># -----------------------------</span>
<span class="c"># Step 4: Final guidance</span>
<span class="c"># -----------------------------</span>

print_next_steps<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"=== Step 4/4: Next steps ==="</span>
  <span class="nb">cat</span> <span class="o">&lt;&lt;</span><span class="no">EOF</span><span class="sh">

Toolkit location:
  </span><span class="nv">$TOOLKIT_DIR</span><span class="sh">

Generated scripts:

1) Capability audit (safe; optional prompts for tunings):
   </span><span class="nv">$AUDIT_SCRIPT</span><span class="sh">

2) Menu-driven display setup wrapper:
   </span><span class="nv">$MENU_SCRIPT</span><span class="sh">

3) Interactive mode picker (REQUIRES X SESSION; CHANGES DISPLAY MODES):
   </span><span class="nv">$INTERACTIVE_SCRIPT</span><span class="sh">

4) RK3588 dual-monitor fix (REQUIRES X SESSION; CHANGES DISPLAY MODES):
   </span><span class="nv">$DUAL_FIX_SCRIPT</span><span class="sh">

5) Autorandr bootstrap (optional autostart/systemd integration):
   </span><span class="nv">$BOOTSTRAP_SCRIPT</span><span class="sh">

6) Optional PowerShell (pwsh) interactive configurator (requires pwsh installed):
   </span><span class="nv">$PWSH_SCRIPT</span><span class="sh">

Recommended flow:

  # Optional: baseline audit
  "</span><span class="nv">$AUDIT_SCRIPT</span><span class="sh">"

  # Install display tools / collect info / create custom xrandr / save autorandr profile
  "</span><span class="nv">$MENU_SCRIPT</span><span class="sh">"

  # In X session: safe interactive mode picking
  "</span><span class="nv">$INTERACTIVE_SCRIPT</span><span class="sh">"

  # If you have the specific HDMI+DP low-mode issue
  "</span><span class="nv">$DUAL_FIX_SCRIPT</span><span class="sh">"

  # Wire autorandr persistence at login/resume
  "</span><span class="nv">$BOOTSTRAP_SCRIPT</span><span class="sh">"
</span><span class="no">
EOF
</span><span class="o">}</span>

<span class="c"># -----------------------------</span>
<span class="c"># Main</span>
<span class="c"># -----------------------------</span>

main<span class="o">()</span> <span class="o">{</span>
  log <span class="s2">"RK3588 Display Toolkit Installer — </span><span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span><span class="s2">"</span>
  require_home_context
  check_platform

  install_dependencies
  generate_toolkit_scripts
  run_self_tests
  print_next_steps

  log <span class="s2">"Setup complete."</span>
<span class="o">}</span>

main <span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span>
</code></section></div></div>
  <h1 id="recommended-flow">
    
    
     <a href="#recommended-flow">#</a><a href="#" aria-label="Back to top">Recommended flow:</a>
        
    
  </h1>
      
  <h2 id="optional-baseline-audit">
    
    
     <a href="#optional-baseline-audit">#</a><a href="#" aria-label="Back to top">Optional: baseline audit</a>
        
    
  </h2>
      
<p><code class="language-plaintext highlighter-rouge">/home/linaro/rk3588-display-toolkit/bin/rk3588_audit.sh</code></p>
  <h2 id="install-display-tools--collect-info--create-custom-xrandr--save-autorandr-profile">
    
    
     <a href="#install-display-tools--collect-info--create-custom-xrandr--save-autorandr-profile">#</a><a href="#" aria-label="Back to top">Install display tools / collect info / create custom xrandr / save autorandr profile</a>
        
    
  </h2>
      
<p><code class="language-plaintext highlighter-rouge">bash /home/linaro/rk3588-display-toolkit/bin/debian_display_setup.sh</code></p>
  <h2 id="in-x-session-safe-interactive-mode-picking">
    
    
     <a href="#in-x-session-safe-interactive-mode-picking">#</a><a href="#" aria-label="Back to top">In X session: safe interactive mode picking</a>
        
    
  </h2>
      
<p><code class="language-plaintext highlighter-rouge">bash /home/linaro/rk3588-display-toolkit/bin/monitor_setup_interactive.sh</code>
  <code class="language-plaintext highlighter-rouge">pwsh /home/linaro/rk3588-display-toolkit/bin/pwsh_monitor_setup.ps1</code></p>
  <h2 id="if-you-have-the-specific-hdmidp-low-mode-issue">
    
    
     <a href="#if-you-have-the-specific-hdmidp-low-mode-issue">#</a><a href="#" aria-label="Back to top">If you have the specific HDMI+DP low-mode issue</a>
        
    
  </h2>
      
<p><code class="language-plaintext highlighter-rouge">bash /home/linaro/rk3588-display-toolkit/bin/rk3588_dual_display_setup.sh</code></p>
  <h2 id="wire-autorandr-persistence-at-loginresume">
    
    
     <a href="#wire-autorandr-persistence-at-loginresume">#</a><a href="#" aria-label="Back to top">Wire autorandr persistence at login/resume</a>
        
    
  </h2>
      
<p><code class="language-plaintext highlighter-rouge">bash /home/linaro/rk3588-display-toolkit/bin/rk3588_autorandr_bootstrap.sh</code></p><hr />
  <h1 id="homelinarork3588-display-toolkitbindebian_display_setupsh">
    
    
     <a href="#homelinarork3588-display-toolkitbindebian_display_setupsh">#</a><a href="#" aria-label="Back to top">/home/linaro/rk3588-display-toolkit/bin/debian_display_setup.sh</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label=" Code Block" data-filename="_code_block.txt" data-code="#!/usr/bin/env bash
set -euo pipefail
IFS=$&#39;\n\t&#39;

# debian_display_setup.sh
# Menu-driven helper for:
#   - One-time package install
#   - Monitor info collection (xrandr + sysfs EDID + optional root-only tools)
#   - Custom xrandr script template
#   - Autorandr profile save

MONITOR_INFO_OUTDIR=&quot;&quot;
CUSTOM_XRANDR_SCRIPT_PATH=&quot;${HOME}/my_custom_display_config.sh&quot;
TOOLKIT_HOME=&quot;${HOME}/rk3588-display-toolkit&quot;
CONFIG_DIR=&quot;${TOOLKIT_HOME}/state/debian_display_master&quot;
PREP_DONE_FLAG=&quot;${CONFIG_DIR}/system_prep_done.flag&quot;

log() { printf &#39;[%(%F %T)T] %s\n&#39; -1 &quot;$*&quot;; }

ensure_config_dir() {
  mkdir -p &quot;$CONFIG_DIR&quot;
  if [[ $EUID -eq 0 &amp;&amp; -n &quot;${SUDO_USER:-}&quot; &amp;&amp; &quot;${SUDO_USER}&quot; != &quot;root&quot; ]]; then
    chown -R &quot;$SUDO_USER:$(id -gn &quot;$SUDO_USER&quot;)&quot; &quot;$CONFIG_DIR&quot; 2&gt;/dev/null || true
  fi
}

require_root_or_return() {
  if [[ $EUID -ne 0 ]]; then
    echo &quot;ERROR: This step must be run with sudo/root.&quot; &gt;&amp;2
    echo &quot;Re-run with: sudo bash $0&quot; &gt;&amp;2
    return 1
  fi
  return 0
}

system_prep() {
  echo
  echo &quot;--- Stage 1: One-Time System Preparation (sudo required) ---&quot;
  require_root_or_return || return 1

  echo &quot;&gt;&gt;&gt; Updating apt lists...&quot;
  apt-get update

  echo &quot;&gt;&gt;&gt; Installing autorandr + tools...&quot;
  apt-get install -y --no-install-recommends \
    autorandr xrandr x11-xserver-utils python3 python3-tk \
    read-edid ddcutil hwinfo inxi lshw edid-decode bc

  if systemctl list-unit-files | grep -q &#39;^autorandr\.service&#39;; then
    systemctl enable --now autorandr.service || true
  fi
  if systemctl list-unit-files | grep -q &#39;^autorandr-resume\.service&#39;; then
    systemctl enable --now autorandr-resume.service || true
  fi

  ensure_config_dir
  date &gt; &quot;$PREP_DONE_FLAG&quot;
  echo &quot;&gt;&gt;&gt; System preparation complete.&quot;
}

_mi_setup_outdir() {
  local real_user home_base
  if [[ $EUID -eq 0 &amp;&amp; -n &quot;${SUDO_USER:-}&quot; &amp;&amp; &quot;$SUDO_USER&quot; != &quot;root&quot; ]]; then
    real_user=&quot;$SUDO_USER&quot;
  else
    real_user=&quot;$(whoami)&quot;
  fi
  home_base=&quot;$(getent passwd &quot;$real_user&quot; | cut -d: -f6)&quot;
  [[ -n &quot;$home_base&quot; &amp;&amp; -d &quot;$home_base&quot; ]] || home_base=&quot;/tmp&quot;

  MONITOR_INFO_OUTDIR=&quot;${home_base}/monitor-info-$(date +%Y%m%d-%H%M%S)&quot;
  mkdir -p &quot;$MONITOR_INFO_OUTDIR&quot;
  : &gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;

  if [[ $EUID -eq 0 &amp;&amp; -n &quot;${SUDO_USER:-}&quot; ]]; then
    chown -R &quot;$SUDO_USER:$(id -gn &quot;$SUDO_USER&quot;)&quot; &quot;$MONITOR_INFO_OUTDIR&quot; 2&gt;/dev/null || true
  fi
}

_mi_log_cmd() {
  local logfile=&quot;$1&quot;; shift
  {
    echo &quot;===== $(date &#39;+%F %T&#39;) : $* =====&quot;
    &quot;$@&quot; 2&gt;&amp;1 || echo &quot;(ERROR: &#39;$*&#39; failed code $?)&quot;
    echo
  } &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/$logfile&quot;
}

_mi_detect_connectors_sysfs() {
  local regex=&#39;^[a-zA-Z]+(-[a-zA-Z0-9]+)*-[0-9]+$&#39;
  echo &quot;--- DRM connectors (sysfs) ---&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
  for card in /sys/class/drm/card*; do
    [[ -d &quot;$card&quot; ]] || continue
    for p in &quot;$card&quot;/*; do
      [[ -d &quot;$p&quot; ]] || continue
      local name
      name=&quot;$(basename &quot;$p&quot;)&quot;
      if [[ &quot;$name&quot; =~ $regex ]]; then
        echo &quot;DRM connector: $name&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
      fi
    done
  done
}

_mi_collect_sysfs_edid() {
  command -v edid-decode &gt;/dev/null 2&gt;&amp;1 || return 0
  echo &quot;--- EDID decode (sysfs) ---&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
  while IFS= read -r edid; do
    [[ -s &quot;$edid&quot; ]] || continue
    _mi_log_cmd &quot;edid_sysfs.log&quot; edid-decode &quot;$edid&quot;
  done &lt; &lt;(find /sys/class/drm -name edid 2&gt;/dev/null || true)
}

_mi_generate_cvt_interactive() {
  if ! command -v cvt &gt;/dev/null 2&gt;&amp;1; then
    echo &quot;Note: &#39;cvt&#39; not found; skipping modeline generator.&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
    return 0
  fi
  echo
  read -r -p &quot;Generate a modeline via cvt? Enter &#39;width height refresh&#39; (or Enter to skip): &quot; W H R
  if [[ -n &quot;${W:-}&quot; &amp;&amp; -n &quot;${H:-}&quot; &amp;&amp; -n &quot;${R:-}&quot; ]]; then
    cvt &quot;$W&quot; &quot;$H&quot; &quot;$R&quot; | tee -a &quot;$MONITOR_INFO_OUTDIR/cvt_modeline.log&quot; &gt;/dev/null
    echo &quot;Wrote: $MONITOR_INFO_OUTDIR/cvt_modeline.log&quot;
  fi
}

monitor_info() {
  echo
  echo &quot;--- Stage 2: Collect Monitor Information ---&quot;
  _mi_setup_outdir
  echo &quot;Collecting monitor information into: $MONITOR_INFO_OUTDIR&quot;

  _mi_detect_connectors_sysfs

  if command -v xrandr &gt;/dev/null 2&gt;&amp;1; then
    _mi_log_cmd &quot;xrandr_verbose.log&quot; xrandr --verbose
    xrandr | tee -a &quot;$MONITOR_INFO_OUTDIR/summary.txt&quot; &gt;/dev/null || true
  else
    echo &quot;xrandr not found. Run Stage 1 first.&quot; | tee -a &quot;$MONITOR_INFO_OUTDIR/summary.txt&quot; &gt;/dev/null
  fi

  _mi_collect_sysfs_edid

  if [[ $EUID -eq 0 ]]; then
    command -v ddcutil &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;ddcutil_detect.log&quot; ddcutil detect --verbose || true
    command -v get-edid &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;get_edid.log&quot; get-edid || true
    command -v hwinfo &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;hwinfo_monitor.log&quot; hwinfo --monitor || true
    command -v lshw &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;lshw_display.log&quot; lshw -C display || true
  else
    echo &quot;Note: root-only tools (ddcutil, get-edid, hwinfo, lshw) are skipped unless run with sudo.&quot; | tee -a &quot;$MONITOR_INFO_OUTDIR/summary.txt&quot; &gt;/dev/null
  fi

  _mi_generate_cvt_interactive

  echo &quot;Done. Summary: $MONITOR_INFO_OUTDIR/summary.txt&quot;
}

create_or_edit_custom_xrandr() {
  echo
  echo &quot;--- Stage 3: Create/Edit Custom Xrandr Configuration Script ---&quot;

  if [[ ! -f &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot; ]]; then
    cat &gt;&quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot; &lt;&lt;&#39;SH&#39;
#!/usr/bin/env bash
set -euo pipefail

# Custom Xrandr Configuration Script
# Edit this file to match your connector names and desired modes.

command -v xrandr &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: xrandr not found&quot; &gt;&amp;2; exit 1; }

echo &quot;Applying custom xrandr settings...&quot;

# Example:
# OUTPUT_1_NAME=&quot;HDMI-1&quot;
# MODE_1_NAME=&quot;1920x1080&quot;
# xrandr --output &quot;$OUTPUT_1_NAME&quot; --mode &quot;$MODE_1_NAME&quot; --primary

# Safe fallback:
xrandr --auto
SH
    chmod +x &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot;
    echo &quot;Created template: $CUSTOM_XRANDR_SCRIPT_PATH&quot;
  else
    echo &quot;Custom script exists: $CUSTOM_XRANDR_SCRIPT_PATH&quot;
  fi

  read -r -p &quot;Open with nano now? (y/N): &quot; ans
  if [[ &quot;$ans&quot; =~ ^[Yy]$ ]]; then
    nano &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot;
  fi
}

test_custom_xrandr() {
  echo
  echo &quot;--- Stage 4: Test Custom Xrandr Script (must be in X session) ---&quot;
  if [[ -z &quot;${DISPLAY:-}&quot; ]]; then
    echo &quot;ERROR: DISPLAY is not set. Run from an active X session.&quot; &gt;&amp;2
    return 1
  fi
  if [[ $EUID -eq 0 ]]; then
    echo &quot;WARNING: Running xrandr as root is not recommended. Prefer running as your user.&quot; &gt;&amp;2
  fi
  if ! bash &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot;; then
    echo &quot;Error: custom xrandr script failed.&quot; &gt;&amp;2
    echo &quot;Recovery hint: switch to a TTY (Ctrl+Alt+F2), then try: DISPLAY=:0 xrandr --auto (if possible), or reboot.&quot; &gt;&amp;2
    return 1
  fi
  echo &quot;Custom xrandr script executed.&quot;
}

save_autorandr_profile() {
  echo
  echo &quot;--- Stage 5: Save Autorandr Profile (run in X session) ---&quot;
  command -v autorandr &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: autorandr not found. Run Stage 1.&quot; &gt;&amp;2; return 1; }
  read -r -p &quot;Enter profile name: &quot; pname
  pname=&quot;$(echo &quot;$pname&quot; | tr -s &#39; /\:&amp;?&#39; &#39;_&#39;)&quot;
  [[ -n &quot;$pname&quot; ]] || { echo &quot;No profile name provided.&quot; &gt;&amp;2; return 1; }
  autorandr --save &quot;$pname&quot;
  echo &quot;Saved autorandr profile: $pname&quot;
}

main_menu() {
  ensure_config_dir
  echo
  echo &quot;Debian Bullseye Display Setup &amp; Management Utility&quot;
  echo &quot;==================================================&quot;
  echo &quot;NOTE: Some actions require sudo, others require an active X session.&quot;

  PS3=&quot;Choose an option: &quot;
  local options=(
    &quot;1) One-time system preparation (sudo required)&quot;
    &quot;2) Collect monitor information&quot;
    &quot;3) Create/edit custom xrandr script&quot;
    &quot;4) Test custom xrandr script (X session)&quot;
    &quot;5) Save autorandr profile (X session)&quot;
    &quot;6) Exit&quot;
  )

  select opt in &quot;${options[@]}&quot;; do
    case &quot;$REPLY&quot; in
      1) system_prep ;;
      2) monitor_info ;;
      3) create_or_edit_custom_xrandr ;;
      4) test_custom_xrandr ;;
      5) save_autorandr_profile ;;
      6) echo &quot;Exiting.&quot;; exit 0 ;;
      *) echo &quot;Invalid option.&quot; ;;
    esac
    echo
    read -r -p &quot;Press Enter to return to the menu...&quot; _
  done
}

main_menu" data-download-link="" data-download-label="Download ">
  <code class="language-">#!/usr/bin/env bash
set -euo pipefail
IFS=$&#39;\n\t&#39;

# debian_display_setup.sh
# Menu-driven helper for:
#   - One-time package install
#   - Monitor info collection (xrandr + sysfs EDID + optional root-only tools)
#   - Custom xrandr script template
#   - Autorandr profile save

MONITOR_INFO_OUTDIR=&quot;&quot;
CUSTOM_XRANDR_SCRIPT_PATH=&quot;${HOME}/my_custom_display_config.sh&quot;
TOOLKIT_HOME=&quot;${HOME}/rk3588-display-toolkit&quot;
CONFIG_DIR=&quot;${TOOLKIT_HOME}/state/debian_display_master&quot;
PREP_DONE_FLAG=&quot;${CONFIG_DIR}/system_prep_done.flag&quot;

log() { printf &#39;[%(%F %T)T] %s\n&#39; -1 &quot;$*&quot;; }

ensure_config_dir() {
  mkdir -p &quot;$CONFIG_DIR&quot;
  if [[ $EUID -eq 0 &amp;&amp; -n &quot;${SUDO_USER:-}&quot; &amp;&amp; &quot;${SUDO_USER}&quot; != &quot;root&quot; ]]; then
    chown -R &quot;$SUDO_USER:$(id -gn &quot;$SUDO_USER&quot;)&quot; &quot;$CONFIG_DIR&quot; 2&gt;/dev/null || true
  fi
}

require_root_or_return() {
  if [[ $EUID -ne 0 ]]; then
    echo &quot;ERROR: This step must be run with sudo/root.&quot; &gt;&amp;2
    echo &quot;Re-run with: sudo bash $0&quot; &gt;&amp;2
    return 1
  fi
  return 0
}

system_prep() {
  echo
  echo &quot;--- Stage 1: One-Time System Preparation (sudo required) ---&quot;
  require_root_or_return || return 1

  echo &quot;&gt;&gt;&gt; Updating apt lists...&quot;
  apt-get update

  echo &quot;&gt;&gt;&gt; Installing autorandr + tools...&quot;
  apt-get install -y --no-install-recommends \
    autorandr xrandr x11-xserver-utils python3 python3-tk \
    read-edid ddcutil hwinfo inxi lshw edid-decode bc

  if systemctl list-unit-files | grep -q &#39;^autorandr\.service&#39;; then
    systemctl enable --now autorandr.service || true
  fi
  if systemctl list-unit-files | grep -q &#39;^autorandr-resume\.service&#39;; then
    systemctl enable --now autorandr-resume.service || true
  fi

  ensure_config_dir
  date &gt; &quot;$PREP_DONE_FLAG&quot;
  echo &quot;&gt;&gt;&gt; System preparation complete.&quot;
}

_mi_setup_outdir() {
  local real_user home_base
  if [[ $EUID -eq 0 &amp;&amp; -n &quot;${SUDO_USER:-}&quot; &amp;&amp; &quot;$SUDO_USER&quot; != &quot;root&quot; ]]; then
    real_user=&quot;$SUDO_USER&quot;
  else
    real_user=&quot;$(whoami)&quot;
  fi
  home_base=&quot;$(getent passwd &quot;$real_user&quot; | cut -d: -f6)&quot;
  [[ -n &quot;$home_base&quot; &amp;&amp; -d &quot;$home_base&quot; ]] || home_base=&quot;/tmp&quot;

  MONITOR_INFO_OUTDIR=&quot;${home_base}/monitor-info-$(date +%Y%m%d-%H%M%S)&quot;
  mkdir -p &quot;$MONITOR_INFO_OUTDIR&quot;
  : &gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;

  if [[ $EUID -eq 0 &amp;&amp; -n &quot;${SUDO_USER:-}&quot; ]]; then
    chown -R &quot;$SUDO_USER:$(id -gn &quot;$SUDO_USER&quot;)&quot; &quot;$MONITOR_INFO_OUTDIR&quot; 2&gt;/dev/null || true
  fi
}

_mi_log_cmd() {
  local logfile=&quot;$1&quot;; shift
  {
    echo &quot;===== $(date &#39;+%F %T&#39;) : $* =====&quot;
    &quot;$@&quot; 2&gt;&amp;1 || echo &quot;(ERROR: &#39;$*&#39; failed code $?)&quot;
    echo
  } &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/$logfile&quot;
}

_mi_detect_connectors_sysfs() {
  local regex=&#39;^[a-zA-Z]+(-[a-zA-Z0-9]+)*-[0-9]+$&#39;
  echo &quot;--- DRM connectors (sysfs) ---&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
  for card in /sys/class/drm/card*; do
    [[ -d &quot;$card&quot; ]] || continue
    for p in &quot;$card&quot;/*; do
      [[ -d &quot;$p&quot; ]] || continue
      local name
      name=&quot;$(basename &quot;$p&quot;)&quot;
      if [[ &quot;$name&quot; =~ $regex ]]; then
        echo &quot;DRM connector: $name&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
      fi
    done
  done
}

_mi_collect_sysfs_edid() {
  command -v edid-decode &gt;/dev/null 2&gt;&amp;1 || return 0
  echo &quot;--- EDID decode (sysfs) ---&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
  while IFS= read -r edid; do
    [[ -s &quot;$edid&quot; ]] || continue
    _mi_log_cmd &quot;edid_sysfs.log&quot; edid-decode &quot;$edid&quot;
  done &lt; &lt;(find /sys/class/drm -name edid 2&gt;/dev/null || true)
}

_mi_generate_cvt_interactive() {
  if ! command -v cvt &gt;/dev/null 2&gt;&amp;1; then
    echo &quot;Note: &#39;cvt&#39; not found; skipping modeline generator.&quot; &gt;&gt;&quot;$MONITOR_INFO_OUTDIR/summary.txt&quot;
    return 0
  fi
  echo
  read -r -p &quot;Generate a modeline via cvt? Enter &#39;width height refresh&#39; (or Enter to skip): &quot; W H R
  if [[ -n &quot;${W:-}&quot; &amp;&amp; -n &quot;${H:-}&quot; &amp;&amp; -n &quot;${R:-}&quot; ]]; then
    cvt &quot;$W&quot; &quot;$H&quot; &quot;$R&quot; | tee -a &quot;$MONITOR_INFO_OUTDIR/cvt_modeline.log&quot; &gt;/dev/null
    echo &quot;Wrote: $MONITOR_INFO_OUTDIR/cvt_modeline.log&quot;
  fi
}

monitor_info() {
  echo
  echo &quot;--- Stage 2: Collect Monitor Information ---&quot;
  _mi_setup_outdir
  echo &quot;Collecting monitor information into: $MONITOR_INFO_OUTDIR&quot;

  _mi_detect_connectors_sysfs

  if command -v xrandr &gt;/dev/null 2&gt;&amp;1; then
    _mi_log_cmd &quot;xrandr_verbose.log&quot; xrandr --verbose
    xrandr | tee -a &quot;$MONITOR_INFO_OUTDIR/summary.txt&quot; &gt;/dev/null || true
  else
    echo &quot;xrandr not found. Run Stage 1 first.&quot; | tee -a &quot;$MONITOR_INFO_OUTDIR/summary.txt&quot; &gt;/dev/null
  fi

  _mi_collect_sysfs_edid

  if [[ $EUID -eq 0 ]]; then
    command -v ddcutil &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;ddcutil_detect.log&quot; ddcutil detect --verbose || true
    command -v get-edid &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;get_edid.log&quot; get-edid || true
    command -v hwinfo &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;hwinfo_monitor.log&quot; hwinfo --monitor || true
    command -v lshw &gt;/dev/null 2&gt;&amp;1 &amp;&amp; _mi_log_cmd &quot;lshw_display.log&quot; lshw -C display || true
  else
    echo &quot;Note: root-only tools (ddcutil, get-edid, hwinfo, lshw) are skipped unless run with sudo.&quot; | tee -a &quot;$MONITOR_INFO_OUTDIR/summary.txt&quot; &gt;/dev/null
  fi

  _mi_generate_cvt_interactive

  echo &quot;Done. Summary: $MONITOR_INFO_OUTDIR/summary.txt&quot;
}

create_or_edit_custom_xrandr() {
  echo
  echo &quot;--- Stage 3: Create/Edit Custom Xrandr Configuration Script ---&quot;

  if [[ ! -f &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot; ]]; then
    cat &gt;&quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot; &lt;&lt;&#39;SH&#39;
#!/usr/bin/env bash
set -euo pipefail

# Custom Xrandr Configuration Script
# Edit this file to match your connector names and desired modes.

command -v xrandr &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: xrandr not found&quot; &gt;&amp;2; exit 1; }

echo &quot;Applying custom xrandr settings...&quot;

# Example:
# OUTPUT_1_NAME=&quot;HDMI-1&quot;
# MODE_1_NAME=&quot;1920x1080&quot;
# xrandr --output &quot;$OUTPUT_1_NAME&quot; --mode &quot;$MODE_1_NAME&quot; --primary

# Safe fallback:
xrandr --auto
SH
    chmod +x &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot;
    echo &quot;Created template: $CUSTOM_XRANDR_SCRIPT_PATH&quot;
  else
    echo &quot;Custom script exists: $CUSTOM_XRANDR_SCRIPT_PATH&quot;
  fi

  read -r -p &quot;Open with nano now? (y/N): &quot; ans
  if [[ &quot;$ans&quot; =~ ^[Yy]$ ]]; then
    nano &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot;
  fi
}

test_custom_xrandr() {
  echo
  echo &quot;--- Stage 4: Test Custom Xrandr Script (must be in X session) ---&quot;
  if [[ -z &quot;${DISPLAY:-}&quot; ]]; then
    echo &quot;ERROR: DISPLAY is not set. Run from an active X session.&quot; &gt;&amp;2
    return 1
  fi
  if [[ $EUID -eq 0 ]]; then
    echo &quot;WARNING: Running xrandr as root is not recommended. Prefer running as your user.&quot; &gt;&amp;2
  fi
  if ! bash &quot;$CUSTOM_XRANDR_SCRIPT_PATH&quot;; then
    echo &quot;Error: custom xrandr script failed.&quot; &gt;&amp;2
    echo &quot;Recovery hint: switch to a TTY (Ctrl+Alt+F2), then try: DISPLAY=:0 xrandr --auto (if possible), or reboot.&quot; &gt;&amp;2
    return 1
  fi
  echo &quot;Custom xrandr script executed.&quot;
}

save_autorandr_profile() {
  echo
  echo &quot;--- Stage 5: Save Autorandr Profile (run in X session) ---&quot;
  command -v autorandr &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: autorandr not found. Run Stage 1.&quot; &gt;&amp;2; return 1; }
  read -r -p &quot;Enter profile name: &quot; pname
  pname=&quot;$(echo &quot;$pname&quot; | tr -s &#39; /\:&amp;?&#39; &#39;_&#39;)&quot;
  [[ -n &quot;$pname&quot; ]] || { echo &quot;No profile name provided.&quot; &gt;&amp;2; return 1; }
  autorandr --save &quot;$pname&quot;
  echo &quot;Saved autorandr profile: $pname&quot;
}

main_menu() {
  ensure_config_dir
  echo
  echo &quot;Debian Bullseye Display Setup &amp; Management Utility&quot;
  echo &quot;==================================================&quot;
  echo &quot;NOTE: Some actions require sudo, others require an active X session.&quot;

  PS3=&quot;Choose an option: &quot;
  local options=(
    &quot;1) One-time system preparation (sudo required)&quot;
    &quot;2) Collect monitor information&quot;
    &quot;3) Create/edit custom xrandr script&quot;
    &quot;4) Test custom xrandr script (X session)&quot;
    &quot;5) Save autorandr profile (X session)&quot;
    &quot;6) Exit&quot;
  )

  select opt in &quot;${options[@]}&quot;; do
    case &quot;$REPLY&quot; in
      1) system_prep ;;
      2) monitor_info ;;
      3) create_or_edit_custom_xrandr ;;
      4) test_custom_xrandr ;;
      5) save_autorandr_profile ;;
      6) echo &quot;Exiting.&quot;; exit 0 ;;
      *) echo &quot;Invalid option.&quot; ;;
    esac
    echo
    read -r -p &quot;Press Enter to return to the menu...&quot; _
  done
}

main_menu</code>
</section>
  <h1 id="homelinarork3588-display-toolkitbinmonitor_setup_interactivesh">
    
    
     <a href="#homelinarork3588-display-toolkitbinmonitor_setup_interactivesh">#</a><a href="#" aria-label="Back to top">/home/linaro/rk3588-display-toolkit/bin/monitor_setup_interactive.sh</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label=" Code Block" data-filename="_code_block.txt" data-code="#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$&#39;\n\t&#39;

# monitor_setup_interactive.sh
#
# Safer interactive mode picker with visual verification:
#   - SafeMode-first: tries a short list of common resolutions first
#   - Output ordering: HDMI/DP/DVI/eDP/VGA then the rest
#   - Tk overlay: draws a red border on the active monitor
#
# WARNING: This script changes display modes.
# Recovery: switch to a TTY (Ctrl+Alt+F2) and run: DISPLAY=:0 xrandr --auto (if possible) or reboot.

LOGF=&quot;${LOGF:-/tmp/monitor-setup.log}&quot;
exec &gt; &gt;(tee -a &quot;$LOGF&quot;) 2&gt;&amp;1

log() { printf &#39;[%(%F %T)T] %s\n&#39; -1 &quot;$*&quot;; }
fail() { log &quot;ERROR: $*&quot;; exit 1; }
need() { command -v &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1 || fail &quot;$1 not found&quot;; }

need xrandr
need python3
need timeout

python3 - &lt;&lt;&#39;PY&#39; 2&gt;/dev/null || fail &quot;python3-tk not available. Install python3-tk.&quot;
import tkinter
PY

[[ -n &quot;${DISPLAY:-}&quot; ]] || fail &quot;DISPLAY is not set. Run from an active X session.&quot;

SAFEMODES=(
  1920x1080 1680x1050 1600x900 1440x900 1366x768 1280x1024 1280x960
  1280x800 1280x720 1024x768 800x600 640x480
)

get_outputs() { xrandr --query | awk &#39;/ connected/{print $1}&#39;; }

sort_outputs() {
  local -a outs
  mapfile -t outs &lt; &lt;(get_outputs)
  local prefs=(HDMI DP DVI eDP VGA)
  for p in &quot;${prefs[@]}&quot;; do
    for o in &quot;${outs[@]}&quot;; do [[ &quot;$o&quot; == ${p}* ]] &amp;&amp; echo &quot;$o&quot;; done
  done
  for o in &quot;${outs[@]}&quot;; do
    local hit=0
    for p in &quot;${prefs[@]}&quot;; do [[ &quot;$o&quot; == ${p}* ]] &amp;&amp; hit=1; done
    ((hit==0)) &amp;&amp; echo &quot;$o&quot;
  done
}

get_modes_for_output() {
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o {inblock=1; next}
    /^[A-Z]/ {inblock=0}
    inblock &amp;&amp; $1 ~ /^[0-9]+x[0-9]+/ {print $1}
  &#39; | awk &#39;!seen[$0]++&#39;
}

current_mode_for_output() {
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o {inblock=1; next}
    /^[A-Z]/ {inblock=0}
    inblock &amp;&amp; $1 ~ /^[0-9]+x[0-9]+/ {
      if ($0 ~ /\*/) {print $1; exit}
    }
  &#39;
}

pick_safelist() {
  local -a avail=()
  mapfile -t avail
  local -a picked=()
  for safe in &quot;${SAFEMODES[@]}&quot;; do
    for m in &quot;${avail[@]}&quot;; do
      [[ &quot;$m&quot; == &quot;$safe&quot; ]] &amp;&amp; { picked+=(&quot;$m&quot;); break; }
    done
    (( ${#picked[@]} &gt;= 4 )) &amp;&amp; break
  done
  if (( ${#picked[@]} &gt; 0 )); then
    printf &#39;%s\n&#39; &quot;${picked[@]}&quot;
  else
    printf &#39;%s\n&#39; &quot;${avail[@]}&quot; | head -n 4
  fi
}

current_geometry() {
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o { if (match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/)) { print substr($0, RSTART, RLENGTH) } }
  &#39;
}

show_rectangle() {
  local W=&quot;$1&quot; H=&quot;$2&quot; X=&quot;$3&quot; Y=&quot;$4&quot;
  log &quot;   overlay ${W}x${H}+${X}+${Y} for 5s&quot;
  timeout 7s python3 - &quot;$W&quot; &quot;$H&quot; &quot;$X&quot; &quot;$Y&quot; &lt;&lt;&#39;PY&#39;
import sys, tkinter as t
W,H,X,Y = map(int, sys.argv[1:])
root = t.Tk()
root.overrideredirect(True)
root.geometry(f&quot;{W}x{H}+{X}+{Y}&quot;)
frame = t.Frame(root, width=W, height=H, highlightbackground=&#39;red&#39;, highlightthickness=8)
frame.pack()
root.attributes(&#39;-topmost&#39;, True)
root.after(5000, root.quit)
root.mainloop()
try:
    root.destroy()
except Exception:
    pass
PY
}

ask_ynq() {
  local prompt=&quot;$1&quot; ch
  while true; do
    printf &#39;%s&#39; &quot;$prompt&quot; &gt; /dev/tty
    IFS= read -r -n1 ch &lt; /dev/tty || ch=&quot;&quot;
    printf &#39;\n&#39; &gt; /dev/tty
    case &quot;$ch&quot; in
      y|Y) return 0;;
      n|N) return 1;;
      q|Q) return 2;;
      *) prompt=&quot;Please type y (accept), n (next), or q (quit): &quot;;;
    esac
  done
}

restore_mode_best_effort() {
  local out=&quot;$1&quot; prev=&quot;$2&quot;
  if [[ -n &quot;$prev&quot; ]]; then
    xrandr --output &quot;$out&quot; --mode &quot;$prev&quot; &gt;/dev/null 2&gt;&amp;1 || true
  else
    xrandr --output &quot;$out&quot; --auto &gt;/dev/null 2&gt;&amp;1 || true
  fi
}

try_modes_for_output() {
  local out=&quot;$1&quot;; shift
  local -a modes=(&quot;$@&quot;)
  local prev
  prev=&quot;$(current_mode_for_output &quot;$out&quot; || true)&quot;

  for mode in &quot;${modes[@]}&quot;; do
    log &quot;Trying $out -&gt; $mode&quot;
    if ! xrandr --output &quot;$out&quot; --mode &quot;$mode&quot;; then
      log &quot;Failed to set $mode on $out&quot;
      continue
    fi

    sleep 0.4
    local geom
    geom=&quot;$(current_geometry &quot;$out&quot; || true)&quot;
    if [[ &quot;$geom&quot; =~ ([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+) ]]; then
      show_rectangle &quot;${BASH_REMATCH[1]}&quot; &quot;${BASH_REMATCH[2]}&quot; &quot;${BASH_REMATCH[3]}&quot; &quot;${BASH_REMATCH[4]}&quot;
      if ask_ynq &quot;Keep $mode for $out? [y/n/q] &quot;; then
        log &quot;Accepted $mode for $out&quot;
        return 0
      else
        local rc=$?
        if ((rc==2)); then
          restore_mode_best_effort &quot;$out&quot; &quot;$prev&quot;
          return 2
        fi
      fi
    else
      log &quot;Could not parse geometry for $out after applying $mode (continuing).&quot;
    fi
  done

  restore_mode_best_effort &quot;$out&quot; &quot;$prev&quot;
  return 1
}

log &quot;Starting interactive monitor configuration...&quot;
mapfile -t outputs &lt; &lt;(sort_outputs)

(( ${#outputs[@]} &gt; 0 )) || fail &quot;No connected outputs detected by xrandr.&quot;

for out in &quot;${outputs[@]}&quot;; do
  log &quot;Configuring $out...&quot;
  mapfile -t avail &lt; &lt;(get_modes_for_output &quot;$out&quot;)
  (( ${#avail[@]} &gt; 0 )) || { log &quot;No modes found for $out (skipping).&quot;; continue; }

  mapfile -t testlist &lt; &lt;(printf &#39;%s\n&#39; &quot;${avail[@]}&quot; | pick_safelist)
  if try_modes_for_output &quot;$out&quot; &quot;${testlist[@]}&quot;; then
    continue
  else
    rc=$?
    ((rc==2)) &amp;&amp; { log &quot;Quit requested.&quot;; exit 0; }
  fi

  if ask_ynq &quot;No SafeMode accepted for $out. Try ALL modes (riskier)? [y/n/q] &quot;; then
    if try_modes_for_output &quot;$out&quot; &quot;${avail[@]}&quot;; then
      continue
    fi
  else
    rc=$?
    ((rc==2)) &amp;&amp; { log &quot;Quit requested.&quot;; exit 0; }
  fi

done

log &quot;Done. For persistence, save an autorandr profile using debian_display_setup.sh.&quot;" data-download-link="" data-download-label="Download ">
  <code class="language-">#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$&#39;\n\t&#39;

# monitor_setup_interactive.sh
#
# Safer interactive mode picker with visual verification:
#   - SafeMode-first: tries a short list of common resolutions first
#   - Output ordering: HDMI/DP/DVI/eDP/VGA then the rest
#   - Tk overlay: draws a red border on the active monitor
#
# WARNING: This script changes display modes.
# Recovery: switch to a TTY (Ctrl+Alt+F2) and run: DISPLAY=:0 xrandr --auto (if possible) or reboot.

LOGF=&quot;${LOGF:-/tmp/monitor-setup.log}&quot;
exec &gt; &gt;(tee -a &quot;$LOGF&quot;) 2&gt;&amp;1

log() { printf &#39;[%(%F %T)T] %s\n&#39; -1 &quot;$*&quot;; }
fail() { log &quot;ERROR: $*&quot;; exit 1; }
need() { command -v &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1 || fail &quot;$1 not found&quot;; }

need xrandr
need python3
need timeout

python3 - &lt;&lt;&#39;PY&#39; 2&gt;/dev/null || fail &quot;python3-tk not available. Install python3-tk.&quot;
import tkinter
PY

[[ -n &quot;${DISPLAY:-}&quot; ]] || fail &quot;DISPLAY is not set. Run from an active X session.&quot;

SAFEMODES=(
  1920x1080 1680x1050 1600x900 1440x900 1366x768 1280x1024 1280x960
  1280x800 1280x720 1024x768 800x600 640x480
)

get_outputs() { xrandr --query | awk &#39;/ connected/{print $1}&#39;; }

sort_outputs() {
  local -a outs
  mapfile -t outs &lt; &lt;(get_outputs)
  local prefs=(HDMI DP DVI eDP VGA)
  for p in &quot;${prefs[@]}&quot;; do
    for o in &quot;${outs[@]}&quot;; do [[ &quot;$o&quot; == ${p}* ]] &amp;&amp; echo &quot;$o&quot;; done
  done
  for o in &quot;${outs[@]}&quot;; do
    local hit=0
    for p in &quot;${prefs[@]}&quot;; do [[ &quot;$o&quot; == ${p}* ]] &amp;&amp; hit=1; done
    ((hit==0)) &amp;&amp; echo &quot;$o&quot;
  done
}

get_modes_for_output() {
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o {inblock=1; next}
    /^[A-Z]/ {inblock=0}
    inblock &amp;&amp; $1 ~ /^[0-9]+x[0-9]+/ {print $1}
  &#39; | awk &#39;!seen[$0]++&#39;
}

current_mode_for_output() {
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o {inblock=1; next}
    /^[A-Z]/ {inblock=0}
    inblock &amp;&amp; $1 ~ /^[0-9]+x[0-9]+/ {
      if ($0 ~ /\*/) {print $1; exit}
    }
  &#39;
}

pick_safelist() {
  local -a avail=()
  mapfile -t avail
  local -a picked=()
  for safe in &quot;${SAFEMODES[@]}&quot;; do
    for m in &quot;${avail[@]}&quot;; do
      [[ &quot;$m&quot; == &quot;$safe&quot; ]] &amp;&amp; { picked+=(&quot;$m&quot;); break; }
    done
    (( ${#picked[@]} &gt;= 4 )) &amp;&amp; break
  done
  if (( ${#picked[@]} &gt; 0 )); then
    printf &#39;%s\n&#39; &quot;${picked[@]}&quot;
  else
    printf &#39;%s\n&#39; &quot;${avail[@]}&quot; | head -n 4
  fi
}

current_geometry() {
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o { if (match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/)) { print substr($0, RSTART, RLENGTH) } }
  &#39;
}

show_rectangle() {
  local W=&quot;$1&quot; H=&quot;$2&quot; X=&quot;$3&quot; Y=&quot;$4&quot;
  log &quot;   overlay ${W}x${H}+${X}+${Y} for 5s&quot;
  timeout 7s python3 - &quot;$W&quot; &quot;$H&quot; &quot;$X&quot; &quot;$Y&quot; &lt;&lt;&#39;PY&#39;
import sys, tkinter as t
W,H,X,Y = map(int, sys.argv[1:])
root = t.Tk()
root.overrideredirect(True)
root.geometry(f&quot;{W}x{H}+{X}+{Y}&quot;)
frame = t.Frame(root, width=W, height=H, highlightbackground=&#39;red&#39;, highlightthickness=8)
frame.pack()
root.attributes(&#39;-topmost&#39;, True)
root.after(5000, root.quit)
root.mainloop()
try:
    root.destroy()
except Exception:
    pass
PY
}

ask_ynq() {
  local prompt=&quot;$1&quot; ch
  while true; do
    printf &#39;%s&#39; &quot;$prompt&quot; &gt; /dev/tty
    IFS= read -r -n1 ch &lt; /dev/tty || ch=&quot;&quot;
    printf &#39;\n&#39; &gt; /dev/tty
    case &quot;$ch&quot; in
      y|Y) return 0;;
      n|N) return 1;;
      q|Q) return 2;;
      *) prompt=&quot;Please type y (accept), n (next), or q (quit): &quot;;;
    esac
  done
}

restore_mode_best_effort() {
  local out=&quot;$1&quot; prev=&quot;$2&quot;
  if [[ -n &quot;$prev&quot; ]]; then
    xrandr --output &quot;$out&quot; --mode &quot;$prev&quot; &gt;/dev/null 2&gt;&amp;1 || true
  else
    xrandr --output &quot;$out&quot; --auto &gt;/dev/null 2&gt;&amp;1 || true
  fi
}

try_modes_for_output() {
  local out=&quot;$1&quot;; shift
  local -a modes=(&quot;$@&quot;)
  local prev
  prev=&quot;$(current_mode_for_output &quot;$out&quot; || true)&quot;

  for mode in &quot;${modes[@]}&quot;; do
    log &quot;Trying $out -&gt; $mode&quot;
    if ! xrandr --output &quot;$out&quot; --mode &quot;$mode&quot;; then
      log &quot;Failed to set $mode on $out&quot;
      continue
    fi

    sleep 0.4
    local geom
    geom=&quot;$(current_geometry &quot;$out&quot; || true)&quot;
    if [[ &quot;$geom&quot; =~ ([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+) ]]; then
      show_rectangle &quot;${BASH_REMATCH[1]}&quot; &quot;${BASH_REMATCH[2]}&quot; &quot;${BASH_REMATCH[3]}&quot; &quot;${BASH_REMATCH[4]}&quot;
      if ask_ynq &quot;Keep $mode for $out? [y/n/q] &quot;; then
        log &quot;Accepted $mode for $out&quot;
        return 0
      else
        local rc=$?
        if ((rc==2)); then
          restore_mode_best_effort &quot;$out&quot; &quot;$prev&quot;
          return 2
        fi
      fi
    else
      log &quot;Could not parse geometry for $out after applying $mode (continuing).&quot;
    fi
  done

  restore_mode_best_effort &quot;$out&quot; &quot;$prev&quot;
  return 1
}

log &quot;Starting interactive monitor configuration...&quot;
mapfile -t outputs &lt; &lt;(sort_outputs)

(( ${#outputs[@]} &gt; 0 )) || fail &quot;No connected outputs detected by xrandr.&quot;

for out in &quot;${outputs[@]}&quot;; do
  log &quot;Configuring $out...&quot;
  mapfile -t avail &lt; &lt;(get_modes_for_output &quot;$out&quot;)
  (( ${#avail[@]} &gt; 0 )) || { log &quot;No modes found for $out (skipping).&quot;; continue; }

  mapfile -t testlist &lt; &lt;(printf &#39;%s\n&#39; &quot;${avail[@]}&quot; | pick_safelist)
  if try_modes_for_output &quot;$out&quot; &quot;${testlist[@]}&quot;; then
    continue
  else
    rc=$?
    ((rc==2)) &amp;&amp; { log &quot;Quit requested.&quot;; exit 0; }
  fi

  if ask_ynq &quot;No SafeMode accepted for $out. Try ALL modes (riskier)? [y/n/q] &quot;; then
    if try_modes_for_output &quot;$out&quot; &quot;${avail[@]}&quot;; then
      continue
    fi
  else
    rc=$?
    ((rc==2)) &amp;&amp; { log &quot;Quit requested.&quot;; exit 0; }
  fi

done

log &quot;Done. For persistence, save an autorandr profile using debian_display_setup.sh.&quot;</code>
</section>
  <h1 id="homelinarork3588-display-toolkitbinpwsh_monitor_setupps1">
    
    
     <a href="#homelinarork3588-display-toolkitbinpwsh_monitor_setupps1">#</a><a href="#" aria-label="Back to top">/home/linaro/rk3588-display-toolkit/bin/pwsh_monitor_setup.ps1</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label=" Code Block" data-filename="_code_block.txt" data-code="#!/usr/bin/env pwsh
&lt;###
Pwsh Monitor Setup — Integrated, Optimized Build
TARGET: Linux + X11 (xrandr), PowerShell Core (pwsh)

Highlights:
- Dependency detection + optional auto-install (supports apt/dnf/zypper/pacman).
- X session readiness checks.
- Tkinter overlay verification.
- Interactive mode selection per output, with ordering prompt.
- Saves layout to JSON for reuse.

NOTE: This script is generated by the RK3588 toolkit installer.
###&gt;

[CmdletBinding()]
param(
  [switch] $DebugMode,
  [switch] $AutoInstall,
  [switch] $NoInstall,
  [int] $OverlaySeconds = 5,
  [string] $ConfigPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = &#39;Stop&#39;
if ($DebugMode) { $VerbosePreference = &#39;Continue&#39; }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }
$tsFile = &quot;/tmp/pwsh_monitor_setup-$(Get-Date -Format &#39;yyyyMMdd-HHmmss&#39;).log&quot;
try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {}

function Test-Cmd([string]$Name) { $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue) }
function Test-IsRoot { try { ((&amp; id &#39;-u&#39; 2&gt;$null) -eq 0) } catch { $false } }

function Detect-PackageManager {
  if (Test-Cmd &#39;apt-get&#39;) { return &#39;apt&#39; }
  if (Test-Cmd &#39;dnf&#39;) { return &#39;dnf&#39; }
  if (Test-Cmd &#39;zypper&#39;) { return &#39;zypper&#39; }
  if (Test-Cmd &#39;pacman&#39;) { return &#39;pacman&#39; }
  return $null
}

function Install-Dep([string]$pkg) {
  $pm = Detect-PackageManager
  if (-not $pm) { throw &#39;No supported package manager found.&#39; }
  if (-not (Test-IsRoot)) { throw &#39;Auto-install requires root.&#39; }
  switch ($pm) {
    &#39;apt&#39; { &amp; apt-get update; &amp; apt-get install -y $pkg }
    &#39;dnf&#39; { &amp; dnf install -y $pkg }
    &#39;zypper&#39; { &amp; zypper -n install $pkg }
    &#39;pacman&#39; { &amp; pacman -Sy --noconfirm $pkg }
  }
}

function Ensure-DepMapped([string]$cmd, [hashtable]$pkgMap, [string]$friendly) {
  if (Test-Cmd $cmd) { return }
  if ($NoInstall) { throw &quot;Missing dependency &#39;$friendly&#39; and -NoInstall specified.&quot; }
  if (-not $AutoInstall) { throw &quot;Missing dependency &#39;$friendly&#39;. Rerun with -AutoInstall.&quot; }
  $pm = Detect-PackageManager
  if (-not $pkgMap.ContainsKey($pm)) { throw &quot;Unsupported PM for &#39;$friendly&#39;.&quot; }
  Install-Dep $pkgMap[$pm]
  if (-not (Test-Cmd $cmd)) { throw &quot;Dependency &#39;$friendly&#39; missing after install.&quot; }
}

function Test-PythonTk {
@&#39;
import sys
try:
  import tkinter as t
  root=t.Tk(); root.withdraw()
  print(&#39;OK&#39;)
except Exception:
  sys.exit(1)
&#39;@ | Set-Content -Path ($tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;) -Encoding UTF8
  try {
    $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp) -PassThru -NoNewWindow -Wait
    return ($p.ExitCode -eq 0)
  } finally {
    try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
  }
}

function Assert-XSessionOrExit {
  if (-not $env:DISPLAY) { $env:DISPLAY = &#39;:0&#39; }
  for ($i=0; $i -lt 6; $i++) {
    try { &amp; xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
  }
  Write-Error &#39;No X11 display/xrandr available.&#39;
  Stop-TranscriptSafe
  exit 20
}

try {
  Ensure-DepMapped &#39;xrandr&#39;  @{ apt=&#39;xrandr&#39;; dnf=&#39;xrandr&#39;; zypper=&#39;xrandr&#39;; pacman=&#39;xorg-xrandr&#39; } &#39;xrandr&#39;
  Ensure-DepMapped &#39;python3&#39; @{ apt=&#39;python3&#39;; dnf=&#39;python3&#39;; zypper=&#39;python3&#39;; pacman=&#39;python&#39; }  &#39;python3&#39;
} catch {
  Write-Error $_.Exception.Message
  Stop-TranscriptSafe
  exit 2
}

Assert-XSessionOrExit
if (-not (Test-PythonTk)) {
  Write-Error &quot;python3-tk check failed. Install tkinter (python3-tk).&quot;
  Stop-TranscriptSafe
  exit 2
}

function Get-XrandrLines { (&amp; xrandr --query | Out-String) -split &quot;`n&quot; }
function Get-ConnectedOutputs { Get-XrandrLines | ForEach-Object { if ($_ -match &#39;^\s*(\S+)\s+connected&#39;) { $Matches[1] } } }
function Invoke-Xrandr([string[]]$XRArgs) {
  $p = Start-Process -FilePath &#39;xrandr&#39; -ArgumentList $XRArgs -PassThru -NoNewWindow -Wait
  if ($DebugMode) { Write-Verbose (&quot;xrandr &quot; + ($XRArgs -join &#39; &#39;) + &quot; =&gt; &quot; + $p.ExitCode) }
  $p.ExitCode
}

function Get-OutputModeCandidates([string]$Output) {
  $lines = Get-XrandrLines
  $in = $false
  $cands = New-Object &#39;System.Collections.Generic.List[object]&#39;
  foreach ($ln in $lines) {
    if (-not $in) {
      if ($ln -match &quot;^\s*$([Regex]::Escape($Output))\s+connected&quot;) { $in = $true }
    } else {
      if ($ln -match &#39;^\S+\s+(connected|disconnected)&#39;) { break }
      if ($ln -match &#39;^\s+((\d{3,5}x\d{3,5})(i)?\S*)\s+(.+)$&#39;) {
        $tok=$Matches[1]; $res=$Matches[2]; $rest=$Matches[4]
        $w=[int]($res -split &#39;x&#39;)[0]; $h=[int]($res -split &#39;x&#39;)[1]
        $mAll = [regex]::Matches($rest, &#39;(\d+(?:\.\d+)?)([*+]{0,2})&#39;)
        foreach ($m in $mAll) {
          $hz=$m.Groups[1].Value
          if ([string]::IsNullOrWhiteSpace($hz)) { continue }
          $cands.Add([pscustomobject]@{Output=$Output; ModeToken=$tok; W=$w; H=$h; Rate=[double]$hz; Label=&quot;$tok@$hz&quot;; Prefer=$m.Groups[2].Value -match &#39;\+&#39;; Current=$m.Groups[2].Value -match &#39;\*&#39;})
        }
      }
    }
  }
  return $cands | Sort-Object @{e={$_.W*$_.H};d=$true}, @{e={$_.Rate};d=$true}
}

function Show-OverlayTk([int]$W,[int]$H,[int]$X,[int]$Y,[int]$Seconds) {
$py = @&#39;
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk(); root.overrideredirect(1); root.attributes(&quot;-topmost&quot;, True)
root.geometry(f&quot;{w}x{h}+{x}+{y}&quot;)
t.Frame(root, width=w, height=h, highlightbackground=&quot;red&quot;, highlightthickness=8).pack()
root.after(sec*1000, root.destroy); root.mainloop()
&#39;@
  $tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;
  [IO.File]::WriteAllText($tmp, $py)
  $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp, $W, $H, $X, $Y, $Seconds) -PassThru -NoNewWindow
  try { Wait-Process -Id $p.Id -Timeout ([Math]::Max($Seconds+3, 8)) } catch { try { Stop-Process -Id $p.Id -Force } catch {} }
  try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
}

$outs = Get-ConnectedOutputs
if (-not $outs) {
  Write-Error &#39;No connected monitors detected.&#39;
  Stop-TranscriptSafe
  exit 21
}

$ordered = New-Object &#39;System.Collections.Generic.List[string]&#39;
if ($outs.Count -gt 1) {
  Write-Host &quot;Monitors: $($outs -join &#39;, &#39;)&quot; -ForegroundColor Cyan
  $rem = [System.Collections.Generic.List[string]]::new(); $rem.AddRange([string[]]$outs)
  while ($rem.Count -gt 0) {
    $q = if ($ordered.Count -eq 0) { &#39;Leftmost monitor?&#39; } else { &quot;Right of $($ordered[-1])?&quot; }
    for ($i=0; $i -lt $rem.Count; $i++) { Write-Host &quot; [$($i+1)] $($rem[$i])&quot; }
    $ans = Read-Host &quot;$q (1-$($rem.Count))&quot;
    if ($ans -match &#39;^\d+$&#39; -and [int]$ans -ge 1 -and [int]$ans -le $rem.Count) {
      $idx=[int]$ans-1; $ordered.Add($rem[$idx]); $rem.RemoveAt($idx)
    }
  }
} else { $ordered.Add($outs[0]) }

$all = @{}; foreach ($o in $ordered) { $all[$o] = Get-OutputModeCandidates $o }
$chosen = [ordered]@{}; foreach ($o in $ordered) { $chosen[$o] = $null }

foreach ($current in $ordered) {
  Write-Host &quot;Select mode for $current&quot; -ForegroundColor Cyan
  $cands = @($all[$current])
  if (-not $cands -or $cands.Count -lt 1) { continue }

  $idx=1
  foreach ($c in $cands) { Write-Host (&quot; [{0}] {1} ({2}x{3})&quot; -f $idx++, $c.Label, $c.W, $c.H) }
  $ans = Read-Host &quot;Choice (1-$($cands.Count)), or Enter to keep current&quot;
  if ($ans -match &#39;^\d+$&#39; -and [int]$ans -ge 1 -and [int]$ans -le $cands.Count) {
    $c = $cands[[int]$ans-1]
    $x=0
    foreach ($o in $ordered) {
      $tgt = if ($o -eq $current) { $c } else { $chosen[$o] ?? $all[$o][0] }
      if ($tgt) {
        $args = @(&#39;--output&#39;, $o, &#39;--mode&#39;, $tgt.ModeToken, &#39;--pos&#39;, &quot;${x}x0&quot;)
        if ($tgt.Rate) { $args += @(&#39;--rate&#39;, (&quot;{0:0.##}&quot; -f $tgt.Rate)) }
        Invoke-Xrandr $args | Out-Null
        $x += $tgt.W
      }
    }
    Show-OverlayTk $c.W $c.H 0 0 $OverlaySeconds
    if ((Read-Host &#39;Keep? (y/n)&#39;) -eq &#39;y&#39;) { $chosen[$current] = $c }
  }
}

$persist = [ordered]@{}
foreach ($o in $ordered) {
  $c = $chosen[$o]
  if ($null -eq $c) { continue }
  $persist[$o] = [ordered]@{ mode=$c.ModeToken; rate=$(if($c.Rate){[double]$c.Rate}else{$null}) }
}

$target = $ConfigPath
if ([string]::IsNullOrWhiteSpace($target)) { $target = &quot;$HOME/.config/pwsh-monitor-layout.json&quot; }
$dir = Split-Path -Parent $target
if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Force -Path $dir | Out-Null }
($persist | ConvertTo-Json) | Set-Content -Path $target
Write-Host &quot;Saved layout to: $target&quot; -ForegroundColor Green

Stop-TranscriptSafe
exit 0" data-download-link="" data-download-label="Download ">
  <code class="language-">#!/usr/bin/env pwsh
&lt;###
Pwsh Monitor Setup — Integrated, Optimized Build
TARGET: Linux + X11 (xrandr), PowerShell Core (pwsh)

Highlights:
- Dependency detection + optional auto-install (supports apt/dnf/zypper/pacman).
- X session readiness checks.
- Tkinter overlay verification.
- Interactive mode selection per output, with ordering prompt.
- Saves layout to JSON for reuse.

NOTE: This script is generated by the RK3588 toolkit installer.
###&gt;

[CmdletBinding()]
param(
  [switch] $DebugMode,
  [switch] $AutoInstall,
  [switch] $NoInstall,
  [int] $OverlaySeconds = 5,
  [string] $ConfigPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = &#39;Stop&#39;
if ($DebugMode) { $VerbosePreference = &#39;Continue&#39; }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }
$tsFile = &quot;/tmp/pwsh_monitor_setup-$(Get-Date -Format &#39;yyyyMMdd-HHmmss&#39;).log&quot;
try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {}

function Test-Cmd([string]$Name) { $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue) }
function Test-IsRoot { try { ((&amp; id &#39;-u&#39; 2&gt;$null) -eq 0) } catch { $false } }

function Detect-PackageManager {
  if (Test-Cmd &#39;apt-get&#39;) { return &#39;apt&#39; }
  if (Test-Cmd &#39;dnf&#39;) { return &#39;dnf&#39; }
  if (Test-Cmd &#39;zypper&#39;) { return &#39;zypper&#39; }
  if (Test-Cmd &#39;pacman&#39;) { return &#39;pacman&#39; }
  return $null
}

function Install-Dep([string]$pkg) {
  $pm = Detect-PackageManager
  if (-not $pm) { throw &#39;No supported package manager found.&#39; }
  if (-not (Test-IsRoot)) { throw &#39;Auto-install requires root.&#39; }
  switch ($pm) {
    &#39;apt&#39; { &amp; apt-get update; &amp; apt-get install -y $pkg }
    &#39;dnf&#39; { &amp; dnf install -y $pkg }
    &#39;zypper&#39; { &amp; zypper -n install $pkg }
    &#39;pacman&#39; { &amp; pacman -Sy --noconfirm $pkg }
  }
}

function Ensure-DepMapped([string]$cmd, [hashtable]$pkgMap, [string]$friendly) {
  if (Test-Cmd $cmd) { return }
  if ($NoInstall) { throw &quot;Missing dependency &#39;$friendly&#39; and -NoInstall specified.&quot; }
  if (-not $AutoInstall) { throw &quot;Missing dependency &#39;$friendly&#39;. Rerun with -AutoInstall.&quot; }
  $pm = Detect-PackageManager
  if (-not $pkgMap.ContainsKey($pm)) { throw &quot;Unsupported PM for &#39;$friendly&#39;.&quot; }
  Install-Dep $pkgMap[$pm]
  if (-not (Test-Cmd $cmd)) { throw &quot;Dependency &#39;$friendly&#39; missing after install.&quot; }
}

function Test-PythonTk {
@&#39;
import sys
try:
  import tkinter as t
  root=t.Tk(); root.withdraw()
  print(&#39;OK&#39;)
except Exception:
  sys.exit(1)
&#39;@ | Set-Content -Path ($tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;) -Encoding UTF8
  try {
    $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp) -PassThru -NoNewWindow -Wait
    return ($p.ExitCode -eq 0)
  } finally {
    try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
  }
}

function Assert-XSessionOrExit {
  if (-not $env:DISPLAY) { $env:DISPLAY = &#39;:0&#39; }
  for ($i=0; $i -lt 6; $i++) {
    try { &amp; xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
  }
  Write-Error &#39;No X11 display/xrandr available.&#39;
  Stop-TranscriptSafe
  exit 20
}

try {
  Ensure-DepMapped &#39;xrandr&#39;  @{ apt=&#39;xrandr&#39;; dnf=&#39;xrandr&#39;; zypper=&#39;xrandr&#39;; pacman=&#39;xorg-xrandr&#39; } &#39;xrandr&#39;
  Ensure-DepMapped &#39;python3&#39; @{ apt=&#39;python3&#39;; dnf=&#39;python3&#39;; zypper=&#39;python3&#39;; pacman=&#39;python&#39; }  &#39;python3&#39;
} catch {
  Write-Error $_.Exception.Message
  Stop-TranscriptSafe
  exit 2
}

Assert-XSessionOrExit
if (-not (Test-PythonTk)) {
  Write-Error &quot;python3-tk check failed. Install tkinter (python3-tk).&quot;
  Stop-TranscriptSafe
  exit 2
}

function Get-XrandrLines { (&amp; xrandr --query | Out-String) -split &quot;`n&quot; }
function Get-ConnectedOutputs { Get-XrandrLines | ForEach-Object { if ($_ -match &#39;^\s*(\S+)\s+connected&#39;) { $Matches[1] } } }
function Invoke-Xrandr([string[]]$XRArgs) {
  $p = Start-Process -FilePath &#39;xrandr&#39; -ArgumentList $XRArgs -PassThru -NoNewWindow -Wait
  if ($DebugMode) { Write-Verbose (&quot;xrandr &quot; + ($XRArgs -join &#39; &#39;) + &quot; =&gt; &quot; + $p.ExitCode) }
  $p.ExitCode
}

function Get-OutputModeCandidates([string]$Output) {
  $lines = Get-XrandrLines
  $in = $false
  $cands = New-Object &#39;System.Collections.Generic.List[object]&#39;
  foreach ($ln in $lines) {
    if (-not $in) {
      if ($ln -match &quot;^\s*$([Regex]::Escape($Output))\s+connected&quot;) { $in = $true }
    } else {
      if ($ln -match &#39;^\S+\s+(connected|disconnected)&#39;) { break }
      if ($ln -match &#39;^\s+((\d{3,5}x\d{3,5})(i)?\S*)\s+(.+)$&#39;) {
        $tok=$Matches[1]; $res=$Matches[2]; $rest=$Matches[4]
        $w=[int]($res -split &#39;x&#39;)[0]; $h=[int]($res -split &#39;x&#39;)[1]
        $mAll = [regex]::Matches($rest, &#39;(\d+(?:\.\d+)?)([*+]{0,2})&#39;)
        foreach ($m in $mAll) {
          $hz=$m.Groups[1].Value
          if ([string]::IsNullOrWhiteSpace($hz)) { continue }
          $cands.Add([pscustomobject]@{Output=$Output; ModeToken=$tok; W=$w; H=$h; Rate=[double]$hz; Label=&quot;$tok@$hz&quot;; Prefer=$m.Groups[2].Value -match &#39;\+&#39;; Current=$m.Groups[2].Value -match &#39;\*&#39;})
        }
      }
    }
  }
  return $cands | Sort-Object @{e={$_.W*$_.H};d=$true}, @{e={$_.Rate};d=$true}
}

function Show-OverlayTk([int]$W,[int]$H,[int]$X,[int]$Y,[int]$Seconds) {
$py = @&#39;
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk(); root.overrideredirect(1); root.attributes(&quot;-topmost&quot;, True)
root.geometry(f&quot;{w}x{h}+{x}+{y}&quot;)
t.Frame(root, width=w, height=h, highlightbackground=&quot;red&quot;, highlightthickness=8).pack()
root.after(sec*1000, root.destroy); root.mainloop()
&#39;@
  $tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;
  [IO.File]::WriteAllText($tmp, $py)
  $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp, $W, $H, $X, $Y, $Seconds) -PassThru -NoNewWindow
  try { Wait-Process -Id $p.Id -Timeout ([Math]::Max($Seconds+3, 8)) } catch { try { Stop-Process -Id $p.Id -Force } catch {} }
  try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
}

$outs = Get-ConnectedOutputs
if (-not $outs) {
  Write-Error &#39;No connected monitors detected.&#39;
  Stop-TranscriptSafe
  exit 21
}

$ordered = New-Object &#39;System.Collections.Generic.List[string]&#39;
if ($outs.Count -gt 1) {
  Write-Host &quot;Monitors: $($outs -join &#39;, &#39;)&quot; -ForegroundColor Cyan
  $rem = [System.Collections.Generic.List[string]]::new(); $rem.AddRange([string[]]$outs)
  while ($rem.Count -gt 0) {
    $q = if ($ordered.Count -eq 0) { &#39;Leftmost monitor?&#39; } else { &quot;Right of $($ordered[-1])?&quot; }
    for ($i=0; $i -lt $rem.Count; $i++) { Write-Host &quot; [$($i+1)] $($rem[$i])&quot; }
    $ans = Read-Host &quot;$q (1-$($rem.Count))&quot;
    if ($ans -match &#39;^\d+$&#39; -and [int]$ans -ge 1 -and [int]$ans -le $rem.Count) {
      $idx=[int]$ans-1; $ordered.Add($rem[$idx]); $rem.RemoveAt($idx)
    }
  }
} else { $ordered.Add($outs[0]) }

$all = @{}; foreach ($o in $ordered) { $all[$o] = Get-OutputModeCandidates $o }
$chosen = [ordered]@{}; foreach ($o in $ordered) { $chosen[$o] = $null }

foreach ($current in $ordered) {
  Write-Host &quot;Select mode for $current&quot; -ForegroundColor Cyan
  $cands = @($all[$current])
  if (-not $cands -or $cands.Count -lt 1) { continue }

  $idx=1
  foreach ($c in $cands) { Write-Host (&quot; [{0}] {1} ({2}x{3})&quot; -f $idx++, $c.Label, $c.W, $c.H) }
  $ans = Read-Host &quot;Choice (1-$($cands.Count)), or Enter to keep current&quot;
  if ($ans -match &#39;^\d+$&#39; -and [int]$ans -ge 1 -and [int]$ans -le $cands.Count) {
    $c = $cands[[int]$ans-1]
    $x=0
    foreach ($o in $ordered) {
      $tgt = if ($o -eq $current) { $c } else { $chosen[$o] ?? $all[$o][0] }
      if ($tgt) {
        $args = @(&#39;--output&#39;, $o, &#39;--mode&#39;, $tgt.ModeToken, &#39;--pos&#39;, &quot;${x}x0&quot;)
        if ($tgt.Rate) { $args += @(&#39;--rate&#39;, (&quot;{0:0.##}&quot; -f $tgt.Rate)) }
        Invoke-Xrandr $args | Out-Null
        $x += $tgt.W
      }
    }
    Show-OverlayTk $c.W $c.H 0 0 $OverlaySeconds
    if ((Read-Host &#39;Keep? (y/n)&#39;) -eq &#39;y&#39;) { $chosen[$current] = $c }
  }
}

$persist = [ordered]@{}
foreach ($o in $ordered) {
  $c = $chosen[$o]
  if ($null -eq $c) { continue }
  $persist[$o] = [ordered]@{ mode=$c.ModeToken; rate=$(if($c.Rate){[double]$c.Rate}else{$null}) }
}

$target = $ConfigPath
if ([string]::IsNullOrWhiteSpace($target)) { $target = &quot;$HOME/.config/pwsh-monitor-layout.json&quot; }
$dir = Split-Path -Parent $target
if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Force -Path $dir | Out-Null }
($persist | ConvertTo-Json) | Set-Content -Path $target
Write-Host &quot;Saved layout to: $target&quot; -ForegroundColor Green

Stop-TranscriptSafe
exit 0</code>
</section>
  <h1 id="homelinarork3588-display-toolkitbinrk3588_auditsh">
    
    
     <a href="#homelinarork3588-display-toolkitbinrk3588_auditsh">#</a><a href="#" aria-label="Back to top">/home/linaro/rk3588-display-toolkit/bin/rk3588_audit.sh</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label=" Code Block" data-filename="_code_block.txt" data-code="#!/usr/bin/env bash
set -euo pipefail
set -o errtrace
IFS=$&#39;\n\t&#39;
trap &#39;echo &quot;Error on or near line ${LINENO}; command exited with status $?&quot; &gt;&amp;2&#39; ERR

# rk3588_audit.sh
#
# Purpose:
#   - Create a timestamped audit directory under ~/rk3588_audit_&lt;timestamp&gt;/
#   - Collect system/display/GPU/VPU/network/storage snapshots
#   - Install diagnostic packages idempotently (skips missing packages)
#   - Avoid destructive actions; optional actions require explicit confirmation

START_TS=&quot;$(date +%Y%m%d_%H%M%S)&quot;
AUDIT_DIR=&quot;$HOME/rk3588_audit_${START_TS}&quot;
LOG_DIR=&quot;$AUDIT_DIR/logs&quot;
OUT_DIR=&quot;$AUDIT_DIR/out&quot;
REPORT_MD=&quot;$AUDIT_DIR/REPORT.md&quot;
LOG_FILE=&quot;$LOG_DIR/audit.log&quot;
ENV_FILE=&quot;$LOG_DIR/env.txt&quot;
DMESG_FILE=&quot;$LOG_DIR/dmesg.txt&quot;

CMD_FAIL_HINT=&quot;Check ${LOG_FILE} and ${REPORT_MD} for details.&quot;

: &quot;${NET_TIMEOUT:=5}&quot;
: &quot;${FIO_SIZE_MB:=512}&quot;
: &quot;${FIO_BS:=1M}&quot;
: &quot;${FIO_IODEPTH:=16}&quot;
: &quot;${RUN_COLORS:=1}&quot;

TMPDIR_CREATED=&quot;&quot;
cleanup() {
  if [[ -n &quot;${TMPDIR_CREATED:-}&quot; &amp;&amp; -d &quot;$TMPDIR_CREATED&quot; ]]; then
    rm -rf &quot;$TMPDIR_CREATED&quot; || true
  fi
}
trap cleanup EXIT SIGINT SIGTERM

if [[ -t 1 &amp;&amp; &quot;$RUN_COLORS&quot; -eq 1 ]] &amp;&amp; command -v tput &gt;/dev/null 2&gt;&amp;1; then
  GREEN=&quot;$(tput setaf 2)&quot;; YELLOW=&quot;$(tput setaf 3)&quot;; RED=&quot;$(tput setaf 1)&quot;; BLUE=&quot;$(tput setaf 4)&quot;; BOLD=&quot;$(tput bold)&quot;; RESET=&quot;$(tput sgr0)&quot;
else
  GREEN=&quot;&quot;; YELLOW=&quot;&quot;; RED=&quot;&quot;; BLUE=&quot;&quot;; BOLD=&quot;&quot;; RESET=&quot;&quot;
fi

log() { echo -e &quot;$*&quot; | tee -a &quot;$LOG_FILE&quot;; }
section() { log &quot;\n${BOLD}${BLUE}==&gt; $1${RESET}&quot;; }

ensure_dir() { [[ -d &quot;$1&quot; ]] || mkdir -p &quot;$1&quot;; }

ask_yes() {
  local prompt=&quot;$1&quot; ans
  echo
  read -r -p &quot;${YELLOW}${prompt}${RESET} (type &#39;yes&#39; to continue, anything else to cancel): &quot; ans
  [[ &quot;$ans&quot; == &quot;yes&quot; ]] || { echo &quot;Cancelled by user.&quot;; return 1; }
}

need_sudo() {
  command -v sudo &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: sudo required.&quot; &gt;&amp;2; exit 1; }
  sudo -v || { echo &quot;Error: sudo auth failed.&quot; &gt;&amp;2; exit 1; }
}

package_available() {
  local pkg=&quot;$1&quot;
  apt-cache policy &quot;$pkg&quot; 2&gt;/dev/null | awk &#39;/Candidate:/ {print $2}&#39; | grep -vq &quot;(none)&quot;
}

is_installed() { dpkg -s &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1; }

ensure_package() {
  local pkg=&quot;$1&quot;
  if is_installed &quot;$pkg&quot;; then
    log &quot;Package already installed: ${GREEN}${pkg}${RESET}&quot;
    return 0
  fi
  if ! package_available &quot;$pkg&quot;; then
    log &quot;Package not available (skipping): ${YELLOW}${pkg}${RESET}&quot;
    return 0
  fi
  log &quot;Installing package: ${GREEN}${pkg}${RESET}&quot;
  sudo apt-get install -y --no-install-recommends &quot;$pkg&quot; &gt;&gt;&quot;$LOG_FILE&quot; 2&gt;&amp;1 || {
    echo &quot;Error: Failed to install &#39;$pkg&#39;. ${CMD_FAIL_HINT}&quot; &gt;&amp;2
    exit 1
  }
}

ensure_packages() { for pkg in &quot;$@&quot;; do ensure_package &quot;$pkg&quot;; done; }

run_continue() {
  local title=&quot;$1&quot;; shift
  log &quot;\n--- $title ---&quot;
  &quot;$@&quot; &gt;&gt;&quot;$LOG_FILE&quot; 2&gt;&amp;1 || log &quot;  (Command failed but continuing): $*&quot;
}

run_fail() {
  local title=&quot;$1&quot;; shift
  log &quot;\n&gt;&gt;&gt; $title&quot;
  &quot;$@&quot; &gt;&gt;&quot;$LOG_FILE&quot; 2&gt;&amp;1 || { echo &quot;Error: $title failed. ${CMD_FAIL_HINT}&quot; &gt;&amp;2; exit 1; }
}

quick_net_check() {
  section &quot;Quick network check&quot;
  if command -v ping &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ping -c1 -W &quot;$NET_TIMEOUT&quot; deb.debian.org &gt;/dev/null 2&gt;&amp;1; then
    log &quot;Network reachable.&quot;
    return 0
  fi
  log &quot;Network check failed; installs/downloads may be limited.&quot;
  return 1
}

check_platform() {
  section &quot;Platform checks&quot;
  local debver arch
  debver=&quot;$(cut -d&#39;.&#39; -f1 &lt; /etc/debian_version 2&gt;/dev/null || echo unknown)&quot;
  arch=&quot;$(uname -m 2&gt;/dev/null || echo unknown)&quot;
  log &quot;Debian major: $debver&quot;
  log &quot;Arch        : $arch&quot;
  [[ &quot;$debver&quot; == &quot;11&quot; ]] || log &quot;WARNING: tuned for Debian 11 (Bullseye).&quot;
  [[ &quot;$arch&quot; == &quot;aarch64&quot; || &quot;$arch&quot; == &quot;arm64&quot; ]] || log &quot;WARNING: tuned for ARM64.&quot;
}

enable_nonfree_optional() {
  section &quot;Optional: Enable contrib/non-free (Bullseye)&quot;
  if ! ask_yes &quot;Enable &#39;contrib non-free&#39; in /etc/apt/sources.list (backup + apt update)?&quot;; then
    log &quot;Skipped enabling contrib/non-free.&quot;
    return 0
  fi

  local src=&quot;/etc/apt/sources.list&quot;
  if [[ ! -f &quot;$src&quot; ]]; then
    log &quot;No $src found; skipping.&quot;
    return 0
  fi

  sudo cp -a &quot;$src&quot; &quot;${src}.bak.${START_TS}&quot;

  TMPDIR_CREATED=&quot;$(mktemp -d)&quot;
  local tmp=&quot;$TMPDIR_CREATED/sources.list&quot;

  sudo awk &#39;{
    if ($1==&quot;deb&quot; || $1==&quot;deb-src&quot;) {
      line=$0
      has_contrib=match(line,/(^| )contrib( |$)/)
      has_nonfree=match(line,/(^| )non-free( |$)/)
      if (!has_contrib) line=line&quot; contrib&quot;
      if (!has_nonfree) line=line&quot; non-free&quot;
      print line
    } else {
      print
    }
  }&#39; &quot;$src&quot; | sudo tee &quot;$tmp&quot; &gt;/dev/null

  sudo mv &quot;$tmp&quot; &quot;$src&quot;
  run_fail &quot;apt-get update (after enabling contrib/non-free)&quot; sudo apt-get update
  rm -rf &quot;$TMPDIR_CREATED&quot; || true
  TMPDIR_CREATED=&quot;&quot;
}

main() {
  ensure_dir &quot;$AUDIT_DIR&quot;; ensure_dir &quot;$LOG_DIR&quot;; ensure_dir &quot;$OUT_DIR&quot;
  : &gt;&quot;$LOG_FILE&quot;

  section &quot;Start&quot;
  log &quot;Audit directory: $AUDIT_DIR&quot;
  log &quot;Log file       : $LOG_FILE&quot;

  need_sudo

  {
    echo &quot;===== ENVIRONMENT =====&quot;
    echo &quot;Timestamp: $START_TS&quot;
    uname -a || true
    echo
    echo &quot;----- /etc/os-release -----&quot;
    cat /etc/os-release 2&gt;/dev/null || true
    echo
    echo &quot;----- /proc/cmdline -----&quot;
    cat /proc/cmdline 2&gt;/dev/null || true
    echo
    echo &quot;----- CPU -----&quot;
    lscpu 2&gt;/dev/null || true
    echo
    echo &quot;----- Memory/CMA -----&quot;
    grep -E &#39;CmaTotal|CmaFree|MemTotal|MemFree|HugePages&#39; /proc/meminfo 2&gt;/dev/null || true
  } &gt;&quot;$ENV_FILE&quot;

  run_continue &quot;Collect dmesg&quot; bash -lc &quot;sudo dmesg -T &gt; &#39;$DMESG_FILE&#39;&quot;

  check_platform
  quick_net_check || true

  section &quot;APT update&quot;
  run_fail &quot;apt-get update&quot; sudo apt-get update

  enable_nonfree_optional || true

  section &quot;Install baseline diagnostic tools (idempotent; skips unavailable)&quot;
  ensure_packages \
    curl wget ca-certificates \
    pciutils usbutils lshw hwinfo inxi \
    ethtool iproute2 net-tools jq \
    i2c-tools lm-sensors \
    v4l-utils \
    gstreamer1.0-tools gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly \
    ffmpeg alsa-utils \
    vulkan-tools mesa-utils kmscube \
    xrandr x11-xserver-utils autorandr \
    edid-decode read-edid ddcutil \
    fio hdparm nvme-cli smartmontools \
    iw wireless-tools bluez can-utils

  section &quot;System overview&quot;
  run_continue &quot;lshw (short)&quot; sudo lshw -short
  run_continue &quot;lsblk -O&quot; lsblk -O
  run_continue &quot;df -hT&quot; df -hT
  run_continue &quot;lsusb -t&quot; lsusb -t
  run_continue &quot;lspci -nnk&quot; lspci -nnk
  run_continue &quot;Kernel warnings/errors (last 200)&quot; bash -lc &#39;dmesg -T --level=err,warn | tail -n 200&#39;

  section &quot;GPU &amp; Display&quot;
  run_continue &quot;GPU modules loaded&quot; bash -lc &quot;lsmod | egrep -i &#39;panthor|panfrost|mali|kbase&#39; || true&quot;
  run_continue &quot;GPU-related dmesg&quot; bash -lc &quot;dmesg -T | egrep -i &#39;mali|panthor|panfrost|csf|gpu&#39; || true&quot;
  run_continue &quot;DRM connectors (modetest -c)&quot; modetest -c
  run_continue &quot;kmscube smoke test&quot; bash -lc &quot;kmscube -i 100 &gt;/dev/null 2&gt;&amp;1 || true&quot;
  run_continue &quot;Vulkan summary&quot; vulkaninfo --summary
  run_continue &quot;xrandr --props (if X running)&quot; bash -lc &quot;DISPLAY=\${DISPLAY:-:0} xrandr --props 2&gt;/dev/null || true&quot;

  section &quot;Video / V4L2 / Codecs&quot;
  run_continue &quot;List V4L2 devices&quot; v4l2-ctl --list-devices
  run_continue &quot;FFmpeg hwaccels&quot; ffmpeg -hide_banner -hwaccels
  run_continue &quot;GStreamer rockchip-ish plugins&quot; bash -lc &quot;gst-inspect-1.0 | egrep -i &#39;v4l2|rkv|hantro|rockchip&#39; || true&quot;

  section &quot;Audio&quot;
  run_continue &quot;ALSA playback&quot; aplay -l
  run_continue &quot;ALSA capture&quot; arecord -l

  section &quot;Network&quot;
  run_continue &quot;ip -details addr&quot; ip -details address
  run_continue &quot;iw dev&quot; iw dev

  section &quot;Storage&quot;
  run_continue &quot;lsblk (model/serial)&quot; lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,MODEL,SERIAL,TRAN
  run_continue &quot;SATA/NVMe/PCIe dmesg&quot; bash -lc &quot;dmesg -T | egrep -i &#39;sata|ahci|nvme|pcie&#39; || true&quot;
  run_continue &quot;nvme list (if any)&quot; bash -lc &quot;ls /dev/nvme*n1 &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo nvme list || true&quot;

  section &quot;Optional actions&quot;
  if ask_yes &quot;Run powertop --auto-tune (changes power tunables until reboot)?&quot;; then
    run_fail &quot;powertop --auto-tune&quot; sudo powertop --auto-tune
  fi
  if ask_yes &quot;Run sensors-detect (interactive; may load modules)?&quot;; then
    run_fail &quot;sensors-detect&quot; sudo sensors-detect
  fi
  if ask_yes &quot;Run quick fio seq read/write in $HOME (~${FIO_SIZE_MB}MB temp file, then removed)?&quot;; then
    TMPDIR_CREATED=&quot;$(mktemp -d)&quot;
    local fiofile=&quot;$TMPDIR_CREATED/fio_test.dat&quot;
    run_fail &quot;dd create file&quot; dd if=/dev/zero of=&quot;$fiofile&quot; bs=1M count=&quot;$FIO_SIZE_MB&quot; status=none
    run_fail &quot;fio seq rw&quot; fio --name=seqrw --filename=&quot;$fiofile&quot; --rw=readwrite --bs=&quot;$FIO_BS&quot; --direct=1 --numjobs=1 --iodepth=&quot;$FIO_IODEPTH&quot; --size=&quot;${FIO_SIZE_MB}M&quot; --group_reporting
    rm -rf &quot;$TMPDIR_CREATED&quot; || true
    TMPDIR_CREATED=&quot;&quot;
  fi

  section &quot;REPORT.md&quot;
  {
    echo &quot;# RK3588 Capability Audit — $START_TS&quot;
    echo
    echo &quot;Audit directory: $AUDIT_DIR&quot;
    echo &quot;Log file: $LOG_FILE&quot;
    echo &quot;Env snapshot: $ENV_FILE&quot;
    echo &quot;dmesg: $DMESG_FILE&quot;
  } &gt;&quot;$REPORT_MD&quot;

  ( cd &quot;$HOME&quot; &amp;&amp; tar czf &quot;${AUDIT_DIR}.tar.gz&quot; &quot;$(basename &quot;$AUDIT_DIR&quot;)&quot; )

  section &quot;Done&quot;
  log &quot;Report : $REPORT_MD&quot;
  log &quot;Archive: ${AUDIT_DIR}.tar.gz&quot;
}

main &quot;$@&quot;" data-download-link="" data-download-label="Download ">
  <code class="language-">#!/usr/bin/env bash
set -euo pipefail
set -o errtrace
IFS=$&#39;\n\t&#39;
trap &#39;echo &quot;Error on or near line ${LINENO}; command exited with status $?&quot; &gt;&amp;2&#39; ERR

# rk3588_audit.sh
#
# Purpose:
#   - Create a timestamped audit directory under ~/rk3588_audit_&lt;timestamp&gt;/
#   - Collect system/display/GPU/VPU/network/storage snapshots
#   - Install diagnostic packages idempotently (skips missing packages)
#   - Avoid destructive actions; optional actions require explicit confirmation

START_TS=&quot;$(date +%Y%m%d_%H%M%S)&quot;
AUDIT_DIR=&quot;$HOME/rk3588_audit_${START_TS}&quot;
LOG_DIR=&quot;$AUDIT_DIR/logs&quot;
OUT_DIR=&quot;$AUDIT_DIR/out&quot;
REPORT_MD=&quot;$AUDIT_DIR/REPORT.md&quot;
LOG_FILE=&quot;$LOG_DIR/audit.log&quot;
ENV_FILE=&quot;$LOG_DIR/env.txt&quot;
DMESG_FILE=&quot;$LOG_DIR/dmesg.txt&quot;

CMD_FAIL_HINT=&quot;Check ${LOG_FILE} and ${REPORT_MD} for details.&quot;

: &quot;${NET_TIMEOUT:=5}&quot;
: &quot;${FIO_SIZE_MB:=512}&quot;
: &quot;${FIO_BS:=1M}&quot;
: &quot;${FIO_IODEPTH:=16}&quot;
: &quot;${RUN_COLORS:=1}&quot;

TMPDIR_CREATED=&quot;&quot;
cleanup() {
  if [[ -n &quot;${TMPDIR_CREATED:-}&quot; &amp;&amp; -d &quot;$TMPDIR_CREATED&quot; ]]; then
    rm -rf &quot;$TMPDIR_CREATED&quot; || true
  fi
}
trap cleanup EXIT SIGINT SIGTERM

if [[ -t 1 &amp;&amp; &quot;$RUN_COLORS&quot; -eq 1 ]] &amp;&amp; command -v tput &gt;/dev/null 2&gt;&amp;1; then
  GREEN=&quot;$(tput setaf 2)&quot;; YELLOW=&quot;$(tput setaf 3)&quot;; RED=&quot;$(tput setaf 1)&quot;; BLUE=&quot;$(tput setaf 4)&quot;; BOLD=&quot;$(tput bold)&quot;; RESET=&quot;$(tput sgr0)&quot;
else
  GREEN=&quot;&quot;; YELLOW=&quot;&quot;; RED=&quot;&quot;; BLUE=&quot;&quot;; BOLD=&quot;&quot;; RESET=&quot;&quot;
fi

log() { echo -e &quot;$*&quot; | tee -a &quot;$LOG_FILE&quot;; }
section() { log &quot;\n${BOLD}${BLUE}==&gt; $1${RESET}&quot;; }

ensure_dir() { [[ -d &quot;$1&quot; ]] || mkdir -p &quot;$1&quot;; }

ask_yes() {
  local prompt=&quot;$1&quot; ans
  echo
  read -r -p &quot;${YELLOW}${prompt}${RESET} (type &#39;yes&#39; to continue, anything else to cancel): &quot; ans
  [[ &quot;$ans&quot; == &quot;yes&quot; ]] || { echo &quot;Cancelled by user.&quot;; return 1; }
}

need_sudo() {
  command -v sudo &gt;/dev/null 2&gt;&amp;1 || { echo &quot;Error: sudo required.&quot; &gt;&amp;2; exit 1; }
  sudo -v || { echo &quot;Error: sudo auth failed.&quot; &gt;&amp;2; exit 1; }
}

package_available() {
  local pkg=&quot;$1&quot;
  apt-cache policy &quot;$pkg&quot; 2&gt;/dev/null | awk &#39;/Candidate:/ {print $2}&#39; | grep -vq &quot;(none)&quot;
}

is_installed() { dpkg -s &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1; }

ensure_package() {
  local pkg=&quot;$1&quot;
  if is_installed &quot;$pkg&quot;; then
    log &quot;Package already installed: ${GREEN}${pkg}${RESET}&quot;
    return 0
  fi
  if ! package_available &quot;$pkg&quot;; then
    log &quot;Package not available (skipping): ${YELLOW}${pkg}${RESET}&quot;
    return 0
  fi
  log &quot;Installing package: ${GREEN}${pkg}${RESET}&quot;
  sudo apt-get install -y --no-install-recommends &quot;$pkg&quot; &gt;&gt;&quot;$LOG_FILE&quot; 2&gt;&amp;1 || {
    echo &quot;Error: Failed to install &#39;$pkg&#39;. ${CMD_FAIL_HINT}&quot; &gt;&amp;2
    exit 1
  }
}

ensure_packages() { for pkg in &quot;$@&quot;; do ensure_package &quot;$pkg&quot;; done; }

run_continue() {
  local title=&quot;$1&quot;; shift
  log &quot;\n--- $title ---&quot;
  &quot;$@&quot; &gt;&gt;&quot;$LOG_FILE&quot; 2&gt;&amp;1 || log &quot;  (Command failed but continuing): $*&quot;
}

run_fail() {
  local title=&quot;$1&quot;; shift
  log &quot;\n&gt;&gt;&gt; $title&quot;
  &quot;$@&quot; &gt;&gt;&quot;$LOG_FILE&quot; 2&gt;&amp;1 || { echo &quot;Error: $title failed. ${CMD_FAIL_HINT}&quot; &gt;&amp;2; exit 1; }
}

quick_net_check() {
  section &quot;Quick network check&quot;
  if command -v ping &gt;/dev/null 2&gt;&amp;1 &amp;&amp; ping -c1 -W &quot;$NET_TIMEOUT&quot; deb.debian.org &gt;/dev/null 2&gt;&amp;1; then
    log &quot;Network reachable.&quot;
    return 0
  fi
  log &quot;Network check failed; installs/downloads may be limited.&quot;
  return 1
}

check_platform() {
  section &quot;Platform checks&quot;
  local debver arch
  debver=&quot;$(cut -d&#39;.&#39; -f1 &lt; /etc/debian_version 2&gt;/dev/null || echo unknown)&quot;
  arch=&quot;$(uname -m 2&gt;/dev/null || echo unknown)&quot;
  log &quot;Debian major: $debver&quot;
  log &quot;Arch        : $arch&quot;
  [[ &quot;$debver&quot; == &quot;11&quot; ]] || log &quot;WARNING: tuned for Debian 11 (Bullseye).&quot;
  [[ &quot;$arch&quot; == &quot;aarch64&quot; || &quot;$arch&quot; == &quot;arm64&quot; ]] || log &quot;WARNING: tuned for ARM64.&quot;
}

enable_nonfree_optional() {
  section &quot;Optional: Enable contrib/non-free (Bullseye)&quot;
  if ! ask_yes &quot;Enable &#39;contrib non-free&#39; in /etc/apt/sources.list (backup + apt update)?&quot;; then
    log &quot;Skipped enabling contrib/non-free.&quot;
    return 0
  fi

  local src=&quot;/etc/apt/sources.list&quot;
  if [[ ! -f &quot;$src&quot; ]]; then
    log &quot;No $src found; skipping.&quot;
    return 0
  fi

  sudo cp -a &quot;$src&quot; &quot;${src}.bak.${START_TS}&quot;

  TMPDIR_CREATED=&quot;$(mktemp -d)&quot;
  local tmp=&quot;$TMPDIR_CREATED/sources.list&quot;

  sudo awk &#39;{
    if ($1==&quot;deb&quot; || $1==&quot;deb-src&quot;) {
      line=$0
      has_contrib=match(line,/(^| )contrib( |$)/)
      has_nonfree=match(line,/(^| )non-free( |$)/)
      if (!has_contrib) line=line&quot; contrib&quot;
      if (!has_nonfree) line=line&quot; non-free&quot;
      print line
    } else {
      print
    }
  }&#39; &quot;$src&quot; | sudo tee &quot;$tmp&quot; &gt;/dev/null

  sudo mv &quot;$tmp&quot; &quot;$src&quot;
  run_fail &quot;apt-get update (after enabling contrib/non-free)&quot; sudo apt-get update
  rm -rf &quot;$TMPDIR_CREATED&quot; || true
  TMPDIR_CREATED=&quot;&quot;
}

main() {
  ensure_dir &quot;$AUDIT_DIR&quot;; ensure_dir &quot;$LOG_DIR&quot;; ensure_dir &quot;$OUT_DIR&quot;
  : &gt;&quot;$LOG_FILE&quot;

  section &quot;Start&quot;
  log &quot;Audit directory: $AUDIT_DIR&quot;
  log &quot;Log file       : $LOG_FILE&quot;

  need_sudo

  {
    echo &quot;===== ENVIRONMENT =====&quot;
    echo &quot;Timestamp: $START_TS&quot;
    uname -a || true
    echo
    echo &quot;----- /etc/os-release -----&quot;
    cat /etc/os-release 2&gt;/dev/null || true
    echo
    echo &quot;----- /proc/cmdline -----&quot;
    cat /proc/cmdline 2&gt;/dev/null || true
    echo
    echo &quot;----- CPU -----&quot;
    lscpu 2&gt;/dev/null || true
    echo
    echo &quot;----- Memory/CMA -----&quot;
    grep -E &#39;CmaTotal|CmaFree|MemTotal|MemFree|HugePages&#39; /proc/meminfo 2&gt;/dev/null || true
  } &gt;&quot;$ENV_FILE&quot;

  run_continue &quot;Collect dmesg&quot; bash -lc &quot;sudo dmesg -T &gt; &#39;$DMESG_FILE&#39;&quot;

  check_platform
  quick_net_check || true

  section &quot;APT update&quot;
  run_fail &quot;apt-get update&quot; sudo apt-get update

  enable_nonfree_optional || true

  section &quot;Install baseline diagnostic tools (idempotent; skips unavailable)&quot;
  ensure_packages \
    curl wget ca-certificates \
    pciutils usbutils lshw hwinfo inxi \
    ethtool iproute2 net-tools jq \
    i2c-tools lm-sensors \
    v4l-utils \
    gstreamer1.0-tools gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly \
    ffmpeg alsa-utils \
    vulkan-tools mesa-utils kmscube \
    xrandr x11-xserver-utils autorandr \
    edid-decode read-edid ddcutil \
    fio hdparm nvme-cli smartmontools \
    iw wireless-tools bluez can-utils

  section &quot;System overview&quot;
  run_continue &quot;lshw (short)&quot; sudo lshw -short
  run_continue &quot;lsblk -O&quot; lsblk -O
  run_continue &quot;df -hT&quot; df -hT
  run_continue &quot;lsusb -t&quot; lsusb -t
  run_continue &quot;lspci -nnk&quot; lspci -nnk
  run_continue &quot;Kernel warnings/errors (last 200)&quot; bash -lc &#39;dmesg -T --level=err,warn | tail -n 200&#39;

  section &quot;GPU &amp; Display&quot;
  run_continue &quot;GPU modules loaded&quot; bash -lc &quot;lsmod | egrep -i &#39;panthor|panfrost|mali|kbase&#39; || true&quot;
  run_continue &quot;GPU-related dmesg&quot; bash -lc &quot;dmesg -T | egrep -i &#39;mali|panthor|panfrost|csf|gpu&#39; || true&quot;
  run_continue &quot;DRM connectors (modetest -c)&quot; modetest -c
  run_continue &quot;kmscube smoke test&quot; bash -lc &quot;kmscube -i 100 &gt;/dev/null 2&gt;&amp;1 || true&quot;
  run_continue &quot;Vulkan summary&quot; vulkaninfo --summary
  run_continue &quot;xrandr --props (if X running)&quot; bash -lc &quot;DISPLAY=\${DISPLAY:-:0} xrandr --props 2&gt;/dev/null || true&quot;

  section &quot;Video / V4L2 / Codecs&quot;
  run_continue &quot;List V4L2 devices&quot; v4l2-ctl --list-devices
  run_continue &quot;FFmpeg hwaccels&quot; ffmpeg -hide_banner -hwaccels
  run_continue &quot;GStreamer rockchip-ish plugins&quot; bash -lc &quot;gst-inspect-1.0 | egrep -i &#39;v4l2|rkv|hantro|rockchip&#39; || true&quot;

  section &quot;Audio&quot;
  run_continue &quot;ALSA playback&quot; aplay -l
  run_continue &quot;ALSA capture&quot; arecord -l

  section &quot;Network&quot;
  run_continue &quot;ip -details addr&quot; ip -details address
  run_continue &quot;iw dev&quot; iw dev

  section &quot;Storage&quot;
  run_continue &quot;lsblk (model/serial)&quot; lsblk -o NAME,SIZE,TYPE,MOUNTPOINTS,MODEL,SERIAL,TRAN
  run_continue &quot;SATA/NVMe/PCIe dmesg&quot; bash -lc &quot;dmesg -T | egrep -i &#39;sata|ahci|nvme|pcie&#39; || true&quot;
  run_continue &quot;nvme list (if any)&quot; bash -lc &quot;ls /dev/nvme*n1 &gt;/dev/null 2&gt;&amp;1 &amp;&amp; sudo nvme list || true&quot;

  section &quot;Optional actions&quot;
  if ask_yes &quot;Run powertop --auto-tune (changes power tunables until reboot)?&quot;; then
    run_fail &quot;powertop --auto-tune&quot; sudo powertop --auto-tune
  fi
  if ask_yes &quot;Run sensors-detect (interactive; may load modules)?&quot;; then
    run_fail &quot;sensors-detect&quot; sudo sensors-detect
  fi
  if ask_yes &quot;Run quick fio seq read/write in $HOME (~${FIO_SIZE_MB}MB temp file, then removed)?&quot;; then
    TMPDIR_CREATED=&quot;$(mktemp -d)&quot;
    local fiofile=&quot;$TMPDIR_CREATED/fio_test.dat&quot;
    run_fail &quot;dd create file&quot; dd if=/dev/zero of=&quot;$fiofile&quot; bs=1M count=&quot;$FIO_SIZE_MB&quot; status=none
    run_fail &quot;fio seq rw&quot; fio --name=seqrw --filename=&quot;$fiofile&quot; --rw=readwrite --bs=&quot;$FIO_BS&quot; --direct=1 --numjobs=1 --iodepth=&quot;$FIO_IODEPTH&quot; --size=&quot;${FIO_SIZE_MB}M&quot; --group_reporting
    rm -rf &quot;$TMPDIR_CREATED&quot; || true
    TMPDIR_CREATED=&quot;&quot;
  fi

  section &quot;REPORT.md&quot;
  {
    echo &quot;# RK3588 Capability Audit — $START_TS&quot;
    echo
    echo &quot;Audit directory: $AUDIT_DIR&quot;
    echo &quot;Log file: $LOG_FILE&quot;
    echo &quot;Env snapshot: $ENV_FILE&quot;
    echo &quot;dmesg: $DMESG_FILE&quot;
  } &gt;&quot;$REPORT_MD&quot;

  ( cd &quot;$HOME&quot; &amp;&amp; tar czf &quot;${AUDIT_DIR}.tar.gz&quot; &quot;$(basename &quot;$AUDIT_DIR&quot;)&quot; )

  section &quot;Done&quot;
  log &quot;Report : $REPORT_MD&quot;
  log &quot;Archive: ${AUDIT_DIR}.tar.gz&quot;
}

main &quot;$@&quot;</code>
</section>
  <h1 id="homelinarork3588-display-toolkitbinrk3588_autorandr_bootstrapsh">
    
    
     <a href="#homelinarork3588-display-toolkitbinrk3588_autorandr_bootstrapsh">#</a><a href="#" aria-label="Back to top">/home/linaro/rk3588-display-toolkit/bin/rk3588_autorandr_bootstrap.sh</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label=" Code Block" data-filename="_code_block.txt" data-code="#!/usr/bin/env bash
set -euo pipefail
IFS=$&#39;\n\t&#39;

# rk3588_autorandr_bootstrap.sh
#
# Fixes vs. original:
#   - Works when launched as root *or* as an unprivileged user (fixes &quot;Failed to connect to bus&quot;).
#   - Protects existing preswitch hooks generated by setup scripts (Stage 1 protection).
#   - Treats xrandr correctly on Debian 11 (x11-xserver-utils).
#   - Performs &quot;offline enable&quot; for systemd units when running as root.
#   - Adds a login wrapper to wait for the X11 display server.
#
# Optional inputs:
#   AUTORANDR_PROFILE=&lt;name&gt;
#   TARGET_USER=&lt;username&gt;
#   ASSUME_YES=1
#   TOOLKIT_HOME=&lt;path&gt;
#
# CLI flags:
#   --profile &lt;name&gt;
#   --user &lt;username&gt;
#   --yes

AUTORANDR_PROFILE=&quot;${AUTORANDR_PROFILE:-}&quot;
TARGET_USER=&quot;${TARGET_USER:-${SUDO_USER:-${USER:-}}}&quot;
ASSUME_YES=&quot;${ASSUME_YES:-0}&quot;
TOOLKIT_HOME=&quot;${TOOLKIT_HOME:-}&quot;

log() { printf &#39;[%(%F %T)T] %s\n&#39; -1 &quot;$*&quot;; }
err() { printf &#39;[%(%F %T)T] ERROR: %s\n&#39; -1 &quot;$*&quot; &gt;&amp;2; }
warn() { printf &#39;[%(%F %T)T] WARN: %s\n&#39; -1 &quot;$*&quot; &gt;&amp;2; }

have_cmd() { command -v &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1; }

usage() {
  cat &lt;&lt;&#39;USAGE&#39;
Usage: rk3588_autorandr_bootstrap.sh [--profile NAME] [--user USER] [--yes]

Environment:
  AUTORANDR_PROFILE   Profile to use (otherwise you will be prompted)
  TARGET_USER         User whose autorandr/autostart/systemd-user config will be modified
  ASSUME_YES=1        Non-interactive: assume “yes” to confirmation prompts
  TOOLKIT_HOME        Toolkit dir (defaults to ~TARGET_USER/rk3588-display-toolkit)
USAGE
}

confirm_yes() {
  local msg=&quot;$1&quot; ans
  if [[ &quot;$ASSUME_YES&quot; == &quot;1&quot; ]]; then
    log &quot;ASSUME_YES=1 -&gt; auto-accept: $msg&quot;
    return 0
  fi
  echo
  echo &quot;WARNING: $msg&quot;
  read -r -p &quot;Type &#39;yes&#39; to continue, anything else to cancel: &quot; ans
  [[ &quot;$ans&quot; == &quot;yes&quot; ]] || { err &quot;Cancelled by user.&quot;; return 1; }
}

# ----- privilege helpers -----
SUDO=&quot;&quot;
if [[ &quot;${EUID:-$(id -u)}&quot; -ne 0 ]]; then
  have_cmd sudo || { err &quot;sudo is required (or run as root).&quot;; exit 1; }
  sudo -v || { err &quot;sudo authentication failed.&quot;; exit 1; }
  SUDO=&quot;sudo&quot;
fi

# ----- parse args -----
while [[ $# -gt 0 ]]; do
  case &quot;$1&quot; in
    --profile)
      shift; AUTORANDR_PROFILE=&quot;${1:-}&quot;;;
    --user)
      shift; TARGET_USER=&quot;${1:-}&quot;;;
    --yes)
      ASSUME_YES=1;;
    -h|--help)
      usage; exit 0;;
    *)
      err &quot;Unknown argument: $1&quot;; usage; exit 2;;
  esac
  shift || true
done

# ----- target user/home resolution -----
TARGET_HOME=&quot;&quot;
resolve_target_user() {
  local u=&quot;$TARGET_USER&quot;

  if [[ -z &quot;$u&quot; ]]; then
    u=&quot;$USER&quot;
  fi

  # If running as root and no meaningful target is set, pick the first regular user.
  if [[ &quot;${EUID:-$(id -u)}&quot; -eq 0 &amp;&amp; ( -z &quot;$u&quot; || &quot;$u&quot; == &quot;root&quot; ) ]]; then
    u=&quot;$(getent passwd | awk -F: &#39;$3&gt;=1000 &amp;&amp; $3&lt;60000 &amp;&amp; $6 ~ /^\// {print $1; exit}&#39;)&quot; || true
    if [[ -z &quot;$u&quot; ]]; then
      err &quot;Running as root but no non-root TARGET_USER could be auto-detected. Set TARGET_USER=&lt;user&gt;.&quot;
      exit 1
    fi
    if ! confirm_yes &quot;You are running as root. This script will configure autorandr/autostart/user-units for user &#39;$u&#39;. Proceed?&quot;; then
      exit 1
    fi
  fi

  if ! getent passwd &quot;$u&quot; &gt;/dev/null; then
    err &quot;Target user does not exist: $u&quot;
    exit 1
  fi

  TARGET_USER=&quot;$u&quot;
  TARGET_HOME=&quot;$(getent passwd &quot;$TARGET_USER&quot; | awk -F: &#39;{print $6}&#39;)&quot;

  if [[ -z &quot;$TARGET_HOME&quot; || ! -d &quot;$TARGET_HOME&quot; ]]; then
    err &quot;Could not resolve home directory for user &#39;$TARGET_USER&#39;&quot;
    exit 1
  fi

  if [[ -z &quot;$TOOLKIT_HOME&quot; ]]; then
    TOOLKIT_HOME=&quot;$TARGET_HOME/rk3588-display-toolkit&quot;
  fi
}

run_as_target() {
  if [[ &quot;${EUID:-$(id -u)}&quot; -eq 0 &amp;&amp; &quot;$TARGET_USER&quot; != &quot;root&quot; ]]; then
    sudo -u &quot;$TARGET_USER&quot; -H &quot;$@&quot;
  else
    &quot;$@&quot;
  fi
}

chown_target() {
  local path=&quot;$1&quot;
  if [[ &quot;${EUID:-$(id -u)}&quot; -eq 0 &amp;&amp; &quot;$TARGET_USER&quot; != &quot;root&quot; ]]; then
    chown -R &quot;$TARGET_USER:$TARGET_USER&quot; &quot;$path&quot; 2&gt;/dev/null || true
  fi
}

# ----- apt helpers -----
pkg_installed() { dpkg -s &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1; }
package_available() {
  have_cmd apt-cache || return 1
  apt-cache policy &quot;$1&quot; 2&gt;/dev/null | awk &#39;/Candidate:/ {print $2}&#39; | grep -vq &quot;(none)&quot;
}

apt_install_if_missing() {
  local pkg=&quot;$1&quot;
  if pkg_installed &quot;$pkg&quot;; then
    log &quot;Package already installed: $pkg&quot;
    return 0
  fi
  if ! package_available &quot;$pkg&quot;; then
    log &quot;Package not available in APT sources (skipping): $pkg&quot;
    return 0
  fi
  log &quot;Installing package: $pkg&quot;
  ${SUDO} DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends &quot;$pkg&quot;
}

ensure_deps() {
  log &quot;Ensuring dependencies...&quot;
  ${SUDO} apt-get update

  # On Debian 11, /usr/bin/xrandr is shipped by x11-xserver-utils.
  apt_install_if_missing autorandr
  apt_install_if_missing x11-xserver-utils

  # If the xrandr binary is still missing (rare/minimal setups), try the standalone package if the repo has it.
  if ! have_cmd xrandr; then
    log &quot;xrandr binary not found after installing x11-xserver-utils; attempting standalone xrandr package if available...&quot;
    apt_install_if_missing xrandr
  fi

  have_cmd autorandr || { err &quot;autorandr is still missing after install attempts.&quot;; exit 1; }
  have_cmd xrandr || log &quot;NOTE: xrandr not found. autorandr will not work in X11 sessions until xrandr is available.&quot; 
}

# ----- profile selection/validation (from target user&#39;s config) -----
list_profiles() {
  local dir=&quot;$TARGET_HOME/.config/autorandr&quot;
  [[ -d &quot;$dir&quot; ]] || return 0
  find &quot;$dir&quot; -mindepth 1 -maxdepth 1 -type d -printf &#39;%f\n&#39; 2&gt;/dev/null | sort
}

choose_profile() {
  if [[ -n &quot;$AUTORANDR_PROFILE&quot; ]]; then
    return 0
  fi

  log &quot;Available autorandr profiles for user &#39;$TARGET_USER&#39;:&quot;
  local profiles
  profiles=&quot;$(list_profiles || true)&quot;

  if [[ -z &quot;$profiles&quot; ]]; then
    err &quot;No autorandr profiles found in $TARGET_HOME/.config/autorandr&quot;
    err &quot;Create one first (e.g. &#39;autorandr --save &lt;name&gt;&#39; from within an X11 session).&quot;
    exit 1
  fi

  echo &quot;$profiles&quot; | sed &#39;s/^/ - /&#39;
  read -r -p &quot;Enter the profile name to use: &quot; AUTORANDR_PROFILE
  [[ -n &quot;$AUTORANDR_PROFILE&quot; ]] || { err &quot;No profile provided&quot;; exit 1; }
}

validate_profile_exists() {
  local dir=&quot;$TARGET_HOME/.config/autorandr/$AUTORANDR_PROFILE&quot;
  if [[ ! -d &quot;$dir&quot; ]]; then
    err &quot;Profile &#39;$AUTORANDR_PROFILE&#39; does not exist in $TARGET_HOME/.config/autorandr&quot;
    exit 1
  fi
}

# ----- installs -----
install_preswitch_hook() {
  log &quot;Installing preswitch hook template for profile: $AUTORANDR_PROFILE (user: $TARGET_USER)&quot;
  local ar_dir=&quot;$TARGET_HOME/.config/autorandr/$AUTORANDR_PROFILE&quot;
  mkdir -p &quot;$ar_dir&quot;

  local hook=&quot;$ar_dir/preswitch&quot;

  # FIX: Don&#39;t overwrite existing hooks blindly.
  # This prevents destroying the custom modeline setup generated by rk3588_dual_display_setup.sh
  if [[ -s &quot;$hook&quot; ]]; then
    warn &quot;A preswitch hook already exists at $hook&quot;
    if ! confirm_yes &quot;Overwrite existing preswitch hook with default template? (Select NO if you used the setup script)&quot;; then
      log &quot;Skipping preswitch hook installation (keeping existing configuration).&quot;
      chown_target &quot;$ar_dir&quot;
      return 0
    fi
    # Backup if overwriting
    cp -a &quot;$hook&quot; &quot;${hook}.bak.$(date +%Y%m%d_%H%M%S)&quot; || true
  fi

  cat &gt;&quot;$hook&quot; &lt;&lt;&#39;SH&#39;
#!/bin/sh

# autorandr preswitch hook (template)
# Runs before switching to the profile.
# Use this to (re-)add custom modelines if your hardware/firmware forgets them.

# Example:
# xrandr --newmode &quot;1920x1080_60.00&quot; ... || true
# xrandr --addmode HDMI-1 &quot;1920x1080_60.00&quot; || true

exit 0
SH
  chmod +x &quot;$hook&quot;
  chown_target &quot;$ar_dir&quot;
  log &quot;Hook installed: $hook&quot;
}

install_wrapper_script() {
  # A tiny helper that waits until xrandr can talk to the X server before running autorandr.
  local bin_dir=&quot;$TARGET_HOME/.local/bin&quot;
  local wrapper=&quot;$bin_dir/autorandr-change&quot;

  mkdir -p &quot;$bin_dir&quot;

  cat &gt;&quot;$wrapper&quot; &lt;&lt;&#39;SH&#39;
#!/usr/bin/env bash
set -euo pipefail

# Wait until we have a working DISPLAY and xrandr can query it.
# This makes autorandr more reliable at login across different desktop environments.

AUTORANDR_BIN=&quot;${AUTORANDR_BIN:-/usr/bin/autorandr}&quot;
XRANDR_BIN=&quot;${XRANDR_BIN:-/usr/bin/xrandr}&quot;
MAX_WAIT_SECONDS=&quot;${MAX_WAIT_SECONDS:-20}&quot;

if [[ -z &quot;${DISPLAY:-}&quot; ]]; then
  echo &quot;autorandr-change: DISPLAY is not set; nothing to do.&quot; &gt;&amp;2
  exit 0
fi

# Some environments don&#39;t export XAUTHORITY for systemd user units;
# if it&#39;s missing, fall back to ~/.Xauthority.
if [[ -z &quot;${XAUTHORITY:-}&quot; &amp;&amp; -f &quot;$HOME/.Xauthority&quot; ]]; then
  export XAUTHORITY=&quot;$HOME/.Xauthority&quot;
fi

for ((i=0; i&lt;MAX_WAIT_SECONDS; i++)); do
  if &quot;$XRANDR_BIN&quot; --current &gt;/dev/null 2&gt;&amp;1; then
    exec &quot;$AUTORANDR_BIN&quot; --change
  fi
  sleep 1
done

echo &quot;autorandr-change: timed out waiting for xrandr to become ready (DISPLAY=$DISPLAY).&quot; &gt;&amp;2
exit 0
SH

  chmod +x &quot;$wrapper&quot;
  chown_target &quot;$bin_dir&quot;
  log &quot;Installed wrapper: $wrapper&quot;
}

install_xdg_autostart() {
  local auto_dir=&quot;$TARGET_HOME/.config/autostart&quot;
  local desktop_file=&quot;$auto_dir/autorandr-change.desktop&quot;

  mkdir -p &quot;$auto_dir&quot;

  if [[ -f &quot;$desktop_file&quot; ]]; then
    if ! confirm_yes &quot;This will overwrite $desktop_file (a backup will be created). Proceed?&quot;; then
      log &quot;Skipped XDG autostart.&quot;
      return 0
    fi
    cp -a &quot;$desktop_file&quot; &quot;${desktop_file}.bak.$(date +%Y%m%d_%H%M%S)&quot; || true
  fi

  # Use wrapper to avoid race conditions at login.
  cat &gt;&quot;$desktop_file&quot; &lt;&lt;&#39;DESKTOP&#39;
[Desktop Entry]
Type=Application
Name=Autorandr Apply
Comment=Apply autorandr profile at login
Exec=%h/.local/bin/autorandr-change
X-GNOME-Autostart-enabled=true
DESKTOP

  chown_target &quot;$auto_dir&quot;
  log &quot;Installed XDG autostart: $desktop_file&quot;
}

install_systemd_user_unit() {
  local unit_dir=&quot;$TARGET_HOME/.config/systemd/user&quot;
  local unit_file=&quot;$unit_dir/autorandr-change.service&quot;
  local wants_dir=&quot;$unit_dir/default.target.wants&quot;

  mkdir -p &quot;$unit_dir&quot; &quot;$wants_dir&quot;

  if [[ -f &quot;$unit_file&quot; ]]; then
    if ! confirm_yes &quot;This will overwrite $unit_file (a backup will be created). Proceed?&quot;; then
      log &quot;Skipped systemd user unit.&quot;
      return 0
    fi
    cp -a &quot;$unit_file&quot; &quot;${unit_file}.bak.$(date +%Y%m%d_%H%M%S)&quot; || true
  fi

  cat &gt;&quot;$unit_file&quot; &lt;&lt;&#39;UNIT&#39;
[Unit]
Description=Apply autorandr profile (login)

# If graphical-session.target exists in the user manager, order after it.
After=graphical-session.target

[Service]
Type=oneshot
ExecStart=%h/.local/bin/autorandr-change

[Install]
WantedBy=default.target
UNIT

  # Offline enable: create the symlink systemctl --user enable would create.
  ln -sf ../autorandr-change.service &quot;$wants_dir/autorandr-change.service&quot;

  chown_target &quot;$unit_dir&quot;

  # If we&#39;re *already* in the user&#39;s session bus, also run daemon-reload.
  if run_as_target systemctl --user show-environment &gt;/dev/null 2&gt;&amp;1; then
    run_as_target systemctl --user daemon-reload || true
  fi

  log &quot;Installed systemd user unit: $unit_file&quot;
  log &quot;Enabled (offline) via symlink: $wants_dir/autorandr-change.service&quot;
}

enable_system_services_if_present() {
  # These units vary by distro/package; enable only if they exist.
  if ${SUDO} systemctl list-unit-files 2&gt;/dev/null | grep -q &#39;^autorandr\.service&#39;; then
    if confirm_yes &quot;Enable system-wide autorandr.service now?&quot;; then
      ${SUDO} systemctl enable --now autorandr.service || true
    fi
  fi
  if ${SUDO} systemctl list-unit-files 2&gt;/dev/null | grep -q &#39;^autorandr-resume\.service&#39;; then
    if confirm_yes &quot;Enable system-wide autorandr-resume.service now?&quot;; then
      ${SUDO} systemctl enable --now autorandr-resume.service || true
    fi
  fi
}

try_apply_now() {
  if [[ -z &quot;${DISPLAY:-}&quot; ]]; then
    log &quot;DISPLAY not set; skipping immediate autorandr apply.&quot;
    return 0
  fi

  log &quot;DISPLAY is set; attempting autorandr apply now...&quot;

  # Prefer wrapper (waits for xrandr readiness).
  local wrapper=&quot;$TARGET_HOME/.local/bin/autorandr-change&quot;
  local xauth=&quot;${XAUTHORITY:-$TARGET_HOME/.Xauthority}&quot;

  if [[ -x &quot;$wrapper&quot; ]]; then
    if ! run_as_target env DISPLAY=&quot;$DISPLAY&quot; XAUTHORITY=&quot;$xauth&quot; &quot;$wrapper&quot;; then
      err &quot;autorandr apply failed in-session (you can run &#39;$wrapper&#39; manually later).&quot;
      return 0
    fi
  else
    if ! run_as_target env DISPLAY=&quot;$DISPLAY&quot; XAUTHORITY=&quot;$xauth&quot; /usr/bin/autorandr --change; then
      err &quot;autorandr --change failed in-session (you can run it manually later).&quot;
      return 0
    fi
  fi

  log &quot;autorandr applied.&quot;
}

main() {
  resolve_target_user
  log &quot;Target user: $TARGET_USER&quot;
  log &quot;Target home: $TARGET_HOME&quot;

  ensure_deps
  choose_profile
  validate_profile_exists

  install_preswitch_hook
  install_wrapper_script

  if confirm_yes &quot;Enable system-wide autorandr services (if present)?&quot;; then
    enable_system_services_if_present
  fi

  if confirm_yes &quot;Install XDG autostart entry to run autorandr at login (recommended for desktop environments)?&quot;; then
    install_xdg_autostart
  fi

  if confirm_yes &quot;Install a systemd user unit to run autorandr at login (works even without DBUS during install)?&quot;; then
    install_systemd_user_unit
  fi

  try_apply_now

  log &quot;Done. Profile selected: $AUTORANDR_PROFILE&quot;
  log &quot;Profile config path: $TARGET_HOME/.config/autorandr/$AUTORANDR_PROFILE&quot;
}

main &quot;$@&quot;" data-download-link="" data-download-label="Download ">
  <code class="language-">#!/usr/bin/env bash
set -euo pipefail
IFS=$&#39;\n\t&#39;

# rk3588_autorandr_bootstrap.sh
#
# Fixes vs. original:
#   - Works when launched as root *or* as an unprivileged user (fixes &quot;Failed to connect to bus&quot;).
#   - Protects existing preswitch hooks generated by setup scripts (Stage 1 protection).
#   - Treats xrandr correctly on Debian 11 (x11-xserver-utils).
#   - Performs &quot;offline enable&quot; for systemd units when running as root.
#   - Adds a login wrapper to wait for the X11 display server.
#
# Optional inputs:
#   AUTORANDR_PROFILE=&lt;name&gt;
#   TARGET_USER=&lt;username&gt;
#   ASSUME_YES=1
#   TOOLKIT_HOME=&lt;path&gt;
#
# CLI flags:
#   --profile &lt;name&gt;
#   --user &lt;username&gt;
#   --yes

AUTORANDR_PROFILE=&quot;${AUTORANDR_PROFILE:-}&quot;
TARGET_USER=&quot;${TARGET_USER:-${SUDO_USER:-${USER:-}}}&quot;
ASSUME_YES=&quot;${ASSUME_YES:-0}&quot;
TOOLKIT_HOME=&quot;${TOOLKIT_HOME:-}&quot;

log() { printf &#39;[%(%F %T)T] %s\n&#39; -1 &quot;$*&quot;; }
err() { printf &#39;[%(%F %T)T] ERROR: %s\n&#39; -1 &quot;$*&quot; &gt;&amp;2; }
warn() { printf &#39;[%(%F %T)T] WARN: %s\n&#39; -1 &quot;$*&quot; &gt;&amp;2; }

have_cmd() { command -v &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1; }

usage() {
  cat &lt;&lt;&#39;USAGE&#39;
Usage: rk3588_autorandr_bootstrap.sh [--profile NAME] [--user USER] [--yes]

Environment:
  AUTORANDR_PROFILE   Profile to use (otherwise you will be prompted)
  TARGET_USER         User whose autorandr/autostart/systemd-user config will be modified
  ASSUME_YES=1        Non-interactive: assume “yes” to confirmation prompts
  TOOLKIT_HOME        Toolkit dir (defaults to ~TARGET_USER/rk3588-display-toolkit)
USAGE
}

confirm_yes() {
  local msg=&quot;$1&quot; ans
  if [[ &quot;$ASSUME_YES&quot; == &quot;1&quot; ]]; then
    log &quot;ASSUME_YES=1 -&gt; auto-accept: $msg&quot;
    return 0
  fi
  echo
  echo &quot;WARNING: $msg&quot;
  read -r -p &quot;Type &#39;yes&#39; to continue, anything else to cancel: &quot; ans
  [[ &quot;$ans&quot; == &quot;yes&quot; ]] || { err &quot;Cancelled by user.&quot;; return 1; }
}

# ----- privilege helpers -----
SUDO=&quot;&quot;
if [[ &quot;${EUID:-$(id -u)}&quot; -ne 0 ]]; then
  have_cmd sudo || { err &quot;sudo is required (or run as root).&quot;; exit 1; }
  sudo -v || { err &quot;sudo authentication failed.&quot;; exit 1; }
  SUDO=&quot;sudo&quot;
fi

# ----- parse args -----
while [[ $# -gt 0 ]]; do
  case &quot;$1&quot; in
    --profile)
      shift; AUTORANDR_PROFILE=&quot;${1:-}&quot;;;
    --user)
      shift; TARGET_USER=&quot;${1:-}&quot;;;
    --yes)
      ASSUME_YES=1;;
    -h|--help)
      usage; exit 0;;
    *)
      err &quot;Unknown argument: $1&quot;; usage; exit 2;;
  esac
  shift || true
done

# ----- target user/home resolution -----
TARGET_HOME=&quot;&quot;
resolve_target_user() {
  local u=&quot;$TARGET_USER&quot;

  if [[ -z &quot;$u&quot; ]]; then
    u=&quot;$USER&quot;
  fi

  # If running as root and no meaningful target is set, pick the first regular user.
  if [[ &quot;${EUID:-$(id -u)}&quot; -eq 0 &amp;&amp; ( -z &quot;$u&quot; || &quot;$u&quot; == &quot;root&quot; ) ]]; then
    u=&quot;$(getent passwd | awk -F: &#39;$3&gt;=1000 &amp;&amp; $3&lt;60000 &amp;&amp; $6 ~ /^\// {print $1; exit}&#39;)&quot; || true
    if [[ -z &quot;$u&quot; ]]; then
      err &quot;Running as root but no non-root TARGET_USER could be auto-detected. Set TARGET_USER=&lt;user&gt;.&quot;
      exit 1
    fi
    if ! confirm_yes &quot;You are running as root. This script will configure autorandr/autostart/user-units for user &#39;$u&#39;. Proceed?&quot;; then
      exit 1
    fi
  fi

  if ! getent passwd &quot;$u&quot; &gt;/dev/null; then
    err &quot;Target user does not exist: $u&quot;
    exit 1
  fi

  TARGET_USER=&quot;$u&quot;
  TARGET_HOME=&quot;$(getent passwd &quot;$TARGET_USER&quot; | awk -F: &#39;{print $6}&#39;)&quot;

  if [[ -z &quot;$TARGET_HOME&quot; || ! -d &quot;$TARGET_HOME&quot; ]]; then
    err &quot;Could not resolve home directory for user &#39;$TARGET_USER&#39;&quot;
    exit 1
  fi

  if [[ -z &quot;$TOOLKIT_HOME&quot; ]]; then
    TOOLKIT_HOME=&quot;$TARGET_HOME/rk3588-display-toolkit&quot;
  fi
}

run_as_target() {
  if [[ &quot;${EUID:-$(id -u)}&quot; -eq 0 &amp;&amp; &quot;$TARGET_USER&quot; != &quot;root&quot; ]]; then
    sudo -u &quot;$TARGET_USER&quot; -H &quot;$@&quot;
  else
    &quot;$@&quot;
  fi
}

chown_target() {
  local path=&quot;$1&quot;
  if [[ &quot;${EUID:-$(id -u)}&quot; -eq 0 &amp;&amp; &quot;$TARGET_USER&quot; != &quot;root&quot; ]]; then
    chown -R &quot;$TARGET_USER:$TARGET_USER&quot; &quot;$path&quot; 2&gt;/dev/null || true
  fi
}

# ----- apt helpers -----
pkg_installed() { dpkg -s &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1; }
package_available() {
  have_cmd apt-cache || return 1
  apt-cache policy &quot;$1&quot; 2&gt;/dev/null | awk &#39;/Candidate:/ {print $2}&#39; | grep -vq &quot;(none)&quot;
}

apt_install_if_missing() {
  local pkg=&quot;$1&quot;
  if pkg_installed &quot;$pkg&quot;; then
    log &quot;Package already installed: $pkg&quot;
    return 0
  fi
  if ! package_available &quot;$pkg&quot;; then
    log &quot;Package not available in APT sources (skipping): $pkg&quot;
    return 0
  fi
  log &quot;Installing package: $pkg&quot;
  ${SUDO} DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends &quot;$pkg&quot;
}

ensure_deps() {
  log &quot;Ensuring dependencies...&quot;
  ${SUDO} apt-get update

  # On Debian 11, /usr/bin/xrandr is shipped by x11-xserver-utils.
  apt_install_if_missing autorandr
  apt_install_if_missing x11-xserver-utils

  # If the xrandr binary is still missing (rare/minimal setups), try the standalone package if the repo has it.
  if ! have_cmd xrandr; then
    log &quot;xrandr binary not found after installing x11-xserver-utils; attempting standalone xrandr package if available...&quot;
    apt_install_if_missing xrandr
  fi

  have_cmd autorandr || { err &quot;autorandr is still missing after install attempts.&quot;; exit 1; }
  have_cmd xrandr || log &quot;NOTE: xrandr not found. autorandr will not work in X11 sessions until xrandr is available.&quot; 
}

# ----- profile selection/validation (from target user&#39;s config) -----
list_profiles() {
  local dir=&quot;$TARGET_HOME/.config/autorandr&quot;
  [[ -d &quot;$dir&quot; ]] || return 0
  find &quot;$dir&quot; -mindepth 1 -maxdepth 1 -type d -printf &#39;%f\n&#39; 2&gt;/dev/null | sort
}

choose_profile() {
  if [[ -n &quot;$AUTORANDR_PROFILE&quot; ]]; then
    return 0
  fi

  log &quot;Available autorandr profiles for user &#39;$TARGET_USER&#39;:&quot;
  local profiles
  profiles=&quot;$(list_profiles || true)&quot;

  if [[ -z &quot;$profiles&quot; ]]; then
    err &quot;No autorandr profiles found in $TARGET_HOME/.config/autorandr&quot;
    err &quot;Create one first (e.g. &#39;autorandr --save &lt;name&gt;&#39; from within an X11 session).&quot;
    exit 1
  fi

  echo &quot;$profiles&quot; | sed &#39;s/^/ - /&#39;
  read -r -p &quot;Enter the profile name to use: &quot; AUTORANDR_PROFILE
  [[ -n &quot;$AUTORANDR_PROFILE&quot; ]] || { err &quot;No profile provided&quot;; exit 1; }
}

validate_profile_exists() {
  local dir=&quot;$TARGET_HOME/.config/autorandr/$AUTORANDR_PROFILE&quot;
  if [[ ! -d &quot;$dir&quot; ]]; then
    err &quot;Profile &#39;$AUTORANDR_PROFILE&#39; does not exist in $TARGET_HOME/.config/autorandr&quot;
    exit 1
  fi
}

# ----- installs -----
install_preswitch_hook() {
  log &quot;Installing preswitch hook template for profile: $AUTORANDR_PROFILE (user: $TARGET_USER)&quot;
  local ar_dir=&quot;$TARGET_HOME/.config/autorandr/$AUTORANDR_PROFILE&quot;
  mkdir -p &quot;$ar_dir&quot;

  local hook=&quot;$ar_dir/preswitch&quot;

  # FIX: Don&#39;t overwrite existing hooks blindly.
  # This prevents destroying the custom modeline setup generated by rk3588_dual_display_setup.sh
  if [[ -s &quot;$hook&quot; ]]; then
    warn &quot;A preswitch hook already exists at $hook&quot;
    if ! confirm_yes &quot;Overwrite existing preswitch hook with default template? (Select NO if you used the setup script)&quot;; then
      log &quot;Skipping preswitch hook installation (keeping existing configuration).&quot;
      chown_target &quot;$ar_dir&quot;
      return 0
    fi
    # Backup if overwriting
    cp -a &quot;$hook&quot; &quot;${hook}.bak.$(date +%Y%m%d_%H%M%S)&quot; || true
  fi

  cat &gt;&quot;$hook&quot; &lt;&lt;&#39;SH&#39;
#!/bin/sh

# autorandr preswitch hook (template)
# Runs before switching to the profile.
# Use this to (re-)add custom modelines if your hardware/firmware forgets them.

# Example:
# xrandr --newmode &quot;1920x1080_60.00&quot; ... || true
# xrandr --addmode HDMI-1 &quot;1920x1080_60.00&quot; || true

exit 0
SH
  chmod +x &quot;$hook&quot;
  chown_target &quot;$ar_dir&quot;
  log &quot;Hook installed: $hook&quot;
}

install_wrapper_script() {
  # A tiny helper that waits until xrandr can talk to the X server before running autorandr.
  local bin_dir=&quot;$TARGET_HOME/.local/bin&quot;
  local wrapper=&quot;$bin_dir/autorandr-change&quot;

  mkdir -p &quot;$bin_dir&quot;

  cat &gt;&quot;$wrapper&quot; &lt;&lt;&#39;SH&#39;
#!/usr/bin/env bash
set -euo pipefail

# Wait until we have a working DISPLAY and xrandr can query it.
# This makes autorandr more reliable at login across different desktop environments.

AUTORANDR_BIN=&quot;${AUTORANDR_BIN:-/usr/bin/autorandr}&quot;
XRANDR_BIN=&quot;${XRANDR_BIN:-/usr/bin/xrandr}&quot;
MAX_WAIT_SECONDS=&quot;${MAX_WAIT_SECONDS:-20}&quot;

if [[ -z &quot;${DISPLAY:-}&quot; ]]; then
  echo &quot;autorandr-change: DISPLAY is not set; nothing to do.&quot; &gt;&amp;2
  exit 0
fi

# Some environments don&#39;t export XAUTHORITY for systemd user units;
# if it&#39;s missing, fall back to ~/.Xauthority.
if [[ -z &quot;${XAUTHORITY:-}&quot; &amp;&amp; -f &quot;$HOME/.Xauthority&quot; ]]; then
  export XAUTHORITY=&quot;$HOME/.Xauthority&quot;
fi

for ((i=0; i&lt;MAX_WAIT_SECONDS; i++)); do
  if &quot;$XRANDR_BIN&quot; --current &gt;/dev/null 2&gt;&amp;1; then
    exec &quot;$AUTORANDR_BIN&quot; --change
  fi
  sleep 1
done

echo &quot;autorandr-change: timed out waiting for xrandr to become ready (DISPLAY=$DISPLAY).&quot; &gt;&amp;2
exit 0
SH

  chmod +x &quot;$wrapper&quot;
  chown_target &quot;$bin_dir&quot;
  log &quot;Installed wrapper: $wrapper&quot;
}

install_xdg_autostart() {
  local auto_dir=&quot;$TARGET_HOME/.config/autostart&quot;
  local desktop_file=&quot;$auto_dir/autorandr-change.desktop&quot;

  mkdir -p &quot;$auto_dir&quot;

  if [[ -f &quot;$desktop_file&quot; ]]; then
    if ! confirm_yes &quot;This will overwrite $desktop_file (a backup will be created). Proceed?&quot;; then
      log &quot;Skipped XDG autostart.&quot;
      return 0
    fi
    cp -a &quot;$desktop_file&quot; &quot;${desktop_file}.bak.$(date +%Y%m%d_%H%M%S)&quot; || true
  fi

  # Use wrapper to avoid race conditions at login.
  cat &gt;&quot;$desktop_file&quot; &lt;&lt;&#39;DESKTOP&#39;
[Desktop Entry]
Type=Application
Name=Autorandr Apply
Comment=Apply autorandr profile at login
Exec=%h/.local/bin/autorandr-change
X-GNOME-Autostart-enabled=true
DESKTOP

  chown_target &quot;$auto_dir&quot;
  log &quot;Installed XDG autostart: $desktop_file&quot;
}

install_systemd_user_unit() {
  local unit_dir=&quot;$TARGET_HOME/.config/systemd/user&quot;
  local unit_file=&quot;$unit_dir/autorandr-change.service&quot;
  local wants_dir=&quot;$unit_dir/default.target.wants&quot;

  mkdir -p &quot;$unit_dir&quot; &quot;$wants_dir&quot;

  if [[ -f &quot;$unit_file&quot; ]]; then
    if ! confirm_yes &quot;This will overwrite $unit_file (a backup will be created). Proceed?&quot;; then
      log &quot;Skipped systemd user unit.&quot;
      return 0
    fi
    cp -a &quot;$unit_file&quot; &quot;${unit_file}.bak.$(date +%Y%m%d_%H%M%S)&quot; || true
  fi

  cat &gt;&quot;$unit_file&quot; &lt;&lt;&#39;UNIT&#39;
[Unit]
Description=Apply autorandr profile (login)

# If graphical-session.target exists in the user manager, order after it.
After=graphical-session.target

[Service]
Type=oneshot
ExecStart=%h/.local/bin/autorandr-change

[Install]
WantedBy=default.target
UNIT

  # Offline enable: create the symlink systemctl --user enable would create.
  ln -sf ../autorandr-change.service &quot;$wants_dir/autorandr-change.service&quot;

  chown_target &quot;$unit_dir&quot;

  # If we&#39;re *already* in the user&#39;s session bus, also run daemon-reload.
  if run_as_target systemctl --user show-environment &gt;/dev/null 2&gt;&amp;1; then
    run_as_target systemctl --user daemon-reload || true
  fi

  log &quot;Installed systemd user unit: $unit_file&quot;
  log &quot;Enabled (offline) via symlink: $wants_dir/autorandr-change.service&quot;
}

enable_system_services_if_present() {
  # These units vary by distro/package; enable only if they exist.
  if ${SUDO} systemctl list-unit-files 2&gt;/dev/null | grep -q &#39;^autorandr\.service&#39;; then
    if confirm_yes &quot;Enable system-wide autorandr.service now?&quot;; then
      ${SUDO} systemctl enable --now autorandr.service || true
    fi
  fi
  if ${SUDO} systemctl list-unit-files 2&gt;/dev/null | grep -q &#39;^autorandr-resume\.service&#39;; then
    if confirm_yes &quot;Enable system-wide autorandr-resume.service now?&quot;; then
      ${SUDO} systemctl enable --now autorandr-resume.service || true
    fi
  fi
}

try_apply_now() {
  if [[ -z &quot;${DISPLAY:-}&quot; ]]; then
    log &quot;DISPLAY not set; skipping immediate autorandr apply.&quot;
    return 0
  fi

  log &quot;DISPLAY is set; attempting autorandr apply now...&quot;

  # Prefer wrapper (waits for xrandr readiness).
  local wrapper=&quot;$TARGET_HOME/.local/bin/autorandr-change&quot;
  local xauth=&quot;${XAUTHORITY:-$TARGET_HOME/.Xauthority}&quot;

  if [[ -x &quot;$wrapper&quot; ]]; then
    if ! run_as_target env DISPLAY=&quot;$DISPLAY&quot; XAUTHORITY=&quot;$xauth&quot; &quot;$wrapper&quot;; then
      err &quot;autorandr apply failed in-session (you can run &#39;$wrapper&#39; manually later).&quot;
      return 0
    fi
  else
    if ! run_as_target env DISPLAY=&quot;$DISPLAY&quot; XAUTHORITY=&quot;$xauth&quot; /usr/bin/autorandr --change; then
      err &quot;autorandr --change failed in-session (you can run it manually later).&quot;
      return 0
    fi
  fi

  log &quot;autorandr applied.&quot;
}

main() {
  resolve_target_user
  log &quot;Target user: $TARGET_USER&quot;
  log &quot;Target home: $TARGET_HOME&quot;

  ensure_deps
  choose_profile
  validate_profile_exists

  install_preswitch_hook
  install_wrapper_script

  if confirm_yes &quot;Enable system-wide autorandr services (if present)?&quot;; then
    enable_system_services_if_present
  fi

  if confirm_yes &quot;Install XDG autostart entry to run autorandr at login (recommended for desktop environments)?&quot;; then
    install_xdg_autostart
  fi

  if confirm_yes &quot;Install a systemd user unit to run autorandr at login (works even without DBUS during install)?&quot;; then
    install_systemd_user_unit
  fi

  try_apply_now

  log &quot;Done. Profile selected: $AUTORANDR_PROFILE&quot;
  log &quot;Profile config path: $TARGET_HOME/.config/autorandr/$AUTORANDR_PROFILE&quot;
}

main &quot;$@&quot;</code>
</section>
  <h1 id="homelinarork3588-display-toolkitbinrk3588_dual_display_setupsh">
    
    
     <a href="#homelinarork3588-display-toolkitbinrk3588_dual_display_setupsh">#</a><a href="#" aria-label="Back to top">/home/linaro/rk3588-display-toolkit/bin/rk3588_dual_display_setup.sh</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label=" Code Block" data-filename="_code_block.txt" data-code="#!/usr/bin/env bash
set -euo pipefail
IFS=$&#39;\n\t&#39;

# rk3588_dual_display_setup.sh
#
# Hard-coded dual-monitor fix (HDMI + DP) with autorandr persistence.
#
# OUT1 (default HDMI-1): 1280x720@60 primary
# OUT2 (default DP-1)  : 800x600@60 right-of OUT1
# Includes SVGA (Standard VESA) fallback timing for OUT2.
#
# WARNING: This script changes display modes.

OUT1=&quot;${OUT1:-HDMI-1}&quot;
OUT2=&quot;${OUT2:-DP-1}&quot;

# HDMI-1: 1280x720 59.86 Hz (CVT 0.92M9)
MODE1_NAME=&quot;1280x720_60.00&quot;
MODE1_LINE=&quot;74.50  1280 1344 1472 1664  720 723 728 748 -hsync +vsync&quot;

# DP-1: 800x600 59.86 Hz (CVT 0.48M3) - Primary attempt
MODE2_CVT_NAME=&quot;800x600_60.00&quot;
MODE2_CVT_LINE=&quot;38.25  800 832 912 1024  600 603 607 624 -hsync +vsync&quot;

# DP-1: 800x600 Standard VESA - Fallback
# Note: Inferred standard VESA timings to maintain script fallback logic
MODE2_VGA_NAME=&quot;800x600_60_std&quot;
MODE2_VGA_LINE=&quot;40.00  800 840 968 1056  600 601 605 628 +hsync +vsync&quot;

AR_PROFILE=&quot;rk3588_dual&quot;

log() { printf &#39;[INFO ] %s\n&#39; &quot;$*&quot;; }
err() { printf &#39;[ERROR] %s\n&#39; &quot;$*&quot; &gt;&amp;2; }

need_x() {
  [[ -n &quot;${DISPLAY:-}&quot; ]] || { err &quot;DISPLAY not set. Run from an active X session.&quot;; exit 1; }
}

need_cmd() {
  command -v &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1 || { err &quot;Missing command: $1&quot;; exit 1; }
}

confirm_yes() {
  local msg=&quot;$1&quot; ans
  echo
  echo &quot;WARNING: $msg&quot;
  read -r -p &quot;Type &#39;yes&#39; to continue, anything else to cancel: &quot; ans
  [[ &quot;$ans&quot; == &quot;yes&quot; ]] || { err &quot;Cancelled by user.&quot;; exit 1; }
}

apply_layout() {
  local right_mode=&quot;$1&quot;
  xrandr \
    --output &quot;$OUT1&quot; --mode &quot;$MODE1_NAME&quot; --primary \
    --output &quot;$OUT2&quot; --mode &quot;$right_mode&quot; --right-of &quot;$OUT1&quot;
}

main() {
  need_x
  need_cmd xrandr
  need_cmd autorandr

  confirm_yes &quot;This will change active display modes for $OUT1 and $OUT2. Ensure you can recover via TTY.&quot;

  log &quot;Defining modelines (best-effort)...&quot;
  xrandr --newmode &quot;$MODE1_NAME&quot; $MODE1_LINE 2&gt;/dev/null || true
  xrandr --newmode &quot;$MODE2_CVT_NAME&quot; $MODE2_CVT_LINE 2&gt;/dev/null || true
  xrandr --newmode &quot;$MODE2_VGA_NAME&quot; $MODE2_VGA_LINE 2&gt;/dev/null || true

  xrandr --addmode &quot;$OUT1&quot; &quot;$MODE1_NAME&quot; 2&gt;/dev/null || true
  xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_CVT_NAME&quot; 2&gt;/dev/null || true
  xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_VGA_NAME&quot; 2&gt;/dev/null || true

  log &quot;Applying layout (try CVT timing first)...&quot;
  if ! apply_layout &quot;$MODE2_CVT_NAME&quot;; then
    log &quot;CVT timing failed; trying VESA/SVGA fallback...&quot;
    apply_layout &quot;$MODE2_VGA_NAME&quot;
  fi

  log &quot;Creating autorandr preswitch hook for persistence...&quot;
  local ar_dir=&quot;$HOME/.config/autorandr/$AR_PROFILE&quot;
  mkdir -p &quot;$ar_dir&quot;

  cat &gt;&quot;$ar_dir/preswitch&quot; &lt;&lt;SH
#!/bin/sh
xrandr --newmode &quot;$MODE1_NAME&quot; $MODE1_LINE 2&gt;/dev/null || true
xrandr --newmode &quot;$MODE2_CVT_NAME&quot; $MODE2_CVT_LINE 2&gt;/dev/null || true
xrandr --newmode &quot;$MODE2_VGA_NAME&quot; $MODE2_VGA_LINE 2&gt;/dev/null || true
xrandr --addmode &quot;$OUT1&quot; &quot;$MODE1_NAME&quot; 2&gt;/dev/null || true
xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_CVT_NAME&quot; 2&gt;/dev/null || true
xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_VGA_NAME&quot; 2&gt;/dev/null || true
SH
  chmod +x &quot;$ar_dir/preswitch&quot;

  log &quot;Saving autorandr profile &#39;$AR_PROFILE&#39; (forced)...&quot;
  autorandr --save &quot;$AR_PROFILE&quot; --force

  log &quot;Done. Profile saved: $AR_PROFILE&quot;
}

main &quot;$@&quot;" data-download-link="" data-download-label="Download ">
  <code class="language-">#!/usr/bin/env bash
set -euo pipefail
IFS=$&#39;\n\t&#39;

# rk3588_dual_display_setup.sh
#
# Hard-coded dual-monitor fix (HDMI + DP) with autorandr persistence.
#
# OUT1 (default HDMI-1): 1280x720@60 primary
# OUT2 (default DP-1)  : 800x600@60 right-of OUT1
# Includes SVGA (Standard VESA) fallback timing for OUT2.
#
# WARNING: This script changes display modes.

OUT1=&quot;${OUT1:-HDMI-1}&quot;
OUT2=&quot;${OUT2:-DP-1}&quot;

# HDMI-1: 1280x720 59.86 Hz (CVT 0.92M9)
MODE1_NAME=&quot;1280x720_60.00&quot;
MODE1_LINE=&quot;74.50  1280 1344 1472 1664  720 723 728 748 -hsync +vsync&quot;

# DP-1: 800x600 59.86 Hz (CVT 0.48M3) - Primary attempt
MODE2_CVT_NAME=&quot;800x600_60.00&quot;
MODE2_CVT_LINE=&quot;38.25  800 832 912 1024  600 603 607 624 -hsync +vsync&quot;

# DP-1: 800x600 Standard VESA - Fallback
# Note: Inferred standard VESA timings to maintain script fallback logic
MODE2_VGA_NAME=&quot;800x600_60_std&quot;
MODE2_VGA_LINE=&quot;40.00  800 840 968 1056  600 601 605 628 +hsync +vsync&quot;

AR_PROFILE=&quot;rk3588_dual&quot;

log() { printf &#39;[INFO ] %s\n&#39; &quot;$*&quot;; }
err() { printf &#39;[ERROR] %s\n&#39; &quot;$*&quot; &gt;&amp;2; }

need_x() {
  [[ -n &quot;${DISPLAY:-}&quot; ]] || { err &quot;DISPLAY not set. Run from an active X session.&quot;; exit 1; }
}

need_cmd() {
  command -v &quot;$1&quot; &gt;/dev/null 2&gt;&amp;1 || { err &quot;Missing command: $1&quot;; exit 1; }
}

confirm_yes() {
  local msg=&quot;$1&quot; ans
  echo
  echo &quot;WARNING: $msg&quot;
  read -r -p &quot;Type &#39;yes&#39; to continue, anything else to cancel: &quot; ans
  [[ &quot;$ans&quot; == &quot;yes&quot; ]] || { err &quot;Cancelled by user.&quot;; exit 1; }
}

apply_layout() {
  local right_mode=&quot;$1&quot;
  xrandr \
    --output &quot;$OUT1&quot; --mode &quot;$MODE1_NAME&quot; --primary \
    --output &quot;$OUT2&quot; --mode &quot;$right_mode&quot; --right-of &quot;$OUT1&quot;
}

main() {
  need_x
  need_cmd xrandr
  need_cmd autorandr

  confirm_yes &quot;This will change active display modes for $OUT1 and $OUT2. Ensure you can recover via TTY.&quot;

  log &quot;Defining modelines (best-effort)...&quot;
  xrandr --newmode &quot;$MODE1_NAME&quot; $MODE1_LINE 2&gt;/dev/null || true
  xrandr --newmode &quot;$MODE2_CVT_NAME&quot; $MODE2_CVT_LINE 2&gt;/dev/null || true
  xrandr --newmode &quot;$MODE2_VGA_NAME&quot; $MODE2_VGA_LINE 2&gt;/dev/null || true

  xrandr --addmode &quot;$OUT1&quot; &quot;$MODE1_NAME&quot; 2&gt;/dev/null || true
  xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_CVT_NAME&quot; 2&gt;/dev/null || true
  xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_VGA_NAME&quot; 2&gt;/dev/null || true

  log &quot;Applying layout (try CVT timing first)...&quot;
  if ! apply_layout &quot;$MODE2_CVT_NAME&quot;; then
    log &quot;CVT timing failed; trying VESA/SVGA fallback...&quot;
    apply_layout &quot;$MODE2_VGA_NAME&quot;
  fi

  log &quot;Creating autorandr preswitch hook for persistence...&quot;
  local ar_dir=&quot;$HOME/.config/autorandr/$AR_PROFILE&quot;
  mkdir -p &quot;$ar_dir&quot;

  cat &gt;&quot;$ar_dir/preswitch&quot; &lt;&lt;SH
#!/bin/sh
xrandr --newmode &quot;$MODE1_NAME&quot; $MODE1_LINE 2&gt;/dev/null || true
xrandr --newmode &quot;$MODE2_CVT_NAME&quot; $MODE2_CVT_LINE 2&gt;/dev/null || true
xrandr --newmode &quot;$MODE2_VGA_NAME&quot; $MODE2_VGA_LINE 2&gt;/dev/null || true
xrandr --addmode &quot;$OUT1&quot; &quot;$MODE1_NAME&quot; 2&gt;/dev/null || true
xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_CVT_NAME&quot; 2&gt;/dev/null || true
xrandr --addmode &quot;$OUT2&quot; &quot;$MODE2_VGA_NAME&quot; 2&gt;/dev/null || true
SH
  chmod +x &quot;$ar_dir/preswitch&quot;

  log &quot;Saving autorandr profile &#39;$AR_PROFILE&#39; (forced)...&quot;
  autorandr --save &quot;$AR_PROFILE&quot; --force

  log &quot;Done. Profile saved: $AR_PROFILE&quot;
}

main &quot;$@&quot;</code>
</section>
  <h1 id="homelinaromy_custom_display_configsh">
    
    
     <a href="#homelinaromy_custom_display_configsh">#</a><a href="#" aria-label="Back to top">/home/linaro/my_custom_display_config.sh</a>
        
    
  </h1>
      
<section class="code-block-container" role="group" aria-label="Bash Code Block" data-filename="bash_code_block.sh" data-code="#!/bin/bash
# Xrandr dual-monitor setup (expanded, refactored)
# HDMI-1 → 1280x720@60 (primary)
# DP-1   → 800x600@60 (right of HDMI-1)
# Modelines and outputs are fixed based on provided logs. No placeholders.

set -Eeuo pipefail

# --------------------------
# Utilities / Logging
# --------------------------
log()  { printf &#39;[INFO ] %s\n&#39; &quot;$*&quot;; }
warn() { printf &#39;[WARN ] %s\n&#39; &quot;$*&quot; &gt;&amp;2; }
err()  { printf &#39;[ERROR] %s\n&#39; &quot;$*&quot; &gt;&amp;2; }

# If DRY_RUN=1 is set in the environment, print commands instead of executing them.
: &quot;${DRY_RUN:=0}&quot;
run() {
  if [[ &quot;$DRY_RUN&quot; == &quot;1&quot; ]]; then
    printf &#39;[DRYRUN] %s\n&#39; &quot;$*&quot;
    return 0
  fi
  eval &quot;$@&quot;
}

# --------------------------
# Pre-flight checks
# --------------------------
if ! command -v xrandr &gt;/dev/null 2&gt;&amp;1; then
  err &#39;xrandr not found&#39;
  exit 127
fi

# --------------------------
# Fixed configuration from logs
# --------------------------
# Data derived from: Modeline &quot;1280x720_60.00&quot; 74.50 1280... -hsync +vsync
OUTPUT_1_NAME=&quot;HDMI-1&quot;
MODE_1_NAME=&quot;1280x720_60.00&quot;
# Params: Clock HDisp HSyncStart HSyncEnd HTotal VDisp VSyncStart VSyncEnd VTotal Flags
MODELINE_1_PARAMS=&quot;74.50  1280 1344 1472 1664  720 723 728 748 -hsync +vsync&quot;

# Data derived from: Modeline &quot;800x600_60.00&quot; 38.25 800... -hsync +vsync
OUTPUT_2_NAME=&quot;DP-1&quot;
MODE_2_NAME=&quot;800x600_60.00&quot;
# Params: Clock HDisp HSyncStart HSyncEnd HTotal VDisp VSyncStart VSyncEnd VTotal Flags
MODELINE_2_PARAMS=&quot;38.25  800 832 912 1024  600 603 607 624 -hsync +vsync&quot;

# --------------------------
# Helpers for xrandr state
# --------------------------
connected() {
  xrandr | grep -q &quot;^$1\s*connected&quot;
}

mode_defined() {
  local name=&quot;$1&quot;
  # A mode is &quot;defined&quot; if it appears anywhere in xrandr --query output
  xrandr --query | awk &#39;{print $1}&#39; | grep -Fxq &quot;$name&quot;
}

output_has_mode() {
  local out=&quot;$1&quot; name=&quot;$2&quot;
  # Extract the block for this output and list the mode names, then search for ours.
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o {on=1; next}
    on &amp;&amp; NF==0 {on=0}
    on &amp;&amp; $1!~/^\t/ &amp;&amp; $2==&quot;connected&quot; {on=0}
    on {print $1}
  &#39; | sed &#39;s/^[[:space:]]*//&#39; | grep -Fxq &quot;$name&quot; 2&gt;/dev/null
}

active_geom() {
  # Prints WxH for given output if connected; empty otherwise
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;$1==o &amp;&amp; $2==&quot;connected&quot; {
    match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/);
    if (RSTART) { s=substr($0,RSTART,RLENGTH); sub(/\+.*/, &quot;&quot;, s); print s; }
  }&#39;
}

# --------------------------
# Capture pre-state for reversible changes
# --------------------------
PRESTATE_CMD=()
for out in &quot;$OUTPUT_1_NAME&quot; &quot;$OUTPUT_2_NAME&quot;; do
  if connected &quot;$out&quot;; then
    # Best-effort revert uses preferred mode and auto placement for each output.
    PRESTATE_CMD+=(--output &quot;$out&quot; --auto)
  fi
done

revert() {
  if ((${#PRESTATE_CMD[@]})); then
    warn &quot;Reverting to auto configuration&quot;
    run xrandr &quot;${PRESTATE_CMD[@]}&quot; || warn &quot;Revert failed&quot;
  fi
}

trap &#39;err &quot;Failure occurred&quot;; revert&#39; ERR

# --------------------------
# Ensure modes exist and are assigned to outputs
# --------------------------
ensure_mode_defined() {
  local name=&quot;$1&quot;; shift
  if mode_defined &quot;$name&quot;; then
    # NOTE: This check only verifies the NAME exists. It does NOT verify if the
    # parameters match. If you changed modeline params but kept the name,
    # you must delete the mode manually or rename it.
    log &quot;Mode present: $name (skipping definition)&quot;
  else
    log &quot;Defining mode: $name&quot;
    run xrandr --newmode &quot;$name&quot; &quot;$@&quot;
  fi
}

ensure_output_has_mode() {
  local out=&quot;$1&quot; name=&quot;$2&quot;
  if output_has_mode &quot;$out&quot; &quot;$name&quot;; then
    log &quot;Output $out already has mode $name&quot;
  else
    log &quot;Adding mode $name to $out&quot;
    run xrandr --addmode &quot;$out&quot; &quot;$name&quot;
  fi
}

# Validate outputs are connected before modifying
for out in &quot;$OUTPUT_1_NAME&quot; &quot;$OUTPUT_2_NAME&quot;; do
  if ! connected &quot;$out&quot;; then
    err &quot;Output not connected: $out&quot;
    exit 2
  fi
done

# Define modes idempotently
ensure_mode_defined &quot;$MODE_1_NAME&quot; $MODELINE_1_PARAMS
ensure_mode_defined &quot;$MODE_2_NAME&quot; $MODELINE_2_PARAMS

# Assign modes to each output
ensure_output_has_mode &quot;$OUTPUT_1_NAME&quot; &quot;$MODE_1_NAME&quot;
ensure_output_has_mode &quot;$OUTPUT_2_NAME&quot; &quot;$MODE_2_NAME&quot;

# --------------------------
# Apply requested layout
# --------------------------
LAYOUT_CMD=(
  --output &quot;$OUTPUT_1_NAME&quot; --mode &quot;$MODE_1_NAME&quot; --primary
  --output &quot;$OUTPUT_2_NAME&quot; --mode &quot;$MODE_2_NAME&quot; --right-of &quot;$OUTPUT_1_NAME&quot;
)

log &quot;Applying layout&quot;
run xrandr &quot;${LAYOUT_CMD[@]}&quot;

# --------------------------
# Post-apply verification
# --------------------------
geom1=$(active_geom &quot;$OUTPUT_1_NAME&quot;)
geom2=$(active_geom &quot;$OUTPUT_2_NAME&quot;)

if [[ &quot;$geom1&quot; != &quot;1280x720&quot; ]]; then
  err &quot;Post-check failed: $OUTPUT_1_NAME geometry is &#39;$geom1&#39; (expected 1280x720)&quot;
  revert; exit 3
fi
if [[ &quot;$geom2&quot; != &quot;800x600&quot; ]]; then
  err &quot;Post-check failed: $OUTPUT_2_NAME geometry is &#39;$geom2&#39; (expected 800x600)&quot;
  revert; exit 4
fi

log &quot;Configuration successful: $OUTPUT_1_NAME=$geom1 (primary), $OUTPUT_2_NAME=$geom2 (right)&quot;
exit 0" data-download-link="" data-download-label="Download Bash">
  <code class="language-bash">#!/bin/bash
# Xrandr dual-monitor setup (expanded, refactored)
# HDMI-1 → 1280x720@60 (primary)
# DP-1   → 800x600@60 (right of HDMI-1)
# Modelines and outputs are fixed based on provided logs. No placeholders.

set -Eeuo pipefail

# --------------------------
# Utilities / Logging
# --------------------------
log()  { printf &#39;[INFO ] %s\n&#39; &quot;$*&quot;; }
warn() { printf &#39;[WARN ] %s\n&#39; &quot;$*&quot; &gt;&amp;2; }
err()  { printf &#39;[ERROR] %s\n&#39; &quot;$*&quot; &gt;&amp;2; }

# If DRY_RUN=1 is set in the environment, print commands instead of executing them.
: &quot;${DRY_RUN:=0}&quot;
run() {
  if [[ &quot;$DRY_RUN&quot; == &quot;1&quot; ]]; then
    printf &#39;[DRYRUN] %s\n&#39; &quot;$*&quot;
    return 0
  fi
  eval &quot;$@&quot;
}

# --------------------------
# Pre-flight checks
# --------------------------
if ! command -v xrandr &gt;/dev/null 2&gt;&amp;1; then
  err &#39;xrandr not found&#39;
  exit 127
fi

# --------------------------
# Fixed configuration from logs
# --------------------------
# Data derived from: Modeline &quot;1280x720_60.00&quot; 74.50 1280... -hsync +vsync
OUTPUT_1_NAME=&quot;HDMI-1&quot;
MODE_1_NAME=&quot;1280x720_60.00&quot;
# Params: Clock HDisp HSyncStart HSyncEnd HTotal VDisp VSyncStart VSyncEnd VTotal Flags
MODELINE_1_PARAMS=&quot;74.50  1280 1344 1472 1664  720 723 728 748 -hsync +vsync&quot;

# Data derived from: Modeline &quot;800x600_60.00&quot; 38.25 800... -hsync +vsync
OUTPUT_2_NAME=&quot;DP-1&quot;
MODE_2_NAME=&quot;800x600_60.00&quot;
# Params: Clock HDisp HSyncStart HSyncEnd HTotal VDisp VSyncStart VSyncEnd VTotal Flags
MODELINE_2_PARAMS=&quot;38.25  800 832 912 1024  600 603 607 624 -hsync +vsync&quot;

# --------------------------
# Helpers for xrandr state
# --------------------------
connected() {
  xrandr | grep -q &quot;^$1\s*connected&quot;
}

mode_defined() {
  local name=&quot;$1&quot;
  # A mode is &quot;defined&quot; if it appears anywhere in xrandr --query output
  xrandr --query | awk &#39;{print $1}&#39; | grep -Fxq &quot;$name&quot;
}

output_has_mode() {
  local out=&quot;$1&quot; name=&quot;$2&quot;
  # Extract the block for this output and list the mode names, then search for ours.
  xrandr --query | awk -v o=&quot;$out&quot; &#39;
    $1==o {on=1; next}
    on &amp;&amp; NF==0 {on=0}
    on &amp;&amp; $1!~/^\t/ &amp;&amp; $2==&quot;connected&quot; {on=0}
    on {print $1}
  &#39; | sed &#39;s/^[[:space:]]*//&#39; | grep -Fxq &quot;$name&quot; 2&gt;/dev/null
}

active_geom() {
  # Prints WxH for given output if connected; empty otherwise
  local out=&quot;$1&quot;
  xrandr --query | awk -v o=&quot;$out&quot; &#39;$1==o &amp;&amp; $2==&quot;connected&quot; {
    match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/);
    if (RSTART) { s=substr($0,RSTART,RLENGTH); sub(/\+.*/, &quot;&quot;, s); print s; }
  }&#39;
}

# --------------------------
# Capture pre-state for reversible changes
# --------------------------
PRESTATE_CMD=()
for out in &quot;$OUTPUT_1_NAME&quot; &quot;$OUTPUT_2_NAME&quot;; do
  if connected &quot;$out&quot;; then
    # Best-effort revert uses preferred mode and auto placement for each output.
    PRESTATE_CMD+=(--output &quot;$out&quot; --auto)
  fi
done

revert() {
  if ((${#PRESTATE_CMD[@]})); then
    warn &quot;Reverting to auto configuration&quot;
    run xrandr &quot;${PRESTATE_CMD[@]}&quot; || warn &quot;Revert failed&quot;
  fi
}

trap &#39;err &quot;Failure occurred&quot;; revert&#39; ERR

# --------------------------
# Ensure modes exist and are assigned to outputs
# --------------------------
ensure_mode_defined() {
  local name=&quot;$1&quot;; shift
  if mode_defined &quot;$name&quot;; then
    # NOTE: This check only verifies the NAME exists. It does NOT verify if the
    # parameters match. If you changed modeline params but kept the name,
    # you must delete the mode manually or rename it.
    log &quot;Mode present: $name (skipping definition)&quot;
  else
    log &quot;Defining mode: $name&quot;
    run xrandr --newmode &quot;$name&quot; &quot;$@&quot;
  fi
}

ensure_output_has_mode() {
  local out=&quot;$1&quot; name=&quot;$2&quot;
  if output_has_mode &quot;$out&quot; &quot;$name&quot;; then
    log &quot;Output $out already has mode $name&quot;
  else
    log &quot;Adding mode $name to $out&quot;
    run xrandr --addmode &quot;$out&quot; &quot;$name&quot;
  fi
}

# Validate outputs are connected before modifying
for out in &quot;$OUTPUT_1_NAME&quot; &quot;$OUTPUT_2_NAME&quot;; do
  if ! connected &quot;$out&quot;; then
    err &quot;Output not connected: $out&quot;
    exit 2
  fi
done

# Define modes idempotently
ensure_mode_defined &quot;$MODE_1_NAME&quot; $MODELINE_1_PARAMS
ensure_mode_defined &quot;$MODE_2_NAME&quot; $MODELINE_2_PARAMS

# Assign modes to each output
ensure_output_has_mode &quot;$OUTPUT_1_NAME&quot; &quot;$MODE_1_NAME&quot;
ensure_output_has_mode &quot;$OUTPUT_2_NAME&quot; &quot;$MODE_2_NAME&quot;

# --------------------------
# Apply requested layout
# --------------------------
LAYOUT_CMD=(
  --output &quot;$OUTPUT_1_NAME&quot; --mode &quot;$MODE_1_NAME&quot; --primary
  --output &quot;$OUTPUT_2_NAME&quot; --mode &quot;$MODE_2_NAME&quot; --right-of &quot;$OUTPUT_1_NAME&quot;
)

log &quot;Applying layout&quot;
run xrandr &quot;${LAYOUT_CMD[@]}&quot;

# --------------------------
# Post-apply verification
# --------------------------
geom1=$(active_geom &quot;$OUTPUT_1_NAME&quot;)
geom2=$(active_geom &quot;$OUTPUT_2_NAME&quot;)

if [[ &quot;$geom1&quot; != &quot;1280x720&quot; ]]; then
  err &quot;Post-check failed: $OUTPUT_1_NAME geometry is &#39;$geom1&#39; (expected 1280x720)&quot;
  revert; exit 3
fi
if [[ &quot;$geom2&quot; != &quot;800x600&quot; ]]; then
  err &quot;Post-check failed: $OUTPUT_2_NAME geometry is &#39;$geom2&#39; (expected 800x600)&quot;
  revert; exit 4
fi

log &quot;Configuration successful: $OUTPUT_1_NAME=$geom1 (primary), $OUTPUT_2_NAME=$geom2 (right)&quot;
exit 0</code>
</section>

        </div>
        
          URL: https://ib.bsb.br/xrandr
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/expand/" title="expand" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/google-workspace-uncommon-shortcuts/" title="Google Workspace Uncommon Shortcuts" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scratchpad"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scratchpad" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/ext4-filesystem-backup-script/" title="ext4 filesystem backup script" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="/to-enable-video-acceleration-on-rpi4/" title="to enable video acceleration on RPI4" rel="next">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2026-01-14 14:23:52
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scratchpad">
                  scratchpad
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/xrandr/"
        },
        "headline": "xrandr display-toolkit setup",
        "description": "",
        "datePublished": "2025-04-03T00:00:00+00:00",
        "dateModified": "2025-12-19T22:55:34+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
