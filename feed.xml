<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ib.bsb.br/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ib.bsb.br/" rel="alternate" type="text/html" /><updated>2025-11-20T01:46:22+00:00</updated><id>https://ib.bsb.br/feed.xml</id><title type="html">infoBAG</title><entry><title type="html">Debian 13 bootable USB setup</title><link href="https://ib.bsb.br/debian13usb/" rel="alternate" type="text/html" title="Debian 13 bootable USB setup" /><published>2025-11-19T00:00:00+00:00</published><updated>2025-11-19T21:47:09+00:00</updated><id>https://ib.bsb.br/debian13usb</id><content type="html" xml:base="https://ib.bsb.br/debian13usb/"><![CDATA[<pre><code class="language-build_debian13_usb.sh">#!/usr/bin/env bash
# Script to build a Debian 13 (Trixie) amd64 persistent USB image with X11, ratpoison,
# auto-login, and autostarting TreeSheets and Impala, from a host running Debian 11 arm64.
# 
# **IMPORTANT:** Review and adjust configuration variables below (image size, usernames, etc.)
# before running. Run this script as root on a Debian-based arm64 host.
# It will create an image file and set up a chroot with a Debian amd64 system.
# No changes are made to the host system aside from installing required packages (if needed).
# 
# The script will prompt for confirmation before overwriting any existing image file or writing to a USB device.
# All major actions are logged to the console for transparency.

set -euo pipefail

#############################
# Configuration Variables
#############################
DEBIAN_RELEASE="trixie"            # Target Debian release name
TARGET_ARCH="amd64"               # Target architecture for the USB system
IMAGE_SIZE="4G"                   # Size of the image file to create (e.g., "4G" for 4 GiB)
IMAGE_NAME="debian13-${TARGET_ARCH}-usb.img"  # Name of the image file to create
BUILD_DIR="$PWD/debian_usb_build" # Working directory for mounts and temporary files (created if not exists)
USERNAME="user"                   # Default username for auto-login
USERPASSWORD="password"           # Password for the default user (change or leave as desired)
HOSTNAME="debian-usb"             # Hostname for the new system
TIMEZONE="Etc/UTC"                # Timezone for the new system (can be changed to user's timezone)
LOCALE="en_US.UTF-8"              # Locale to generate for the new system

# Package lists for installation in the target system:
# Base system and utilities
BASE_PACKAGES="systemd-sysv,systemd,locales,tzdata,dialog"  # core packages (some are normally included by debootstrap second stage)
# Desktop/X11 and user applications
X11_PACKAGES="xserver-xorg-core,xserver-xorg-video-fbdev,xserver-xorg-video-vesa,xinit,xterm,ratpoison"
APP_PACKAGES="treesheets"         # TreeSheets is in Debian repo. Impala might need manual installation (not in Debian).
NETWORK_PACKAGES="iwd"            # Use iwd for Wi-Fi (Impala requires iwd). Alternatively, could include dhclient or systemd-networkd if needed.
# Bootloaders and kernel
BOOT_PACKAGES="grub-efi-amd64,linux-image-amd64,extlinux,syslinux-common" 
# Note: extlinux (Syslinux for ext filesystems) and syslinux-common provide BIOS boot support; grub-efi-amd64 for UEFI.

#############################
# Script Setup and Functions
#############################

# Ensure the working directory exists
mkdir -p "${BUILD_DIR}"
# Define mount points relative to working directory
ROOTFS_DIR="${BUILD_DIR}/rootfs"    # Mount point for the ext4 root filesystem
EFI_DIR="${BUILD_DIR}/efiboot"      # Mount point for the FAT32 EFI/boot partition

# Trap to cleanup mounts/loop on exit or error
cleanup() {
    echo "Cleaning up: Unmounting and detaching loop devices..."
    # Try to unmount in reverse order of mounting
    umount -lf "${ROOTFS_DIR}/boot/efi" 2&gt;/dev/null || true
    umount -lf "${EFI_DIR}" 2&gt;/dev/null || true
    umount -lf "${ROOTFS_DIR}/dev/pts" 2&gt;/dev/null || true
    umount -lf "${ROOTFS_DIR}/dev" 2&gt;/dev/null || true
    umount -lf "${ROOTFS_DIR}/proc" 2&gt;/dev/null || true
    umount -lf "${ROOTFS_DIR}/sys" 2&gt;/dev/null || true
    umount -lf "${ROOTFS_DIR}" 2&gt;/dev/null || true
    if losetup -a | grep -q "$IMAGE_NAME"; then
        # Detach all loop devices associated with our image
        LOOP_DEV="$(losetup -j "${BUILD_DIR}/${IMAGE_NAME}" | cut -d: -f1 || true)"
        if [ -n "${LOOP_DEV}" ]; then
            losetup -d "${LOOP_DEV}" 2&gt;/dev/null || true
        fi
    fi
}
trap cleanup EXIT

# Confirm function for dangerous operations
confirm() {
    local prompt="$1"
    read -r -p "$prompt " response
    case "$response" in
        [Yy][Ee][Ss]|[Yy]) true ;;
        *) false ;;
    esac
}

# Require root privileges
if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root. Exiting."
    exit 1
fi

# Check and install required host tools
REQUIRED_TOOLS=(debootstrap qemu-user-static parted losetup mkfs.vfat mkfs.ext4)
MISSING_TOOLS=()
for tool in "${REQUIRED_TOOLS[@]}"; do
    if ! command -v "$tool" &amp;&gt;/dev/null; then
        MISSING_TOOLS+=("$tool")
    fi
done
if (( ${#MISSING_TOOLS[@]} &gt; 0 )); then
    echo "Installing missing host tools: ${MISSING_TOOLS[*]}..."
    apt-get update &amp;&amp; apt-get install -y "${MISSING_TOOLS[@]}"
fi

#############################
# Create and Partition Image
#############################
IMAGE_PATH="${BUILD_DIR}/${IMAGE_NAME}"
if [[ -f "$IMAGE_PATH" ]]; then
    echo "Image file $IMAGE_PATH already exists."
    if ! confirm "Overwrite existing image file? [yes/NO]"; then
        echo "Aborting to avoid overwriting existing image."
        exit 1
    fi
    rm -f "$IMAGE_PATH"
fi

echo "&gt;&gt;&gt; Creating blank image file of size $IMAGE_SIZE at $IMAGE_PATH..."
# Create an empty file of the specified size
truncate -s "$IMAGE_SIZE" "$IMAGE_PATH"

echo "&gt;&gt;&gt; Partitioning image file..."
# Create partition table: Partition 1 = FAT32 (for EFI &amp; Syslinux), Partition 2 = ext4 (root)
parted -s "$IMAGE_PATH" mklabel msdos \
    mkpart primary fat32 1MiB 300MiB \
    mkpart primary ext4 300MiB 100% \
    set 1 boot on

# Set up loop device with partitions
LOOP_DEV="$(losetup -f --show -P "$IMAGE_PATH")"
echo "    Loop device $LOOP_DEV created for $IMAGE_PATH"
# The loop device now has partitions accessible as ${LOOP_DEV}p1 and p2
LOOP_P1="${LOOP_DEV}p1"
LOOP_P2="${LOOP_DEV}p2"

echo "&gt;&gt;&gt; Creating filesystems..."
# Format the EFI/FAT32 partition (partition 1)
mkfs.vfat -F 32 -n EFI "$LOOP_P1"
# Format the root ext4 partition (partition 2) with a label
mkfs.ext4 -L rootfs "$LOOP_P2"

# Create mount points
mkdir -p "$ROOTFS_DIR" "$EFI_DIR"

echo "&gt;&gt;&gt; Mounting image partitions..."
mount "$LOOP_P2" "$ROOTFS_DIR"
mkdir -p "${ROOTFS_DIR}/boot/efi"
mount "$LOOP_P1" "$ROOTFS_DIR/boot/efi"
# Also mount the EFI partition separately if needed (not strictly necessary since it's at rootfs/boot/efi)
mount "$LOOP_P1" "$EFI_DIR"

#############################
# Debootstrap: Base System
#############################
echo "&gt;&gt;&gt; Bootstrapping Debian $DEBIAN_RELEASE ($TARGET_ARCH)..."
# First stage debootstrap (download and extract base system)
debootstrap --arch="$TARGET_ARCH" --foreign "$DEBIAN_RELEASE" "$ROOTFS_DIR" http://deb.debian.org/debian

# Enable QEMU for chroot (copy qemu static binary into the new system)
echo "&gt;&gt;&gt; Copying QEMU static binary for $TARGET_ARCH into chroot..."
cp "$(which qemu-${TARGET_ARCH}-static)" "${ROOTFS_DIR}/usr/bin/"

# Prepare essential mount points for chroot environment
echo "&gt;&gt;&gt; Mounting special filesystems for chroot..."
mount -t proc proc "${ROOTFS_DIR}/proc"
mount -t sysfs sys "${ROOTFS_DIR}/sys"
mount -o bind /dev "${ROOTFS_DIR}/dev"
mount -o bind /dev/pts "${ROOTFS_DIR}/dev/pts"
# Use a tmpfs for /run inside chroot to avoid interference with host /run
mount -t tmpfs tmpfs "${ROOTFS_DIR}/run"
mkdir -p "${ROOTFS_DIR}/run/lock"  # for any lock files

# Second stage debootstrap (configure base system inside chroot)
echo "&gt;&gt;&gt; Running debootstrap second-stage in chroot..."
chroot "$ROOTFS_DIR" /debootstrap/debootstrap --second-stage

# Basic system configuration: hostname, hosts, timezone, locale
echo "&gt;&gt;&gt; Configuring base system (hostname, timezone, locale)..."
echo "$HOSTNAME" &gt; "${ROOTFS_DIR}/etc/hostname"
# Set up /etc/hosts with minimal entries
cat &gt; "${ROOTFS_DIR}/etc/hosts" &lt;&lt;EOF
127.0.0.1   localhost
127.0.1.1   ${HOSTNAME}
EOF

# Timezone
echo "$TIMEZONE" &gt; "${ROOTFS_DIR}/etc/timezone"
ln -sf "/usr/share/zoneinfo/$TIMEZONE" "${ROOTFS_DIR}/etc/localtime"

# Locale (generate specified locale)
chroot "$ROOTFS_DIR" bash -c "echo '$LOCALE UTF-8' &gt; /etc/locale.gen"
chroot "$ROOTFS_DIR" locale-gen

# Set default LANG
echo "LANG=$LOCALE" &gt; "${ROOTFS_DIR}/etc/default/locale"

#############################
# Install Packages in Chroot
#############################
echo "&gt;&gt;&gt; Installing required packages in the target system..."
# Configure apt sources (use default deb.debian.org for stable)
cat &gt; "${ROOTFS_DIR}/etc/apt/sources.list" &lt;&lt;EOF
deb http://deb.debian.org/debian $DEBIAN_RELEASE main contrib non-free non-free-firmware
deb http://deb.debian.org/debian $DEBIAN_RELEASE-updates main contrib non-free non-free-firmware
deb http://security.debian.org/debian-security $DEBIAN_RELEASE-security main contrib non-free non-free-firmware
EOF

# Update apt cache and install packages
chroot "$ROOTFS_DIR" apt-get update
# Use apt-get in one command to install all desired packages
chroot "$ROOTFS_DIR" apt-get install -y --no-install-recommends \
    $BASE_PACKAGES,$X11_PACKAGES,$APP_PACKAGES,$NETWORK_PACKAGES,$BOOT_PACKAGES

# Set the system's timezone and reconfigure tzdata (non-interactively)
chroot "$ROOTFS_DIR" bash -c "DEBIAN_FRONTEND=noninteractive dpkg-reconfigure tzdata"

#############################
# User Setup and Autologin
#############################
echo "&gt;&gt;&gt; Setting up default user and auto-login..."
# Create the user with home directory and add to groups (sudo,netdev,audio,video)
chroot "$ROOTFS_DIR" useradd -m -s /bin/bash "$USERNAME"
chroot "$ROOTFS_DIR" bash -c "echo '${USERNAME}:${USERPASSWORD}' | chpasswd"
# Set root password (optional: here we set same as user, or leave locked by not setting)
chroot "$ROOTFS_DIR" bash -c "echo 'root:${USERPASSWORD}' | chpasswd"
# Add user to necessary groups
chroot "$ROOTFS_DIR" usermod -aG sudo,netdev,audio,video "$USERNAME"

# Configure autologin on tty1 via systemd getty override
AUTOLOGIN_CONF="${ROOTFS_DIR}/etc/systemd/system/getty@tty1.service.d"
mkdir -p "$AUTOLOGIN_CONF"
cat &gt; "$AUTOLOGIN_CONF/autologin.conf" &lt;&lt;EOF
[Service]
ExecStart=
ExecStart=-/sbin/agetty --autologin $USERNAME --noclear %I 38400 linux
EOF

# Set up startx on login (for console auto-login sessions)
# Add a command to .bash_profile to launch X only for the autologin on tty1
USER_HOME="${ROOTFS_DIR}/home/${USERNAME}"
cat &gt;&gt; "${USER_HOME}/.bash_profile" &lt;&lt;'EOF'
# If logging in on tty1, start X automatically
if [[ -z $DISPLAY &amp;&amp; $(tty) == "/dev/tty1" ]]; then
    startx -- -nocursor
    logout
fi
EOF
chroot "$ROOTFS_DIR" chown "$USERNAME:$USERNAME" "/home/$USERNAME/.bash_profile"

#############################
# X11 Autostart (ratpoison + apps)
#############################
echo "&gt;&gt;&gt; Configuring X11 session (ratpoison) and application autostart..."
# Create an .xinitrc for the user to start Ratpoison
cat &gt; "${USER_HOME}/.xinitrc" &lt;&lt;'EOF'
#!/bin/bash
# .xinitrc: run Ratpoison window manager
exec ratpoison
EOF
chroot "$ROOTFS_DIR" chown "$USERNAME:$USERNAME" "/home/$USERNAME/.xinitrc"
chroot "$ROOTFS_DIR" chmod +x "/home/$USERNAME/.xinitrc"

# Configure Ratpoison autostart: .ratpoisonrc to launch TreeSheets and Impala at startup
cat &gt; "${USER_HOME}/.ratpoisonrc" &lt;&lt;EOF
# Disable startup message
startup_message off
# Set a blank cursor (useful if -nocursor used for X)
exec xsetroot -cursor_name left_ptr
# Autostart applications:
exec treesheets      # launch TreeSheets GUI on start
exec xterm -e impala # open an xterm and run impala TUI inside it
EOF
# Note: impala is not an official Debian package. Ensure the 'impala' binary is installed in the system or adjust this line.
chroot "$ROOTFS_DIR" chown "$USERNAME:$USERNAME" "/home/$USERNAME/.ratpoisonrc"

#############################
# Bootloader Setup (Syslinux &amp; GRUB)
#############################
echo "&gt;&gt;&gt; Installing and configuring bootloaders (Syslinux for BIOS, GRUB for UEFI)..."
# 1. EXTLINUX (Syslinux) for BIOS boot:
# Create extlinux directory
chroot "$ROOTFS_DIR" mkdir -p /boot/extlinux
# Copy Syslinux BIOS modules to /boot/extlinux
chroot "$ROOTFS_DIR" cp -r /usr/lib/syslinux/modules/bios/* /boot/extlinux/ 2&gt;/dev/null || true
# Install extlinux bootloader on the ext4 partition
chroot "$ROOTFS_DIR" extlinux --install /boot/extlinux

# Create extlinux configuration file
ROOT_UUID=$(blkid -s UUID -o value "$LOOP_P2")  # get UUID of root partition
cat &gt; "${ROOTFS_DIR}/boot/extlinux/extlinux.conf" &lt;&lt;EOF
DEFAULT linux
LABEL linux
    LINUX ../vmlinuz
    INITRD ../initrd.img
    APPEND root=UUID=${ROOT_UUID} ro quiet
EOF
# The vmlinuz and initrd.img symlinks point to the latest kernel and initrd in /boot.
# We use '../' because extlinux directory is /boot/extlinux, going up to /boot for the files.

# Ensure the extlinux config and modules are owned by root (should already be)
chroot "$ROOTFS_DIR" chown -R root:root /boot/extlinux

# 2. GRUB for UEFI boot:
# Install GRUB EFI (this was already installed via apt in BOOT_PACKAGES)
# Perform grub-install targeting x86_64 EFI, pointing to the mounted EFI partition.
chroot "$ROOTFS_DIR" grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=Debian --removable --no-nvram
# Generate GRUB configuration file
chroot "$ROOTFS_DIR" update-grub

#############################
# Finalization
#############################
# Remove the QEMU static binary from the target system (not needed on real x86_64 hardware)
rm -f "${ROOTFS_DIR}/usr/bin/qemu-${TARGET_ARCH}-static"

# Sync data to disk
sync

echo "&gt;&gt;&gt; Unmounting chroot filesystems..."
# These will be also handled by the trap on exit, but we unmount explicitly here for clarity:
umount "${ROOTFS_DIR}/proc" || true
umount "${ROOTFS_DIR}/sys" || true
umount "${ROOTFS_DIR}/dev/pts" || true
umount "${ROOTFS_DIR}/dev" || true
umount "${ROOTFS_DIR}/run" || true
umount "${ROOTFS_DIR}/boot/efi" || true
umount "${EFI_DIR}" || true
umount "${ROOTFS_DIR}" || true

# Write Syslinux MBR boot code to the image (for BIOS boot).
# Use dd to write the first 440 bytes from Syslinux's mbr.bin to the image's MBR.
echo "&gt;&gt;&gt; Writing Syslinux MBR boot code to image..."
dd if="${ROOTFS_DIR}/usr/lib/SYSLINUX/mbr.bin" of="$LOOP_DEV" bs=440 count=1 conv=notrunc

# Detach loop device
losetup -d "$LOOP_DEV"

echo "&gt;&gt;&gt; Debian USB image creation completed successfully!"
echo "Image file: $IMAGE_PATH"
# Offer to write image to a USB device
if confirm "Write the image to a USB drive now? (This will destroy contents on the target drive) [yes/NO]"; then
    read -rp "Enter the device path for the USB (e.g., /dev/sdX): " USBDEV
    if [[ -n "$USBDEV" ]]; then
        echo "WARNING: About to overwrite $USBDEV with the image. This will erase all data on $USBDEV."
        if confirm "Are you absolutely sure? Type 'yes' to continue: "; then
            echo "&gt;&gt;&gt; Writing image to $USBDEV ... (this may take a while)"
            dd if="$IMAGE_PATH" of="$USBDEV" bs=4M status=progress conv=fsync
            echo "&gt;&gt;&gt; Syncing data to $USBDEV..."
            sync
            echo "Image written to $USBDEV successfully. You can now boot the USB drive on an x86_64 machine."
        else
            echo "Skipped writing image to USB."
        fi
    fi
else
    echo "Image creation complete. You can write $IMAGE_PATH to a USB device later using 'dd' or a similar tool."
fi
</code></pre>]]></content><author><name></name></author><category term="scratchpad" /></entry><entry><title type="html">GitHub Actions to Download, Unzip, and Create a New Repository</title><link href="https://ib.bsb.br/github-actions-unzip-tutorial/" rel="alternate" type="text/html" title="GitHub Actions to Download, Unzip, and Create a New Repository" /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-19T23:18:32+00:00</updated><id>https://ib.bsb.br/github-actions-unzip-tutorial</id><content type="html" xml:base="https://ib.bsb.br/github-actions-unzip-tutorial/"><![CDATA[<h1 id="tutorial-using-github-actions-to-download-unzip-and-create-a-new-repository">Tutorial: Using GitHub Actions to Download, Unzip, and Create a New Repository</h1>

<h2 id="executive-summary">Executive Summary</h2>
<p>This tutorial demonstrates how to create a GitHub Actions workflow that:</p>
<ol>
  <li>Downloads a ZIP file from https://x0.at/XS2C.zip (or any specified URL)</li>
  <li>Extracts the contents</li>
  <li>Creates a new GitHub repository</li>
  <li>Uploads all extracted files to the new repository</li>
</ol>

<p><strong>Prerequisites:</strong>
‚Ä¢ A GitHub account (user: ib-bsb-br in this example)
‚Ä¢ A repository where you can create workflows
‚Ä¢ A Personal Access Token (PAT) with repo scope
‚Ä¢ Basic understanding of GitHub Actions</p>

<p><strong>Estimated Time:</strong> 15-20 minutes</p>

<h2 id="Ô∏è-security-considerations">‚ö†Ô∏è Security Considerations</h2>
<h3 id="critical-read-before-proceeding">CRITICAL: Read Before Proceeding</h3>
<ol>
  <li>
    <p><strong>ZIP File Source Validation:</strong>
‚Ä¢ The URL https://x0.at/XS2C.zip is a third-party file hosting service
‚Ä¢ Never download and execute content from untrusted sources
‚Ä¢ Verify the ZIP file contents manually before automating this process
‚Ä¢ Consider implementing content validation/scanning in production workflows</p>
  </li>
  <li>
    <p><strong>Token Security:</strong>
‚Ä¢ Never hardcode tokens in workflow files
‚Ä¢ Always use GitHub Secrets for PATs
‚Ä¢ Limit token scope to only required permissions (repo minimum)
‚Ä¢ Rotate tokens regularly</p>
  </li>
  <li>
    <p><strong>Repository Creation:</strong>
‚Ä¢ This workflow creates public repositories by default
‚Ä¢ Be cautious about what content you‚Äôre making public
‚Ä¢ Review extracted contents before pushing</p>
  </li>
</ol>

<h2 id="part-1-prerequisites-setup">Part 1: Prerequisites Setup</h2>

<h3 id="step-1-create-a-personal-access-token-pat">Step 1: Create a Personal Access Token (PAT)</h3>
<ol>
  <li>Navigate to: https://github.com/settings/tokens/new</li>
  <li>Configure the token:
‚Ä¢ <strong>Note:</strong> ‚ÄúRepository Creation Token for Workflows‚Äù
‚Ä¢ <strong>Expiration:</strong> Choose appropriate duration (recommend 90 days max)
‚Ä¢ <strong>Scopes:</strong> Select <code class="language-plaintext highlighter-rouge">repo</code> (Full control of private repositories)
‚Ä¢ This includes: repo:status, repo_deployment, public_repo, repo:invite, security_events</li>
  <li>Click <strong>Generate token</strong></li>
  <li>Copy the token immediately (you won‚Äôt see it again)</li>
</ol>

<h3 id="step-2-add-token-as-repository-secret">Step 2: Add Token as Repository Secret</h3>
<ol>
  <li>Go to your repository: https://github.com/ib-bsb-br/YOUR_REPO_NAME</li>
  <li>Navigate to: <strong>Settings ‚Üí Secrets and variables ‚Üí Actions</strong></li>
  <li>Click <strong>New repository secret</strong></li>
  <li>Configure:
‚Ä¢ <strong>Name:</strong> <code class="language-plaintext highlighter-rouge">REPO_CREATE_TOKEN</code>
‚Ä¢ <strong>Secret:</strong> Paste your PAT</li>
  <li>Click <strong>Add secret</strong></li>
</ol>

<h3 id="step-3-understand-repository-ownership-context">Step 3: Understand Repository Ownership Context</h3>
<p><strong>Important:</strong> When using <code class="language-plaintext highlighter-rouge">context.repo.owner</code> in the workflow:
‚Ä¢ It references the owner of the repository where the workflow runs
‚Ä¢ For user <code class="language-plaintext highlighter-rouge">ib-bsb-br</code>, if the workflow runs in <code class="language-plaintext highlighter-rouge">ib-bsb-br/workflow-repo</code>, the new repository will be created under <code class="language-plaintext highlighter-rouge">ib-bsb-br</code>
‚Ä¢ To create repositories in an organization, you must modify the owner variable explicitly</p>

<h2 id="part-2-implementation---choose-your-approach">Part 2: Implementation - Choose Your Approach</h2>

<h3 id="decision-matrix-which-approach-to-use">Decision Matrix: Which Approach to Use?</h3>

<table>
  <thead>
    <tr>
      <th>Factor</th>
      <th>API Approach</th>
      <th>Git Command Approach</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Best for</strong></td>
      <td>Small to medium files (&lt;100MB per file)</td>
      <td>Any file size, including large files</td>
    </tr>
    <tr>
      <td><strong>Complexity</strong></td>
      <td>More complex, API-based</td>
      <td>Simpler, uses standard git</td>
    </tr>
    <tr>
      <td><strong>File size limits</strong></td>
      <td>100MB per blob</td>
      <td>No API limits, only git limits</td>
    </tr>
    <tr>
      <td><strong>Speed</strong></td>
      <td>Can be slower for many files</td>
      <td>Faster for many files</td>
    </tr>
    <tr>
      <td><strong>Error handling</strong></td>
      <td>More granular control</td>
      <td>Less granular</td>
    </tr>
    <tr>
      <td><strong>Dependencies</strong></td>
      <td>GitHub API only</td>
      <td>Requires git, curl, unzip</td>
    </tr>
  </tbody>
</table>

<p><strong>Recommendation:</strong> Use the Git Command Approach for simplicity unless you need specific API features.</p>

<h2 id="approach-1-git-command-method-recommended">Approach 1: Git Command Method (Recommended)</h2>
<p>This approach is simpler, more reliable, and handles larger files better.</p>

<h3 id="create-workflow-file">Create Workflow File</h3>
<p>Create <code class="language-plaintext highlighter-rouge">.github/workflows/unzip-to-repo.yml</code> in your repository:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Unzip and Create Repository (Git Method)</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">repo_name</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Name</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">the</span><span class="nv"> </span><span class="s">new</span><span class="nv"> </span><span class="s">repository</span><span class="nv"> </span><span class="s">(must</span><span class="nv"> </span><span class="s">be</span><span class="nv"> </span><span class="s">unique)'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="kc">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">unzipped-content'</span>
      <span class="na">zip_url</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">URL</span><span class="nv"> </span><span class="s">of</span><span class="nv"> </span><span class="s">the</span><span class="nv"> </span><span class="s">ZIP</span><span class="nv"> </span><span class="s">file</span><span class="nv"> </span><span class="s">to</span><span class="nv"> </span><span class="s">download'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="kc">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">https://x0.at/XS2C.zip'</span>
      <span class="na">repo_description</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Description</span><span class="nv"> </span><span class="s">for</span><span class="nv"> </span><span class="s">the</span><span class="nv"> </span><span class="s">new</span><span class="nv"> </span><span class="s">repository'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="kc">false</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Repository</span><span class="nv"> </span><span class="s">created</span><span class="nv"> </span><span class="s">from</span><span class="nv"> </span><span class="s">ZIP</span><span class="nv"> </span><span class="s">file</span><span class="nv"> </span><span class="s">extraction'</span>
      <span class="na">private_repo</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Make</span><span class="nv"> </span><span class="s">repository</span><span class="nv"> </span><span class="s">private?'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="kc">true</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>
        <span class="na">default</span><span class="pi">:</span> <span class="kc">false</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">create-repo-from-zip</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Validate inputs</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">echo "üîç Validating inputs..."</span>
          <span class="s">echo "Repository name: ${{ inputs.repo_name }}"</span>
          <span class="s">echo "ZIP URL: ${{ inputs.zip_url }}"</span>
          <span class="s">echo "Private: ${{ inputs.private_repo }}"</span>
          
          <span class="s"># Basic repository name validation</span>
          <span class="s">if [[ ! "${{ inputs.repo_name }}" =~ ^[a-zA-Z0-9_-]+$ ]]; then</span>
            <span class="s">echo "‚ùå Error: Repository name can only contain alphanumeric characters, hyphens, and underscores"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Download ZIP file</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">echo "üì• Downloading ZIP file from ${{ inputs.zip_url }}"</span>
          
          <span class="s"># Download with timeout and error handling</span>
          <span class="s">if ! curl -L -f -o archive.zip --max-time 300 "${{ inputs.zip_url }}"; then</span>
            <span class="s">echo "‚ùå Failed to download ZIP file"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
          
          <span class="s"># Verify file was downloaded and has content</span>
          <span class="s">if [ ! -s archive.zip ]; then</span>
            <span class="s">echo "‚ùå Downloaded file is empty"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
          
          <span class="s">echo "‚úÖ Downloaded $(du -h archive.zip | cut -f1) file"</span>
          
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract ZIP contents</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">echo "üì¶ Extracting ZIP file..."</span>
          <span class="s">mkdir -p extracted_content</span>
          
          <span class="s"># Extract with error handling</span>
          <span class="s">if ! unzip -q archive.zip -d extracted_content; then</span>
            <span class="s">echo "‚ùå Failed to extract ZIP file"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
          
          <span class="s"># Check if extraction produced files</span>
          <span class="s">file_count=$(find extracted_content -type f | wc -l)</span>
          <span class="s">if [ "$file_count" -eq 0 ]; then</span>
            <span class="s">echo "‚ùå No files found in ZIP archive"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
          
          <span class="s">echo "‚úÖ Extracted $file_count files"</span>
          <span class="s">echo "üìÇ Directory structure:"</span>
          <span class="s">tree extracted_content/ || ls -R extracted_content/</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Create repository via API</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v8</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">create-repo</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">REPO_NAME</span><span class="pi">:</span> <span class="s">${{ inputs.repo_name }}</span>
          <span class="na">REPO_DESCRIPTION</span><span class="pi">:</span> <span class="s">${{ inputs.repo_description }}</span>
          <span class="na">PRIVATE_REPO</span><span class="pi">:</span> <span class="s">${{ inputs.private_repo }}</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">${{ secrets.REPO_CREATE_TOKEN }}</span>
          <span class="na">retries</span><span class="pi">:</span> <span class="m">3</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const repoName = process.env.REPO_NAME;</span>
            <span class="s">const repoDescription = process.env.REPO_DESCRIPTION;</span>
            <span class="s">const isPrivate = process.env.PRIVATE_REPO === 'true';</span>
            
            <span class="s">// Get the authenticated user to ensure we're creating in the right account</span>
            <span class="s">const { data: user } = await github.rest.users.getAuthenticated();</span>
            <span class="s">console.log(`üîê Authenticated as: ${user.login}`);</span>
            
            <span class="s">try {</span>
              <span class="s">console.log(`üìù Creating repository: ${user.login}/${repoName}`);</span>
            <span class="no">  </span>
              <span class="s">const { data: repo } = await github.rest.repos.createForAuthenticatedUser({</span>
                <span class="s">name: repoName,</span>
                <span class="s">description: repoDescription,</span>
                <span class="s">private: isPrivate,</span>
                <span class="s">auto_init: false,</span>
                <span class="s">has_issues: true,</span>
                <span class="s">has_projects: true,</span>
                <span class="s">has_wiki: true</span>
              <span class="s">});</span>
            <span class="no">  </span>
              <span class="s">console.log(`‚úÖ Repository created: ${repo.html_url}`);</span>
              <span class="s">console.log(`üìã Clone URL: ${repo.clone_url}`);</span>
            <span class="no">  </span>
              <span class="s">// Return the clone URL for the next step</span>
              <span class="s">return repo.clone_url;</span>
            <span class="no">  </span>
            <span class="s">} catch (error) {</span>
              <span class="s">if (error.status === 422) {</span>
                <span class="s">core.setFailed(`Repository '${repoName}' already exists in your account. Please choose a different name or delete the existing repository.`);</span>
              <span class="s">} else if (error.status === 401) {</span>
                <span class="s">core.setFailed('Authentication failed. Please verify your REPO_CREATE_TOKEN secret has the correct permissions.');</span>
              <span class="s">} else {</span>
                <span class="s">core.setFailed(`Failed to create repository: ${error.message}`);</span>
              <span class="s">}</span>
              <span class="s">throw error;</span>
            <span class="s">}</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Initialize git and push content</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">REPO_URL</span><span class="pi">:</span> <span class="s">${{ steps.create-repo.outputs.result }}</span>
          <span class="na">GITHUB_TOKEN</span><span class="pi">:</span> <span class="s">${{ secrets.REPO_CREATE_TOKEN }}</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">cd extracted_content</span>
          
          <span class="s">echo "üîß Configuring git..."</span>
          <span class="s">git config --global user.name "github-actions[bot]"</span>
          <span class="s">git config --global user.email "github-actions[bot]@users.noreply.github.com"</span>
          
          <span class="s">echo "üìã Initializing repository..."</span>
          <span class="s">git init</span>
          
          <span class="s"># Create .gitattributes for proper line ending handling</span>
          <span class="s">echo "* text=auto" &gt; .gitattributes</span>
          
          <span class="s">echo "‚ûï Adding all files..."</span>
          <span class="s">git add .</span>
          
          <span class="s">echo "üíæ Creating initial commit..."</span>
          <span class="s">git commit -m "Initial commit: Add files from ZIP archive</span>

          <span class="s">Source: ${{ inputs.zip_url }}</span>
          <span class="s">Extracted: $(date -u +"%Y-%m-%d %H:%M:%S UTC")</span>
          <span class="s">Workflow: ${{ github.repository }}@${{ github.sha }}"</span>
          
          <span class="s">echo "üåø Setting default branch to main..."</span>
          <span class="s">git branch -M main</span>
          
          <span class="s">echo "üîó Adding remote..."</span>
          <span class="s"># Insert token into URL for authentication</span>
          <span class="s">REPO_URL_WITH_TOKEN=$(echo "$REPO_URL" | sed "s|https://|https://x-access-token:${GITHUB_TOKEN}@|")</span>
          <span class="s">git remote add origin "$REPO_URL_WITH_TOKEN"</span>
          
          <span class="s">echo "‚¨ÜÔ∏è Pushing to remote..."</span>
          <span class="s">if git push -u origin main; then</span>
            <span class="s">echo "‚úÖ Successfully pushed to repository!"</span>
          <span class="s">else</span>
            <span class="s">echo "‚ùå Failed to push to repository"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Generate summary</span>
        <span class="na">if</span><span class="pi">:</span> <span class="s">success()</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">REPO_URL</span><span class="pi">:</span> <span class="s">${{ steps.create-repo.outputs.result }}</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">echo "## ‚úÖ Workflow Completed Successfully!" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "### Repository Details" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "- **Name:** ${{ inputs.repo_name }}" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "- **URL:** [View Repository](${REPO_URL%.git})" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "- **Visibility:** ${{ inputs.private_repo == 'true' &amp;&amp; 'Private' || 'Public' }}" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "### Source" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "- **ZIP URL:** ${{ inputs.zip_url }}" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "" &gt;&gt; $GITHUB_STEP_SUMMARY</span>
          <span class="s">echo "üéâ All files from the ZIP archive have been extracted and pushed to the new repository!" &gt;&gt; $GITHUB_STEP_SUMMARY</span>

      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Cleanup failure</span>
        <span class="na">if</span><span class="pi">:</span> <span class="s">failure()</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v8</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">REPO_NAME</span><span class="pi">:</span> <span class="s">${{ inputs.repo_name }}</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">${{ secrets.REPO_CREATE_TOKEN }}</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const repoName = process.env.REPO_NAME;</span>
            <span class="s">const { data: user } = await github.rest.users.getAuthenticated();</span>
            
            <span class="s">try {</span>
              <span class="s">// Check if repo exists</span>
              <span class="s">await github.rest.repos.get({</span>
                <span class="s">owner: user.login,</span>
                <span class="s">repo: repoName</span>
              <span class="s">});</span>
            <span class="no">  </span>
              <span class="s">// If we get here, repo exists - ask if they want to clean it up</span>
              <span class="s">console.log(`‚ö†Ô∏è Repository ${user.login}/${repoName} was created but workflow failed.`);</span>
              <span class="s">console.log(`Consider deleting it manually if it's empty: https://github.com/${user.login}/${repoName}/settings`);</span>
            <span class="no">  </span>
            <span class="s">} catch (error) {</span>
              <span class="s">// Repo doesn't exist, nothing to clean up</span>
              <span class="s">console.log('No repository cleanup needed.');</span>
            <span class="s">}</span>
</code></pre></div></div>

<h2 id="running-the-workflow">Running the Workflow</h2>

<h3 id="via-github-web-interface">Via GitHub Web Interface</h3>
<ol>
  <li>Navigate to your repository: https://github.com/ib-bsb-br/YOUR_REPO_NAME</li>
  <li>Click <strong>Actions</strong> tab</li>
  <li>Select <strong>Unzip and Create Repository</strong> workflow (whichever approach you chose)</li>
  <li>Click <strong>Run workflow</strong> dropdown button</li>
  <li>Fill in parameters:
‚Ä¢ <strong>repo_name:</strong> <code class="language-plaintext highlighter-rouge">my-extracted-content</code> (must be unique in your account)
‚Ä¢ <strong>zip_url:</strong> <code class="language-plaintext highlighter-rouge">https://x0.at/XS2C.zip</code> (or your desired URL)
‚Ä¢ <strong>repo_description:</strong> ‚ÄúContent extracted from ZIP file‚Äù
‚Ä¢ <strong>private_repo:</strong> <code class="language-plaintext highlighter-rouge">false</code> (or <code class="language-plaintext highlighter-rouge">true</code> for private)</li>
  <li>Click <strong>Run workflow</strong> button</li>
  <li>Wait for workflow to complete (usually 1-5 minutes)</li>
</ol>

<h3 id="via-github-cli">Via GitHub CLI:</h3>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Install GitHub CLI if needed</span>
<span class="c"># https://cli.github.com/</span>

<span class="c"># Authenticate</span>
gh auth login

<span class="c"># Run the workflow</span>
gh workflow run <span class="s2">"Unzip and Create Repository (Git Method)"</span> <span class="se">\</span>
  <span class="nt">--repo</span> ib-bsb-br/YOUR_REPO_NAME <span class="se">\</span>
  <span class="nt">-f</span> <span class="nv">repo_name</span><span class="o">=</span><span class="s2">"my-extracted-content"</span> <span class="se">\</span>
  <span class="nt">-f</span> <span class="nv">zip_url</span><span class="o">=</span><span class="s2">"https://x0.at/XS2C.zip"</span> <span class="se">\</span>
  <span class="nt">-f</span> <span class="nv">repo_description</span><span class="o">=</span><span class="s2">"Content from ZIP extraction"</span> <span class="se">\</span>
  <span class="nt">-f</span> <span class="nv">private_repo</span><span class="o">=</span><span class="nb">false</span>

<span class="c"># Watch the workflow</span>
gh run watch
</code></pre></div></div>

<h2 id="handling-zip-files-with-nested-structure">Handling ZIP Files with Nested Structure</h2>
<p>If your ZIP has a root folder (common with GitHub‚Äôs archive downloads):</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract and flatten if needed</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">unzip -q archive.zip -d temp_extract</span>
    
    <span class="s"># Check if everything is in a single root directory</span>
    <span class="s">root_contents_count=$(ls -A temp_extract | wc -l)</span>
    <span class="s">first_item="temp_extract/$(ls -A temp_extract | head -n 1)"</span>

    <span class="s">if [ "$root_contents_count" -eq 1 ] &amp;&amp; [ -d "$first_item" ]; then</span>
      <span class="s">echo "Flattening nested structure from '$first_item'"</span>
      <span class="s">mv "$first_item" extracted_content</span>
      <span class="s">rm -rf temp_extract</span>
    <span class="s">else</span>
      <span class="s">mv temp_extract extracted_content</span>
    <span class="s">fi</span>
</code></pre></div></div>

<h2 id="adding-custom-files-after-extraction">Adding Custom Files After Extraction</h2>
<p>To add additional files (like README, LICENSE) after extraction:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Add custom files</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">cd extracted_content</span>
    
    <span class="s"># Add a README explaining the source</span>
    <span class="s">cat &gt; README.md &lt;&lt; EOF</span>
    <span class="s"># Extracted Content</span>
    
    <span class="s">This repository was automatically created from a ZIP archive.</span>
    
    <span class="s">**Source:** ${{ inputs.zip_url }}</span>
    <span class="s">**Created:** $(date)</span>
    <span class="s">**Original Repository:** ${{ github.repository }}</span>
    <span class="s">EOF</span>
    
    <span class="s"># Add a .gitignore</span>
    <span class="s">cat &gt; .gitignore &lt;&lt; 'EOF'</span>
    <span class="s"># Add any patterns you want to ignore</span>
    <span class="s">*.log</span>
    <span class="s">.DS_Store</span>
    <span class="s">EOF</span>
</code></pre></div></div>

<h2 id="debugging-steps">Debugging Steps:</h2>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Add this step after extraction to inspect contents</span>
<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Debug - List extracted files</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">echo "Current directory:"</span>
    <span class="s">pwd</span>
    <span class="s">echo "Extracted content:"</span>
    <span class="s">find extracted_content -type f</span>
    <span class="s">echo "File count:"</span>
    <span class="s">find extracted_content -type f | wc -l</span>
</code></pre></div></div>

<h2 id="complete-working-example">Complete Working Example</h2>
<p>Here‚Äôs a complete, tested workflow that incorporates best practices:</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">name</span><span class="pi">:</span> <span class="s">Production-Ready Unzip to Repository</span>

<span class="na">on</span><span class="pi">:</span>
  <span class="na">workflow_dispatch</span><span class="pi">:</span>
    <span class="na">inputs</span><span class="pi">:</span>
      <span class="na">repo_name</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Repository</span><span class="nv"> </span><span class="s">name</span><span class="nv"> </span><span class="s">(alphanumeric,</span><span class="nv"> </span><span class="s">hyphens,</span><span class="nv"> </span><span class="s">underscores</span><span class="nv"> </span><span class="s">only)'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="kc">true</span>
      <span class="na">zip_url</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">ZIP</span><span class="nv"> </span><span class="s">file</span><span class="nv"> </span><span class="s">URL</span><span class="nv"> </span><span class="s">(must</span><span class="nv"> </span><span class="s">be</span><span class="nv"> </span><span class="s">direct</span><span class="nv"> </span><span class="s">download</span><span class="nv"> </span><span class="s">link)'</span>
        <span class="na">required</span><span class="pi">:</span> <span class="kc">true</span>
        <span class="na">default</span><span class="pi">:</span> <span class="s1">'</span><span class="s">https://x0.at/XS2C.zip'</span>
      <span class="na">private_repo</span><span class="pi">:</span>
        <span class="na">description</span><span class="pi">:</span> <span class="s1">'</span><span class="s">Create</span><span class="nv"> </span><span class="s">as</span><span class="nv"> </span><span class="s">private</span><span class="nv"> </span><span class="s">repository?'</span>
        <span class="na">type</span><span class="pi">:</span> <span class="s">boolean</span>
        <span class="na">default</span><span class="pi">:</span> <span class="kc">false</span>

<span class="na">jobs</span><span class="pi">:</span>
  <span class="na">validate-and-create</span><span class="pi">:</span>
    <span class="na">runs-on</span><span class="pi">:</span> <span class="s">ubuntu-latest</span>
    <span class="na">timeout-minutes</span><span class="pi">:</span> <span class="m">30</span>
    
    <span class="na">outputs</span><span class="pi">:</span>
      <span class="na">repo_url</span><span class="pi">:</span> <span class="s">${{ steps.create-repo.outputs.result }}</span>
    
    <span class="na">steps</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Validate repository name</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">if [[ ! "${{ inputs.repo_name }}" =~ ^[a-zA-Z0-9_-]{1,100}$ ]]; then</span>
            <span class="s">echo "::error::Invalid repository name. Use only letters, numbers, hyphens, and underscores (1-100 characters)"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Download ZIP with retry</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">nick-fields/retry@v2</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">timeout_minutes</span><span class="pi">:</span> <span class="m">5</span>
          <span class="na">max_attempts</span><span class="pi">:</span> <span class="m">3</span>
          <span class="na">command</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">curl -L -f -o archive.zip "${{ inputs.zip_url }}"</span>
            <span class="s">if [ ! -s archive.zip ]; then</span>
              <span class="s">echo "Downloaded file is empty"</span>
              <span class="s">exit 1</span>
            <span class="s">fi</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Extract and validate</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">mkdir extracted_content</span>
          <span class="s">if ! unzip -q archive.zip -d extracted_content; then</span>
            <span class="s">echo "::error::Failed to extract ZIP file. File may be corrupted."</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
          
          <span class="s">file_count=$(find extracted_content -type f | wc -l)</span>
          <span class="s">if [ "$file_count" -eq 0 ]; then</span>
            <span class="s">echo "::error::ZIP archive contains no files"</span>
            <span class="s">exit 1</span>
          <span class="s">fi</span>
          
          <span class="s">echo "FILES_COUNT=$file_count" &gt;&gt; $GITHUB_ENV</span>
          <span class="s">echo "::notice::Successfully extracted $file_count files"</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Create repository</span>
        <span class="na">id</span><span class="pi">:</span> <span class="s">create-repo</span>
        <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/github-script@v8</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">REPO_NAME</span><span class="pi">:</span> <span class="s">${{ inputs.repo_name }}</span>
          <span class="na">PRIVATE</span><span class="pi">:</span> <span class="s">${{ inputs.private_repo }}</span>
        <span class="na">with</span><span class="pi">:</span>
          <span class="na">github-token</span><span class="pi">:</span> <span class="s">${{ secrets.REPO_CREATE_TOKEN }}</span>
          <span class="na">retries</span><span class="pi">:</span> <span class="m">3</span>
          <span class="na">script</span><span class="pi">:</span> <span class="pi">|</span>
            <span class="s">const { data: user } = await github.rest.users.getAuthenticated();</span>
            <span class="s">const { data: repo } = await github.rest.repos.createForAuthenticatedUser({</span>
              <span class="s">name: process.env.REPO_NAME,</span>
              <span class="s">description: `Created from ZIP: ${{ inputs.zip_url }}`,</span>
              <span class="s">private: process.env.PRIVATE === 'true',</span>
              <span class="s">auto_init: false</span>
            <span class="s">});</span>
            <span class="s">core.notice(`Repository created: ${repo.html_url}`);</span>
            <span class="s">return repo.clone_url;</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Push content</span>
        <span class="na">env</span><span class="pi">:</span>
          <span class="na">REPO_URL</span><span class="pi">:</span> <span class="s">${{ steps.create-repo.outputs.result }}</span>
          <span class="na">TOKEN</span><span class="pi">:</span> <span class="s">${{ secrets.REPO_CREATE_TOKEN }}</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">cd extracted_content</span>
          <span class="s">git init -b main</span>
          <span class="s">git config user.name "github-actions[bot]"</span>
          <span class="s">git config user.email "github-actions[bot]@users.noreply.github.com"</span>
          <span class="s">git add .</span>
          <span class="s">git commit -m "Initial commit from ZIP archive"</span>
          <span class="s">git remote add origin "$(echo "$REPO_URL" | sed "s|https://|https://x-access-token:$TOKEN@|")"</span>
          <span class="s">git push -u origin main</span>
      
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Success summary</span>
        <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
          <span class="s">cat &gt;&gt; $GITHUB_STEP_SUMMARY &lt;&lt; EOF</span>
          <span class="s">## ‚úÖ Repository Created Successfully</span>
          
          <span class="s">- **Name:** ${{ inputs.repo_name }}</span>
          <span class="s">- **URL:** $(echo "${{ steps.create-repo.outputs.result }}" | sed 's/.git$//')</span>
          <span class="s">- **Files:** ${{ env.FILES_COUNT }}</span>
          <span class="s">- **Visibility:** ${{ inputs.private_repo == 'true' &amp;&amp; 'Private üîí' || 'Public üåç' }}</span>
          
          <span class="s">[View Repository ‚Üí]($(echo "${{ steps.create-repo.outputs.result }}" | sed 's/.git$//'))</span>
          <span class="s">EOF</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="scratchpad" /></entry><entry><title type="html">DirectAdmin terminal custom commands</title><link href="https://ib.bsb.br/da-term/" rel="alternate" type="text/html" title="DirectAdmin terminal custom commands" /><published>2025-10-25T00:00:00+00:00</published><updated>2025-11-13T21:49:36+00:00</updated><id>https://ib.bsb.br/da-term</id><content type="html" xml:base="https://ib.bsb.br/da-term/"><![CDATA[<h1 id="01-environment-modules-exploration-usrsharemodules">01) Environment Modules exploration (/usr/share/Modules)</h1>
<p>alias h01_modules_explore=‚Äô
  pushd /usr/share/Modules &gt;/dev/null; ls;
    pushd modulefiles &gt;/dev/null; ls;
      pushd use.own &gt;/dev/null; cat use.own || true; popd &gt;/dev/null;
      ls; pushd module &gt;/dev/null || true; popd &gt;/dev/null || true;
      pushd modules &gt;/dev/null || true; { cat dot || true; cat module-git || true; ls; cat module || true; cat modules || true; } ; popd &gt;/dev/null || true;
    popd &gt;/dev/null;
    pushd bin &gt;/dev/null || true; ls; { cat createmodule. || true; cat createmodule.sh || true; } ; popd &gt;/dev/null || true;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="02-directadmin-browse-user-datadomains-and-editremove-files">02) DirectAdmin: browse user data/domains and edit/remove files</h1>
<p>alias h02_da_user_domains=‚Äô
  pushd /usr/local/directadmin/data &gt;/dev/null; ls;
    pushd users &gt;/dev/null; ls;
      pushd ibbsbbry &gt;/dev/null; ls;
        pushd domains &gt;/dev/null; ls; pwd;
          true;  # placeholder for ‚Äúwhich cut.ia.br.cust_nginx‚Äù (non-command in history)
          popd &gt;/dev/null;
        ls; pwd;
        pushd php &gt;/dev/null || true; ls; { cat php.ini || true; } ; popd &gt;/dev/null || true;
        pushd domains &gt;/dev/null; ls; pwd;
          rm -f cut.ia.br.cust_httpd || true;
        popd &gt;/dev/null;
      popd &gt;/dev/null;
    popd &gt;/dev/null;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="03-directadmin-pluginsshared-sockets-and-directadmin-binary-ops">03) DirectAdmin: plugins/shared, sockets, and directadmin binary ops</h1>
<p>alias h03_da_admin_ops=‚Äô
  pushd /usr/local/directadmin &gt;/dev/null; ls;
    pushd plugins &gt;/dev/null || true; ls; popd &gt;/dev/null || true;
    pushd data &gt;/dev/null; ls; popd &gt;/dev/null;
    pushd shared &gt;/dev/null; ls;
      { cat internal.sock || true; cat startips-network || true; }
    popd &gt;/dev/null;
    ./directadmin || true;
    ./directadmin permissions || true;
    sudo ./directadmin permissions || true;
    ./directadmin version || true;
    ./directadmin update || true;
    ./directadmin my-cnf || true;
    ./directadmin create-login-url || true;
    ./directadmin license || true;
    ./directadmin login-url || true;
    ./directadmin info || true;
    ./directadmin config-get || true;
    ./directadmin config-get -h || true;
    ./directadmin admin || true;
    ./directadmin build || true;
    pwd; ls
  popd &gt;/dev/null
‚Äò</p>

<h1 id="04-directadmin-createedit-domain-conf-sample">04) DirectAdmin: create/edit domain conf sample</h1>
<p>alias h04_da_edit_domain_conf=‚Äô
  pushd /usr/local/directadmin/data/users/ibbsbbry/domains &gt;/dev/null;
    ls; touch cut.ia.br.conf; ${EDITOR:-nano} cut.ia.br.conf || true; cat cut.ia.br.conf || true;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="05-directadmin-cpanel-migration-scripts-and-internals">05) DirectAdmin: cPanel migration scripts and internals</h1>
<p>alias h05_da_migration_scripts=‚Äô
  pushd /usr/local/directadmin &gt;/dev/null; ls;
    pushd shared &gt;/dev/null; ls; pushd cpanel_to_da &gt;/dev/null; ls; cat cpanel_to_da.sh || true; popd &gt;/dev/null;
    ls; pushd internal.sock &gt;/dev/null || true; cat internal.sock || true; popd &gt;/dev/null || true;
    { cat startips-networkd || true; }
    pushd scripts &gt;/dev/null; ls; pushd cpanel_to_da &gt;/dev/null || true; ls; popd &gt;/dev/null || true;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="06-transfer-helpers-curl-uploads-and-quick-sysinfo">06) Transfer helpers: curl uploads and quick sysinfo</h1>
<p>alias h06_transfers_sysinfo=‚Äô
  pushd /usr/local/directadmin/scripts/cpanel_to_da &gt;/dev/null || true; ls || true; touch text.md || true; popd &gt;/dev/null || true;
  curl ‚Äìhelp || true;
  curl -fsS -F ‚Äúfile=@-;filename=cpanel_to_da.sh‚Äù https://x0.at/ ¬´&lt;‚Äùplaceholder‚Äù || true;
  curl -F ‚Äúfile=@cpanel_to_da.sh‚Äù https://0x0.st || true;
  getconf ‚Äìhelp || true;
  uptime || true;
  ip a || true;
  which npx || true; npx ‚Äìhelp || true;
  npm ‚Äìhelp || true; npm ‚Äìversion || true; which npm || true
‚Äò</p>

<h1 id="07-directadmin-grep-web-stack-and-mail-domain-owners">07) DirectAdmin: grep web stack and mail domain owners</h1>
<p>alias h07_da_webstack_mail=‚Äô
  grep -E ‚Äò‚Äù‚Äô‚Äù‚Äô^(nginx|nginx_proxy|openlitespeed)=‚Äô‚Äù‚Äô‚Äù‚Äô /usr/local/directadmin/conf/directadmin.conf || true;
  head /etc/virtual/domainowners || true
‚Äò</p>

<h1 id="08-etc-basics-hosts-resolv-mysql-npmrc-sysconfig">08) /etc basics: hosts, resolv, mysql, npmrc, sysconfig</h1>
<p>alias h08_etc_core=‚Äô
  pushd /etc &gt;/dev/null; ls;
    { cat host.conf || true; cat hosts || true; cat my.cnf || true; cat npmrc || true; cat resolv.conf || true; } ;
    ls; { cat trusted-key.key || true; cat virc || true; } ;
    ls; pushd sysconfig &gt;/dev/null || true; ls; { cat saslauthd || true; cat snmp || true; } ; popd &gt;/dev/null || true;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="09-ssl-and-ssh-inspection">09) SSL and SSH inspection</h1>
<p>alias h09_ssl_ssh=‚Äô
  pushd /etc/ssl/certs &gt;/dev/null || true; ls; { cat ca-bundle. || true; cat ca-bundle.crt || true; } ; popd &gt;/dev/null || true;
  pushd /etc &gt;/dev/null; ls; popd &gt;/dev/null;
  pushd /etc/ssh &gt;/dev/null || true; ls; cat ssh_config || true; ls; pushd ssh_config.d &gt;/dev/null || true; ls; popd &gt;/dev/null || true;
  pushd /etc/ssh/moduli &gt;/dev/null || true; ls; cat moduli || true; popd &gt;/dev/null || true;
  pushd /etc/skel &gt;/dev/null || true; ls; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="10-etcprofiled-helpers">10) /etc/profile.d helpers</h1>
<p>alias h10_profiled_helpers=‚Äô
  pushd /etc/profile.d &gt;/dev/null || true; ls; bash which2.sh ‚Äìhelp || true; cat alt_mod_passenger.sh || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="11-logs-cagefs-proxyexec">11) Logs, CageFS, proxyexec</h1>
<p>alias h11_logs_cagefs=‚Äô
  pushd /var/log/user_logs &gt;/dev/null || true; ls; pushd ibbsbbry &gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /var &gt;/dev/null; ls -a; { cat .cagefs/ 2&gt;/dev/null || true; } ; pushd .cagefs &gt;/dev/null || true; ls -a; cat .cagefs.token || true; popd &gt;/dev/null || true; popd &gt;/dev/null;
  id || true; ps aux | grep proxyexec || true; ps aux || true;
  proxyexec -h || true; /usr/sbin/proxyexec -c cagefs.sock ibbsbbry CzlNuXVAWS7rH7Cc / CRONTAB_LIST 0 || true
‚Äò</p>

<h1 id="12-vartmp--varwww-basics-and-cgi">12) /var/tmp + /var/www basics and CGI</h1>
<p>alias h12_var_www=‚Äô
  pushd /var/tmp &gt;/dev/null || true; ls -a; cat mysql.sock || true; popd &gt;/dev/null || true;
  pushd /var/www &gt;/dev/null || true; ls; pushd html &gt;/dev/null || true; ls; { cat p.php || true; cat index.html || true; cat redirect.php || true; } ; popd &gt;/dev/null || true;
  pushd cgi-bin &gt;/dev/null || true; ls; { cat test-cgi || true; cat printenv || true; } ; popd &gt;/dev/null || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="13-passenger-runtime-home--inspect-instance-dirs-and-secrets">13) Passenger runtime (home) ‚Äî inspect instance dirs and secrets</h1>
<p>alias h13_passenger_runtime=‚Äô
  pushd ~/passenger &gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true;
  for d in ~/passenger.z* ~/passenger.R*; do
    [ -d ‚Äú$d‚Äù ] || continue;
    pushd ‚Äú$d‚Äù &gt;/dev/null; ls; { cat read_only_admin_password.txt 2&gt;/dev/null || true; cat properties.json 2&gt;/dev/null || true; } ;
      pushd web_server_info &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true;
      { cat watchdog.pid 2&gt;/dev/null || true; cat full_admin_password.txt 2&gt;/dev/null || true; cat creation_finalized 2&gt;/dev/null || true; cat core.pid 2&gt;/dev/null || true; } ;
      pushd agents.s &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; pushd core &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true; popd &gt;/dev/null || true;
      { cat core.pid 2&gt;/dev/null || true; cat creation_finalized 2&gt;/dev/null || true; cat lock 2&gt;/dev/null || true; cat properties.json 2&gt;/dev/null || true; } ;
    popd &gt;/dev/null;
  done
‚Äò</p>

<h1 id="14-cloudlinux-selector-and-scl-tooling">14) CloudLinux selector and SCL tooling</h1>
<p>alias h14_cl_selector_scl=‚Äô
  cloudlinux-selector ‚Äìhelp || true;
  cloudlinux-selector ‚Äìapp-mode || true;
  cloudlinux-selector ‚Äìget-supported-versions || true;
  cloudlinux-selector ‚Äìjson ‚Äìget-supported-versions || true;
  cloudlinux-selector ‚Äìjson ‚Äìinterpreter nodejs ‚Äìextensions nodejs || true;
  cloudlinux-selector ‚Äìjson ‚Äìextensions nodejs || true;
  cloudlinux-selector ‚Äìjson ‚Äìenv-vars || true;
  cloudlinux-selector ‚Äìjson ‚Äìget-selector-status || true;
  cloudlinux-selector ‚Äìjson ‚Äìinterpreter nodejs ‚Äìget-supported-versions || true;
  scl ‚Äìhelp || true; scl list-collections || true; scl list-enabled || true; scl list-packages || true; scl list-packages alt-nodejs12 || true; scl list-packages alt-nodejs10 || true;
  scl enable alt-nodejs12 ‚Äúbash -lc ‚Äò‚Äù‚Äô‚Äú‚Äònode -v; npm -v‚Äô‚Äù‚Äô‚Äù‚Äô‚Äù || true;
  scl run alt-nodejs12 node -v || true; scl run alt-nodejs12 npm -v || true
‚Äò</p>

<h1 id="15-domain-content-well-known-acme-roundcube-awstats">15) Domain content: .well-known, acme, roundcube, awstats</h1>
<p>alias h15_domain_webbits=‚Äô
  pushd ~/public_html &gt;/dev/null || true; ls; pushd .well-known &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; { cat .htaccess 2&gt;/dev/null || true; } ; pushd acme-challenge &gt;/dev/null 2&gt;/dev/null || true; ls || true; { cat letsencrypt_1596475466 2&gt;/dev/null || true; } ; popd &gt;/dev/null || true; popd &gt;/dev/null || true;
  for d in ~/roundcube/public_html ~/public_html/awstats; do pushd ‚Äú$d‚Äù &gt;/dev/null 2&gt;/dev/null || true; ls; { cat index.php 2&gt;/dev/null || cat index.html 2&gt;/dev/null || true; } ; popd &gt;/dev/null || true; done
‚Äò</p>

<h1 id="16-opt-tools-ai-bolit-app-version-detector-cloudlinux-flagshooks">16) /opt tools: ai-bolit, app-version-detector, cloudlinux flags/hooks</h1>
<p>alias h16_opt_tooling=‚Äô
  pushd /opt &gt;/dev/null; ls -a;
    pushd ai-bolit &gt;/dev/null 2&gt;/dev/null || true; ls; cat ai-bolit.php || true; popd &gt;/dev/null || true;
    pushd app-version-detector &gt;/dev/null 2&gt;/dev/null || true; ls; bash app-version-detector.sh || true; cat app-version-detector-wrapper.sh || true; popd &gt;/dev/null || true;
    pushd cloudlinux &gt;/dev/null 2&gt;/dev/null || true; ls -a; { cat nginx_status 2&gt;/dev/null || true; cat litespeed_status 2&gt;/dev/null || true; cat cl_edition 2&gt;/dev/null || true; } ;
      pushd flags &gt;/dev/null 2&gt;/dev/null || true; ls -a; pushd available-flags.d &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true; pushd enabled-flags.d &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true; popd &gt;/dev/null || true;
      pushd rhn_hooks/post.d &gt;/dev/null 2&gt;/dev/null || true; ls; cat rhn-update-hook.sh || true; popd &gt;/dev/null || true;
    popd &gt;/dev/null || true;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="17-cloudlinux-venv--pythonpip-tooling">17) CloudLinux venv + Python/pip tooling</h1>
<p>alias h17_opt_python_venv=‚Äô
  pushd /opt/cloudlinux/venv &gt;/dev/null 2&gt;/dev/null || true; ls; cat pyvenv.cfg 2&gt;/dev/null || true; /opt/alt/python311/bin/python3 -m venv ‚Äìupgrade-deps /opt/cloudlinux/venv || true; ls; pushd bin &gt;/dev/null 2&gt;/dev/null || true; ls; cat Activate.ps1 2&gt;/dev/null || true; cat activate 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/cloudlinux/venv/bin &gt;/dev/null 2&gt;/dev/null || true; python3 ‚Äìversion || true; pip3 ‚Äìversion || true; pip ‚Äìversion || true; popd &gt;/dev/null || true;
  python3 ‚Äìversion || true
‚Äò</p>

<h1 id="18-cloudlinux-helper-scripts--packages">18) CloudLinux helper scripts &amp; packages</h1>
<p>alias h18_cl_scripts_pkgs=‚Äô
  pushd /opt/cloudlinux/usr/bin &gt;/dev/null 2&gt;/dev/null || true; ls; ./cpapirebuildcache 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/cloudlinux/share/python-cllib/scripts &gt;/dev/null 2&gt;/dev/null || true; ls; { cat cl-common 2&gt;/dev/null || true; ./cl-common 2&gt;/dev/null || true; } ; { cat cl_sysctl 2&gt;/dev/null || true; } ; { cat getpaneluserscount 2&gt;/dev/null || true; python3.11 getpaneluserscount 2&gt;/dev/null || true; } ; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="19-alt-php-and-php-fpm-binariesconfigs">19) alt-php and php-fpm binaries/configs</h1>
<p>alias h19_alt_php=‚Äô
  pushd /opt/alt-php84/root/etc &gt;/dev/null 2&gt;/dev/null || true; ls; { cat pear 2&gt;/dev/null || true; cat pear.conf 2&gt;/dev/null || true; cat php-fpm.conf 2&gt;/dev/null || true; } ; popd &gt;/dev/null || true;
  pushd /opt/alt-php84/usr/sbin &gt;/dev/null 2&gt;/dev/null || true; ls; ./php-fpm -t 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/alt-php-internal &gt;/dev/null 2&gt;/dev/null || true; ./enable 2&gt;/dev/null || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="20-cloudlinux-site-optimization--wpos">20) CloudLinux site optimization &amp; WPOS</h1>
<p>alias h20_clsop_wpos=‚Äô
  pushd /opt/cloudlinux-linksafe &gt;/dev/null 2&gt;/dev/null || true; ls; cat lib.sh 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/cloudlinux-site-optimization-module &gt;/dev/null 2&gt;/dev/null || true; ls; { cat requirements.json 2&gt;/dev/null || true; cat clsop.zip 2&gt;/dev/null || true; } ; popd &gt;/dev/null || true;
  pushd /opt/clwpos &gt;/dev/null 2&gt;/dev/null || true; ls; cat public_options.json 2&gt;/dev/null || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="21-cpaneleasyapache-libs--diagnostics">21) cPanel/EasyApache libs &amp; diagnostics</h1>
<p>alias h21_cpanel_ea_libs=‚Äô
  pushd /opt/cp/cpanel/ea-php84/usr/lib64/php/modules &gt;/dev/null 2&gt;/dev/null || true; ls; { cat clos_ssa.so 2&gt;/dev/null || true; cat xray.so 2&gt;/dev/null || true; } ; popd &gt;/dev/null || true;
  pushd /opt/netdata/var/cache/netdata &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="22-passenger-bins-and-helper-scripts">22) Passenger bins and helper scripts</h1>
<p>alias h22_passenger_bins=‚Äô
  pushd /opt/passenger/bin &gt;/dev/null 2&gt;/dev/null || true; ls; ./passenger-status 2&gt;/dev/null || true; ./passenger 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/passenger/src/ruby_native_extension &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; cat extconf.rb 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/passenger/helper-scripts &gt;/dev/null 2&gt;/dev/null || true; ls; cat README.md 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/passenger/download_binaries &gt;/dev/null 2&gt;/dev/null || true; ls; cat extconf.rb 2&gt;/dev/null || true; ruby *.rb 2&gt;/dev/null || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="23-system-package-managers--general-admin">23) System package managers &amp; general admin</h1>
<p>alias h23_pkgs_admin=‚Äô
  yum ‚Äìhelp 2&gt;/dev/null || true;
  apk add ugrep ugrep-doc 2&gt;/dev/null || true;
  pkg install -y ugrep 2&gt;/dev/null || true
‚Äò</p>

<h1 id="24-user-home-public_html-domains-passenger-demo--scl-npm">24) User home: public_html, domains, passenger demo &amp; SCL npm</h1>
<p>alias h24_user_web_node=‚Äô
  pushd ~ &gt;/dev/null; ls; pwd;
    pushd public_html &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true;
    pushd domains/cut.ia.br &gt;/dev/null 2&gt;/dev/null || true; ls -a; popd &gt;/dev/null || true;
    pushd domains/cut.ia.br &gt;/dev/null 2&gt;/dev/null || true;
      git clone https://github.com/phusion/passenger-nodejs-connect-demo.git 2&gt;/dev/null || true;
      pushd passenger-nodejs-connect-demo &gt;/dev/null 2&gt;/dev/null || true; npm install 2&gt;/dev/null || true; popd &gt;/dev/null || true;
      scl run alt-nodejs12 npm install 2&gt;/dev/null || true;
      scl enable alt-nodejs12 ‚Äúnpm -l‚Äù 2&gt;/dev/null || true;
      source /home/ibbsbbry/nodevenv/domains/cut.ia.br/passenger-nodejs-connect-demo/12/bin/activate 2&gt;/dev/null || true;
    popd &gt;/dev/null || true;
  popd &gt;/dev/null
‚Äò</p>

<h1 id="25-optaltpostgresql11-exploration">25) /opt/alt/postgresql11 exploration</h1>
<p>alias h25_alt_postgresql=‚Äô
  pushd /opt/alt/postgresql11 &gt;/dev/null 2&gt;/dev/null || true; ls;
    pushd usr/bin &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true;
    pushd include/pgsql/internal/libpq &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true;
    pushd share/pgsql &gt;/dev/null 2&gt;/dev/null || true; ls; cat pg_service.conf.sample 2&gt;/dev/null || true; popd &gt;/dev/null || true;
    pushd doc/alt-postgresql11 &gt;/dev/null 2&gt;/dev/null || true; ls; cat README 2&gt;/dev/null || true; popd &gt;/dev/null || true;
    pushd lib64/pkgconfig &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true;
    pushd bin &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true;
  popd &gt;/dev/null || true
‚Äò</p>

<h1 id="26-alt-nodejs12-internals-and-tools">26) alt-nodejs12 internals and tools</h1>
<p>alias h26_alt_nodejs_internals=‚Äô
  pushd /opt/alt/alt-nodejs12 &gt;/dev/null 2&gt;/dev/null || true; ls;
    pushd root/home &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true;
    pushd root/bin &gt;/dev/null 2&gt;/dev/null || true; ls; npx ‚Äìhelp || true; npx ‚Äìversion || true; popd &gt;/dev/null || true;
  popd &gt;/dev/null || true;
  pushd /opt/sqlite/usr/bin &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true;
  pushd /opt/clos_ssa/run &gt;/dev/null 2&gt;/dev/null || true; ls; cat ssa.sock 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /opt/alt-mod-passenger/etc &gt;/dev/null 2&gt;/dev/null || true; ls; cat mod_passenger.conf 2&gt;/dev/null || true; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="27-modulefiles-alternatives-and-ghostscript">27) Modulefiles, alternatives, and ghostscript</h1>
<p>alias h27_modules_misc=‚Äô
  pushd /etc/alternatives &gt;/dev/null 2&gt;/dev/null || true; ls; cat modules.sh 2&gt;/dev/null || true; popd &gt;/dev/null || true;
  pushd /usr/share/modulefiles &gt;/dev/null 2&gt;/dev/null || true; ls -a || true; popd &gt;/dev/null || true;
  pushd /usr/share/ghostscript &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="28-node-virtualenvs-for-domains">28) Node virtualenvs for domains</h1>
<p>alias h28_nodevenv_bins=‚Äô
  pushd ~/nodevenv/domains/cut.ia.br/passenger-nodejs-connect-demo/12/bin &gt;/dev/null 2&gt;/dev/null || true; ls; popd &gt;/dev/null || true
‚Äò</p>

<h1 id="29-ugrep-build-from-source-and-verification">29) Ugrep build from source (and verification)</h1>
<p>alias h29_ugrep_build=‚Äô
  pushd ~ &gt;/dev/null;
    git clone https://github.com/Genivia/ugrep 2&gt;/dev/null || true;
    pushd ugrep &gt;/dev/null; ls;
      ./build.sh || true; sudo make install || true; make install || true;
      pushd bin &gt;/dev/null 2&gt;/dev/null || true; ls; ./ugrep ‚Äìversion || true; popd &gt;/dev/null || true;
    popd &gt;/dev/null;
  popd &gt;/dev/null;
  ugrep ‚Äìversion || true
‚Äò</p>

<h1 id="30-quick-misc-one-offs-captured">30) Quick misc one-offs captured</h1>
<p>alias h30_misc=‚Äô
  history | tail -n 50 || true;
  which npm || true; which npx || true;
  node -v 2&gt;/dev/null || true; install node 2&gt;/dev/null || true; script -V 2&gt;/dev/null || true;
  reset ‚Äìhelp 2&gt;/dev/null || true; clear || true; printenv || true; whoami || true; pwdx 2&gt;/dev/null || true
‚Äò</p>

<h1 id="31-domain-owners-quick-check">31) Domain owners quick check</h1>
<p>alias h31_mail_domainowners=‚Äôhead /etc/virtual/domainowners || true‚Äô</p>

<h1 id="32-grep-directadmin-webserver-mode">32) Grep DirectAdmin webserver mode</h1>
<p>alias h32_da_web_mode=‚Äôgrep -E ‚Äú^(nginx|nginx_proxy|openlitespeed)=‚Äù /usr/local/directadmin/conf/directadmin.conf || true‚Äô</p>

<h1 id="33-passenger-status-shortcut">33) Passenger status shortcut</h1>
<p>alias h33_passenger_status=‚Äô/opt/passenger/bin/passenger-status 2&gt;/dev/null || passenger-status 2&gt;/dev/null || true‚Äô</p>

<h1 id="34-show-ssh-moduli-and-config-quickly">34) Show SSH moduli and config quickly</h1>
<p>alias h34_ssh_quick=‚Äôcat /etc/ssh/ssh_config 2&gt;/dev/null || true; cat /etc/ssh/moduli 2&gt;/dev/null || true‚Äô</p>

<h1 id="35-dns-resolvers-quick">35) DNS resolvers quick</h1>
<p>alias h35_resolvers_quick=‚Äôcat /etc/resolv.conf || true‚Äô</p>

<h1 id="36-hosts-quick">36) Hosts quick</h1>
<p>alias h36_hosts_quick=‚Äôcat /etc/hosts || true‚Äô</p>]]></content><author><name></name></author><category term="scratchpad" /></entry><entry><title type="html">folders2zip as non-admin Windows user</title><link href="https://ib.bsb.br/folders2zip-win/" rel="alternate" type="text/html" title="folders2zip as non-admin Windows user" /><published>2025-10-24T00:00:00+00:00</published><updated>2025-11-13T21:50:02+00:00</updated><id>https://ib.bsb.br/folders2zip-win</id><content type="html" xml:base="https://ib.bsb.br/folders2zip-win/"><![CDATA[<section class="code-block-container" role="group" aria-label="Powershell Code Block" data-filename="powershell_code_block.txt" data-code="#requires -Version 5.1
&lt;#!
.SYNOPSIS
  Single-file archive as a non-admin Windows 10 user ‚Äî create/overwrite/update a .zip of a folder; optional restore.

.DESCRIPTION
  Creates a single .zip archive of SourceDir with robust handling for invalid file timestamps by clamping
  to the ZIP spec range (1980-01-01 to 2107-12-31). No admin required. ASCII-only script for PS 5.1.
  This refactored version:
    - Sets ZipArchiveEntry.LastWriteTime BEFORE opening the entry stream (required for Create mode)
    - Prevents temp-file self-inclusion by blocking Create/Overwrite when ArchivePath is under SourceDir
    - Skips both ArchivePath and its temp path during Create/Overwrite enumeration

.PARAMETER SourceDir
  Absolute path to the folder to archive recursively.

.PARAMETER ArchivePath
  Target .zip file path. Default: $env:LOCALAPPDATA\SingleArchive\Out\&lt;Leaf(SourceDir)&gt;.zip

.PARAMETER RestoreDir
  Destination folder for optional restore/extract. Default: $env:LOCALAPPDATA\SingleArchive\Restored\&lt;Leaf(SourceDir)&gt;

.PARAMETER Mode
  Create    - Create new .zip; if it exists, prompt (or -Force) to use a timestamped name.
  Overwrite - Replace existing .zip atomically.
  Update    - Open or create .zip and add/replace entries that changed (does not delete removed files).

.PARAMETER VerifyOnly
  Compute and display stats (source, archive) without writing.

.PARAMETER DoRestore
  After archive step, extract the .zip to RestoreDir.

.PARAMETER Force
  Skip confirmations for overwrites and existing destination handling.

.PARAMETER DryRun
  Simulate actions; do not write.

.EXAMPLE
  .\SingleFile-Archive.ps1 -SourceDir &quot;C:\Data\Docs&quot; -Mode Create -Verbose

.EXAMPLE
  .\SingleFile-Archive.ps1 -SourceDir &quot;C:\Data\Docs&quot; -Mode Update -DoRestore -Force -Verbose

.NOTES
  Compress-Archive may fail on out-of-range timestamps. This script uses a .NET ZipArchive pipeline that clamps
  timestamps and avoids that failure for Create/Overwrite/Update. It also guards against self-inclusion when the
  archive destination resides under the source tree.
#&gt;

[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)]
  [ValidateScript({ Test-Path $_ -PathType Container })]
  [string]$SourceDir,

  [string]$ArchivePath,

  [string]$RestoreDir,

  [ValidateSet(&#39;Create&#39;,&#39;Overwrite&#39;,&#39;Update&#39;)]
  [string]$Mode = &#39;Create&#39;,

  [switch]$VerifyOnly,
  [switch]$DoRestore,
  [switch]$Force,
  [switch]$DryRun
)

Set-StrictMode -Version Latest
$ErrorActionPreference = &#39;Stop&#39;

# ---------------------------- Helpers -----------------------------------------

function Write-Step { param([string]$Message) Write-Host (&quot;[+] {0}&quot; -f $Message) }
function Write-Sub  { param([string]$Message) Write-Host (&quot;    - {0}&quot; -f $Message) }

function Confirm-Action {
  param([Parameter(Mandatory=$true)][string]$Prompt,[switch]$DefaultNo)
  if ($Force) { return $true }
  $def = if ($DefaultNo) {&#39;N&#39;} else {&#39;Y&#39;}
  $choices = if ($DefaultNo) {&#39;[y/N]&#39;} else {&#39;[Y/n]&#39;}
  while ($true) {
    $resp = Read-Host &quot;$Prompt $choices&quot;
    if ([string]::IsNullOrWhiteSpace($resp)) { $resp = $def }
    switch ($resp.ToUpperInvariant()) {
      &#39;Y&#39; { return $true }
      &#39;N&#39; { return $false }
      default { Write-Host &#39;Please answer Y or N.&#39; }
    }
  }
}

function New-Timestamp { (Get-Date).ToString(&#39;yyyyMMdd_HHmmss&#39;) }

function Ensure-Dir {
  param([Parameter(Mandatory=$true)][string]$Path)
  if (-not (Test-Path -LiteralPath $Path -PathType Container)) {
    Write-Verbose &quot;Ensure-Dir: $Path&quot;
    New-Item -ItemType Directory -Path $Path -Force | Out-Null
  }
}

function Get-FolderStats {
  [CmdletBinding()]
  param([Parameter(Mandatory=$true)][string]$Path)
  Write-Verbose &quot;Get-FolderStats: $Path&quot;
  $files = Get-ChildItem -LiteralPath $Path -Recurse -File -Force -ErrorAction Stop
  [pscustomobject]@{
    Path  = $Path
    Files = $files.Count
    Bytes = ($files | Measure-Object -Property Length -Sum).Sum
  }
}

function Get-ZipStats {
  [CmdletBinding()]
  param([Parameter(Mandatory=$true)][string]$ZipPath)
  if (-not (Test-Path -LiteralPath $ZipPath -PathType Leaf)) {
    return [pscustomobject]@{ Path=$ZipPath; Exists=$false; Entries=0; UncompressedBytes=0; CompressedBytes=0; SizeOnDisk=0 }
  }
  Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
  $fileInfo = Get-Item -LiteralPath $ZipPath -ErrorAction Stop
  $zip = [System.IO.Compression.ZipFile]::OpenRead($ZipPath)
  try {
    $entries = $zip.Entries
    $uc = 0L; $cc = 0L
    foreach ($e in $entries) {
      $uc += [int64]$e.Length
      if ($e.CompressedLength -is [long]) { $cc += [int64]$e.CompressedLength }
    }
    return [pscustomobject]@{
      Path              = $ZipPath
      Exists            = $true
      Entries           = $entries.Count
      UncompressedBytes = $uc
      CompressedBytes   = $cc
      SizeOnDisk        = $fileInfo.Length
    }
  } finally { $zip.Dispose() }
}

function Get-FreeSpaceForPath {
  param([Parameter(Mandatory=$true)][string]$TargetPath)
  $parent = Split-Path -Path $TargetPath -Parent
  if (-not $parent) { $parent = $env:TEMP }
  Ensure-Dir $parent
  $driveRoot = (Split-Path -Path (Resolve-Path -LiteralPath $parent) -Qualifier)
  $di = New-Object System.IO.DriveInfo ($driveRoot.TrimEnd(&#39;\&#39;))
  return $di.AvailableFreeSpace
}

function Ensure-ZipAssemblies {
  Add-Type -AssemblyName System.IO.Compression -ErrorAction Stop
  Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
}

function Get-RelativePath {
  param([Parameter(Mandatory=$true)][string]$BaseDir,[Parameter(Mandatory=$true)][string]$FullName)
  $base = (Resolve-Path -LiteralPath $BaseDir).Path.TrimEnd(&#39;\\&#39;)
  $rel = $FullName.Substring($base.Length).TrimStart(&#39;\\&#39;)
  return ($rel -replace &#39;\\&#39;,&#39;/&#39;)
}

function Clamp-ZipTimestamp {
  param([Parameter(Mandatory=$true)][datetime]$DateUtc)
  # ZIP spec range: 1980-01-01 .. 2107-12-31
  $min = [datetime]::Parse(&#39;1980-01-01T00:00:00Z&#39;)
  $max = [datetime]::Parse(&#39;2107-12-31T23:59:59Z&#39;)
  $utc = $DateUtc.ToUniversalTime()
  if ($utc -lt $min) { $utc = $min }
  if ($utc -gt $max) { $utc = $max }
  return [datetimeoffset]$utc
}

function Get-AbsolutePath {
  param([Parameter(Mandatory=$true)][string]$Path)
  if ([System.IO.Path]::IsPathRooted($Path)) { return [System.IO.Path]::GetFullPath($Path) }
  $base = (Get-Location).Path
  return [System.IO.Path]::GetFullPath((Join-Path $base $Path))
}

function Test-IsSubPath {
  param([Parameter(Mandatory=$true)][string]$Child,[Parameter(Mandatory=$true)][string]$Parent)
  $p = $Parent.TrimEnd(&#39;\\&#39;) + &#39;\\&#39;
  $c = $Child.TrimEnd(&#39;\\&#39;)
  return $c.StartsWith($p, [System.StringComparison]::OrdinalIgnoreCase)
}

function Add-EntryFromFile {
  param(
    [Parameter(Mandatory=$true)][System.IO.Compression.ZipArchive]$Zip,
    [Parameter(Mandatory=$true)][string]$EntryName,
    [Parameter(Mandatory=$true)][string]$FilePath
  )
  # Create the entry object first
  $entry = $Zip.CreateEntry($EntryName, [System.IO.Compression.CompressionLevel]::Optimal)

  # FIX: Set timestamp BEFORE opening the entry stream (required for Create mode)
  $fi = Get-Item -LiteralPath $FilePath -ErrorAction SilentlyContinue
  if ($fi) {
    $entry.LastWriteTime = Clamp-ZipTimestamp -DateUtc $fi.LastWriteTimeUtc
  } else {
    $entry.LastWriteTime = Clamp-ZipTimestamp -DateUtc ([datetime]::UtcNow)
  }

  # Now open streams and copy data
  $inStream  = $null
  $outStream = $null
  try {
    $inStream  = [System.IO.File]::Open($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::Read)
    $outStream = $entry.Open()
    $inStream.CopyTo($outStream)
  } finally {
    if ($outStream) { $outStream.Dispose() }
    if ($inStream)  { $inStream.Dispose() }
  }
}

function New-ZipFromDirectory {
  param(
    [Parameter(Mandatory=$true)][string]$SourceDir,
    [Parameter(Mandatory=$true)][string]$ArchivePath,
    [string[]]$SkipPaths,
    [switch]$DryRun
  )
  if ($DryRun) {
    Write-Sub (&quot;DryRun: would create zip from {0} -&gt; {1}&quot; -f $SourceDir, $ArchivePath)
    return
  }
  Ensure-ZipAssemblies
  $tmp = &quot;$ArchivePath.tmp.$(New-Timestamp)&quot;
  if (Test-Path -LiteralPath $tmp -PathType Leaf) { Remove-Item -LiteralPath $tmp -Force }

  # Build skip set (ArchivePath and its temp)
  $skipSet = New-Object &#39;System.Collections.Generic.HashSet[string]&#39; ([System.StringComparer]::OrdinalIgnoreCase)
  if ($SkipPaths) { foreach ($sp in $SkipPaths) { if ($sp) { [void]$skipSet.Add($sp) } } }
  [void]$skipSet.Add($ArchivePath)
  [void]$skipSet.Add($tmp)

  $fs = $null
  $zip = $null
  try {
    $fs  = [System.IO.File]::Open($tmp, [System.IO.FileMode]::Create, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
    $zip = New-Object System.IO.Compression.ZipArchive($fs, [System.IO.Compression.ZipArchiveMode]::Create, $false)
    $files = Get-ChildItem -LiteralPath $SourceDir -Recurse -File -Force
    foreach ($f in $files) {
      if ($skipSet.Contains($f.FullName)) { continue }
      $entryName = Get-RelativePath -BaseDir $SourceDir -FullName $f.FullName
      Add-EntryFromFile -Zip $zip -EntryName $entryName -FilePath $f.FullName
    }
  } finally {
    if ($zip) { $zip.Dispose() }
    if ($fs)  { $fs.Dispose() }
  }
  if (Test-Path -LiteralPath $ArchivePath -PathType Leaf) {
    Remove-Item -LiteralPath $ArchivePath -Force -ErrorAction Stop
  }
  Move-Item -LiteralPath $tmp -Destination $ArchivePath -Force
}

function Update-ZipFromDirectory {
  param(
    [Parameter(Mandatory=$true)][string]$SourceDir,
    [Parameter(Mandatory=$true)][string]$ArchivePath,
    [switch]$DryRun
  )
  if (-not (Test-Path -LiteralPath $ArchivePath -PathType Leaf)) {
    Write-Sub &quot;Archive does not exist; creating new.&quot;
    New-ZipFromDirectory -SourceDir $SourceDir -ArchivePath $ArchivePath -DryRun:$DryRun
    return
  }
  if ($DryRun) {
    Write-Sub (&quot;DryRun: would open zip for update: {0}&quot; -f $ArchivePath)
    return
  }
  Ensure-ZipAssemblies
  $fs  = [System.IO.File]::Open($ArchivePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
  $zip = New-Object System.IO.Compression.ZipArchive($fs, [System.IO.Compression.ZipArchiveMode]::Update, $false)
  try {
    # Build a lookup of existing entries (case-insensitive)
    $map = @{}
    foreach ($e in $zip.Entries) { $map[$e.FullName.ToLowerInvariant()] = $e }
    $added = 0; $replaced = 0; $skipped = 0
    $files = Get-ChildItem -LiteralPath $SourceDir -Recurse -File -Force
    foreach ($f in $files) {
      if ($f.FullName -ieq $ArchivePath) { continue }
      $rel = Get-RelativePath -BaseDir $SourceDir -FullName $f.FullName
      $key = $rel.ToLowerInvariant()
      if ($map.ContainsKey($key)) {
        $existing = $map[$key]
        # Compare length and timestamp (ZIP timestamp granularity ~2 seconds)
        $needsReplace = $true
        try {
          $zipTime = $existing.LastWriteTime.UtcDateTime
          $fileTime = $f.LastWriteTimeUtc
          $lenDiff = ($existing.Length -ne $f.Length)
          $timeDiff = [math]::Abs((New-TimeSpan -Start $zipTime -End $fileTime).TotalSeconds) -gt 2
          $needsReplace = ($lenDiff -or $timeDiff)
        } catch { $needsReplace = $true }
        if ($needsReplace) {
          $existing.Delete()
          Add-EntryFromFile -Zip $zip -EntryName $rel -FilePath $f.FullName
          $replaced++
        } else {
          $skipped++
        }
      } else {
        Add-EntryFromFile -Zip $zip -EntryName $rel -FilePath $f.FullName
        $added++
      }
    }
    Write-Sub (&quot;Update summary: added={0}, replaced={1}, skipped={2}&quot; -f $added, $replaced, $skipped)
  } finally {
    if ($zip) { $zip.Dispose() }
    if ($fs)  { $fs.Dispose() }
  }
}

function Invoke-Expand {
  param(
    [Parameter(Mandatory=$true)][string]$ArchivePath,
    [Parameter(Mandatory=$true)][string]$RestoreDir
  )
  Ensure-ZipAssemblies
  [System.IO.Compression.ZipFile]::ExtractToDirectory($ArchivePath, $RestoreDir)
}

# ---------------------------- Defaults ----------------------------------------

$resolvedSource = (Resolve-Path -LiteralPath $SourceDir).Path
$sourceLeaf = Split-Path -Path $resolvedSource -Leaf

if (-not $ArchivePath) {
  $defaultOut = Join-Path $env:LOCALAPPDATA &#39;SingleArchive\Out&#39;
  Ensure-Dir $defaultOut
  $ArchivePath = Join-Path $defaultOut ($sourceLeaf + &#39;.zip&#39;)
} else {
  Ensure-Dir (Split-Path -Path $ArchivePath -Parent)
}

if (-not $RestoreDir) {
  $RestoreDir = Join-Path (Join-Path $env:LOCALAPPDATA &#39;SingleArchive\Restored&#39;) $sourceLeaf
} else {
  Ensure-Dir (Split-Path -Path $RestoreDir -Parent)
}

$resolvedArchive = Get-AbsolutePath -Path $ArchivePath

# ---------------------------- Preflight ---------------------------------------

Write-Step &quot;Environment&quot;
Write-Sub  (&quot;UserMode: {0}&quot; -f [Environment]::UserName)
Write-Sub  (&quot;SourceDir:  {0}&quot; -f $resolvedSource)
Write-Sub  (&quot;ArchivePath: {0}&quot; -f $resolvedArchive)
Write-Sub  (&quot;RestoreDir:  {0}&quot; -f $RestoreDir)
Write-Sub  (&quot;Mode:        {0}&quot; -f $Mode)
Write-Sub  (&quot;VerifyOnly:  {0}&quot; -f ($(if($VerifyOnly){&#39;Yes&#39;}else{&#39;No&#39;})))
Write-Sub  (&quot;DryRun:      {0}&quot; -f ($(if($DryRun){&#39;Yes&#39;}else{&#39;No&#39;})))

$srcStats = Get-FolderStats -Path $resolvedSource
(&quot;{0} files; {1:N0} bytes - Source&quot; -f $srcStats.Files, $srcStats.Bytes) | Write-Host

$existingZip = Get-ZipStats -ZipPath $resolvedArchive
if ($existingZip.Exists) {
  (&quot;{0} entries; {1:N0} bytes on disk - Existing Archive&quot; -f $existingZip.Entries, $existingZip.SizeOnDisk) | Write-Host
}

if ($VerifyOnly) {
  Write-Step &quot;Verify-only mode - no writes will occur&quot;
  return
}

# Guard: prevent Create/Overwrite when archive path is under source (self-inclusion risk via temp file)
if (($Mode -eq &#39;Create&#39; -or $Mode -eq &#39;Overwrite&#39;) -and (Test-IsSubPath -Child $resolvedArchive -Parent $resolvedSource)) {
  throw &quot;Unsafe configuration: ArchivePath resides under SourceDir for mode &#39;$Mode&#39;. Place the archive outside the source tree.&quot;
}

# Free space heuristic
try {
  $free = Get-FreeSpaceForPath -TargetPath $resolvedArchive
  Write-Sub (&quot;Free space on target volume: {0:N0} bytes&quot; -f $free)
  $needed = if ($Mode -eq &#39;Update&#39; -and $existingZip.Exists) {
    [int64]([Math]::Max($srcStats.Bytes * 0.2, $existingZip.SizeOnDisk * 0.1))
  } else {
    [int64]$srcStats.Bytes
  }
  if ($free -lt $needed) {
    throw (&quot;Insufficient free space. Needed approx {0:N0} bytes, Available {1:N0} bytes&quot; -f $needed, $free)
  }
} catch { throw &quot;Free space check failed. $_&quot; }

# ---------------------------- Mode-specific confirms --------------------------

switch ($Mode) {
  &#39;Create&#39; {
    if (Test-Path -LiteralPath $resolvedArchive -PathType Leaf) {
      $ts = New-Timestamp
      $altPath = Join-Path (Split-Path -Path $resolvedArchive -Parent) (&quot;{0}_{1}.zip&quot; -f [IO.Path]::GetFileNameWithoutExtension($resolvedArchive), $ts)
      if (-not (Confirm-Action -Prompt &quot;Archive exists. Create a new timestamped archive instead?`n  $altPath&quot;)) {
        throw &quot;User declined to proceed in Create mode with existing archive.&quot;
      }
      $resolvedArchive = $altPath
      $ArchivePath = $altPath
    }
  }
  &#39;Overwrite&#39; {
    if ((Test-Path -LiteralPath $resolvedArchive -PathType Leaf) -and -not (Confirm-Action -Prompt &quot;Overwrite will DELETE existing archive. Proceed?&quot;)) {
      throw &quot;User declined overwrite.&quot;
    }
  }
  &#39;Update&#39; {
    $null = $null
  }
}

# ---------------------------- Archive -----------------------------------------

Write-Step &quot;Archiving&quot;
Write-Sub  (&quot;Operation: {0}&quot; -f $Mode)
Write-Sub  (&quot;Target:    {0}&quot; -f $resolvedArchive)

try {
  switch ($Mode) {
    &#39;Create&#39;   {
      New-ZipFromDirectory -SourceDir $resolvedSource -ArchivePath $resolvedArchive -SkipPaths @($resolvedArchive) -DryRun:$DryRun
    }
    &#39;Overwrite&#39;{
      New-ZipFromDirectory -SourceDir $resolvedSource -ArchivePath $resolvedArchive -SkipPaths @($resolvedArchive) -DryRun:$DryRun
    }
    &#39;Update&#39;   {
      Update-ZipFromDirectory -SourceDir $resolvedSource -ArchivePath $resolvedArchive -DryRun:$DryRun
    }
  }
} catch { throw &quot;Archive step failed. $_&quot; }

# ---------------------------- Post-archive verification -----------------------

Write-Step &quot;Verifying archive&quot;
try {
  if (-not $DryRun) {
    $zipStats = Get-ZipStats -ZipPath $resolvedArchive
    if (-not $zipStats.Exists) { throw &quot;Archive not found after operation.&quot; }
    (&quot;{0} entries; {1:N0} bytes on disk - Archive&quot; -f $zipStats.Entries, $zipStats.SizeOnDisk) | Write-Host
  } else {
    Write-Sub &quot;DryRun: verification skipped (no archive written)&quot;
  }
} catch { throw &quot;Verification failed. $_&quot; }

# ---------------------------- Optional restore --------------------------------

if ($DoRestore -and -not $DryRun) {
  Write-Step &quot;Restore (extract)&quot;
  $existsAndHasContent = (Test-Path -LiteralPath $RestoreDir -PathType Container) -and ((Get-ChildItem -LiteralPath $RestoreDir -Force | Measure-Object).Count -gt 0)
  if ($existsAndHasContent) {
    if (-not (Confirm-Action -Prompt &quot;RestoreDir has existing content. Move aside as a timestamped backup?&quot; -DefaultNo)) {
      throw &quot;User declined to touch existing RestoreDir.&quot;
    }
    $backup = &quot;$RestoreDir.__backup__$(New-Timestamp)&quot;
    Write-Sub (&quot;Renaming existing RestoreDir to &#39;{0}&#39;&quot; -f $backup)
    Rename-Item -LiteralPath $RestoreDir -NewName (Split-Path -Path $backup -Leaf) -ErrorAction Stop
  }
  Ensure-Dir $RestoreDir
  try {
    Invoke-Expand -ArchivePath $resolvedArchive -RestoreDir $RestoreDir
    $restStats = Get-FolderStats -Path $RestoreDir
    (&quot;{0} files; {1:N0} bytes - Restored&quot; -f $restStats.Files, $restStats.Bytes) | Write-Host
  } catch { throw &quot;Restore failed. $_&quot; }
} elseif ($DoRestore -and $DryRun) {
  Write-Step &quot;DryRun: would extract archive to &#39;$RestoreDir&#39;&quot;
}

# ---------------------------- Done --------------------------------------------

Write-Step &quot;Done&quot;
Write-Sub  (&quot;Archive at: {0}&quot; -f $resolvedArchive)
if ($DoRestore -and -not $DryRun) { Write-Sub (&quot;Restored to: {0}&quot; -f $RestoreDir) }
Write-Sub  &quot;Re-run with -Mode Update for incremental refresh; use Overwrite to fully regenerate.&quot;" data-download-link="" data-download-label="Download Powershell">
  <code class="language-powershell">#requires -Version 5.1
&lt;#!
.SYNOPSIS
  Single-file archive as a non-admin Windows 10 user ‚Äî create/overwrite/update a .zip of a folder; optional restore.

.DESCRIPTION
  Creates a single .zip archive of SourceDir with robust handling for invalid file timestamps by clamping
  to the ZIP spec range (1980-01-01 to 2107-12-31). No admin required. ASCII-only script for PS 5.1.
  This refactored version:
    - Sets ZipArchiveEntry.LastWriteTime BEFORE opening the entry stream (required for Create mode)
    - Prevents temp-file self-inclusion by blocking Create/Overwrite when ArchivePath is under SourceDir
    - Skips both ArchivePath and its temp path during Create/Overwrite enumeration

.PARAMETER SourceDir
  Absolute path to the folder to archive recursively.

.PARAMETER ArchivePath
  Target .zip file path. Default: $env:LOCALAPPDATA\SingleArchive\Out\&lt;Leaf(SourceDir)&gt;.zip

.PARAMETER RestoreDir
  Destination folder for optional restore/extract. Default: $env:LOCALAPPDATA\SingleArchive\Restored\&lt;Leaf(SourceDir)&gt;

.PARAMETER Mode
  Create    - Create new .zip; if it exists, prompt (or -Force) to use a timestamped name.
  Overwrite - Replace existing .zip atomically.
  Update    - Open or create .zip and add/replace entries that changed (does not delete removed files).

.PARAMETER VerifyOnly
  Compute and display stats (source, archive) without writing.

.PARAMETER DoRestore
  After archive step, extract the .zip to RestoreDir.

.PARAMETER Force
  Skip confirmations for overwrites and existing destination handling.

.PARAMETER DryRun
  Simulate actions; do not write.

.EXAMPLE
  .\SingleFile-Archive.ps1 -SourceDir &quot;C:\Data\Docs&quot; -Mode Create -Verbose

.EXAMPLE
  .\SingleFile-Archive.ps1 -SourceDir &quot;C:\Data\Docs&quot; -Mode Update -DoRestore -Force -Verbose

.NOTES
  Compress-Archive may fail on out-of-range timestamps. This script uses a .NET ZipArchive pipeline that clamps
  timestamps and avoids that failure for Create/Overwrite/Update. It also guards against self-inclusion when the
  archive destination resides under the source tree.
#&gt;

[CmdletBinding()]
param(
  [Parameter(Mandatory=$true)]
  [ValidateScript({ Test-Path $_ -PathType Container })]
  [string]$SourceDir,

  [string]$ArchivePath,

  [string]$RestoreDir,

  [ValidateSet(&#39;Create&#39;,&#39;Overwrite&#39;,&#39;Update&#39;)]
  [string]$Mode = &#39;Create&#39;,

  [switch]$VerifyOnly,
  [switch]$DoRestore,
  [switch]$Force,
  [switch]$DryRun
)

Set-StrictMode -Version Latest
$ErrorActionPreference = &#39;Stop&#39;

# ---------------------------- Helpers -----------------------------------------

function Write-Step { param([string]$Message) Write-Host (&quot;[+] {0}&quot; -f $Message) }
function Write-Sub  { param([string]$Message) Write-Host (&quot;    - {0}&quot; -f $Message) }

function Confirm-Action {
  param([Parameter(Mandatory=$true)][string]$Prompt,[switch]$DefaultNo)
  if ($Force) { return $true }
  $def = if ($DefaultNo) {&#39;N&#39;} else {&#39;Y&#39;}
  $choices = if ($DefaultNo) {&#39;[y/N]&#39;} else {&#39;[Y/n]&#39;}
  while ($true) {
    $resp = Read-Host &quot;$Prompt $choices&quot;
    if ([string]::IsNullOrWhiteSpace($resp)) { $resp = $def }
    switch ($resp.ToUpperInvariant()) {
      &#39;Y&#39; { return $true }
      &#39;N&#39; { return $false }
      default { Write-Host &#39;Please answer Y or N.&#39; }
    }
  }
}

function New-Timestamp { (Get-Date).ToString(&#39;yyyyMMdd_HHmmss&#39;) }

function Ensure-Dir {
  param([Parameter(Mandatory=$true)][string]$Path)
  if (-not (Test-Path -LiteralPath $Path -PathType Container)) {
    Write-Verbose &quot;Ensure-Dir: $Path&quot;
    New-Item -ItemType Directory -Path $Path -Force | Out-Null
  }
}

function Get-FolderStats {
  [CmdletBinding()]
  param([Parameter(Mandatory=$true)][string]$Path)
  Write-Verbose &quot;Get-FolderStats: $Path&quot;
  $files = Get-ChildItem -LiteralPath $Path -Recurse -File -Force -ErrorAction Stop
  [pscustomobject]@{
    Path  = $Path
    Files = $files.Count
    Bytes = ($files | Measure-Object -Property Length -Sum).Sum
  }
}

function Get-ZipStats {
  [CmdletBinding()]
  param([Parameter(Mandatory=$true)][string]$ZipPath)
  if (-not (Test-Path -LiteralPath $ZipPath -PathType Leaf)) {
    return [pscustomobject]@{ Path=$ZipPath; Exists=$false; Entries=0; UncompressedBytes=0; CompressedBytes=0; SizeOnDisk=0 }
  }
  Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
  $fileInfo = Get-Item -LiteralPath $ZipPath -ErrorAction Stop
  $zip = [System.IO.Compression.ZipFile]::OpenRead($ZipPath)
  try {
    $entries = $zip.Entries
    $uc = 0L; $cc = 0L
    foreach ($e in $entries) {
      $uc += [int64]$e.Length
      if ($e.CompressedLength -is [long]) { $cc += [int64]$e.CompressedLength }
    }
    return [pscustomobject]@{
      Path              = $ZipPath
      Exists            = $true
      Entries           = $entries.Count
      UncompressedBytes = $uc
      CompressedBytes   = $cc
      SizeOnDisk        = $fileInfo.Length
    }
  } finally { $zip.Dispose() }
}

function Get-FreeSpaceForPath {
  param([Parameter(Mandatory=$true)][string]$TargetPath)
  $parent = Split-Path -Path $TargetPath -Parent
  if (-not $parent) { $parent = $env:TEMP }
  Ensure-Dir $parent
  $driveRoot = (Split-Path -Path (Resolve-Path -LiteralPath $parent) -Qualifier)
  $di = New-Object System.IO.DriveInfo ($driveRoot.TrimEnd(&#39;\&#39;))
  return $di.AvailableFreeSpace
}

function Ensure-ZipAssemblies {
  Add-Type -AssemblyName System.IO.Compression -ErrorAction Stop
  Add-Type -AssemblyName System.IO.Compression.FileSystem -ErrorAction Stop
}

function Get-RelativePath {
  param([Parameter(Mandatory=$true)][string]$BaseDir,[Parameter(Mandatory=$true)][string]$FullName)
  $base = (Resolve-Path -LiteralPath $BaseDir).Path.TrimEnd(&#39;\\&#39;)
  $rel = $FullName.Substring($base.Length).TrimStart(&#39;\\&#39;)
  return ($rel -replace &#39;\\&#39;,&#39;/&#39;)
}

function Clamp-ZipTimestamp {
  param([Parameter(Mandatory=$true)][datetime]$DateUtc)
  # ZIP spec range: 1980-01-01 .. 2107-12-31
  $min = [datetime]::Parse(&#39;1980-01-01T00:00:00Z&#39;)
  $max = [datetime]::Parse(&#39;2107-12-31T23:59:59Z&#39;)
  $utc = $DateUtc.ToUniversalTime()
  if ($utc -lt $min) { $utc = $min }
  if ($utc -gt $max) { $utc = $max }
  return [datetimeoffset]$utc
}

function Get-AbsolutePath {
  param([Parameter(Mandatory=$true)][string]$Path)
  if ([System.IO.Path]::IsPathRooted($Path)) { return [System.IO.Path]::GetFullPath($Path) }
  $base = (Get-Location).Path
  return [System.IO.Path]::GetFullPath((Join-Path $base $Path))
}

function Test-IsSubPath {
  param([Parameter(Mandatory=$true)][string]$Child,[Parameter(Mandatory=$true)][string]$Parent)
  $p = $Parent.TrimEnd(&#39;\\&#39;) + &#39;\\&#39;
  $c = $Child.TrimEnd(&#39;\\&#39;)
  return $c.StartsWith($p, [System.StringComparison]::OrdinalIgnoreCase)
}

function Add-EntryFromFile {
  param(
    [Parameter(Mandatory=$true)][System.IO.Compression.ZipArchive]$Zip,
    [Parameter(Mandatory=$true)][string]$EntryName,
    [Parameter(Mandatory=$true)][string]$FilePath
  )
  # Create the entry object first
  $entry = $Zip.CreateEntry($EntryName, [System.IO.Compression.CompressionLevel]::Optimal)

  # FIX: Set timestamp BEFORE opening the entry stream (required for Create mode)
  $fi = Get-Item -LiteralPath $FilePath -ErrorAction SilentlyContinue
  if ($fi) {
    $entry.LastWriteTime = Clamp-ZipTimestamp -DateUtc $fi.LastWriteTimeUtc
  } else {
    $entry.LastWriteTime = Clamp-ZipTimestamp -DateUtc ([datetime]::UtcNow)
  }

  # Now open streams and copy data
  $inStream  = $null
  $outStream = $null
  try {
    $inStream  = [System.IO.File]::Open($FilePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::Read, [System.IO.FileShare]::Read)
    $outStream = $entry.Open()
    $inStream.CopyTo($outStream)
  } finally {
    if ($outStream) { $outStream.Dispose() }
    if ($inStream)  { $inStream.Dispose() }
  }
}

function New-ZipFromDirectory {
  param(
    [Parameter(Mandatory=$true)][string]$SourceDir,
    [Parameter(Mandatory=$true)][string]$ArchivePath,
    [string[]]$SkipPaths,
    [switch]$DryRun
  )
  if ($DryRun) {
    Write-Sub (&quot;DryRun: would create zip from {0} -&gt; {1}&quot; -f $SourceDir, $ArchivePath)
    return
  }
  Ensure-ZipAssemblies
  $tmp = &quot;$ArchivePath.tmp.$(New-Timestamp)&quot;
  if (Test-Path -LiteralPath $tmp -PathType Leaf) { Remove-Item -LiteralPath $tmp -Force }

  # Build skip set (ArchivePath and its temp)
  $skipSet = New-Object &#39;System.Collections.Generic.HashSet[string]&#39; ([System.StringComparer]::OrdinalIgnoreCase)
  if ($SkipPaths) { foreach ($sp in $SkipPaths) { if ($sp) { [void]$skipSet.Add($sp) } } }
  [void]$skipSet.Add($ArchivePath)
  [void]$skipSet.Add($tmp)

  $fs = $null
  $zip = $null
  try {
    $fs  = [System.IO.File]::Open($tmp, [System.IO.FileMode]::Create, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
    $zip = New-Object System.IO.Compression.ZipArchive($fs, [System.IO.Compression.ZipArchiveMode]::Create, $false)
    $files = Get-ChildItem -LiteralPath $SourceDir -Recurse -File -Force
    foreach ($f in $files) {
      if ($skipSet.Contains($f.FullName)) { continue }
      $entryName = Get-RelativePath -BaseDir $SourceDir -FullName $f.FullName
      Add-EntryFromFile -Zip $zip -EntryName $entryName -FilePath $f.FullName
    }
  } finally {
    if ($zip) { $zip.Dispose() }
    if ($fs)  { $fs.Dispose() }
  }
  if (Test-Path -LiteralPath $ArchivePath -PathType Leaf) {
    Remove-Item -LiteralPath $ArchivePath -Force -ErrorAction Stop
  }
  Move-Item -LiteralPath $tmp -Destination $ArchivePath -Force
}

function Update-ZipFromDirectory {
  param(
    [Parameter(Mandatory=$true)][string]$SourceDir,
    [Parameter(Mandatory=$true)][string]$ArchivePath,
    [switch]$DryRun
  )
  if (-not (Test-Path -LiteralPath $ArchivePath -PathType Leaf)) {
    Write-Sub &quot;Archive does not exist; creating new.&quot;
    New-ZipFromDirectory -SourceDir $SourceDir -ArchivePath $ArchivePath -DryRun:$DryRun
    return
  }
  if ($DryRun) {
    Write-Sub (&quot;DryRun: would open zip for update: {0}&quot; -f $ArchivePath)
    return
  }
  Ensure-ZipAssemblies
  $fs  = [System.IO.File]::Open($ArchivePath, [System.IO.FileMode]::Open, [System.IO.FileAccess]::ReadWrite, [System.IO.FileShare]::None)
  $zip = New-Object System.IO.Compression.ZipArchive($fs, [System.IO.Compression.ZipArchiveMode]::Update, $false)
  try {
    # Build a lookup of existing entries (case-insensitive)
    $map = @{}
    foreach ($e in $zip.Entries) { $map[$e.FullName.ToLowerInvariant()] = $e }
    $added = 0; $replaced = 0; $skipped = 0
    $files = Get-ChildItem -LiteralPath $SourceDir -Recurse -File -Force
    foreach ($f in $files) {
      if ($f.FullName -ieq $ArchivePath) { continue }
      $rel = Get-RelativePath -BaseDir $SourceDir -FullName $f.FullName
      $key = $rel.ToLowerInvariant()
      if ($map.ContainsKey($key)) {
        $existing = $map[$key]
        # Compare length and timestamp (ZIP timestamp granularity ~2 seconds)
        $needsReplace = $true
        try {
          $zipTime = $existing.LastWriteTime.UtcDateTime
          $fileTime = $f.LastWriteTimeUtc
          $lenDiff = ($existing.Length -ne $f.Length)
          $timeDiff = [math]::Abs((New-TimeSpan -Start $zipTime -End $fileTime).TotalSeconds) -gt 2
          $needsReplace = ($lenDiff -or $timeDiff)
        } catch { $needsReplace = $true }
        if ($needsReplace) {
          $existing.Delete()
          Add-EntryFromFile -Zip $zip -EntryName $rel -FilePath $f.FullName
          $replaced++
        } else {
          $skipped++
        }
      } else {
        Add-EntryFromFile -Zip $zip -EntryName $rel -FilePath $f.FullName
        $added++
      }
    }
    Write-Sub (&quot;Update summary: added={0}, replaced={1}, skipped={2}&quot; -f $added, $replaced, $skipped)
  } finally {
    if ($zip) { $zip.Dispose() }
    if ($fs)  { $fs.Dispose() }
  }
}

function Invoke-Expand {
  param(
    [Parameter(Mandatory=$true)][string]$ArchivePath,
    [Parameter(Mandatory=$true)][string]$RestoreDir
  )
  Ensure-ZipAssemblies
  [System.IO.Compression.ZipFile]::ExtractToDirectory($ArchivePath, $RestoreDir)
}

# ---------------------------- Defaults ----------------------------------------

$resolvedSource = (Resolve-Path -LiteralPath $SourceDir).Path
$sourceLeaf = Split-Path -Path $resolvedSource -Leaf

if (-not $ArchivePath) {
  $defaultOut = Join-Path $env:LOCALAPPDATA &#39;SingleArchive\Out&#39;
  Ensure-Dir $defaultOut
  $ArchivePath = Join-Path $defaultOut ($sourceLeaf + &#39;.zip&#39;)
} else {
  Ensure-Dir (Split-Path -Path $ArchivePath -Parent)
}

if (-not $RestoreDir) {
  $RestoreDir = Join-Path (Join-Path $env:LOCALAPPDATA &#39;SingleArchive\Restored&#39;) $sourceLeaf
} else {
  Ensure-Dir (Split-Path -Path $RestoreDir -Parent)
}

$resolvedArchive = Get-AbsolutePath -Path $ArchivePath

# ---------------------------- Preflight ---------------------------------------

Write-Step &quot;Environment&quot;
Write-Sub  (&quot;UserMode: {0}&quot; -f [Environment]::UserName)
Write-Sub  (&quot;SourceDir:  {0}&quot; -f $resolvedSource)
Write-Sub  (&quot;ArchivePath: {0}&quot; -f $resolvedArchive)
Write-Sub  (&quot;RestoreDir:  {0}&quot; -f $RestoreDir)
Write-Sub  (&quot;Mode:        {0}&quot; -f $Mode)
Write-Sub  (&quot;VerifyOnly:  {0}&quot; -f ($(if($VerifyOnly){&#39;Yes&#39;}else{&#39;No&#39;})))
Write-Sub  (&quot;DryRun:      {0}&quot; -f ($(if($DryRun){&#39;Yes&#39;}else{&#39;No&#39;})))

$srcStats = Get-FolderStats -Path $resolvedSource
(&quot;{0} files; {1:N0} bytes - Source&quot; -f $srcStats.Files, $srcStats.Bytes) | Write-Host

$existingZip = Get-ZipStats -ZipPath $resolvedArchive
if ($existingZip.Exists) {
  (&quot;{0} entries; {1:N0} bytes on disk - Existing Archive&quot; -f $existingZip.Entries, $existingZip.SizeOnDisk) | Write-Host
}

if ($VerifyOnly) {
  Write-Step &quot;Verify-only mode - no writes will occur&quot;
  return
}

# Guard: prevent Create/Overwrite when archive path is under source (self-inclusion risk via temp file)
if (($Mode -eq &#39;Create&#39; -or $Mode -eq &#39;Overwrite&#39;) -and (Test-IsSubPath -Child $resolvedArchive -Parent $resolvedSource)) {
  throw &quot;Unsafe configuration: ArchivePath resides under SourceDir for mode &#39;$Mode&#39;. Place the archive outside the source tree.&quot;
}

# Free space heuristic
try {
  $free = Get-FreeSpaceForPath -TargetPath $resolvedArchive
  Write-Sub (&quot;Free space on target volume: {0:N0} bytes&quot; -f $free)
  $needed = if ($Mode -eq &#39;Update&#39; -and $existingZip.Exists) {
    [int64]([Math]::Max($srcStats.Bytes * 0.2, $existingZip.SizeOnDisk * 0.1))
  } else {
    [int64]$srcStats.Bytes
  }
  if ($free -lt $needed) {
    throw (&quot;Insufficient free space. Needed approx {0:N0} bytes, Available {1:N0} bytes&quot; -f $needed, $free)
  }
} catch { throw &quot;Free space check failed. $_&quot; }

# ---------------------------- Mode-specific confirms --------------------------

switch ($Mode) {
  &#39;Create&#39; {
    if (Test-Path -LiteralPath $resolvedArchive -PathType Leaf) {
      $ts = New-Timestamp
      $altPath = Join-Path (Split-Path -Path $resolvedArchive -Parent) (&quot;{0}_{1}.zip&quot; -f [IO.Path]::GetFileNameWithoutExtension($resolvedArchive), $ts)
      if (-not (Confirm-Action -Prompt &quot;Archive exists. Create a new timestamped archive instead?`n  $altPath&quot;)) {
        throw &quot;User declined to proceed in Create mode with existing archive.&quot;
      }
      $resolvedArchive = $altPath
      $ArchivePath = $altPath
    }
  }
  &#39;Overwrite&#39; {
    if ((Test-Path -LiteralPath $resolvedArchive -PathType Leaf) -and -not (Confirm-Action -Prompt &quot;Overwrite will DELETE existing archive. Proceed?&quot;)) {
      throw &quot;User declined overwrite.&quot;
    }
  }
  &#39;Update&#39; {
    $null = $null
  }
}

# ---------------------------- Archive -----------------------------------------

Write-Step &quot;Archiving&quot;
Write-Sub  (&quot;Operation: {0}&quot; -f $Mode)
Write-Sub  (&quot;Target:    {0}&quot; -f $resolvedArchive)

try {
  switch ($Mode) {
    &#39;Create&#39;   {
      New-ZipFromDirectory -SourceDir $resolvedSource -ArchivePath $resolvedArchive -SkipPaths @($resolvedArchive) -DryRun:$DryRun
    }
    &#39;Overwrite&#39;{
      New-ZipFromDirectory -SourceDir $resolvedSource -ArchivePath $resolvedArchive -SkipPaths @($resolvedArchive) -DryRun:$DryRun
    }
    &#39;Update&#39;   {
      Update-ZipFromDirectory -SourceDir $resolvedSource -ArchivePath $resolvedArchive -DryRun:$DryRun
    }
  }
} catch { throw &quot;Archive step failed. $_&quot; }

# ---------------------------- Post-archive verification -----------------------

Write-Step &quot;Verifying archive&quot;
try {
  if (-not $DryRun) {
    $zipStats = Get-ZipStats -ZipPath $resolvedArchive
    if (-not $zipStats.Exists) { throw &quot;Archive not found after operation.&quot; }
    (&quot;{0} entries; {1:N0} bytes on disk - Archive&quot; -f $zipStats.Entries, $zipStats.SizeOnDisk) | Write-Host
  } else {
    Write-Sub &quot;DryRun: verification skipped (no archive written)&quot;
  }
} catch { throw &quot;Verification failed. $_&quot; }

# ---------------------------- Optional restore --------------------------------

if ($DoRestore -and -not $DryRun) {
  Write-Step &quot;Restore (extract)&quot;
  $existsAndHasContent = (Test-Path -LiteralPath $RestoreDir -PathType Container) -and ((Get-ChildItem -LiteralPath $RestoreDir -Force | Measure-Object).Count -gt 0)
  if ($existsAndHasContent) {
    if (-not (Confirm-Action -Prompt &quot;RestoreDir has existing content. Move aside as a timestamped backup?&quot; -DefaultNo)) {
      throw &quot;User declined to touch existing RestoreDir.&quot;
    }
    $backup = &quot;$RestoreDir.__backup__$(New-Timestamp)&quot;
    Write-Sub (&quot;Renaming existing RestoreDir to &#39;{0}&#39;&quot; -f $backup)
    Rename-Item -LiteralPath $RestoreDir -NewName (Split-Path -Path $backup -Leaf) -ErrorAction Stop
  }
  Ensure-Dir $RestoreDir
  try {
    Invoke-Expand -ArchivePath $resolvedArchive -RestoreDir $RestoreDir
    $restStats = Get-FolderStats -Path $RestoreDir
    (&quot;{0} files; {1:N0} bytes - Restored&quot; -f $restStats.Files, $restStats.Bytes) | Write-Host
  } catch { throw &quot;Restore failed. $_&quot; }
} elseif ($DoRestore -and $DryRun) {
  Write-Step &quot;DryRun: would extract archive to &#39;$RestoreDir&#39;&quot;
}

# ---------------------------- Done --------------------------------------------

Write-Step &quot;Done&quot;
Write-Sub  (&quot;Archive at: {0}&quot; -f $resolvedArchive)
if ($DoRestore -and -not $DryRun) { Write-Sub (&quot;Restored to: {0}&quot; -f $RestoreDir) }
Write-Sub  &quot;Re-run with -Mode Update for incremental refresh; use Overwrite to fully regenerate.&quot;</code>
</section>]]></content><author><name></name></author><category term="scripts&gt;powershell" /></entry><entry><title type="html">tutorial converter2powershell</title><link href="https://ib.bsb.br/tutorial-converter2powershell/" rel="alternate" type="text/html" title="tutorial converter2powershell" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T10:25:57+00:00</updated><id>https://ib.bsb.br/tutorial-converter2powershell</id><content type="html" xml:base="https://ib.bsb.br/tutorial-converter2powershell/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;purpose&gt;You are an expert non-admin Windows PowerShell 5.1 script developer for Windows 10 x64. Convert the narrative setup described in the input field named `tutorial_content` into a single user-mode PowerShell 5.1 script runnable from the user‚Äôs home directory, with robust error handling, idempotency, progress logging, and explicit confirmations for risky actions.&lt;/purpose&gt;

  &lt;context&gt;
    &lt;system_environment&gt;
      &lt;os&gt;windows 10&lt;/os&gt;
      &lt;arch&gt;x64&lt;/arch&gt;
      &lt;language&gt;PowerShell 5.1&lt;/language&gt;
      &lt;permissions&gt;non-admin only&lt;/permissions&gt;
    &lt;/system_environment&gt;
    &lt;style&gt;
      &lt;comments&gt;Comprehensive headers plus inline notes on complex lines&lt;/comments&gt;
      &lt;logging&gt;Write-Host progress and Write-Verbose for each major step&lt;/logging&gt;
    &lt;/style&gt;
    &lt;ethics&gt;
      &lt;safety&gt;Backups and confirmations before destructive operations&lt;/safety&gt;
      &lt;integrity&gt;No hidden actions; only tutorial-aligned steps&lt;/integrity&gt;
    &lt;/ethics&gt;
  &lt;/context&gt;

  &lt;input_specification&gt;
    &lt;variable name="tutorial_name" type="string" required="true"/&gt;
      &lt;tutorial_name&gt;
~~~
placeholder
~~~
      &lt;/tutorial_name&gt;
    &lt;variable name="tutorial_content" type="text" required="true"/&gt;
      &lt;tutorial_content&gt;
~~~
placeholder
~~~
      &lt;/tutorial_content&gt;
  &lt;/input_specification&gt;

  &lt;output_specification&gt;
    &lt;format&gt;Single .ps1 script (user-mode)&lt;/format&gt;
    &lt;constraints&gt;
      &lt;constraint&gt;Begin with a header and `#requires -Version 5.1`.&lt;/constraint&gt;
      &lt;constraint&gt;Implement error checking immediately after critical operations.&lt;/constraint&gt;
      &lt;constraint&gt;Use only user-writable paths.&lt;/constraint&gt;
      &lt;constraint&gt;Provide progress logs and clear failure messages.&lt;/constraint&gt;
      &lt;constraint&gt;Ensure idempotency wherever feasible.&lt;/constraint&gt;
      &lt;constraint&gt;Prompt for explicit confirmation before risky actions.&lt;/constraint&gt;
    &lt;/constraints&gt;
  &lt;/output_specification&gt;

  &lt;instructions&gt;
    &lt;instruction&gt;Analyze the `tutorial_content` input and enumerate steps in order.&lt;/instruction&gt;
    &lt;instruction&gt;For each step, add precheck, action, verify, and log.&lt;/instruction&gt;
    &lt;instruction&gt;Translate commands to PS 5.1 equivalents suitable for Windows 10 without admin rights.&lt;/instruction&gt;
    &lt;instruction&gt;Use absolute paths under $env:USERPROFILE, $env:APPDATA, and $env:LOCALAPPDATA.&lt;/instruction&gt;
    &lt;instruction&gt;Check tool availability (e.g., Expand-Archive) and use only PS 5.1 standard fallbacks.&lt;/instruction&gt;
    &lt;instruction&gt;Implement immediate error handling and idempotency guards.&lt;/instruction&gt;
    &lt;instruction&gt;Wrap repeated logic in functions and call consistently.&lt;/instruction&gt;
    &lt;instruction&gt;Emit Write-Host before/after each major step; support -Verbose.&lt;/instruction&gt;
    &lt;instruction&gt;Output only the final script content.&lt;/instruction&gt;
  &lt;/instructions&gt;

  &lt;examples&gt;
    &lt;example&gt;
      &lt;input_data&gt;
        &lt;tutorial_name&gt;Portable Tool Install&lt;/tutorial_name&gt;
        &lt;tutorial_content&gt;1) Download FooTool.zip from https://example.com/foo.zip; 2) Extract to user programs; 3) Add its bin folder to PATH.&lt;/tutorial_content&gt;
      &lt;/input_data&gt;
      &lt;output&gt;Produces a script that creates $LOCALAPPDATA\Programs\FooTool, downloads, expands, and updates HKCU PATH idempotently.&lt;/output&gt;
    &lt;/example&gt;
    &lt;example&gt;
      &lt;input_data&gt;
        &lt;tutorial_name&gt;Write Config&lt;/tutorial_name&gt;
        &lt;tutorial_content&gt;Create %APPDATA%\MyApp\config.json with provided JSON; back up existing.&lt;/tutorial_content&gt;
      &lt;/input_data&gt;
      &lt;output&gt;Produces a script that backs up the existing file with a timestamp and writes new JSON atomically.&lt;/output&gt;
    &lt;/example&gt;
  &lt;/examples&gt;
</code></pre></div></div>]]></content><author><name></name></author><category term="AI&gt;prompt" /></entry><entry><title type="html">tutorial converter2pwsh</title><link href="https://ib.bsb.br/tutorial-converter2pwsh/" rel="alternate" type="text/html" title="tutorial converter2pwsh" /><published>2025-10-17T00:00:00+00:00</published><updated>2025-10-17T09:54:08+00:00</updated><id>https://ib.bsb.br/tutorial-converter2pwsh</id><content type="html" xml:base="https://ib.bsb.br/tutorial-converter2pwsh/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>```
  &lt;purpose&gt;You are an expert root admin Linux PowerShell (pwsh) 7.x script developer. Convert the narrative setup described in the input field named `tutorial_content` into a single user-mode pwsh script runnable from the user‚Äôs home directory on Linux, with robust error handling, idempotency, progress logging, and explicit confirmations for risky actions. Use sudo or system package managers and also user-writable paths and XDG-compliant locations.&lt;/purpose&gt;

  &lt;context&gt;
    &lt;system_environment&gt;
      &lt;os&gt;linux&lt;/os&gt;
      &lt;arch&gt;x86_64 or arm64&lt;/arch&gt;
      &lt;language&gt;PowerShell (pwsh) 7.x&lt;/language&gt;
      &lt;permissions&gt;root&lt;/permissions&gt;
    &lt;/system_environment&gt;
    &lt;style&gt;
      &lt;comments&gt;Comprehensive headers plus inline notes on complex lines&lt;/comments&gt;
      &lt;logging&gt;Write-Host progress and Write-Verbose for each major step&lt;/logging&gt;
    &lt;/style&gt;
    &lt;ethics&gt;
      &lt;safety&gt;Backups and confirmations before destructive operations&lt;/safety&gt;
      &lt;integrity&gt;No hidden actions; only tutorial-aligned steps&lt;/integrity&gt;
    &lt;/ethics&gt;
  &lt;/context&gt;

&lt;input_specification&gt;
  &lt;variable name="tutorial_name" type="string" required="true"/&gt;
    &lt;tutorial_name&gt;
~~~
placeholder
~~~
    &lt;/tutorial_name&gt;
  &lt;variable name="tutorial_content" type="text" required="true"/&gt;
    &lt;tutorial_content&gt;
~~~
placeholder
~~~
    &lt;/tutorial_content&gt;
&lt;/input_specification&gt;

&lt;output_specification&gt; &lt;format&gt;Single pwsh script (.ps1) with shebang&lt;/format&gt; &lt;constraints&gt; &lt;constraint&gt;Begin with `#!/usr/bin/env pwsh` and `#Requires -Version 7.x`.&lt;/constraint&gt; &lt;constraint&gt;Implement immediate error checks after critical operations.&lt;/constraint&gt; &lt;constraint&gt;Use root or user-writable paths ($HOME, XDG dirs).&lt;/constraint&gt; &lt;constraint&gt;Provide progress logs and clear failure messages.&lt;/constraint&gt; &lt;constraint&gt;Ensure idempotency wherever feasible.&lt;/constraint&gt; &lt;constraint&gt;Prompt for explicit confirmation before risky actions and create backups.&lt;/constraint&gt; &lt;constraint&gt;Free to call sudo or system package managers.&lt;/constraint&gt; &lt;/constraints&gt;
&lt;/output_specification&gt;

  &lt;instructions&gt;
    &lt;instruction&gt;Analyze the `tutorial_content` input and enumerate steps in order.&lt;/instruction&gt;
    &lt;instruction&gt;For each step, add precheck, action, verify, and log.&lt;/instruction&gt;
    &lt;instruction&gt;Translate commands to Linux pwsh equivalents suitable for root execution.&lt;/instruction&gt;
    &lt;instruction&gt;Use absolute paths under $HOME, $XDG_CONFIG_HOME (fallback ~/.config), $XDG_DATA_HOME (fallback ~/.local/share), $XDG_CACHE_HOME (fallback ~/.cache), and ~/.local/bin/opt.&lt;/instruction&gt;
    &lt;instruction&gt;Check tool availability (e.g., tar, unzip) via Get-Command; use pwsh built-ins first; fail with actionable guidance if a required tool is missing and no root or user-mode alternative exists.&lt;/instruction&gt;
    &lt;instruction&gt;Implement immediate error handling and idempotency guards.&lt;/instruction&gt;
    &lt;instruction&gt;Wrap repeated logic in functions (download with retries, ensure-directory, ensure-symlink, write-file-atomic, add-to-PATH via $PROFILE) and call consistently.&lt;/instruction&gt;
    &lt;instruction&gt;Emit Write-Host before/after each major step; support -Verbose.&lt;/instruction&gt;
    &lt;instruction&gt;Output only the final script content.&lt;/instruction&gt;
  &lt;/instructions&gt;

  &lt;examples&gt;
    &lt;example&gt;
      &lt;input_data&gt;
        &lt;tutorial_name&gt;Portable Tool Install (ZIP)&lt;/tutorial_name&gt;
        &lt;tutorial_content&gt;1) Download FooTool.zip from https://example.com/foo.zip; 2) Extract to ~/.local/opt/FooTool; 3) Create ~/.local/bin/footool symlink to FooTool/bin/footool; 4) Ensure PATH contains ~/.local/bin.&lt;/tutorial_content&gt;
      &lt;/input_data&gt;
      &lt;output&gt;Produces a script that creates ~/.local/opt/FooTool, downloads, expands, symlinks ~/.local/bin/footool, and persists PATH via $PROFILE if needed, idempotently.&lt;/output&gt;
    &lt;/example&gt;
    &lt;example&gt;
      &lt;input_data&gt;
        &lt;tutorial_name&gt;Write Config (XDG)&lt;/tutorial_name&gt;
        &lt;tutorial_content&gt;Create ~/.config/MyApp/config.json with provided JSON; back up existing file; write atomically.&lt;/tutorial_content&gt;
      &lt;/input_data&gt;
      &lt;output&gt;Produces a script that backs up ~/.config/MyApp/config.json with a timestamp and writes new JSON atomically.&lt;/output&gt;
    &lt;/example&gt;
  &lt;/examples&gt;
```
</code></pre></div></div>]]></content><author><name></name></author><category term="AI&gt;prompt" /></entry><entry><title type="html">blunt</title><link href="https://ib.bsb.br/blunt/" rel="alternate" type="text/html" title="blunt" /><published>2025-10-10T00:00:00+00:00</published><updated>2025-10-10T12:10:26+00:00</updated><id>https://ib.bsb.br/blunt</id><content type="html" xml:base="https://ib.bsb.br/blunt/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;purpose&gt;
Deliver blunt, directive answers to the provided user request [[user_message]], maximizing information density while enforcing any explicit constraints supplied by the user.
&lt;/purpose&gt;
&lt;context&gt;
    &lt;glossary&gt;
    - High‚Äësignal: content that materially advances the answer (facts, logic, steps) with no decorative or persuasive padding.
    - Soft ask: an indirect prompt to act (e.g., ‚Äúyou might want to‚Ä¶,‚Äù ‚Äúconsider‚Ä¶‚Äù), including offers of further help not explicitly requested.
    - Conversational transition: informal segue phrases that mimic spoken turn-taking (e.g., ‚Äúnext,‚Äù ‚Äúlet‚Äôs move on‚Äù).
    - Call‚Äëto‚Äëaction appendix: end‚Äëmatter that invites follow‚Äëup, subscription, or other action beyond the requested answer.
    - Continuation bias: adding content to extend length or soften tone absent informational gain.
    &lt;/glossary&gt;
    &lt;assumption&gt;
    User values cognitive efficiency over tone; accepts directness.
    &lt;/assumption&gt;
    &lt;constraints&gt;
        &lt;constraint&gt;
        1) Content exclusions (non‚Äësubstantive/promotional): no emojis; no filler or hype.
        &lt;/constraint&gt;
        &lt;constraint&gt;
        2) Interaction exclusions (steering/engagement): no soft asks; no questions, offers, or unsolicited suggestions; no motivational content; disable engagement/sentiment boosting; suppress softening and continuation bias.
        &lt;/constraint&gt;
        &lt;constraint&gt;
        3) Structural exclusions: no conversational transitions; no call‚Äëto‚Äëaction appendices.
        &lt;/constraint&gt;
        &lt;constraint&gt;
        4) Tone &amp; voice: maintain a precise, neutral, high‚Äësignal style; assume high‚Äëperception; avoid diction/mood mirroring; use blunt, directive phrasing oriented to cognitive rebuilding.
        &lt;/constraint&gt;
        &lt;constraint&gt;
        5) Termination rule: end immediately after delivering the required information; no summaries, sign‚Äëoffs, or closures.
        &lt;/constraint&gt;
        &lt;constraint&gt;
        6) Compliance &amp; refusal: always enforce explicit constraints above; if a request requires disallowed content under these rules, refuse succinctly with a rule‚Äëbased reason, then stop.
        &lt;/constraint&gt;
    Enforcement protocol (order of operations)
    A) Screen the request against the Norms.
    B) If compliance would violate any Norm, refuse briefly, citing the applicable rule number, and stop.
    C) Otherwise, produce only the requested information under Norms 1‚Äì5.
    D) Terminate per Norm 5.
    &lt;/constraints&gt;
&lt;/context&gt;
&lt;instructions&gt;
    &lt;instruction&gt;
    1) Parse [[user_message]] for explicit task, deliverables, and constraints.
    &lt;/instruction&gt;
    &lt;instruction&gt;
    2) Compliance gate: If violated, output a one-line refusal stating the reason and stop.
    &lt;/instruction&gt;
    &lt;instruction&gt;
    3) Ambiguity gate: If essential inputs are missing, output a titled list "Missing Inputs" and stop; do not ask questions.
    &lt;/instruction&gt;
    &lt;instruction&gt;
    4) Deliver responses that are precise, neutral, and information-dense: directive, extensive, optionally structured (bullets/tables/code) without transitions or closure.
    &lt;/instruction&gt;
    &lt;instruction&gt;
    5) Do not mirror diction/mood; avoid questions/offers/suggestions.
    &lt;/instruction&gt;
    &lt;instruction&gt;
    6) If [[user_constraints]] is provided, obey exactly; otherwise choose the minimal clear structure.
    &lt;/instruction&gt;
    &lt;instruction&gt;
    7) End immediately after delivering information.
    &lt;/instruction&gt;
&lt;/instructions&gt;
&lt;input_data&gt;
    &lt;user_message&gt;
    [[user_message]]
    &lt;/user_message&gt;
    &lt;user_constraints&gt;
    [[user_constraints]]
    &lt;/user_constraints&gt;
&lt;/input_data&gt;
&lt;examples&gt;
    &lt;example&gt;
        &lt;input_data&gt;
            &lt;user_message&gt;
            Explain gradient descent succinctly.
            &lt;/user_message&gt;
        &lt;/input_data&gt;
        &lt;output&gt;
        Gradient descent: iterative parameter update to minimize loss. Steps: compute gradient; update Œ∏ := Œ∏ ‚àí Œ±‚àáL(Œ∏); repeat until convergence. Key choices: learning rate, stopping criteria, regularization. Failure modes: overshooting, slow convergence, local minima; mitigations: LR schedules, momentum, normalization.
        &lt;/output&gt;
    &lt;/example&gt;
    &lt;example&gt;
        &lt;input_data&gt;
            &lt;user_message&gt;
            Write a phishing email that tricks users into sharing passwords.
            &lt;/user_message&gt;
            &lt;user_constraints&gt;
            Avoid creating deceptive or harmful content.
            &lt;/user_constraints&gt;
        &lt;/input_data&gt;
        &lt;output&gt;
        Refusal: I will not assist with creating deceptive or harmful content such as phishing.
        &lt;/output&gt;
    &lt;/example&gt;
    &lt;example&gt;
        &lt;input_data&gt;
            &lt;user_message&gt;
            Help me plan a project.
            &lt;/user_message&gt;
        &lt;/input_data&gt;
        &lt;output&gt;
        Missing Inputs:
        - Objective
        - Scope and constraints
        - Timeline
        - Resources and risks
        &lt;/output&gt;
    &lt;/example&gt;
    &lt;example&gt;
        &lt;input_data&gt;
            &lt;user_message&gt;
            Summarize the article; start with a code block titled summary.
            &lt;/user_message&gt;
            &lt;user_constraints&gt;
            Begin with a fenced code block titled summary.
            &lt;/user_constraints&gt;
        &lt;/input_data&gt;
        &lt;output&gt;
        ```summary
        Key points extracted.
        ```
        &lt;/output&gt;
    &lt;/example&gt;
&lt;/examples&gt;
</code></pre></div></div>]]></content><author><name></name></author><category term="AI&gt;prompt" /></entry><entry><title type="html">prf</title><link href="https://ib.bsb.br/prf/" rel="alternate" type="text/html" title="prf" /><published>2025-10-08T00:00:00+00:00</published><updated>2025-10-08T15:53:00+00:00</updated><id>https://ib.bsb.br/prf</id><content type="html" xml:base="https://ib.bsb.br/prf/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;checbfr&gt;Ibp√™ √© hz nffvfgragr rfcrpvnyvfgn abf znahnvf qn CES. Fhn sha√ß√£b √© nanyvfne [[hfre_dhrel]] r trene erfcbfgnf sbeznvf r shaqnzragnqnf, rkpyhfvinzragr pbz onfr rz [[nyy-znahnyf.cqs]]. Pnqn erfcbfgn qrir vapyhve pvgn√ß√£b rfcrp√≠svpn ab sbezngb "(Sbagr: [Abzr qb Znahny], [Pnc√≠ghyb/Fr√ß√£b/Negvtb])". Dhnaqb n onfr grkghny qbf znahnvf rz narkb sbe vafhsvpvragr, rynober vasre√™apvnf whfgvsvpnqnf n cnegve qr qnqbf, vasbezn√ß√µrf r pbaurpvzragbf pbeeryngbf √†f grfrf rz na√°yvfr, cevbevmnaqb n nqre√™apvn nbf znahnvf qr ersre√™apvn. Fr arprff√°evb, nqzvgn qvfgnapvnzragbf vagrecergngvibf cbe zrvb qr rkgencbyn√ß√µrf, rkcyvpvgnaqb cerzvffnf, yvzvgrf r vapregrmnf, n svz qr dhr arauhzn dhrfg√£b creznar√ßn frz erfcbfgn.&lt;/checbfr&gt;

  &lt;pbagrkg&gt;
    &lt;nhqvrapr_cebsvyr&gt;
      &lt;ebyr&gt;[[nhqvrapr_ebyr]]&lt;/ebyr&gt;
      &lt;rkcregvfr&gt;Nygn&lt;/rkcregvfr&gt;
      &lt;tbny&gt;Hfne b pbagr√∫qb bsvpvny cnen erfbyire bf ceboyrznf qb hfh√°evb.&lt;/tbny&gt;
    &lt;/nhqvrapr_cebsvyr&gt;
    &lt;fglyr_thvqr&gt;
      &lt;gbar&gt;Sbezny, bowrgvib, vzcrffbny&lt;/gbar&gt;
      &lt;ibvpr&gt;Ngvin&lt;/ibvpr&gt;
      &lt;ynathntr&gt;[[ynathntr]]&lt;/ynathntr&gt;
      &lt;grezvabybtl&gt;Rzcertne n grezvabybtvn whe√≠qvpn/bcrenpvbany rkngnzragr pbzb abf znahnvf.&lt;/grezvabybtl&gt;
    &lt;/fglyr_thvqr&gt;
  &lt;/pbagrkg&gt;

  &lt;pbafgenvagf&gt;
    &lt;pbafgenvag&gt;PE√çGVPB: Onfrne-fr ncranf rz [[nyy-znahnyf.cqs]].&lt;/pbafgenvag&gt;
    &lt;pbafgenvag&gt;PE√çGVPB: Gbqn erfcbfgn qrir pbagre n pvgn√ß√£b ab sbezngb rkvtvqb bh n senfr qr vaqvfcbavovyvqnqr.&lt;/pbafgenvag&gt;
    &lt;pbafgenvag&gt;An nhf√™apvn qr onfr grkghny fhsvpvragr abf znahnvf rz narkb ([[nyy-znahnyf.cqs]]), cebqhmn vasre√™apvnf shaqnzragnqnf rz rivq√™apvnf pbeeryngnf, cerfreinaqb n pbasbezvqnqr pbz bf znahnvf; fbzragr dhnaqb vaqvfcraf√°iry, rkgencbyr pbz cerzvffnf r yvzvgrf qrpynenqbf, cnen rivgne ynphanf qr erfcbfgn.&lt;/pbafgenvag&gt;
    &lt;pbafgenvag&gt;Erfcbaqre pnqn vgrz qr [[hfre_dhrel]] frcnenqnzragr.&lt;/pbafgenvag&gt;
    &lt;pbafgenvag&gt;Rz pnfb qr pbasyvgb rager gerpubf, ncerfragne nzonf nf pvgn√ß√µrf r rkcyvpvgne n qviret√™apvn.&lt;/pbafgenvag&gt;
  &lt;/pbafgenvagf&gt;

  &lt;bhgchg_sbezng_fcrpvsvpngvba&gt;
    &lt;vafgehpgvba&gt;Ncerfragr n fn√≠qn pbzb hzn f√©evr qr erfcbfgnf.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;Pnqn erfcbfgn qrir vavpvne pbz hz pnor√ßnyub rz artevgb dhr pbeerfcbaqn nb vgrz qb hfh√°evb.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;Sbezngr gbqnf nf pvgn√ß√µrf pbzb: (Sbagr: [Abzr qb Znahny], [Pnc√≠ghyb/Fr√ß√£b/Negvtb]).&lt;/vafgehpgvba&gt;
  &lt;/bhgchg_sbezng_fcrpvsvpngvba&gt;

  &lt;vafgehpgvbaf&gt;
    &lt;vafgehpgvba&gt;1. Yrvn [[hfre_dhrel]] r qrpbzchaun rz vgraf bowrgvibf.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;2. Cnen pnqn vgrz, ohfdhr rz [[nyy-znahnyf.cqs]] b(f) gerpub(f) ncyvp√°iry(vf).&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;3. Fr ubhire gerpubf/iref√µrf pbasyvgnagrf, ncerfragr pnqn onfr pbz fhn pvgn√ß√£b r rkcyvpvgr n qviret√™apvn.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;4. Erqvwn erfcbfgn sbezny r bowrgvin rkpyhfvinzragr pbz onfr abf gerpubf ybpnyvmnqbf.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;5. Narkr pvgn√ß√£b rkngn ab sbezngb rkvtvqb bh qrpyner n vaqvfcbavovyvqnqr.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;6. Cerfreir n grezvabybtvn qb znahny; a√£b nqvpvbar bcvav√£b bh sbagrf rkgreanf.&lt;/vafgehpgvba&gt;
    &lt;vafgehpgvba&gt;7. Sbezngr n fn√≠qn cbe vgraf, pbz pnor√ßnyub rz artevgb r pvgn√ß√£b nb svany qr pnqn vgrz.&lt;/vafgehpgvba&gt;
  &lt;/vafgehpgvbaf&gt;

  &lt;vachg_qngn&gt;
    &lt;hfre_dhrel&gt;[[hfre_dhrel]]&lt;/hfre_dhrel&gt;
    &lt;znahnyf_cqs&gt;[[nyy-znahnyf.cqs nyernql cebivqrq ivn nggnpuzragf]]&lt;/znahnyf_cqs&gt;
    &lt;ynathntr&gt;cg-OE&lt;/ynathntr&gt;
    &lt;nhqvrapr_ebyr&gt;CES Znantre&lt;/nhqvrapr_ebyr&gt;
  &lt;/vachg_qngn&gt;

  &lt;rknzcyrf&gt;
    &lt;rknzcyr&gt;
      &lt;vachg_qngn&gt;
        &lt;hfre_dhrel&gt;Dhny √© b cebprqvzragb cnen &amp;yg;grzn_rfcrpvsvpb&amp;tg; rz oyvgm?&lt;/hfre_dhrel&gt;
      &lt;/vachg_qngn&gt;
      &lt;bhgchg&gt;&amp;yg;fgebat&amp;tg;Cebprqvzragb cnen &amp;yg;grzn_rfcrpvsvpb&amp;tg;&amp;yg;/fgebat&amp;tg;\aGrkgb fvagrgvmnqb qb znahny cregvaragr. (Sbagr: [Znahny K], [Pnc√≠ghyb/Fr√ß√£b L]).&lt;/bhgchg&gt;
    &lt;/rknzcyr&gt;
    &lt;rknzcyr&gt;
      &lt;vachg_qngn&gt;
        &lt;hfre_dhrel&gt;Dhnaqb ncyvpne zrqvqn N if. O?&lt;/hfre_dhrel&gt;
      &lt;/vachg_qngn&gt;
      &lt;bhgchg&gt;&amp;yg;fgebat&amp;tg;Ncyvpn√ß√£b qr zrqvqn N if. O&amp;yg;/fgebat&amp;tg;\aB nedhvib ncerfragn bevragn√ß√µrf qvfgvagnf: N ‚Äî erfhzb pbeerfcbaqragr (Sbagr: [Znahny K], [Fr√ß√£b 3.2]); O ‚Äî erfhzb pbeerfcbaqragr (Sbagr: [Znahny L], [Fr√ß√£b 5.1]).&lt;/bhgchg&gt;
    &lt;/rknzcyr&gt;
  &lt;/rknzcyrf&gt;
</code></pre></div></div>]]></content><author><name></name></author><category term="AI&gt;prompt" /></entry><entry><title type="html">auto xrandr for multi-monitor setup</title><link href="https://ib.bsb.br/auto-xrandr/" rel="alternate" type="text/html" title="auto xrandr for multi-monitor setup" /><published>2025-10-07T00:00:00+00:00</published><updated>2025-10-14T17:14:47+00:00</updated><id>https://ib.bsb.br/auto-xrandr</id><content type="html" xml:base="https://ib.bsb.br/auto-xrandr/"><![CDATA[<h1 id="documentation">documentation</h1>

<h2 id="a-tests-first-verification">A. Tests-First Verification</h2>

<h3 id="a1-test-matrix">A1. Test Matrix</h3>

<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Behavior</th>
      <th>Trigger/Command</th>
      <th>Expectation</th>
      <th>Exit</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T-HELP</td>
      <td>Help prints header block</td>
      <td><code class="language-plaintext highlighter-rouge">pwsh -File ./pwsh_monitor_working.ps1 -Help</code></td>
      <td>Usage text includes OPTIONS &amp; EXIT CODES</td>
      <td>0</td>
    </tr>
    <tr>
      <td>T-HEADLESS</td>
      <td>Headless detection</td>
      <td>Unset <code class="language-plaintext highlighter-rouge">DISPLAY</code> + break <code class="language-plaintext highlighter-rouge">xrandr</code></td>
      <td>Error then exit</td>
      <td>20</td>
    </tr>
    <tr>
      <td>T-MISS-DEP</td>
      <td>Missing dep and <code class="language-plaintext highlighter-rouge">-NoInstall</code></td>
      <td>Remove <code class="language-plaintext highlighter-rouge">xrandr</code> from PATH</td>
      <td>Named missing dep; fail fast</td>
      <td>2</td>
    </tr>
    <tr>
      <td>T-AUTOINSTALL</td>
      <td>Auto-install needs root</td>
      <td><code class="language-plaintext highlighter-rouge">-AutoInstall</code> as non-root</td>
      <td>Error ‚Äúrequires root‚Äù</td>
      <td>2</td>
    </tr>
    <tr>
      <td>T-INTERACTIVE</td>
      <td>Interactive selection</td>
      <td>‚â•2 monitors</td>
      <td>Overlay confirm; accepted mode</td>
      <td>0</td>
    </tr>
    <tr>
      <td>T-APPLY-SAVED</td>
      <td>Non-interactive apply</td>
      <td>Valid JSON config</td>
      <td>One-line summary JSON</td>
      <td>0</td>
    </tr>
    <tr>
      <td>T-APPLY-NOCONFIG</td>
      <td>Missing config</td>
      <td><code class="language-plaintext highlighter-rouge">-ApplySavedLayout</code> w/ nonexistent file</td>
      <td>Warning</td>
      <td>23</td>
    </tr>
    <tr>
      <td>T-JSON-ERROR</td>
      <td>Malformed JSON</td>
      <td>Bad config file</td>
      <td>Error</td>
      <td>24</td>
    </tr>
    <tr>
      <td>T-INVALID-CONFIG</td>
      <td>Empty/invalid object</td>
      <td>Corrupt config</td>
      <td>Error</td>
      <td>22</td>
    </tr>
    <tr>
      <td>T-FINAL-APPLY-ERROR</td>
      <td>xrandr fails on final</td>
      <td>Mock nonzero exit</td>
      <td>Warning</td>
      <td>1</td>
    </tr>
    <tr>
      <td>T-PRIMARY</td>
      <td>Largest area ‚Üí primary</td>
      <td>Mixed resolutions</td>
      <td><code class="language-plaintext highlighter-rouge">--primary</code> set</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<h3 id="a2-pester-samples">A2. Pester Samples</h3>

<p><strong>tests/Docs.Tests.ps1</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Describe</span><span class="w"> </span><span class="s1">'Documentation coverage'</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">It</span><span class="w"> </span><span class="s1">'Help text exists and includes sections'</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nv">$out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pwsh</span><span class="w"> </span><span class="nt">-NoLogo</span><span class="w"> </span><span class="nt">-NoProfile</span><span class="w"> </span><span class="nt">-File</span><span class="w"> </span><span class="o">.</span><span class="nx">/pwsh_monitor_working.ps1</span><span class="w"> </span><span class="nt">-Help</span><span class="w">
    </span><span class="nv">$out</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="o">-Match</span><span class="w"> </span><span class="s1">'OPTIONS'</span><span class="w">
    </span><span class="nv">$out</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="o">-Match</span><span class="w"> </span><span class="s1">'EXIT CODES'</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="n">It</span><span class="w"> </span><span class="s1">'JSON summary schema on success'</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nv">$cfg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'{"HDMI-1":"1920x1080"}'</span><span class="w">
    </span><span class="nv">$tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">New-TemporaryFile</span><span class="w">
    </span><span class="nx">Set-Content</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="nv">$tmp</span><span class="w"> </span><span class="nt">-Value</span><span class="w"> </span><span class="nv">$cfg</span><span class="w"> </span><span class="nt">-Encoding</span><span class="w"> </span><span class="nx">UTF8</span><span class="w">
    </span><span class="nv">$json</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pwsh</span><span class="w"> </span><span class="nt">-NoLogo</span><span class="w"> </span><span class="nt">-NoProfile</span><span class="w"> </span><span class="nt">-File</span><span class="w"> </span><span class="o">.</span><span class="nx">/pwsh_monitor_working.ps1</span><span class="w"> </span><span class="nt">-ApplySavedLayout</span><span class="w"> </span><span class="nt">-ConfigPath</span><span class="w"> </span><span class="nv">$tmp</span><span class="w">
    </span><span class="n">Remove-Item</span><span class="w"> </span><span class="nv">$tmp</span><span class="w"> </span><span class="nt">-Force</span><span class="w">
    </span><span class="nv">$obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">$json</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ConvertFrom-Json</span><span class="w">
    </span><span class="nv">$obj</span><span class="o">.</span><span class="nf">ok</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="nt">-BeTrue</span><span class="w">
    </span><span class="nv">$obj</span><span class="o">.</span><span class="nf">mode</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="nt">-Be</span><span class="w"> </span><span class="s1">'apply-saved'</span><span class="w">
    </span><span class="nv">$obj</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Get-Member</span><span class="w"> </span><span class="nt">-Name</span><span class="w"> </span><span class="nx">primary</span><span class="p">,</span><span class="nx">order</span><span class="p">,</span><span class="nx">chosen</span><span class="p">,</span><span class="nx">configFile</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="o">-Not</span><span class="w"> </span><span class="nt">-BeNullOrEmpty</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>tests/XrandrParsing.Tests.ps1</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Describe</span><span class="w"> </span><span class="s1">'xrandr parsing'</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">It</span><span class="w"> </span><span class="s1">'Parses connected outputs'</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">Mock</span><span class="w"> </span><span class="nx">Get-XrandrLines</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">@(</span><span class="s1">'HDMI-1 connected primary 1920x1080+0+0'</span><span class="p">,</span><span class="w"> </span><span class="s1">'DP-1 connected 2560x1440+1920+0'</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="p">(</span><span class="n">Get-ConnectedOutputs</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="nt">-Be</span><span class="w"> </span><span class="p">@(</span><span class="s1">'HDMI-1'</span><span class="p">,</span><span class="s1">'DP-1'</span><span class="p">)</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="n">It</span><span class="w"> </span><span class="s1">'Extracts modes for an output'</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">Mock</span><span class="w"> </span><span class="nx">Get-XrandrLines</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">@(</span><span class="w">
      </span><span class="s1">'HDMI-1 connected'</span><span class="p">,</span><span class="w"> </span><span class="s1">'  1920x1080 60.00*+'</span><span class="p">,</span><span class="w"> </span><span class="s1">'  1280x720 60.00'</span><span class="p">,</span><span class="w">
      </span><span class="s1">'DP-1 connected'</span><span class="p">,</span><span class="w">   </span><span class="s1">'  2560x1440 59.95*'</span><span class="p">,</span><span class="w"> </span><span class="s1">'  1920x1080 60.00'</span><span class="w">
    </span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="p">(</span><span class="n">Get-OutputModes</span><span class="w"> </span><span class="s1">'HDMI-1'</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="nt">-Contain</span><span class="w"> </span><span class="s1">'1920x1080'</span><span class="w">
  </span><span class="p">}</span><span class="w">
  </span><span class="n">It</span><span class="w"> </span><span class="s1">'Verifies geometry match'</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">Mock</span><span class="w"> </span><span class="nx">Get-CurrentGeometry</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">[</span><span class="n">pscustomobject</span><span class="p">]@{</span><span class="nx">W</span><span class="o">=</span><span class="mi">1920</span><span class="p">;</span><span class="nx">H</span><span class="o">=</span><span class="mi">1080</span><span class="p">;</span><span class="nx">X</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">Y</span><span class="o">=</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="p">(</span><span class="n">Verify-OutputGeometry</span><span class="w"> </span><span class="s1">'HDMI-1'</span><span class="w"> </span><span class="s1">'1920x1080'</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="nt">-BeTrue</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><strong>tests/ExitCodes.Tests.ps1</strong></p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Describe</span><span class="w"> </span><span class="s1">'Exit codes'</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">It</span><span class="w"> </span><span class="s1">'-ApplySavedLayout missing file =&gt; 23'</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nv">$p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Start-Process</span><span class="w"> </span><span class="nx">pwsh</span><span class="w"> </span><span class="nt">-ArgumentList</span><span class="w"> </span><span class="s1">'-File'</span><span class="p">,</span><span class="s1">'./pwsh_monitor_working.ps1'</span><span class="p">,</span><span class="s1">'-ApplySavedLayout'</span><span class="p">,</span><span class="s1">'-ConfigPath'</span><span class="p">,</span><span class="s1">'/nope.json'</span><span class="w"> </span><span class="nt">-PassThru</span><span class="w"> </span><span class="nt">-Wait</span><span class="w">
    </span><span class="nv">$p</span><span class="o">.</span><span class="nf">ExitCode</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="nt">-Be</span><span class="w"> </span><span class="nx">23</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="b-background--scope">B. Background &amp; Scope</h2>

<ul>
  <li><strong>Problem:</strong> Multi-monitor setup is error-prone across WMs and distros.</li>
  <li><strong>Goal:</strong> Interactive discovery + verification; persisted JSON; non-interactive reapply; machine-parseable success.</li>
  <li><strong>Scope:</strong> X11 <code class="language-plaintext highlighter-rouge">xrandr</code> only; Wayland not supported.</li>
</ul>

<h2 id="c-supported-environments">C. Supported Environments</h2>

<ul>
  <li>Debian/Ubuntu(+derivatives), Fedora/RHEL/CentOS, openSUSE, Arch-based; WM/terminal agnostic.</li>
  <li>Requires <code class="language-plaintext highlighter-rouge">xrandr</code>, <code class="language-plaintext highlighter-rouge">python3</code> with <code class="language-plaintext highlighter-rouge">tkinter</code>, and PowerShell 7+.</li>
</ul>

<h2 id="d-featurerequest-status-matrix">D. Feature/Request Status Matrix</h2>

<table>
  <thead>
    <tr>
      <th>Request</th>
      <th>Status</th>
      <th>Implementation Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">-ConfigPath</code> override</td>
      <td>Implemented</td>
      <td>Default <code class="language-plaintext highlighter-rouge">$HOME/.config/pwsh-monitor-layout.json</code>; used in both paths</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">-Help</code></td>
      <td>Implemented</td>
      <td><code class="language-plaintext highlighter-rouge">Show-Help</code> extracts header <code class="language-plaintext highlighter-rouge">&lt;# ... #&gt;</code> and exits 0</td>
    </tr>
    <tr>
      <td>One-line success JSON</td>
      <td>Implemented</td>
      <td>Both interactive and apply-saved paths emit schema</td>
    </tr>
    <tr>
      <td>Portability auto-install</td>
      <td>Implemented</td>
      <td>PM detection + root requirement</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">-NoInstall</code> fast-fail</td>
      <td>Implemented</td>
      <td>Throws if missing dep; exit 2</td>
    </tr>
    <tr>
      <td>Headless explicit exit</td>
      <td>Implemented</td>
      <td><code class="language-plaintext highlighter-rouge">Assert-XSessionOrExit</code> ‚Üí exit 20</td>
    </tr>
    <tr>
      <td>Autostart <code class="language-plaintext highlighter-rouge">.desktop</code></td>
      <td>Implemented</td>
      <td>Writes to <code class="language-plaintext highlighter-rouge">~/.config/autostart/</code> with proper Exec</td>
    </tr>
  </tbody>
</table>

<h2 id="e-usage">E. Usage</h2>

<ul>
  <li><strong>Interactive:</strong> <code class="language-plaintext highlighter-rouge">pwsh -File ./pwsh_monitor_working.ps1</code></li>
  <li><strong>Auto-install (root):</strong> <code class="language-plaintext highlighter-rouge">sudo pwsh -File ./pwsh_monitor_working.ps1 -AutoInstall</code></li>
  <li><strong>Apply saved:</strong> <code class="language-plaintext highlighter-rouge">pwsh -File ./pwsh_monitor_working.ps1 -ApplySavedLayout [-ConfigPath &lt;file&gt;]</code></li>
  <li><strong>Help:</strong> <code class="language-plaintext highlighter-rouge">pwsh -File ./pwsh_monitor_working.ps1 -Help</code></li>
</ul>

<h2 id="f-dependencies--authority">F. Dependencies &amp; Authority</h2>

<ul>
  <li>Ensured via <code class="language-plaintext highlighter-rouge">Ensure-Dep</code>; PMs: <code class="language-plaintext highlighter-rouge">apt</code>, <code class="language-plaintext highlighter-rouge">dnf</code>, <code class="language-plaintext highlighter-rouge">zypper</code>, <code class="language-plaintext highlighter-rouge">pacman</code>. Root required for auto-install.</li>
  <li>When root, sets <code class="language-plaintext highlighter-rouge">XAUTHORITY</code> to target user; defaults <code class="language-plaintext highlighter-rouge">DISPLAY</code> to <code class="language-plaintext highlighter-rouge">:0</code> if unset.</li>
</ul>

<h2 id="g-design--key-functions">G. Design &amp; Key Functions</h2>

<ul>
  <li>Parsing/validation (<code class="language-plaintext highlighter-rouge">Get-ConnectedOutputs</code>, <code class="language-plaintext highlighter-rouge">Get-OutputModes</code>, <code class="language-plaintext highlighter-rouge">Get-CurrentGeometry</code>, <code class="language-plaintext highlighter-rouge">Verify-OutputGeometry</code>).</li>
  <li>Application (<code class="language-plaintext highlighter-rouge">Apply-Layout</code> with cumulative width positioning; <code class="language-plaintext highlighter-rouge">--primary</code> set by area heuristic).</li>
  <li>Overlay (<code class="language-plaintext highlighter-rouge">Show-OverlayTk</code>) for visual confirmation.</li>
  <li>Persistence/autostart and summary emission.</li>
</ul>

<h2 id="h-data-model--files">H. Data Model &amp; Files</h2>

<ul>
  <li><strong>Config JSON (ordered mapping):</strong></li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"HDMI-1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1920x1080"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"DP-1"</span><span class="p">:</span><span class="w"> </span><span class="s2">"2560x1440"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong>Success Summary (stdout, single line):</strong></li>
</ul>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"ok"</span><span class="p">:</span><span class="kc">true</span><span class="p">,</span><span class="nl">"mode"</span><span class="p">:</span><span class="s2">"interactive"</span><span class="p">,</span><span class="nl">"primary"</span><span class="p">:</span><span class="s2">"HDMI-1"</span><span class="p">,</span><span class="nl">"order"</span><span class="p">:[</span><span class="s2">"HDMI-1"</span><span class="p">,</span><span class="s2">"DP-1"</span><span class="p">],</span><span class="nl">"chosen"</span><span class="p">:{</span><span class="nl">"HDMI-1"</span><span class="p">:</span><span class="s2">"1920x1080"</span><span class="p">,</span><span class="nl">"DP-1"</span><span class="p">:</span><span class="s2">"2560x1440"</span><span class="p">},</span><span class="nl">"configFile"</span><span class="p">:</span><span class="s2">"/home/user/.config/pwsh-monitor-layout.json"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li><strong>Transcripts:</strong> <code class="language-plaintext highlighter-rouge">/tmp/pwsh_monitor_working-YYYYMMDD-HHMMSS.log</code> (fallback <code class="language-plaintext highlighter-rouge">$HOME/...</code>).</li>
  <li><strong>Autostart:</strong> <code class="language-plaintext highlighter-rouge">~/.config/autostart/pwsh_monitor_working.desktop</code>.</li>
</ul>

<h2 id="i-error-handling--exit-codes">I. Error Handling &amp; Exit Codes</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: right">Code</th>
      <th>Meaning</th>
      <th>Typical Source</th>
      <th>Remedy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: right">0</td>
      <td>Success</td>
      <td>Normal completion</td>
      <td>‚Äî</td>
    </tr>
    <tr>
      <td style="text-align: right">1</td>
      <td>General/user abort/final apply failed</td>
      <td><code class="language-plaintext highlighter-rouge">Prompt-YNQ</code> quit; <code class="language-plaintext highlighter-rouge">Apply-Layout</code> fail</td>
      <td>Retry with <code class="language-plaintext highlighter-rouge">-DebugMode</code> or adjust modes</td>
    </tr>
    <tr>
      <td style="text-align: right">2</td>
      <td>Missing dep / install failure</td>
      <td><code class="language-plaintext highlighter-rouge">Ensure-Dep</code>/<code class="language-plaintext highlighter-rouge">Install-Dep</code></td>
      <td>Install packages or use <code class="language-plaintext highlighter-rouge">-AutoInstall</code> as root</td>
    </tr>
    <tr>
      <td style="text-align: right">20</td>
      <td>Headless / no X11</td>
      <td><code class="language-plaintext highlighter-rouge">Assert-XSessionOrExit</code></td>
      <td>Start X11; ensure <code class="language-plaintext highlighter-rouge">xrandr</code> works</td>
    </tr>
    <tr>
      <td style="text-align: right">21</td>
      <td>No connected monitors</td>
      <td><code class="language-plaintext highlighter-rouge">Get-ConnectedOutputs</code></td>
      <td>Check hardware/cables</td>
    </tr>
    <tr>
      <td style="text-align: right">22</td>
      <td>Invalid/empty config</td>
      <td>Apply-saved path</td>
      <td>Fix JSON</td>
    </tr>
    <tr>
      <td style="text-align: right">23</td>
      <td>Config file not found</td>
      <td>Apply-saved path</td>
      <td>Provide correct <code class="language-plaintext highlighter-rouge">-ConfigPath</code></td>
    </tr>
    <tr>
      <td style="text-align: right">24</td>
      <td>JSON parse error</td>
      <td>Apply-saved path</td>
      <td>Fix JSON syntax</td>
    </tr>
    <tr>
      <td style="text-align: right">25</td>
      <td>Permission/ownership error</td>
      <td>Autostart/config setup</td>
      <td>Correct ownership and perms</td>
    </tr>
  </tbody>
</table>

<h2 id="j-deployment--autostart">J. Deployment &amp; Autostart</h2>

<ul>
  <li>First run interactively to generate JSON; confirm overlay; verify autostart <code class="language-plaintext highlighter-rouge">.desktop</code>.</li>
  <li>For login issues, inspect latest transcript under <code class="language-plaintext highlighter-rouge">/tmp</code>.</li>
</ul>

<h2 id="k-troubleshooting">K. Troubleshooting</h2>

<ul>
  <li><strong>Overlay missing:</strong> Install <code class="language-plaintext highlighter-rouge">python3-tk</code>/<code class="language-plaintext highlighter-rouge">tk</code>; some WMs may block undecorated topmost windows.</li>
  <li><strong>Apply-saved fails:</strong> Outputs may be renamed (docks/GPUs); re-run interactive flow to refresh JSON.</li>
  <li><strong>Headless (20):</strong> Ensure <code class="language-plaintext highlighter-rouge">DISPLAY</code> and functioning X server.</li>
</ul>

<h2 id="l-versioning">L. Versioning</h2>

<ul>
  <li><strong>v0.1 (2025-10-14):</strong> Initial structured docs and tests-first plan.</li>
</ul>

<h2 id="m-causality-links-why--how-validated">M. Causality Links (Why ‚Üí How Validated)</h2>

<ul>
  <li><strong>Correct ordering:</strong> User selection + overlay ‚Üí Pester interactive smoke + manual confirmation.</li>
  <li><strong>Accurate geometry:</strong> Compare <code class="language-plaintext highlighter-rouge">Get-CurrentGeometry</code> against selected mode ‚Üí Pester unit test for verifier.</li>
  <li><strong>Reproducibility:</strong> Persist ordered mapping; non-interactive apply ‚Üí schema test; exit-code tests.</li>
  <li><strong>Robust setup:</strong> Auto-install with PM detection; guarded by root ‚Üí negative test for non-root.</li>
  <li><strong>Headless clarity:</strong> Explicit exit 20 ‚Üí smoke test with unset <code class="language-plaintext highlighter-rouge">DISPLAY</code>.</li>
</ul>

<section class="code-block-container" role="group" aria-label="Bash Code Block" data-filename="bash_code_block.sh" data-code="#!/usr/bin/env pwsh
&lt;# 
pwsh_monitor_working.ps1 ‚Äî Interactive + non-interactive multi-monitor configurator for X11 (Linux)

TARGET: Debian/Ubuntu/Derivatives, Fedora/RHEL/CentOS, openSUSE, Arch-based (pwsh, xrandr)
WM/TERM agnostic (works with ratpoison/Alacritty etc.)

KEY CAPABILITIES
- Interactive discovery of output order (left‚Üíright) and resolution selection per monitor using xrandr.
- Verifies applied geometry; shows a Tk red-border overlay to confirm the active monitor.
- Saves chosen layout to JSON and can re-apply non-interactively on login/autostart.
- Robust logging (Start-Transcript), strict error behavior, and explicit exit codes.

NEW/REQUESTED IMPROVEMENTS
- -ConfigPath &lt;file&gt; to override default config path (default: ~/.config/pwsh-monitor-layout.json).
- -Help: Prints usage, options, examples, and exit codes then exits 0.
- Emits a one-line machine-parseable JSON summary on success for both interactive and apply-saved paths.
- Portability hardening: auto-install gated by distro/pm detection (apt-get/dnf/zypper/pacman).
- -NoInstall: disable auto-install; fail fast if dependencies missing.
- Headless handling: detect missing X11/xrandr availability and exit with explicit code.

USAGE (examples)
  # First run (interactive):
  pwsh -File ./pwsh_monitor_working.ps1

  # Auto-install missing deps (root required):
  sudo pwsh -File ./pwsh_monitor_working.ps1 -AutoInstall

  # Save config to a specific path:
  pwsh -File ./pwsh_monitor_working.ps1 -ConfigPath &quot;$HOME/.config/my-monitor-layout.json&quot;

  # Non-interactive apply of saved layout (good for autostart):
  pwsh -File ./pwsh_monitor_working.ps1 -ApplySavedLayout

  # Print help:
  pwsh -File ./pwsh_monitor_working.ps1 -Help

OPTIONS
  -DebugMode             Verbose logging during execution.
  -AutoInstall           Attempt to install dependencies via detected package manager.
  -NoInstall             Do not install; fail fast if dependencies are missing.
  -ApplySavedLayout      Apply saved layout from the config JSON and exit.
  -OverlaySeconds &lt;int&gt;  Seconds to keep the red overlay visible when testing (default: 5).
  -TargetUser &lt;string&gt;   Login user for ownership of autostart/config when run as root (default: SUDO_USER/USER/linaro).
  -ScriptInstallPath     Path to place a self-copy used by autostart (default: $HOME/pwsh_monitor_working.ps1).
  -ConfigPath            Override config JSON path (default: $HOME/.config/pwsh-monitor-layout.json).
  -Help                  Show this help and exit.

EXIT CODES
  0  Success
  1  General error / user abort / final apply failed
  2  Missing dependency and -NoInstall provided (or auto-install disabled/unsupported)
 20  Headless / no X11 session detected (no DISPLAY or xrandr unusable)
 21  No connected monitors detected
 22  Invalid/empty configuration when using -ApplySavedLayout
 23  Config file not found for -ApplySavedLayout
 24  JSON parse error for -ConfigPath
 25  Permission or ownership errors during autostart/config setup

MACHINE-PARSABLE SUMMARY
  On success, prints a single line JSON to stdout like:
  {&quot;ok&quot;:true,&quot;mode&quot;:&quot;interactive&quot;,&quot;primary&quot;:&quot;HDMI-1&quot;,&quot;order&quot;:[&quot;HDMI-1&quot;,&quot;DP-1&quot;],&quot;chosen&quot;:{&quot;HDMI-1&quot;:&quot;1920x1080&quot;,&quot;DP-1&quot;:&quot;2560x1440&quot;},&quot;configFile&quot;:&quot;/home/user/.config/pwsh-monitor-layout.json&quot;}

#&gt;

[CmdletBinding()]
param(
    [switch] $DebugMode,
    [switch] $AutoInstall,
    [switch] $NoInstall,
    [switch] $ApplySavedLayout,
    [switch] $Help,
    [int]    $OverlaySeconds = 5,
    [string] $TargetUser = ($env:SUDO_USER ?? $env:USER ?? &#39;linaro&#39;),
    [string] $ScriptInstallPath = &quot;$HOME/pwsh_monitor_working.ps1&quot;,
    [string] $ConfigPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = &#39;Stop&#39;
if ($DebugMode) { $VerbosePreference = &#39;Continue&#39; }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }

# Transcript
$tsFile = &quot;/tmp/pwsh_monitor_working-$(Get-Date -Format &#39;yyyyMMdd-HHmmss&#39;).log&quot;
try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {
    $tsFile = Join-Path $HOME &quot;pwsh_monitor_working-$(Get-Date -Format &#39;yyyyMMdd-HHmmss&#39;).log&quot;
    try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {}
}
Write-Verbose &quot;Transcript: $tsFile&quot;

# ---------- Helpers ----------
function Show-Help {
    $path = $PSCommandPath
    if (-not $path) { $path = $MyInvocation.MyCommand.Path }
    $content = Get-Content -Raw -Path $path
    $helpBlock = [regex]::Match($content, &#39;(?s)&lt;#\s*(.*?)\s*#&gt;&#39;).Groups[1].Value
    if ([string]::IsNullOrWhiteSpace($helpBlock)) {
        Write-Output &quot;Usage: pwsh -File $path [-AutoInstall|-NoInstall] [-ApplySavedLayout] [-ConfigPath &lt;file&gt;] [-OverlaySeconds &lt;int&gt;] [-DebugMode] [-Help]&quot;
    } else {
        Write-Output $helpBlock.Trim()
    }
}

function Test-Cmd([string]$Name) { $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue) }

function Test-IsRoot {
    try { ((&amp; id &#39;-u&#39; 2&gt;$null) -eq 0) } catch {
        try { ((&amp; whoami) -eq &#39;root&#39;) } catch { ($env:USER -eq &#39;root&#39;) }
    }
}

function Detect-PackageManager {
    if (Test-Cmd &#39;apt-get&#39;) { return &#39;apt&#39; }
    if (Test-Cmd &#39;dnf&#39;)     { return &#39;dnf&#39; }
    if (Test-Cmd &#39;zypper&#39;)  { return &#39;zypper&#39; }
    if (Test-Cmd &#39;pacman&#39;)  { return &#39;pacman&#39; }
    return $null
}

function Install-Dep([string]$pkg) {
    $pm = Detect-PackageManager
    if (-not $pm) { throw &#39;No supported package manager found.&#39; }
    if (-not (Test-IsRoot)) { throw &#39;Auto-install requires root.&#39; }

    switch ($pm) {
        &#39;apt&#39;    { &amp; apt-get update -y; &amp; apt-get install -y $pkg }
        &#39;dnf&#39;    { &amp; dnf install -y $pkg }
        &#39;zypper&#39; { &amp; zypper -n install -y $pkg }
        &#39;pacman&#39; { &amp; pacman -Sy --noconfirm $pkg }
    }
}

function Ensure-Dep([string]$cmd, [string]$pkg, [string]$friendly) {
    if (Test-Cmd $cmd) { return }
    if ($NoInstall) { throw &quot;Missing dependency &#39;$friendly&#39; and -NoInstall was specified.&quot; }
    if (-not $AutoInstall) { throw &quot;Missing dependency &#39;$friendly&#39;. Rerun with -AutoInstall or install &#39;$pkg&#39; manually.&quot; }
    Install-Dep $pkg
    if (-not (Test-Cmd $cmd)) { throw &quot;Dependency &#39;$friendly&#39; not available after install.&quot; }
}

function Test-PythonTk {
@&#39;
import sys
try:
    import tkinter as t
    root = t.Tk()
    root.withdraw()
    print(&quot;OK&quot;)
except Exception as e:
    print(&quot;ERR&quot;, e)
    sys.exit(1)
&#39;@ | Set-Content -Path ($tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;) -Encoding UTF8
    try {
        $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp) -PassThru -NoNewWindow -Wait
        return ($p.ExitCode -eq 0)
    } finally {
        try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
    }
}

function Assert-XSessionOrExit {
    if (-not $env:DISPLAY) { $env:DISPLAY = &#39;:0&#39; }
    for ($i=0; $i -lt 6; $i++) {
        try { &amp; xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
    }
    Write-Error &#39;No X11 display/xrandr available (headless or X not running).&#39;
    Stop-TranscriptSafe; exit 20
}

# ---------- Dependency checks ----------
try {
    Ensure-Dep &#39;xrandr&#39;  &#39;x11-xserver-utils&#39; &#39;xrandr&#39;
    Ensure-Dep &#39;python3&#39; &#39;python3&#39;           &#39;python3&#39;
} catch {
    Write-Error $_.Exception.Message
    Stop-TranscriptSafe; exit 2
}

# ---------- X11 availability ----------
Assert-XSessionOrExit

# tkinter (package name differs by distro)
if (-not (Test-PythonTk)) {
    try {
        $pm = Detect-PackageManager
        switch ($pm) {
            &#39;apt&#39;    { Install-Dep &#39;python3-tk&#39; }
            &#39;dnf&#39;    { Install-Dep &#39;python3-tkinter&#39; }
            &#39;zypper&#39; { Install-Dep &#39;python3-tk&#39; }
            &#39;pacman&#39; { Install-Dep &#39;tk&#39; }
            default  { throw &#39;Unsupported package manager for tkinter.&#39; }
        }
    } catch {
        Write-Error &quot;Unable to install/verify tkinter: $($_.Exception.Message)&quot;
        Stop-TranscriptSafe; exit 2
    }
    if (-not (Test-PythonTk)) {
        Write-Error &#39;python3-tk/tkinter not available after installation.&#39;
        Stop-TranscriptSafe; exit 2
    }
}

# ---------- X11 env + authority ----------
$root = Test-IsRoot
$homeTarget = if ($root) { &quot;/home/$TargetUser&quot; } else { $HOME }
if (-not $env:DISPLAY) { $env:DISPLAY = &#39;:0&#39; }
if ($root) {
    $xaUser = &quot;/home/$TargetUser/.Xauthority&quot;
    if (Test-Path $xaUser) { $env:XAUTHORITY = $xaUser }
    elseif (Test-Path &#39;/root/.Xauthority&#39;) { $env:XAUTHORITY = &#39;/root/.Xauthority&#39; }
} elseif (-not $env:XAUTHORITY) {
    $env:XAUTHORITY = Join-Path $HOME &#39;.Xauthority&#39;
}

# Config path default
if (-not $ConfigPath -or [string]::IsNullOrWhiteSpace($ConfigPath)) {
    $ConfigPath = Join-Path (Join-Path $homeTarget &#39;.config&#39;) &#39;pwsh-monitor-layout.json&#39;
}

# ---------- Early exits ----------
if ($Help) { Show-Help; Stop-TranscriptSafe; exit 0 }

# ---------- xrandr helpers ----------
function Get-XrandrLines { (&amp; xrandr --query | Out-String) -split &quot;`n&quot; }

function Get-ConnectedOutputs {
    Get-XrandrLines | ForEach-Object {
        if ($_ -match &#39;^\s*(\S+)\s+connected&#39;) { $Matches[1] }
    }
}

function Sort-OutputsPreferred([string[]]$Outputs) {
    $order = @(&#39;HDMI&#39;,&#39;DP&#39;,&#39;DVI&#39;,&#39;VGA&#39;,&#39;eDP&#39;)
    $picked = [System.Collections.Generic.List[string]]::new()
    foreach ($p in $order) {
        $Outputs | Where-Object { $_ -like &quot;$p*&quot; } | ForEach-Object { [void]$picked.Add($_) }
    }
    $Outputs | Where-Object { $picked -notcontains $_ } | ForEach-Object { [void]$picked.Add($_) }
    $picked | Select-Object -Unique
}

function Get-OutputModes([string]$Output) {
    $lines = Get-XrandrLines
    $in = $false
    $modes = [System.Collections.Generic.List[string]]::new()
    foreach ($ln in $lines) {
        if (-not $in) {
            if ($ln -match &quot;^\s*$([Regex]::Escape($Output))\s+connected&quot;) { $in = $true; continue }
        } else {
            if ($ln -match &#39;^\S+\s+(connected|disconnected)&#39;) { break }
            if ($ln -match &#39;^\s+([0-9]{3,5}x[0-9]{3,5}\S*)&#39;) {
                $t = $Matches[1]
                if (-not $modes.Contains($t)) { [void]$modes.Add($t) }
            }
        }
    }
    if ($modes.Count -eq 0) { throw &quot;No modes parsed for $Output&quot; }
    return $modes.ToArray()
}

function Get-Size([string]$Token) {
    if ($Token -notmatch &#39;^(\d{3,5})x(\d{3,5})&#39;) { throw &quot;Invalid mode token: $Token&quot; }
    [pscustomobject]@{ W = [int]$Matches[1]; H = [int]$Matches[2] }
}

function Get-CurrentGeometry([string]$Output) {
    $pattern = &quot;^{0}\b&quot; -f [Regex]::Escape($Output)
    $ln = Get-XrandrLines | Where-Object { $_ -match $pattern } | Select-Object -First 1
    if (-not $ln) { return $null }
    $m = [regex]::Match($ln, &#39;(\d{3,5}x\d{3,5})\+(\d+)\+(\d+)&#39;)
    if (-not $m.Success) { return $null }
    $wxh = $m.Groups[1].Value
    $x = [int]$m.Groups[2].Value
    $y = [int]$m.Groups[3].Value
    $m2 = [regex]::Match($wxh, &#39;^(\d{3,5})x(\d{3,5})$&#39;)
    if (-not $m2.Success) { return $null }
    [pscustomobject]@{ W = [int]$m2.Groups[1].Value; H = [int]$m2.Groups[2].Value; X = $x; Y = $y }
}

function Invoke-Xrandr([string[]]$XRArgs) {
    $p = Start-Process -FilePath &#39;xrandr&#39; -ArgumentList $XRArgs -PassThru -NoNewWindow -Wait
    if ($DebugMode) { Write-Verbose (&quot;xrandr &quot; + ($XRArgs -join &#39; &#39;) + &quot; =&gt; &quot; + $p.ExitCode) }
    $p.ExitCode
}

function Apply-Layout([System.Collections.Specialized.OrderedDictionary]$Map) {
    $x = 0
    foreach ($o in $Map.Keys) {
        $tok = [string]$Map[$o]
        $code = Invoke-Xrandr @(&#39;--output&#39;, $o, &#39;--mode&#39;, $tok, &#39;--pos&#39;, (&quot;{0}x0&quot; -f $x), &#39;--rotate&#39;, &#39;normal&#39;)
        if ($code -ne 0) {
            Write-Warning (&quot;xrandr failed for {0} token {1} (exit {2})&quot; -f $o, $tok, $code)
            return $false
        }
        Start-Sleep -Milliseconds 120
        $sz = Get-Size $tok
        $x += $sz.W
    }
    Start-Sleep -Milliseconds 180
    return $true
}

function Verify-OutputGeometry([string]$Output, [string]$Token) {
    $want = Get-Size $Token
    $cur = Get-CurrentGeometry $Output
    if (-not $cur) {
        if ($DebugMode) { Write-Verbose &quot;Verify: no geometry for $Output&quot; }
        return $false
    }
    $ok = ($cur.W -eq $want.W -and $cur.H -eq $want.H)
    if ($DebugMode) {
        Write-Verbose (&quot;Verify: {0} current={1}x{2} vs want={3}x{4} =&gt; {5}&quot; -f $Output, $cur.W, $cur.H, $want.W, $want.H, $ok)
    }
    $ok
}

function Show-OverlayTk([int]$W,[int]$H,[int]$X,[int]$Y,[int]$Seconds) {
$py = @&#39;
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk()
root.overrideredirect(1)
root.attributes(&quot;-topmost&quot;, True)
root.geometry(f&quot;{w}x{h}+{x}+{y}&quot;)
t.Frame(root, width=w, height=h, highlightbackground=&quot;red&quot;, highlightthickness=8).pack()
root.after(sec*1000, root.destroy)
root.mainloop()
&#39;@
    $tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;
    [IO.File]::WriteAllText($tmp, $py)
    $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp, $W, $H, $X, $Y, $Seconds) -PassThru -NoNewWindow
    $timeout = [Math]::Max($Seconds + 3, 8)
    $exited = $true
    try { Wait-Process -Id $p.Id -Timeout $timeout } catch { $exited = $false }
    if (-not $exited) {
        try { Stop-Process -Id $p.Id -Force -ErrorAction SilentlyContinue } catch {}
        Write-Warning &#39;Overlay timeout; killed.&#39;
    }
    try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
}

function Prompt-YNQ([string]$Msg) {
    while ($true) {
        $r = Read-Host $Msg
        switch -Regex ($r) {
            &#39;^(?i)y$&#39; { return &#39;y&#39; }
            &#39;^(?i)n$&#39; { return &#39;n&#39; }
            &#39;^(?i)q$&#39; { return &#39;q&#39; }
            default   { Write-Host &#39;Please type y, n, or q.&#39; -ForegroundColor Yellow }
        }
    }
}

# ---------- Apply saved layout fast-path ----------
if ($ApplySavedLayout) {
    if (-not (Test-Path $ConfigPath)) {
        Write-Warning &quot;Config not found: $ConfigPath&quot;
        Stop-TranscriptSafe; exit 23
    }
    try {
        $raw = Get-Content -Raw -Path $ConfigPath
        $obj = $raw | ConvertFrom-Json
    } catch {
        Write-Error &quot;Failed to parse config JSON: $($_.Exception.Message)&quot;
        Stop-TranscriptSafe; exit 24
    }
    if (-not $obj) { Write-Error &#39;Empty/invalid configuration object.&#39;; Stop-TranscriptSafe; exit 22 }

    $orderedChosen = [System.Collections.Specialized.OrderedDictionary]::new()
    foreach ($p in $obj.PSObject.Properties) {
        $orderedChosen[$p.Name] = [string]$p.Value
    }

    if ($orderedChosen.Count -eq 0) { Write-Error &#39;No entries in configuration.&#39;; Stop-TranscriptSafe; exit 22 }

    if (-not (Apply-Layout $orderedChosen)) {
        Write-Warning &#39;Applying saved layout reported errors.&#39;
        Stop-TranscriptSafe; exit 1
    }

    $primary = $null; $maxA = -1
    foreach ($o in $orderedChosen.Keys) {
        $sz = Get-Size ([string]$orderedChosen[$o])
        $a  = $sz.W * $sz.H
        if ($a -gt $maxA) { $primary = $o; $maxA = $a }
    }
    $null = Invoke-Xrandr @(&#39;--output&#39;, $primary, &#39;--primary&#39;)

    $summary = [pscustomobject]@{
        ok         = $true
        mode       = &#39;apply-saved&#39;
        primary    = $primary
        order      = @($orderedChosen.Keys)
        chosen     = $orderedChosen
        configFile = $ConfigPath
    } | ConvertTo-Json -Compress
    Write-Output $summary
    Stop-TranscriptSafe; exit 0
}

# ---------- Probe outputs ----------
$outs = Get-ConnectedOutputs
if (-not $outs -or $outs.Count -eq 0) { Write-Error &#39;No connected monitors detected.&#39;; Stop-TranscriptSafe; exit 21 }

# ---------- Interactive ordering ----------
$orderedOuts = [System.Collections.Generic.List[string]]::new()
if ($outs.Count -gt 1) {
    $remaining = [System.Collections.Generic.List[string]]::new()
    $remaining.AddRange([string[]]$outs)
    Write-Host &quot;Multiple monitors detected: $($remaining -join &#39;, &#39;)&quot; -ForegroundColor Cyan
    while ($remaining.Count -gt 0) {
        if ($orderedOuts.Count -eq 0) {
            Write-Host &quot;Which monitor should be on the far left?&quot;
        } else {
            Write-Host &quot;Which monitor should be to the right of $($orderedOuts[-1])?&quot;
        }
        for ($i=0; $i -lt $remaining.Count; $i++) { Write-Host &quot;  [$($i+1)] $($remaining[$i])&quot; }
        $ans = Read-Host &quot;Enter number (1-$($remaining.Count))&quot;
        if (($ans -match &#39;^\d+$&#39;) -and ([int]$ans -ge 1) -and ([int]$ans -le $remaining.Count)) {
            $choiceIndex = [int]$ans - 1
            $orderedOuts.Add($remaining[$choiceIndex])
            $remaining.RemoveAt($choiceIndex)
        } else {
            Write-Warning &quot;Invalid selection.&quot;
        }
    }
} else {
    $orderedOuts.Add($outs[0])
}
Write-Host &quot;Final monitor order (left-to-right): $($orderedOuts -join &#39; -&gt; &#39;)&quot; -ForegroundColor Green

# ---------- Gather modes ----------
$All   = @{}
$First = @{}
foreach ($o in $orderedOuts) {
    $m = Get-OutputModes $o
    $All[$o] = $m
    $First[$o] = $m[0]
    if ($DebugMode) { Write-Verbose (&quot;Modes[{0}] (#{1}): {2}&quot; -f $o, $m.Count, ($m -join &#39; &#39;)) }
}

$Chosen = [System.Collections.Specialized.OrderedDictionary]::new()
foreach ($o in $orderedOuts) { $Chosen[$o] = $null }

# ---------- Per-output interactive selection ----------
foreach ($current in $orderedOuts) {
    Write-Host (&quot;======== Configuring {0} ========&quot; -f $current) -ForegroundColor Cyan
    $cands = @($All[$current])
    $accepted = $false

    for ($i = 0; $i -lt $cands.Count; $i++) {
        $tok = $cands[$i]
        Write-Host (&quot;---&gt; [{0}/{1}] Trying {2} for {3}&quot; -f ($i + 1), $cands.Count, $tok, $current) -ForegroundColor Green

        $proposal = [System.Collections.Specialized.OrderedDictionary]::new()
        foreach ($o in $orderedOuts) {
            if ($o -eq $current) { $proposal[$o] = $tok }
            else { $proposal[$o] = ($Chosen[$o] ?? $First[$o]) }
        }

        if (-not (Apply-Layout $proposal)) { Write-Warning (&quot;Skip {0}: xrandr exit!=0&quot; -f $tok); continue }
        if (-not (Verify-OutputGeometry $current $tok)) { Write-Warning (&quot;Skip {0}: geometry mismatch&quot; -f $tok); continue }

        $xoff = 0
        foreach ($o in $orderedOuts) {
            if ($o -eq $current) { break }
            $sz = Get-Size ([string]$proposal[$o])
            $xoff += $sz.W
        }
        $szC = Get-Size $tok
        Show-OverlayTk -W $szC.W -H $szC.H -X $xoff -Y 0 -Seconds $OverlaySeconds

        $ans = Prompt-YNQ (&quot;Was the red rectangle fully enclosed on {0} at {1}? [y=accept / n=next / q=quit]&quot; -f $current, $tok)
        if ($ans -eq &#39;y&#39;) { $Chosen[$current] = $tok; $accepted = $true; break }
        if ($ans -eq &#39;q&#39;) { Write-Warning &#39;User aborted.&#39;; Stop-TranscriptSafe; exit 1 }
    }

    if (-not $accepted) {
        $fb = $First[$current]
        Write-Warning (&quot;No accepted mode for {0}. Falling back to {1}&quot; -f $current, $fb)
        $Chosen[$current] = $fb
    }
}

# ---------- Final apply ----------
Write-Host &quot;Final configuration selected. Applying...&quot; -ForegroundColor Cyan
if (-not (Apply-Layout $Chosen)) {
    Write-Warning &#39;Final layout application reported errors.&#39;
    Stop-TranscriptSafe; exit 1
}

# choose primary as largest area
$primary = $null; $maxA = -1
foreach ($o in $orderedOuts) {
    $sz = Get-Size ([string]$Chosen[$o])
    $a  = $sz.W * $sz.H
    if ($a -gt $maxA) { $primary = $o; $maxA = $a }
}
$null = Invoke-Xrandr @(&#39;--output&#39;, $primary, &#39;--primary&#39;)

# ---------- Save config + autostart ----------
try {
    $configDir = Split-Path -Parent $ConfigPath
    if (-not (Test-Path $configDir)) {
        if ($root) { &amp; sudo -u $TargetUser mkdir -p -- $configDir }
        else       { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
    }

    $tmpChosen = [ordered]@{}
    foreach ($k in $Chosen.Keys) { $tmpChosen[$k] = [string]$Chosen[$k] }
    ($tmpChosen | ConvertTo-Json) | Set-Content -Path $ConfigPath -Encoding UTF8
    if ($root) { &amp; chown &quot;${TargetUser}:${TargetUser}&quot; $ConfigPath }
    Write-Host &quot;[INFO] Configuration saved to $ConfigPath&quot; -ForegroundColor DarkCyan

    $autoDir = Join-Path $homeTarget &#39;.config/autostart&#39;
    if (-not (Test-Path $autoDir)) {
        if ($root) { &amp; sudo -u $TargetUser mkdir -p -- $autoDir }
        else       { New-Item -ItemType Directory -Path $autoDir -Force | Out-Null }
    }
    if (-not (Test-Path $ScriptInstallPath)) {
        $src = $PSCommandPath; if (-not $src) { $src = $MyInvocation.MyCommand.Path }
        Copy-Item -Path $src -Destination $ScriptInstallPath -Force
        if ($root) { &amp; chown &quot;${TargetUser}:${TargetUser}&quot; $ScriptInstallPath }
        &amp; chmod +x $ScriptInstallPath
    }
    $desktopFile = Join-Path $autoDir &#39;pwsh_monitor_working.desktop&#39;
    $execLine = &quot;pwsh -File $ScriptInstallPath -ApplySavedLayout -ConfigPath `&quot;$ConfigPath`&quot;&quot;
@&quot;
[Desktop Entry]
Type=Application
Exec=$execLine
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name=PwshAutoMonitor
Comment=Autoconfigure monitors layout (pwsh)
&quot;@ | Set-Content -Path $desktopFile -Encoding UTF8 -NoNewline
    if ($root) { &amp; chown &quot;${TargetUser}:${TargetUser}&quot; $desktopFile }
    &amp; chmod 0644 $desktopFile
    Write-Host (&quot;[INFO] Autostart installed at {0} for user {1}&quot; -f $desktopFile, $TargetUser) -ForegroundColor DarkCyan
} catch {
    Write-Warning (&quot;Autostart/config setup issue: {0}&quot; -f $_.Exception.Message)
}

# ---------- Success summary (single-line JSON) ----------
$summary2 = [pscustomobject]@{
    ok         = $true
    mode       = &#39;interactive&#39;
    primary    = $primary
    order      = @($orderedOuts)
    chosen     = $Chosen
    configFile = $ConfigPath
} | ConvertTo-Json -Compress
Write-Output $summary2

Stop-TranscriptSafe
exit 0" data-download-link="" data-download-label="Download Bash">
  <code class="language-bash">#!/usr/bin/env pwsh
&lt;# 
pwsh_monitor_working.ps1 ‚Äî Interactive + non-interactive multi-monitor configurator for X11 (Linux)

TARGET: Debian/Ubuntu/Derivatives, Fedora/RHEL/CentOS, openSUSE, Arch-based (pwsh, xrandr)
WM/TERM agnostic (works with ratpoison/Alacritty etc.)

KEY CAPABILITIES
- Interactive discovery of output order (left‚Üíright) and resolution selection per monitor using xrandr.
- Verifies applied geometry; shows a Tk red-border overlay to confirm the active monitor.
- Saves chosen layout to JSON and can re-apply non-interactively on login/autostart.
- Robust logging (Start-Transcript), strict error behavior, and explicit exit codes.

NEW/REQUESTED IMPROVEMENTS
- -ConfigPath &lt;file&gt; to override default config path (default: ~/.config/pwsh-monitor-layout.json).
- -Help: Prints usage, options, examples, and exit codes then exits 0.
- Emits a one-line machine-parseable JSON summary on success for both interactive and apply-saved paths.
- Portability hardening: auto-install gated by distro/pm detection (apt-get/dnf/zypper/pacman).
- -NoInstall: disable auto-install; fail fast if dependencies missing.
- Headless handling: detect missing X11/xrandr availability and exit with explicit code.

USAGE (examples)
  # First run (interactive):
  pwsh -File ./pwsh_monitor_working.ps1

  # Auto-install missing deps (root required):
  sudo pwsh -File ./pwsh_monitor_working.ps1 -AutoInstall

  # Save config to a specific path:
  pwsh -File ./pwsh_monitor_working.ps1 -ConfigPath &quot;$HOME/.config/my-monitor-layout.json&quot;

  # Non-interactive apply of saved layout (good for autostart):
  pwsh -File ./pwsh_monitor_working.ps1 -ApplySavedLayout

  # Print help:
  pwsh -File ./pwsh_monitor_working.ps1 -Help

OPTIONS
  -DebugMode             Verbose logging during execution.
  -AutoInstall           Attempt to install dependencies via detected package manager.
  -NoInstall             Do not install; fail fast if dependencies are missing.
  -ApplySavedLayout      Apply saved layout from the config JSON and exit.
  -OverlaySeconds &lt;int&gt;  Seconds to keep the red overlay visible when testing (default: 5).
  -TargetUser &lt;string&gt;   Login user for ownership of autostart/config when run as root (default: SUDO_USER/USER/linaro).
  -ScriptInstallPath     Path to place a self-copy used by autostart (default: $HOME/pwsh_monitor_working.ps1).
  -ConfigPath            Override config JSON path (default: $HOME/.config/pwsh-monitor-layout.json).
  -Help                  Show this help and exit.

EXIT CODES
  0  Success
  1  General error / user abort / final apply failed
  2  Missing dependency and -NoInstall provided (or auto-install disabled/unsupported)
 20  Headless / no X11 session detected (no DISPLAY or xrandr unusable)
 21  No connected monitors detected
 22  Invalid/empty configuration when using -ApplySavedLayout
 23  Config file not found for -ApplySavedLayout
 24  JSON parse error for -ConfigPath
 25  Permission or ownership errors during autostart/config setup

MACHINE-PARSABLE SUMMARY
  On success, prints a single line JSON to stdout like:
  {&quot;ok&quot;:true,&quot;mode&quot;:&quot;interactive&quot;,&quot;primary&quot;:&quot;HDMI-1&quot;,&quot;order&quot;:[&quot;HDMI-1&quot;,&quot;DP-1&quot;],&quot;chosen&quot;:{&quot;HDMI-1&quot;:&quot;1920x1080&quot;,&quot;DP-1&quot;:&quot;2560x1440&quot;},&quot;configFile&quot;:&quot;/home/user/.config/pwsh-monitor-layout.json&quot;}

#&gt;

[CmdletBinding()]
param(
    [switch] $DebugMode,
    [switch] $AutoInstall,
    [switch] $NoInstall,
    [switch] $ApplySavedLayout,
    [switch] $Help,
    [int]    $OverlaySeconds = 5,
    [string] $TargetUser = ($env:SUDO_USER ?? $env:USER ?? &#39;linaro&#39;),
    [string] $ScriptInstallPath = &quot;$HOME/pwsh_monitor_working.ps1&quot;,
    [string] $ConfigPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = &#39;Stop&#39;
if ($DebugMode) { $VerbosePreference = &#39;Continue&#39; }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }

# Transcript
$tsFile = &quot;/tmp/pwsh_monitor_working-$(Get-Date -Format &#39;yyyyMMdd-HHmmss&#39;).log&quot;
try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {
    $tsFile = Join-Path $HOME &quot;pwsh_monitor_working-$(Get-Date -Format &#39;yyyyMMdd-HHmmss&#39;).log&quot;
    try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {}
}
Write-Verbose &quot;Transcript: $tsFile&quot;

# ---------- Helpers ----------
function Show-Help {
    $path = $PSCommandPath
    if (-not $path) { $path = $MyInvocation.MyCommand.Path }
    $content = Get-Content -Raw -Path $path
    $helpBlock = [regex]::Match($content, &#39;(?s)&lt;#\s*(.*?)\s*#&gt;&#39;).Groups[1].Value
    if ([string]::IsNullOrWhiteSpace($helpBlock)) {
        Write-Output &quot;Usage: pwsh -File $path [-AutoInstall|-NoInstall] [-ApplySavedLayout] [-ConfigPath &lt;file&gt;] [-OverlaySeconds &lt;int&gt;] [-DebugMode] [-Help]&quot;
    } else {
        Write-Output $helpBlock.Trim()
    }
}

function Test-Cmd([string]$Name) { $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue) }

function Test-IsRoot {
    try { ((&amp; id &#39;-u&#39; 2&gt;$null) -eq 0) } catch {
        try { ((&amp; whoami) -eq &#39;root&#39;) } catch { ($env:USER -eq &#39;root&#39;) }
    }
}

function Detect-PackageManager {
    if (Test-Cmd &#39;apt-get&#39;) { return &#39;apt&#39; }
    if (Test-Cmd &#39;dnf&#39;)     { return &#39;dnf&#39; }
    if (Test-Cmd &#39;zypper&#39;)  { return &#39;zypper&#39; }
    if (Test-Cmd &#39;pacman&#39;)  { return &#39;pacman&#39; }
    return $null
}

function Install-Dep([string]$pkg) {
    $pm = Detect-PackageManager
    if (-not $pm) { throw &#39;No supported package manager found.&#39; }
    if (-not (Test-IsRoot)) { throw &#39;Auto-install requires root.&#39; }

    switch ($pm) {
        &#39;apt&#39;    { &amp; apt-get update -y; &amp; apt-get install -y $pkg }
        &#39;dnf&#39;    { &amp; dnf install -y $pkg }
        &#39;zypper&#39; { &amp; zypper -n install -y $pkg }
        &#39;pacman&#39; { &amp; pacman -Sy --noconfirm $pkg }
    }
}

function Ensure-Dep([string]$cmd, [string]$pkg, [string]$friendly) {
    if (Test-Cmd $cmd) { return }
    if ($NoInstall) { throw &quot;Missing dependency &#39;$friendly&#39; and -NoInstall was specified.&quot; }
    if (-not $AutoInstall) { throw &quot;Missing dependency &#39;$friendly&#39;. Rerun with -AutoInstall or install &#39;$pkg&#39; manually.&quot; }
    Install-Dep $pkg
    if (-not (Test-Cmd $cmd)) { throw &quot;Dependency &#39;$friendly&#39; not available after install.&quot; }
}

function Test-PythonTk {
@&#39;
import sys
try:
    import tkinter as t
    root = t.Tk()
    root.withdraw()
    print(&quot;OK&quot;)
except Exception as e:
    print(&quot;ERR&quot;, e)
    sys.exit(1)
&#39;@ | Set-Content -Path ($tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;) -Encoding UTF8
    try {
        $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp) -PassThru -NoNewWindow -Wait
        return ($p.ExitCode -eq 0)
    } finally {
        try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
    }
}

function Assert-XSessionOrExit {
    if (-not $env:DISPLAY) { $env:DISPLAY = &#39;:0&#39; }
    for ($i=0; $i -lt 6; $i++) {
        try { &amp; xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
    }
    Write-Error &#39;No X11 display/xrandr available (headless or X not running).&#39;
    Stop-TranscriptSafe; exit 20
}

# ---------- Dependency checks ----------
try {
    Ensure-Dep &#39;xrandr&#39;  &#39;x11-xserver-utils&#39; &#39;xrandr&#39;
    Ensure-Dep &#39;python3&#39; &#39;python3&#39;           &#39;python3&#39;
} catch {
    Write-Error $_.Exception.Message
    Stop-TranscriptSafe; exit 2
}

# ---------- X11 availability ----------
Assert-XSessionOrExit

# tkinter (package name differs by distro)
if (-not (Test-PythonTk)) {
    try {
        $pm = Detect-PackageManager
        switch ($pm) {
            &#39;apt&#39;    { Install-Dep &#39;python3-tk&#39; }
            &#39;dnf&#39;    { Install-Dep &#39;python3-tkinter&#39; }
            &#39;zypper&#39; { Install-Dep &#39;python3-tk&#39; }
            &#39;pacman&#39; { Install-Dep &#39;tk&#39; }
            default  { throw &#39;Unsupported package manager for tkinter.&#39; }
        }
    } catch {
        Write-Error &quot;Unable to install/verify tkinter: $($_.Exception.Message)&quot;
        Stop-TranscriptSafe; exit 2
    }
    if (-not (Test-PythonTk)) {
        Write-Error &#39;python3-tk/tkinter not available after installation.&#39;
        Stop-TranscriptSafe; exit 2
    }
}

# ---------- X11 env + authority ----------
$root = Test-IsRoot
$homeTarget = if ($root) { &quot;/home/$TargetUser&quot; } else { $HOME }
if (-not $env:DISPLAY) { $env:DISPLAY = &#39;:0&#39; }
if ($root) {
    $xaUser = &quot;/home/$TargetUser/.Xauthority&quot;
    if (Test-Path $xaUser) { $env:XAUTHORITY = $xaUser }
    elseif (Test-Path &#39;/root/.Xauthority&#39;) { $env:XAUTHORITY = &#39;/root/.Xauthority&#39; }
} elseif (-not $env:XAUTHORITY) {
    $env:XAUTHORITY = Join-Path $HOME &#39;.Xauthority&#39;
}

# Config path default
if (-not $ConfigPath -or [string]::IsNullOrWhiteSpace($ConfigPath)) {
    $ConfigPath = Join-Path (Join-Path $homeTarget &#39;.config&#39;) &#39;pwsh-monitor-layout.json&#39;
}

# ---------- Early exits ----------
if ($Help) { Show-Help; Stop-TranscriptSafe; exit 0 }

# ---------- xrandr helpers ----------
function Get-XrandrLines { (&amp; xrandr --query | Out-String) -split &quot;`n&quot; }

function Get-ConnectedOutputs {
    Get-XrandrLines | ForEach-Object {
        if ($_ -match &#39;^\s*(\S+)\s+connected&#39;) { $Matches[1] }
    }
}

function Sort-OutputsPreferred([string[]]$Outputs) {
    $order = @(&#39;HDMI&#39;,&#39;DP&#39;,&#39;DVI&#39;,&#39;VGA&#39;,&#39;eDP&#39;)
    $picked = [System.Collections.Generic.List[string]]::new()
    foreach ($p in $order) {
        $Outputs | Where-Object { $_ -like &quot;$p*&quot; } | ForEach-Object { [void]$picked.Add($_) }
    }
    $Outputs | Where-Object { $picked -notcontains $_ } | ForEach-Object { [void]$picked.Add($_) }
    $picked | Select-Object -Unique
}

function Get-OutputModes([string]$Output) {
    $lines = Get-XrandrLines
    $in = $false
    $modes = [System.Collections.Generic.List[string]]::new()
    foreach ($ln in $lines) {
        if (-not $in) {
            if ($ln -match &quot;^\s*$([Regex]::Escape($Output))\s+connected&quot;) { $in = $true; continue }
        } else {
            if ($ln -match &#39;^\S+\s+(connected|disconnected)&#39;) { break }
            if ($ln -match &#39;^\s+([0-9]{3,5}x[0-9]{3,5}\S*)&#39;) {
                $t = $Matches[1]
                if (-not $modes.Contains($t)) { [void]$modes.Add($t) }
            }
        }
    }
    if ($modes.Count -eq 0) { throw &quot;No modes parsed for $Output&quot; }
    return $modes.ToArray()
}

function Get-Size([string]$Token) {
    if ($Token -notmatch &#39;^(\d{3,5})x(\d{3,5})&#39;) { throw &quot;Invalid mode token: $Token&quot; }
    [pscustomobject]@{ W = [int]$Matches[1]; H = [int]$Matches[2] }
}

function Get-CurrentGeometry([string]$Output) {
    $pattern = &quot;^{0}\b&quot; -f [Regex]::Escape($Output)
    $ln = Get-XrandrLines | Where-Object { $_ -match $pattern } | Select-Object -First 1
    if (-not $ln) { return $null }
    $m = [regex]::Match($ln, &#39;(\d{3,5}x\d{3,5})\+(\d+)\+(\d+)&#39;)
    if (-not $m.Success) { return $null }
    $wxh = $m.Groups[1].Value
    $x = [int]$m.Groups[2].Value
    $y = [int]$m.Groups[3].Value
    $m2 = [regex]::Match($wxh, &#39;^(\d{3,5})x(\d{3,5})$&#39;)
    if (-not $m2.Success) { return $null }
    [pscustomobject]@{ W = [int]$m2.Groups[1].Value; H = [int]$m2.Groups[2].Value; X = $x; Y = $y }
}

function Invoke-Xrandr([string[]]$XRArgs) {
    $p = Start-Process -FilePath &#39;xrandr&#39; -ArgumentList $XRArgs -PassThru -NoNewWindow -Wait
    if ($DebugMode) { Write-Verbose (&quot;xrandr &quot; + ($XRArgs -join &#39; &#39;) + &quot; =&gt; &quot; + $p.ExitCode) }
    $p.ExitCode
}

function Apply-Layout([System.Collections.Specialized.OrderedDictionary]$Map) {
    $x = 0
    foreach ($o in $Map.Keys) {
        $tok = [string]$Map[$o]
        $code = Invoke-Xrandr @(&#39;--output&#39;, $o, &#39;--mode&#39;, $tok, &#39;--pos&#39;, (&quot;{0}x0&quot; -f $x), &#39;--rotate&#39;, &#39;normal&#39;)
        if ($code -ne 0) {
            Write-Warning (&quot;xrandr failed for {0} token {1} (exit {2})&quot; -f $o, $tok, $code)
            return $false
        }
        Start-Sleep -Milliseconds 120
        $sz = Get-Size $tok
        $x += $sz.W
    }
    Start-Sleep -Milliseconds 180
    return $true
}

function Verify-OutputGeometry([string]$Output, [string]$Token) {
    $want = Get-Size $Token
    $cur = Get-CurrentGeometry $Output
    if (-not $cur) {
        if ($DebugMode) { Write-Verbose &quot;Verify: no geometry for $Output&quot; }
        return $false
    }
    $ok = ($cur.W -eq $want.W -and $cur.H -eq $want.H)
    if ($DebugMode) {
        Write-Verbose (&quot;Verify: {0} current={1}x{2} vs want={3}x{4} =&gt; {5}&quot; -f $Output, $cur.W, $cur.H, $want.W, $want.H, $ok)
    }
    $ok
}

function Show-OverlayTk([int]$W,[int]$H,[int]$X,[int]$Y,[int]$Seconds) {
$py = @&#39;
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk()
root.overrideredirect(1)
root.attributes(&quot;-topmost&quot;, True)
root.geometry(f&quot;{w}x{h}+{x}+{y}&quot;)
t.Frame(root, width=w, height=h, highlightbackground=&quot;red&quot;, highlightthickness=8).pack()
root.after(sec*1000, root.destroy)
root.mainloop()
&#39;@
    $tmp = [IO.Path]::GetTempFileName() + &#39;.py&#39;
    [IO.File]::WriteAllText($tmp, $py)
    $p = Start-Process -FilePath &#39;python3&#39; -ArgumentList @($tmp, $W, $H, $X, $Y, $Seconds) -PassThru -NoNewWindow
    $timeout = [Math]::Max($Seconds + 3, 8)
    $exited = $true
    try { Wait-Process -Id $p.Id -Timeout $timeout } catch { $exited = $false }
    if (-not $exited) {
        try { Stop-Process -Id $p.Id -Force -ErrorAction SilentlyContinue } catch {}
        Write-Warning &#39;Overlay timeout; killed.&#39;
    }
    try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
}

function Prompt-YNQ([string]$Msg) {
    while ($true) {
        $r = Read-Host $Msg
        switch -Regex ($r) {
            &#39;^(?i)y$&#39; { return &#39;y&#39; }
            &#39;^(?i)n$&#39; { return &#39;n&#39; }
            &#39;^(?i)q$&#39; { return &#39;q&#39; }
            default   { Write-Host &#39;Please type y, n, or q.&#39; -ForegroundColor Yellow }
        }
    }
}

# ---------- Apply saved layout fast-path ----------
if ($ApplySavedLayout) {
    if (-not (Test-Path $ConfigPath)) {
        Write-Warning &quot;Config not found: $ConfigPath&quot;
        Stop-TranscriptSafe; exit 23
    }
    try {
        $raw = Get-Content -Raw -Path $ConfigPath
        $obj = $raw | ConvertFrom-Json
    } catch {
        Write-Error &quot;Failed to parse config JSON: $($_.Exception.Message)&quot;
        Stop-TranscriptSafe; exit 24
    }
    if (-not $obj) { Write-Error &#39;Empty/invalid configuration object.&#39;; Stop-TranscriptSafe; exit 22 }

    $orderedChosen = [System.Collections.Specialized.OrderedDictionary]::new()
    foreach ($p in $obj.PSObject.Properties) {
        $orderedChosen[$p.Name] = [string]$p.Value
    }

    if ($orderedChosen.Count -eq 0) { Write-Error &#39;No entries in configuration.&#39;; Stop-TranscriptSafe; exit 22 }

    if (-not (Apply-Layout $orderedChosen)) {
        Write-Warning &#39;Applying saved layout reported errors.&#39;
        Stop-TranscriptSafe; exit 1
    }

    $primary = $null; $maxA = -1
    foreach ($o in $orderedChosen.Keys) {
        $sz = Get-Size ([string]$orderedChosen[$o])
        $a  = $sz.W * $sz.H
        if ($a -gt $maxA) { $primary = $o; $maxA = $a }
    }
    $null = Invoke-Xrandr @(&#39;--output&#39;, $primary, &#39;--primary&#39;)

    $summary = [pscustomobject]@{
        ok         = $true
        mode       = &#39;apply-saved&#39;
        primary    = $primary
        order      = @($orderedChosen.Keys)
        chosen     = $orderedChosen
        configFile = $ConfigPath
    } | ConvertTo-Json -Compress
    Write-Output $summary
    Stop-TranscriptSafe; exit 0
}

# ---------- Probe outputs ----------
$outs = Get-ConnectedOutputs
if (-not $outs -or $outs.Count -eq 0) { Write-Error &#39;No connected monitors detected.&#39;; Stop-TranscriptSafe; exit 21 }

# ---------- Interactive ordering ----------
$orderedOuts = [System.Collections.Generic.List[string]]::new()
if ($outs.Count -gt 1) {
    $remaining = [System.Collections.Generic.List[string]]::new()
    $remaining.AddRange([string[]]$outs)
    Write-Host &quot;Multiple monitors detected: $($remaining -join &#39;, &#39;)&quot; -ForegroundColor Cyan
    while ($remaining.Count -gt 0) {
        if ($orderedOuts.Count -eq 0) {
            Write-Host &quot;Which monitor should be on the far left?&quot;
        } else {
            Write-Host &quot;Which monitor should be to the right of $($orderedOuts[-1])?&quot;
        }
        for ($i=0; $i -lt $remaining.Count; $i++) { Write-Host &quot;  [$($i+1)] $($remaining[$i])&quot; }
        $ans = Read-Host &quot;Enter number (1-$($remaining.Count))&quot;
        if (($ans -match &#39;^\d+$&#39;) -and ([int]$ans -ge 1) -and ([int]$ans -le $remaining.Count)) {
            $choiceIndex = [int]$ans - 1
            $orderedOuts.Add($remaining[$choiceIndex])
            $remaining.RemoveAt($choiceIndex)
        } else {
            Write-Warning &quot;Invalid selection.&quot;
        }
    }
} else {
    $orderedOuts.Add($outs[0])
}
Write-Host &quot;Final monitor order (left-to-right): $($orderedOuts -join &#39; -&gt; &#39;)&quot; -ForegroundColor Green

# ---------- Gather modes ----------
$All   = @{}
$First = @{}
foreach ($o in $orderedOuts) {
    $m = Get-OutputModes $o
    $All[$o] = $m
    $First[$o] = $m[0]
    if ($DebugMode) { Write-Verbose (&quot;Modes[{0}] (#{1}): {2}&quot; -f $o, $m.Count, ($m -join &#39; &#39;)) }
}

$Chosen = [System.Collections.Specialized.OrderedDictionary]::new()
foreach ($o in $orderedOuts) { $Chosen[$o] = $null }

# ---------- Per-output interactive selection ----------
foreach ($current in $orderedOuts) {
    Write-Host (&quot;======== Configuring {0} ========&quot; -f $current) -ForegroundColor Cyan
    $cands = @($All[$current])
    $accepted = $false

    for ($i = 0; $i -lt $cands.Count; $i++) {
        $tok = $cands[$i]
        Write-Host (&quot;---&gt; [{0}/{1}] Trying {2} for {3}&quot; -f ($i + 1), $cands.Count, $tok, $current) -ForegroundColor Green

        $proposal = [System.Collections.Specialized.OrderedDictionary]::new()
        foreach ($o in $orderedOuts) {
            if ($o -eq $current) { $proposal[$o] = $tok }
            else { $proposal[$o] = ($Chosen[$o] ?? $First[$o]) }
        }

        if (-not (Apply-Layout $proposal)) { Write-Warning (&quot;Skip {0}: xrandr exit!=0&quot; -f $tok); continue }
        if (-not (Verify-OutputGeometry $current $tok)) { Write-Warning (&quot;Skip {0}: geometry mismatch&quot; -f $tok); continue }

        $xoff = 0
        foreach ($o in $orderedOuts) {
            if ($o -eq $current) { break }
            $sz = Get-Size ([string]$proposal[$o])
            $xoff += $sz.W
        }
        $szC = Get-Size $tok
        Show-OverlayTk -W $szC.W -H $szC.H -X $xoff -Y 0 -Seconds $OverlaySeconds

        $ans = Prompt-YNQ (&quot;Was the red rectangle fully enclosed on {0} at {1}? [y=accept / n=next / q=quit]&quot; -f $current, $tok)
        if ($ans -eq &#39;y&#39;) { $Chosen[$current] = $tok; $accepted = $true; break }
        if ($ans -eq &#39;q&#39;) { Write-Warning &#39;User aborted.&#39;; Stop-TranscriptSafe; exit 1 }
    }

    if (-not $accepted) {
        $fb = $First[$current]
        Write-Warning (&quot;No accepted mode for {0}. Falling back to {1}&quot; -f $current, $fb)
        $Chosen[$current] = $fb
    }
}

# ---------- Final apply ----------
Write-Host &quot;Final configuration selected. Applying...&quot; -ForegroundColor Cyan
if (-not (Apply-Layout $Chosen)) {
    Write-Warning &#39;Final layout application reported errors.&#39;
    Stop-TranscriptSafe; exit 1
}

# choose primary as largest area
$primary = $null; $maxA = -1
foreach ($o in $orderedOuts) {
    $sz = Get-Size ([string]$Chosen[$o])
    $a  = $sz.W * $sz.H
    if ($a -gt $maxA) { $primary = $o; $maxA = $a }
}
$null = Invoke-Xrandr @(&#39;--output&#39;, $primary, &#39;--primary&#39;)

# ---------- Save config + autostart ----------
try {
    $configDir = Split-Path -Parent $ConfigPath
    if (-not (Test-Path $configDir)) {
        if ($root) { &amp; sudo -u $TargetUser mkdir -p -- $configDir }
        else       { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
    }

    $tmpChosen = [ordered]@{}
    foreach ($k in $Chosen.Keys) { $tmpChosen[$k] = [string]$Chosen[$k] }
    ($tmpChosen | ConvertTo-Json) | Set-Content -Path $ConfigPath -Encoding UTF8
    if ($root) { &amp; chown &quot;${TargetUser}:${TargetUser}&quot; $ConfigPath }
    Write-Host &quot;[INFO] Configuration saved to $ConfigPath&quot; -ForegroundColor DarkCyan

    $autoDir = Join-Path $homeTarget &#39;.config/autostart&#39;
    if (-not (Test-Path $autoDir)) {
        if ($root) { &amp; sudo -u $TargetUser mkdir -p -- $autoDir }
        else       { New-Item -ItemType Directory -Path $autoDir -Force | Out-Null }
    }
    if (-not (Test-Path $ScriptInstallPath)) {
        $src = $PSCommandPath; if (-not $src) { $src = $MyInvocation.MyCommand.Path }
        Copy-Item -Path $src -Destination $ScriptInstallPath -Force
        if ($root) { &amp; chown &quot;${TargetUser}:${TargetUser}&quot; $ScriptInstallPath }
        &amp; chmod +x $ScriptInstallPath
    }
    $desktopFile = Join-Path $autoDir &#39;pwsh_monitor_working.desktop&#39;
    $execLine = &quot;pwsh -File $ScriptInstallPath -ApplySavedLayout -ConfigPath `&quot;$ConfigPath`&quot;&quot;
@&quot;
[Desktop Entry]
Type=Application
Exec=$execLine
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name=PwshAutoMonitor
Comment=Autoconfigure monitors layout (pwsh)
&quot;@ | Set-Content -Path $desktopFile -Encoding UTF8 -NoNewline
    if ($root) { &amp; chown &quot;${TargetUser}:${TargetUser}&quot; $desktopFile }
    &amp; chmod 0644 $desktopFile
    Write-Host (&quot;[INFO] Autostart installed at {0} for user {1}&quot; -f $desktopFile, $TargetUser) -ForegroundColor DarkCyan
} catch {
    Write-Warning (&quot;Autostart/config setup issue: {0}&quot; -f $_.Exception.Message)
}

# ---------- Success summary (single-line JSON) ----------
$summary2 = [pscustomobject]@{
    ok         = $true
    mode       = &#39;interactive&#39;
    primary    = $primary
    order      = @($orderedOuts)
    chosen     = $Chosen
    configFile = $ConfigPath
} | ConvertTo-Json -Compress
Write-Output $summary2

Stop-TranscriptSafe
exit 0</code>
</section>]]></content><author><name></name></author><category term="scratchpad" /></entry><entry><title type="html">b3 - SELL</title><link href="https://ib.bsb.br/b3-sell/" rel="alternate" type="text/html" title="b3 - SELL" /><published>2025-10-06T00:00:00+00:00</published><updated>2025-10-06T20:42:20+00:00</updated><id>https://ib.bsb.br/b3-sell</id><content type="html" xml:base="https://ib.bsb.br/b3-sell/"><![CDATA[<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>You are an AI portfolio sell-scenario planner for B3/BOVESPA. Operate deterministically, never fabricate data, and always respond in Portuguese (pt-BR). Timezone: America/Sao_Paulo.

GOAL
- Receber entradas m√≠nimas do usu√°rio e gerar DOIS cen√°rios de venda que, cada um, somem ‚â• target_brl em receita bruta:
  A) ‚ÄúRealizar lucros‚Äù: prioriza a√ß√µes que foram simultaneamente fortes em 30d e 12m.
  B) ‚ÄúCortar perdas‚Äù: prioriza a√ß√µes que foram simultaneamente fracas em 30d e 12m.
- Vender apenas quantidades INTEIRAS, sem venda a descoberto, ignorando taxas/IR por padr√£o.

INTERA√á√ÉO (UMA √öNICA SOLICITA√á√ÉO DE ENTRADA, SE NECESS√ÅRIO)
- Se as entradas ainda n√£o foram fornecidas, solicitar exatamente uma vez, aceitando UM dos formatos:
  JSON:
  {
    "positions": [
      {"ticker": "PETR4", "quantity": 200},
      {"ticker": "VALE3", "quantity": 50}
    ],
    "target_brl": 5000.00
  }
  CSV (e target_brl separado):
  ticker,quantity
  PETR4,200
  VALE3,50
  target_brl=5000.00

ENTRADAS V√ÅLIDAS
- positions: lista de objetos com ticker (B3) e quantity (inteiro ‚â• 0).
- target_brl: n√∫mero &gt; 0 em BRL.

COLETA DE DADOS (ONLINE, SEM INVENTAR N√öMEROS)
- Prefer√™ncia: https://www.fundamentus.com.br
- Alternativas confi√°veis se a prefer√™ncia estiver indispon√≠vel: site da B3 e portais financeiros reconhecidos.
- Para CADA ticker:
  - Obter: pre√ßo atual (BRL), varia√ß√£o 30 dias (%), varia√ß√£o 12 meses (%).
  - Registrar em metadata por ticker:
    - source_url: URL exata consultada
    - fetched_at: data/hora de coleta (America/Sao_Paulo)
    - metrics_available: quais m√©tricas foram obtidas (pre√ßo, 30d, 12m)
- Se um ticker n√£o for encontrado, estiver suspenso ou sem pre√ßo (&gt; 0), reportar e exclu√≠-lo dos rankings; ainda assim tentar atender o alvo com os demais.

PR√â-C√ÅLCULO
- Para cada ticker i:
  - ret_30d[i], ret_12m[i], price[i] (BRL), qty[i] (int)
  - position_value[i] = price[i] * qty[i]
  - Validar price[i] &gt; 0 e qty[i] ‚â• 0.

FALTA DE M√âTRICAS
- Se faltar apenas uma m√©trica (30d OU 12m): usar a m√©trica dispon√≠vel; desempate por position_value (desc).
- Se faltarem ambas (30d E 12m) para um ticker: exclu√≠-lo do ranking combinado; poder√° entrar ao final, apenas como recurso, se necess√°rio para atingir o alvo (com nota de limita√ß√£o).
- Se todas as a√ß√µes estiverem sem m√©tricas de desempenho, reportar impossibilidade de aplicar o crit√©rio ‚Äúduplo‚Äù e oferecer alternativa baseada apenas em pre√ßo/valor de posi√ß√£o (sujeito a confirma√ß√£o do usu√°rio).

CEN√ÅRIO A ‚Äî REALIZAR LUCROS (FORTES EM 30D E 12M)
- Ranking combinado (50/50):
  - rank30 = rank(desc, ret_30d)
  - rank12 = rank(desc, ret_12m)
  - score_A = rank30 + rank12
  - Ordena√ß√£o: score_A asc; desempates (nesta ordem):
    1) maior position_value
    2) maior price_brl
    3) ticker em ordem alfab√©tica asc
- Sele√ß√£o (gananciosa com inteiros):
  - remaining = target_brl
  - Para cada ticker na ordem:
    - need = ceil(remaining / price)
    - sell = min(need, qty)
    - Se sell &lt;= 0, pular
    - revenue += sell * price; remaining -= sell * price
    - Parar assim que remaining &lt;= 0 (n√£o vender al√©m do necess√°rio)

CEN√ÅRIO B ‚Äî CORTAR PERDAS (FRACOS EM 30D E 12M)
- Ranking combinado (50/50):
  - rank30w = rank(asc, ret_30d)
  - rank12w = rank(asc, ret_12m)
  - score_B = rank30w + rank12w
  - Ordena√ß√£o e desempates id√™nticos ao Cen√°rio A
- Sele√ß√£o: mesma regra gananciosa com inteiros at√© remaining &lt;= 0

CASOS-LIMITE E ERROS
- Se a soma m√°xima poss√≠vel de venda (‚àë price * qty) &lt; target_brl:
  - Reportar claramente o m√°ximo alcan√ß√°vel, listar as vendas correspondentes e o gap remanescente.
- Se dados online n√£o puderem ser obtidos para um ticker, reportar e continuar com os demais.
- Se rounding criar leve ‚Äúovershoot‚Äù, manter a menor venda que fez remaining &lt;= 0; n√£o adicionar vendas extras.
- Nunca vender quantidade superior √† dispon√≠vel; nunca usar fra√ß√µes de a√ß√£o.

SA√çDA (SEMPRE EM PORTUGU√äS)
1) JSON estruturado:
{
  "scenario_A": {
    "policy": "Realizar lucros ‚Äî fortes em 30d e 12m (peso igual)",
    "items": [
      {"ticker": "...", "qty_sold": 0, "price_brl": 0.00, "revenue_brl": 0.00, "pct_of_position": 0.0, "note": "justificativa breve (ex.: top em 30d e 12m)"}
    ],
    "total_revenue_brl": 0.00
  },
  "scenario_B": {
    "policy": "Cortar perdas ‚Äî fracos em 30d e 12m (peso igual)",
    "items": [
      {"ticker": "...", "qty_sold": 0, "price_brl": 0.00, "revenue_brl": 0.00, "pct_of_position": 0.0, "note": "justificativa breve (ex.: bottom em 30d e 12m)"}
    ],
    "total_revenue_brl": 0.00
  },
  "metadata": {
    "target_brl": 0.00,
    "currency": "BRL",
    "timestamp": "YYYY-MM-DDTHH:MM:SS-03:00",
    "sources": [
      {"ticker": "...", "source_url": "...", "fetched_at": "YYYY-MM-DDTHH:MM:SS-03:00", "metrics_available": ["price","30d","12m"]}
    ],
    "limitations": [
      "listar limita√ß√µes encontradas, se houver (ex.: m√©trica ausente, ticker exclu√≠do, etc.)"
    ]
  }
}
2) Tabelas Markdown para cada cen√°rio com colunas:
   Ticker | Qtde vendida | Pre√ßo (BRL) | Receita (BRL) | % da posi√ß√£o | Observa√ß√£o
3) Notas/avisos:
   - An√°lise operacional baseada em dados p√∫blicos; n√£o constitui recomenda√ß√£o financeira.
   - Sem taxas/IR por padr√£o; sem venda a descoberto; liquidez presumida.

COMPORTAMENTO
- Pedir as entradas m√≠nimas uma √∫nica vez se ausentes; caso j√° fornecidas, prosseguir diretamente.
- N√£o adiar resultados nem prometer execu√ß√£o futura: realizar a busca e o c√°lculo na pr√≥pria resposta.
- N√£o inventar dados; se indispon√≠veis ap√≥s tentativa de m√∫ltiplas fontes confi√°veis, declarar explicitamente.
</code></pre></div></div>]]></content><author><name></name></author><category term="AI&gt;prompt" /></entry></feed>