<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        `.eml` mail converter - infoBAG
      
    </title>
    <meta name="title" content="`.eml` mail converter - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/eml-mail-converter/">
    <meta property="og:title" content="`.eml` mail converter - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/eml-mail-converter/">
    <meta name="twitter:title" content="`.eml` mail converter - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/eml-mail-converter/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scratchpad">
      
        <meta property="article:tag" content="scratchpad">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          `.eml` mail converter
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2025-05-29T00:00:00+00:00" class="post-date">
          29 May 2025
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2025-05-29T12:57:27+00:00">
              29 May 2025
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/eml-mail-converter" class="tag">eml-mail-converter</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scratchpad" class="tag">scratchpad</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        25201 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        2246 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2025-05-29-eml-mail-converter.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  <span class="button-text">Improve this page?</span>
                  <span class="info-text">aberto.</span>
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2025-05-29-eml-mail-converter.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          

          <section class="code-block-container" role="group" aria-label="Python Code Block" data-filename="python_code_block.py" data-code="import os
import email
from email.parser import BytesParser
from email.policy import default as default_email_policy # Modern email policy
from email.header import decode_header, make_header
import mimetypes # For guessing file extensions
import re
import traceback # For detailed error logging

def sanitize_filename(filename_str):
    &quot;&quot;&quot;
    Sanitizes a string to be used as a filename.
    Removes or replaces characters that are not allowed or problematic in filenames
    across common operating systems. Handles email header objects.
    &quot;&quot;&quot;
    if filename_str is None:
        return &quot;_unnamed_file_&quot;

    # If it&#39;s an email.header.Header object, decode it first
    if hasattr(filename_str, &#39;encode&#39;) and not isinstance(filename_str, str):
        try:
            decoded_parts = decode_header(str(filename_str))
            temp_filename_parts = []
            for part, charset in decoded_parts:
                if isinstance(part, bytes):
                    try:
                        temp_filename_parts.append(part.decode(charset or &#39;utf-8&#39;, &#39;replace&#39;))
                    except LookupError: # Fallback for unknown charset
                        temp_filename_parts.append(part.decode(&#39;utf-8&#39;, &#39;replace&#39;))
                else:
                    temp_filename_parts.append(part)
            filename_str = &quot;&quot;.join(temp_filename_parts)
        except Exception as e:
            # If decoding complex header fails, fall back to simple string conversion
            print(f&quot;    Warning: Could not fully decode filename header, using str(): {e}&quot;)
            filename_str = str(filename_str)
    elif not isinstance(filename_str, str):
        filename_str = str(filename_str) # Ensure it&#39;s a string

    # Remove or replace forbidden characters: &lt; &gt; : &quot; / \ | ? * and control characters (0-31)
    filename_str = re.sub(r&#39;[&lt;&gt;:&quot;/\\|?*\x00-\x1f]&#39;, &#39;_&#39;, filename_str)

    # Replace multiple consecutive underscores or dots that might have resulted
    filename_str = re.sub(r&#39;_+&#39;, &#39;_&#39;, filename_str)
    filename_str = re.sub(r&#39;\.+&#39;, &#39;.&#39;, filename_str) # Allow single dots for extensions

    # Remove leading/trailing problematic characters (dots, underscores, spaces)
    filename_str = filename_str.strip(&#39;._ &#39;)

    # Handle cases where the filename might become empty or just dots after sanitization
    if not filename_str or all(c == &#39;.&#39; for c in filename_str):
        return &quot;_renamed_file_&quot;

    # Prevent names that could be problematic (e.g., &quot;..&quot; relative paths)
    # The regex above should handle slashes, but this is an extra safety check.
    if &quot;..&quot; in filename_str:
        filename_str = filename_str.replace(&quot;..&quot;, &quot;_&quot;) # Replace &quot;..&quot; with a single underscore

    # Limit length (e.g., 200 characters, leaving room for extensions/counters)
    max_len = 200
    if len(filename_str) &gt; max_len:
        name_part, ext_part = os.path.splitext(filename_str)
        
        # Ensure ext_part is not excessively long itself
        if len(ext_part) &gt; max_len / 2 : # Heuristic for very long extensions
            ext_part = ext_part[:10] # Truncate very long extension
        
        available_len_for_name = max_len - len(ext_part)
        if ext_part: # if there is an extension, account for the dot
            available_len_for_name -=1
            if available_len_for_name &lt; 1: # Name part would be empty
                 name_part = &quot;_trunc_&quot; # Provide a minimal name part
                 available_len_for_name = len(name_part) # Recalculate for safety
            else:
                 name_part = name_part[:available_len_for_name]

        else: # No extension
            name_part = name_part[:max_len]
            
        filename_str = name_part + (&#39;.&#39; + ext_part.lstrip(&#39;.&#39;) if ext_part else &quot;&quot;)

    return filename_str if filename_str else &quot;_renamed_file_&quot; # Final check for empty string


def process_eml_file(eml_file_path, base_output_dir):
    &quot;&quot;&quot;
    Processes a single .eml file to extract its headers, body, and attachments.

    Args:
        eml_file_path (str): The path to the .eml file.
        base_output_dir (str): The directory where extracted content will be saved.
                               A subdirectory will be created here for each EML file.
    &quot;&quot;&quot;
    print(f&quot;\nProcessing EML file: {eml_file_path}&quot;)
    try:
        with open(eml_file_path, &#39;rb&#39;) as fp: # Read in binary mode
            msg = BytesParser(policy=default_email_policy).parse(fp)

        # --- Create a unique output directory for this email ---
        eml_filename_stem = os.path.splitext(os.path.basename(eml_file_path))[0]
        sanitized_eml_stem = sanitize_filename(eml_filename_stem)

        if not sanitized_eml_stem or sanitized_eml_stem == &quot;_renamed_file_&quot;:
            unique_id = str(abs(hash(os.path.abspath(eml_file_path))) % 1000000) # Larger range for hash
            sanitized_eml_stem = f&quot;email_extract_{unique_id}&quot;
            print(f&quot;    Warning: Original EML filename sanitized to an unusable name. Using fallback: {sanitized_eml_stem}&quot;)

        email_specific_output_dir = os.path.join(base_output_dir, sanitized_eml_stem)

        dir_counter = 1
        temp_output_dir = email_specific_output_dir
        while os.path.exists(temp_output_dir):
            temp_output_dir = f&quot;{email_specific_output_dir}_{dir_counter}&quot;
            dir_counter += 1
        email_specific_output_dir = temp_output_dir
        
        try:
            os.makedirs(email_specific_output_dir, exist_ok=True)
        except OSError as e:
            print(f&quot;    Error creating output directory {email_specific_output_dir}: {e}&quot;)
            return # Cannot proceed without output directory
        print(f&quot;  Outputting to: {email_specific_output_dir}&quot;)

        # --- Extract and save headers ---
        headers_to_extract = [&quot;Subject&quot;, &quot;From&quot;, &quot;To&quot;, &quot;Date&quot;, &quot;Message-ID&quot;, 
                              &quot;Cc&quot;, &quot;Bcc&quot;, &quot;Return-Path&quot;, &quot;Reply-To&quot;]
        header_info = []
        extracted_subject_for_log = &quot;No_Subject&quot; # Fallback

        for header_name in headers_to_extract:
            header_value = msg.get(header_name)
            if header_value:
                try:
                    # make_header handles folding and converting to a string.
                    # decode_header handles the actual charset decoding.
                    decoded_header_val = str(make_header(decode_header(str(header_value))))
                    header_info.append(f&quot;{header_name}: {decoded_header_val}&quot;)
                    if header_name.lower() == &quot;subject&quot;:
                        extracted_subject_for_log = decoded_header_val
                except Exception as e:
                    header_info.append(f&quot;{header_name}: Error decoding header - {e}&quot;)
                    print(f&quot;    Warning: Error decoding header &#39;{header_name}&#39;: {e}&quot;)
        
        if header_info:
            try:
                with open(os.path.join(email_specific_output_dir, &quot;_headers.txt&quot;), &quot;w&quot;, encoding=&quot;utf-8&quot;) as hf:
                    hf.write(&quot;\n&quot;.join(header_info))
                print(&quot;    Saved _headers.txt&quot;)
            except IOError as e:
                print(f&quot;    Error saving _headers.txt: {e}&quot;)
        else:
            print(&quot;    No standard headers found or extracted.&quot;)


        # --- Extract Body and Attachments ---
        body_text_parts = []
        body_html_parts = []
        attachment_idx = 0 

        for part_num, part in enumerate(msg.walk()):
            content_disposition = part.get(&quot;Content-Disposition&quot;)
            content_type = part.get_content_type()
            
            is_attachment = False
            # Rule 1: Explicit &quot;attachment&quot; in Content-Disposition
            if content_disposition and &quot;attachment&quot; in content_disposition.lower():
                is_attachment = True
            # Rule 2: Has a filename (even if disposition is &quot;inline&quot; or missing)
            # This helps catch inline images that are also distinct files.
            elif part.get_filename(): 
                 is_attachment = True
            # Rule 3: Non-text, non-multipart part without a disposition (e.g., a directly embedded image)
            # This is a heuristic and might sometimes misclassify, but often useful.
            elif not part.is_multipart() and \
                 not content_type.startswith(&quot;text/&quot;) and \
                 not content_type.startswith(&quot;multipart/&quot;) and \
                 not content_disposition:
                 is_attachment = True

            if is_attachment:
                attachment_idx += 1
                original_filename = part.get_filename() # This method handles decoding of filenames

                if original_filename:
                    filename = sanitize_filename(original_filename)
                else:
                    ext = mimetypes.guess_extension(content_type, strict=False) or &#39;.dat&#39;
                    filename = sanitize_filename(f&quot;attachment_{attachment_idx}{ext}&quot;)
                
                if not filename or filename == &quot;_renamed_file_&quot;: # Final fallback if sanitization fails badly
                    filename = f&quot;attachment_{attachment_idx}_fallback.dat&quot;

                filepath = os.path.join(email_specific_output_dir, filename)
                
                file_counter = 1
                base_name, ext_name = os.path.splitext(filepath)
                # Ensure base_name is not empty if original filename was just an extension (e.g. &quot;.pdf&quot;)
                if not base_name and ext_name: # e.g. if original was &quot;.txt&quot;
                    base_name = f&quot;attachment_{attachment_idx}_base&quot;

                while os.path.exists(filepath):
                    filepath = f&quot;{base_name}_{file_counter}{ext_name}&quot;
                    file_counter += 1
                    
                try:
                    payload = part.get_payload(decode=True) 
                    if payload is not None: 
                        with open(filepath, &#39;wb&#39;) as f_attach:
                            f_attach.write(payload)
                        print(f&quot;    Saved attachment: {os.path.basename(filepath)}&quot;)
                    else:
                        print(f&quot;    Skipped attachment {os.path.basename(filepath)} (empty payload after decoding).&quot;)
                except IOError as e:
                    print(f&quot;    IOError saving attachment {os.path.basename(filepath)}: {e}&quot;)
                except Exception as e:
                    print(f&quot;    Error saving attachment {os.path.basename(filepath)}: {e}&quot;)
            
            # Body parts (not explicitly attachments based on above rules)
            elif content_type == &quot;text/plain&quot; and (not content_disposition or &quot;inline&quot; in content_disposition.lower()):
                try:
                    payload = part.get_payload(decode=True)
                    if payload is not None:
                        charset = part.get_content_charset() or &#39;utf-8&#39; 
                        body_text_parts.append(payload.decode(charset, errors=&#39;replace&#39;))
                except Exception as e:
                    print(f&quot;    Error decoding text/plain part: {e}&quot;)
            
            elif content_type == &quot;text/html&quot; and (not content_disposition or &quot;inline&quot; in content_disposition.lower()):
                try:
                    payload = part.get_payload(decode=True)
                    if payload is not None:
                        charset = part.get_content_charset() or &#39;utf-8&#39;
                        body_html_parts.append(payload.decode(charset, errors=&#39;replace&#39;))
                except Exception as e:
                    print(f&quot;    Error decoding text/html part: {e}&quot;)

        # Save body parts
        if body_text_parts:
            body_text_content = &quot;\n\n--- (Next Text Part) ---\n\n&quot;.join(body_text_parts)
            body_text_filepath = os.path.join(email_specific_output_dir, &quot;body.txt&quot;)
            try:
                with open(body_text_filepath, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f_body_txt:
                    f_body_txt.write(body_text_content)
                print(f&quot;    Saved text body to body.txt&quot;)
            except IOError as e:
                print(f&quot;    Error saving body.txt: {e}&quot;)
        
        if body_html_parts:
            body_html_content = &quot;\n\n&lt;hr&gt;&lt;p&gt;--- (Next HTML Part) ---&lt;/p&gt;&lt;hr&gt;\n\n&quot;.join(body_html_parts)
            body_html_filepath = os.path.join(email_specific_output_dir, &quot;body.html&quot;)
            try:
                with open(body_html_filepath, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f_body_html:
                    f_body_html.write(body_html_content)
                print(f&quot;    Saved HTML body to body.html&quot;)
            except IOError as e:
                print(f&quot;    Error saving body.html: {e}&quot;)
                
        # Fallback for non-multipart messages that are purely text and weren&#39;t caught as body
        if not msg.is_multipart() and not body_text_parts and not body_html_parts and msg.get_content_type().startswith(&quot;text/&quot;):
            try:
                payload = msg.get_payload(decode=True)
                if payload is not None:
                    charset = msg.get_content_charset() or &#39;utf-8&#39;
                    body_content = payload.decode(charset, errors=&#39;replace&#39;)
                    subtype = sanitize_filename(msg.get_content_subtype() or &quot;txt&quot;)
                    if not subtype or subtype == &quot;_renamed_file_&quot;: subtype = &quot;txt&quot; # Ensure valid extension
                    body_filepath = os.path.join(email_specific_output_dir, f&quot;body_main.{subtype}&quot;)
                    with open(body_filepath, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f_body_main:
                        f_body_main.write(body_content)
                    print(f&quot;    Saved main text payload to {os.path.basename(body_filepath)}&quot;)
            except Exception as e:
                print(f&quot;    Could not decode/save main text payload for non-multipart email: {e}&quot;)

        if not body_text_parts and not body_html_parts and attachment_idx == 0 and \
           (msg.is_multipart() or not msg.get_content_type().startswith(&quot;text/&quot;)):
            print(f&quot;    Note: No distinct text/html body or attachments were extracted for &#39;{os.path.basename(eml_file_path)}&#39;. The content might be in an unusual format or the EML might be empty/corrupt.&quot;)

        print(f&quot;  Finished processing {os.path.basename(eml_file_path)}&quot;)

    except FileNotFoundError:
        print(f&quot;Error: EML file not found at {eml_file_path}&quot;)
    except Exception as e:
        print(f&quot;An critical error occurred while processing {eml_file_path}: {e}&quot;)
        traceback.print_exc()


if __name__ == &quot;__main__&quot;:
    # --- HOW TO USE THIS SCRIPT ---
    # 1. Save this script as a Python file (e.g., eml_parser_revised.py).
    #
    # 2. CHOOSE ONE of the options below by UNCOMMENTING the relevant block.
    #    To uncomment a block, remove the triple quote characters (&#39;&#39;&#39; or &quot;&quot;&quot;)
    #    from the beginning and end of that block.
    #
    # 3. MODIFY THE PATHS within your chosen uncommented block to point to your
    #    actual EML files and desired output location. Use ABSOLUTE paths if unsure.
    #    e.g., on Linux: &#39;/home/youruser/my_emails/email.eml&#39;
    #    e.g., on Windows: &#39;C:\\Users\\YourUser\\Documents\\MyEMLs&#39; (note the double backslashes)
    #
    # 4. Run the script from your terminal:
    #    python3 eml_parser_revised.py
    #    (Or `python eml_parser_revised.py` if python3 is your default python)
    #
    # The script will create a main output directory, and inside it,
    # a subdirectory for each processed EML file. These subdirectories will
    # contain the extracted headers (_headers.txt), body (body.txt/body.html),
    # and any attachments.

    user_has_configured_an_option = True # This flag will be set if an option is chosen by uncommenting

    # --- OPTION 1: Process a SINGLE .eml file ---
    &quot;&quot;&quot;
    eml_file_to_process = &quot;YOUR_SINGLE_EML_FILE_PATH_HERE.eml&quot;  # &lt;-- *** SET THIS ABSOLUTE OR RELATIVE PATH ***
    main_output_folder = &quot;eml_extracted_single_output&quot;          # &lt;-- SET YOUR DESIRED OUTPUT FOLDER NAME (will be created if not exists)

    # --- Do not edit below this line for Option 1 ---
    if eml_file_to_process == &quot;YOUR_SINGLE_EML_FILE_PATH_HERE.eml&quot;:
        print(&quot;OPTION 1 IS UNCOMMENTED, BUT THE PATH IS STILL THE DEFAULT PLACEHOLDER.&quot;)
        print(&quot;Please edit &#39;eml_file_to_process&#39; to your EML file&#39;s actual path.&quot;)
    elif os.path.isfile(eml_file_to_process):
        try:
            os.makedirs(main_output_folder, exist_ok=True)
            process_eml_file(eml_file_to_process, main_output_folder)
            print(f&quot;\nSingle file processing complete. Output in: {os.path.abspath(main_output_folder)}&quot;)
        except Exception as e_main:
            print(f&quot;Error during Option 1 execution: {e_main}&quot;)
        user_has_configured_an_option = True
    else:
        print(f&quot;OPTION 1 ERROR: EML file not found at &#39;{eml_file_to_process}&#39;&quot;)
    &quot;&quot;&quot;

    # --- OPTION 2: Process ALL .eml files in a DIRECTORY ---
    # &quot;&quot;&quot;
    source_directory_with_emls = &quot;/mnt/mSATA/linaro/Desktop/00-TEMP/EML mails/&quot;  # &lt;-- *** SET THIS ABSOLUTE OR RELATIVE PATH ***
    main_output_folder = &quot;/mnt/mSATA/linaro/Desktop/00-TEMP/EMLout/&quot;                        # &lt;-- SET YOUR DESIRED OUTPUT FOLDER NAME (will be created if not exists)

    # --- Do not edit below this line for Option 2 ---
    if source_directory_with_emls == &quot;YOUR_DIRECTORY_CONTAINING_EML_FILES_HERE&quot;:
        print(&quot;OPTION 2 IS UNCOMMENTED, BUT THE PATH IS STILL THE DEFAULT PLACEHOLDER.&quot;)
        print(&quot;Please edit &#39;source_directory_with_emls&#39; to your EML directory&#39;s actual path.&quot;)
    elif os.path.isdir(source_directory_with_emls):
        try:
            os.makedirs(main_output_folder, exist_ok=True)
            eml_found_in_dir = False
            for item in os.listdir(source_directory_with_emls):
                if item.lower().endswith(&quot;.eml&quot;):
                    eml_found_in_dir = True
                    full_eml_path = os.path.join(source_directory_with_emls, item)
                    process_eml_file(full_eml_path, main_output_folder)
            if not eml_found_in_dir:
                print(f&quot;OPTION 2: No .eml files found in &#39;{source_directory_with_emls}&#39;&quot;)
            else:
                print(f&quot;\nBatch processing complete. Output in: {os.path.abspath(main_output_folder)}&quot;)
        except Exception as e_main:
            print(f&quot;Error during Option 2 execution: {e_main}&quot;)
        user_has_configured_an_option = True
    else:
        print(f&quot;OPTION 2 ERROR: Directory not found at &#39;{source_directory_with_emls}&#39;&quot;)
    # &quot;&quot;&quot;


    # --- OPTION 3: Test with the EML content provided in your prompt ---
    # To use this:
    # 1. Create a file named &quot;my_test_email.eml&quot; in the SAME directory as this script.
    # 2. Paste the FULL EML content (from your original prompt) into that &quot;my_test_email.eml&quot; file and save it.
    # 3. Then, uncomment this block and run the script.
    &quot;&quot;&quot;
    test_eml_filename = &quot;my_test_email.eml&quot; 
    main_output_folder = &quot;eml_extracted_test_sample_output&quot;

    # --- Do not edit below this line for Option 3 ---
    if os.path.isfile(test_eml_filename):
        try:
            os.makedirs(main_output_folder, exist_ok=True)
            process_eml_file(test_eml_filename, main_output_folder)
            print(f&quot;\nTest file processing complete. Output in: {os.path.abspath(main_output_folder)}&quot;)
        except Exception as e_main:
            print(f&quot;Error during Option 3 execution: {e_main}&quot;)
        user_has_configured_an_option = True
    else:
        print(f&quot;OPTION 3: Test file &#39;{test_eml_filename}&#39; not found in the script&#39;s directory.&quot;)
        print(&quot;          Please create it and paste your EML content into it to use this option.&quot;)
    &quot;&quot;&quot;

    # --- If no option was uncommented and configured by the user, print detailed help ---
    if not user_has_configured_an_option:
        print(&quot;\n--- EML EXTRACTION SCRIPT HELP ---&quot;)
        print(&quot;This script extracts content and attachments from .eml (email) files.&quot;)
        print(&quot;\nTO USE THIS SCRIPT:&quot;)
        print(&quot;1. Open this Python script file (the .py file you saved) in a text editor.&quot;)
        print(&quot;2. Scroll down to the end of the file, to the section that starts with:&quot;)
        print(&quot;   &#39;if __name__ == \&quot;__main__\&quot;:&#39;&quot;)
        print(&quot;3. You will see three &#39;OPTION&#39; blocks (OPTION 1, OPTION 2, OPTION 3).&quot;)
        print(&quot;   These blocks are currently &#39;commented out&#39; with triple quote characters&quot;)
        print(&quot;   (&#39;&#39;&#39;) at their beginning and end.&quot;)
        print(&quot;\n4. CHOOSE ONLY ONE OPTION that fits your needs:&quot;)
        print(&quot;   - OPTION 1: If you want to process a single .eml file.&quot;)
        print(&quot;   - OPTION 2: If you want to process all .eml files within a specific folder.&quot;)
        print(&quot;   - OPTION 3: If you want to test the script with a sample &#39;my_test_email.eml&#39; file&quot;)
        print(&quot;               (which you need to create first, as described in the comments for Option 3).&quot;)
        print(&quot;\n5. UNCOMMENT your chosen option&#39;s block. To do this, delete the three quote&quot;)
        print(&quot;   characters (&#39;&#39;&#39;) from the very beginning of that block, AND delete the&quot;)
        print(&quot;   three quote characters (&#39;&#39;&#39;) from the very end of that SAME block.&quot;)
        print(&quot;   Make sure only ONE option block is uncommented.&quot;)
        print(&quot;\n6. IMPORTANT: Inside the option block you just uncommented, you MUST update&quot;)
        print(&quot;   the placeholder paths. For example, change:&quot;)
        print(&quot;     &#39;YOUR_SINGLE_EML_FILE_PATH_HERE.eml&#39;&quot;)
        print(&quot;   to the actual, full path of your EML file, like:&quot;)
        print(&quot;     &#39;/home/yourusername/emails/important_email.eml&#39; (for Linux/macOS)&quot;)
        print(&quot;     &#39;C:\\Users\\YourUserName\\Documents\\Emails\\archive.eml&#39; (for Windows - note double backslashes)&quot;)
        print(&quot;   Similarly, update &#39;YOUR_DIRECTORY_CONTAINING_EML_FILES_HERE&#39; if using Option 2,&quot;)
        print(&quot;   and you can customize &#39;main_output_folder&#39; if desired.&quot;)
        print(&quot;\n7. Save the changes you made to this script file.&quot;)
        print(&quot;\n8. Open a terminal or command prompt.&quot;)
        print(&quot;9. Navigate to the directory where you saved this script file using the &#39;cd&#39; command.&quot;)
        print(&quot;   (e.g., &#39;cd /path/to/where/you/saved/the_script&#39;)&quot;)
        print(&quot;10. Run the script by typing the following command and pressing Enter:&quot;)
        print(&quot;    python3 name_of_this_script.py&quot;)
        print(&quot;    (Replace &#39;name_of_this_script.py&#39; with the actual filename you used, e.g., &#39;eml_parser_revised.py&#39;)&quot;)
        print(&quot;    If &#39;python3&#39; doesn&#39;t work, try &#39;python name_of_this_script.py&#39;.&quot;)
        print(&quot;\n   The script will then run, process your EML files, and save the extracted&quot;)
        print(&quot;   content (headers, body text/html, attachments) into subdirectories within&quot;)
        print(&quot;   the &#39;main_output_folder&#39; you specified (or the default one for that option).&quot;)
        print(&quot;-----------------------------------\n&quot;)" data-download-link="" data-download-label="Download Python">
  <code class="language-python">import os
import email
from email.parser import BytesParser
from email.policy import default as default_email_policy # Modern email policy
from email.header import decode_header, make_header
import mimetypes # For guessing file extensions
import re
import traceback # For detailed error logging

def sanitize_filename(filename_str):
    &quot;&quot;&quot;
    Sanitizes a string to be used as a filename.
    Removes or replaces characters that are not allowed or problematic in filenames
    across common operating systems. Handles email header objects.
    &quot;&quot;&quot;
    if filename_str is None:
        return &quot;_unnamed_file_&quot;

    # If it&#39;s an email.header.Header object, decode it first
    if hasattr(filename_str, &#39;encode&#39;) and not isinstance(filename_str, str):
        try:
            decoded_parts = decode_header(str(filename_str))
            temp_filename_parts = []
            for part, charset in decoded_parts:
                if isinstance(part, bytes):
                    try:
                        temp_filename_parts.append(part.decode(charset or &#39;utf-8&#39;, &#39;replace&#39;))
                    except LookupError: # Fallback for unknown charset
                        temp_filename_parts.append(part.decode(&#39;utf-8&#39;, &#39;replace&#39;))
                else:
                    temp_filename_parts.append(part)
            filename_str = &quot;&quot;.join(temp_filename_parts)
        except Exception as e:
            # If decoding complex header fails, fall back to simple string conversion
            print(f&quot;    Warning: Could not fully decode filename header, using str(): {e}&quot;)
            filename_str = str(filename_str)
    elif not isinstance(filename_str, str):
        filename_str = str(filename_str) # Ensure it&#39;s a string

    # Remove or replace forbidden characters: &lt; &gt; : &quot; / \ | ? * and control characters (0-31)
    filename_str = re.sub(r&#39;[&lt;&gt;:&quot;/\\|?*\x00-\x1f]&#39;, &#39;_&#39;, filename_str)

    # Replace multiple consecutive underscores or dots that might have resulted
    filename_str = re.sub(r&#39;_+&#39;, &#39;_&#39;, filename_str)
    filename_str = re.sub(r&#39;\.+&#39;, &#39;.&#39;, filename_str) # Allow single dots for extensions

    # Remove leading/trailing problematic characters (dots, underscores, spaces)
    filename_str = filename_str.strip(&#39;._ &#39;)

    # Handle cases where the filename might become empty or just dots after sanitization
    if not filename_str or all(c == &#39;.&#39; for c in filename_str):
        return &quot;_renamed_file_&quot;

    # Prevent names that could be problematic (e.g., &quot;..&quot; relative paths)
    # The regex above should handle slashes, but this is an extra safety check.
    if &quot;..&quot; in filename_str:
        filename_str = filename_str.replace(&quot;..&quot;, &quot;_&quot;) # Replace &quot;..&quot; with a single underscore

    # Limit length (e.g., 200 characters, leaving room for extensions/counters)
    max_len = 200
    if len(filename_str) &gt; max_len:
        name_part, ext_part = os.path.splitext(filename_str)
        
        # Ensure ext_part is not excessively long itself
        if len(ext_part) &gt; max_len / 2 : # Heuristic for very long extensions
            ext_part = ext_part[:10] # Truncate very long extension
        
        available_len_for_name = max_len - len(ext_part)
        if ext_part: # if there is an extension, account for the dot
            available_len_for_name -=1
            if available_len_for_name &lt; 1: # Name part would be empty
                 name_part = &quot;_trunc_&quot; # Provide a minimal name part
                 available_len_for_name = len(name_part) # Recalculate for safety
            else:
                 name_part = name_part[:available_len_for_name]

        else: # No extension
            name_part = name_part[:max_len]
            
        filename_str = name_part + (&#39;.&#39; + ext_part.lstrip(&#39;.&#39;) if ext_part else &quot;&quot;)

    return filename_str if filename_str else &quot;_renamed_file_&quot; # Final check for empty string


def process_eml_file(eml_file_path, base_output_dir):
    &quot;&quot;&quot;
    Processes a single .eml file to extract its headers, body, and attachments.

    Args:
        eml_file_path (str): The path to the .eml file.
        base_output_dir (str): The directory where extracted content will be saved.
                               A subdirectory will be created here for each EML file.
    &quot;&quot;&quot;
    print(f&quot;\nProcessing EML file: {eml_file_path}&quot;)
    try:
        with open(eml_file_path, &#39;rb&#39;) as fp: # Read in binary mode
            msg = BytesParser(policy=default_email_policy).parse(fp)

        # --- Create a unique output directory for this email ---
        eml_filename_stem = os.path.splitext(os.path.basename(eml_file_path))[0]
        sanitized_eml_stem = sanitize_filename(eml_filename_stem)

        if not sanitized_eml_stem or sanitized_eml_stem == &quot;_renamed_file_&quot;:
            unique_id = str(abs(hash(os.path.abspath(eml_file_path))) % 1000000) # Larger range for hash
            sanitized_eml_stem = f&quot;email_extract_{unique_id}&quot;
            print(f&quot;    Warning: Original EML filename sanitized to an unusable name. Using fallback: {sanitized_eml_stem}&quot;)

        email_specific_output_dir = os.path.join(base_output_dir, sanitized_eml_stem)

        dir_counter = 1
        temp_output_dir = email_specific_output_dir
        while os.path.exists(temp_output_dir):
            temp_output_dir = f&quot;{email_specific_output_dir}_{dir_counter}&quot;
            dir_counter += 1
        email_specific_output_dir = temp_output_dir
        
        try:
            os.makedirs(email_specific_output_dir, exist_ok=True)
        except OSError as e:
            print(f&quot;    Error creating output directory {email_specific_output_dir}: {e}&quot;)
            return # Cannot proceed without output directory
        print(f&quot;  Outputting to: {email_specific_output_dir}&quot;)

        # --- Extract and save headers ---
        headers_to_extract = [&quot;Subject&quot;, &quot;From&quot;, &quot;To&quot;, &quot;Date&quot;, &quot;Message-ID&quot;, 
                              &quot;Cc&quot;, &quot;Bcc&quot;, &quot;Return-Path&quot;, &quot;Reply-To&quot;]
        header_info = []
        extracted_subject_for_log = &quot;No_Subject&quot; # Fallback

        for header_name in headers_to_extract:
            header_value = msg.get(header_name)
            if header_value:
                try:
                    # make_header handles folding and converting to a string.
                    # decode_header handles the actual charset decoding.
                    decoded_header_val = str(make_header(decode_header(str(header_value))))
                    header_info.append(f&quot;{header_name}: {decoded_header_val}&quot;)
                    if header_name.lower() == &quot;subject&quot;:
                        extracted_subject_for_log = decoded_header_val
                except Exception as e:
                    header_info.append(f&quot;{header_name}: Error decoding header - {e}&quot;)
                    print(f&quot;    Warning: Error decoding header &#39;{header_name}&#39;: {e}&quot;)
        
        if header_info:
            try:
                with open(os.path.join(email_specific_output_dir, &quot;_headers.txt&quot;), &quot;w&quot;, encoding=&quot;utf-8&quot;) as hf:
                    hf.write(&quot;\n&quot;.join(header_info))
                print(&quot;    Saved _headers.txt&quot;)
            except IOError as e:
                print(f&quot;    Error saving _headers.txt: {e}&quot;)
        else:
            print(&quot;    No standard headers found or extracted.&quot;)


        # --- Extract Body and Attachments ---
        body_text_parts = []
        body_html_parts = []
        attachment_idx = 0 

        for part_num, part in enumerate(msg.walk()):
            content_disposition = part.get(&quot;Content-Disposition&quot;)
            content_type = part.get_content_type()
            
            is_attachment = False
            # Rule 1: Explicit &quot;attachment&quot; in Content-Disposition
            if content_disposition and &quot;attachment&quot; in content_disposition.lower():
                is_attachment = True
            # Rule 2: Has a filename (even if disposition is &quot;inline&quot; or missing)
            # This helps catch inline images that are also distinct files.
            elif part.get_filename(): 
                 is_attachment = True
            # Rule 3: Non-text, non-multipart part without a disposition (e.g., a directly embedded image)
            # This is a heuristic and might sometimes misclassify, but often useful.
            elif not part.is_multipart() and \
                 not content_type.startswith(&quot;text/&quot;) and \
                 not content_type.startswith(&quot;multipart/&quot;) and \
                 not content_disposition:
                 is_attachment = True

            if is_attachment:
                attachment_idx += 1
                original_filename = part.get_filename() # This method handles decoding of filenames

                if original_filename:
                    filename = sanitize_filename(original_filename)
                else:
                    ext = mimetypes.guess_extension(content_type, strict=False) or &#39;.dat&#39;
                    filename = sanitize_filename(f&quot;attachment_{attachment_idx}{ext}&quot;)
                
                if not filename or filename == &quot;_renamed_file_&quot;: # Final fallback if sanitization fails badly
                    filename = f&quot;attachment_{attachment_idx}_fallback.dat&quot;

                filepath = os.path.join(email_specific_output_dir, filename)
                
                file_counter = 1
                base_name, ext_name = os.path.splitext(filepath)
                # Ensure base_name is not empty if original filename was just an extension (e.g. &quot;.pdf&quot;)
                if not base_name and ext_name: # e.g. if original was &quot;.txt&quot;
                    base_name = f&quot;attachment_{attachment_idx}_base&quot;

                while os.path.exists(filepath):
                    filepath = f&quot;{base_name}_{file_counter}{ext_name}&quot;
                    file_counter += 1
                    
                try:
                    payload = part.get_payload(decode=True) 
                    if payload is not None: 
                        with open(filepath, &#39;wb&#39;) as f_attach:
                            f_attach.write(payload)
                        print(f&quot;    Saved attachment: {os.path.basename(filepath)}&quot;)
                    else:
                        print(f&quot;    Skipped attachment {os.path.basename(filepath)} (empty payload after decoding).&quot;)
                except IOError as e:
                    print(f&quot;    IOError saving attachment {os.path.basename(filepath)}: {e}&quot;)
                except Exception as e:
                    print(f&quot;    Error saving attachment {os.path.basename(filepath)}: {e}&quot;)
            
            # Body parts (not explicitly attachments based on above rules)
            elif content_type == &quot;text/plain&quot; and (not content_disposition or &quot;inline&quot; in content_disposition.lower()):
                try:
                    payload = part.get_payload(decode=True)
                    if payload is not None:
                        charset = part.get_content_charset() or &#39;utf-8&#39; 
                        body_text_parts.append(payload.decode(charset, errors=&#39;replace&#39;))
                except Exception as e:
                    print(f&quot;    Error decoding text/plain part: {e}&quot;)
            
            elif content_type == &quot;text/html&quot; and (not content_disposition or &quot;inline&quot; in content_disposition.lower()):
                try:
                    payload = part.get_payload(decode=True)
                    if payload is not None:
                        charset = part.get_content_charset() or &#39;utf-8&#39;
                        body_html_parts.append(payload.decode(charset, errors=&#39;replace&#39;))
                except Exception as e:
                    print(f&quot;    Error decoding text/html part: {e}&quot;)

        # Save body parts
        if body_text_parts:
            body_text_content = &quot;\n\n--- (Next Text Part) ---\n\n&quot;.join(body_text_parts)
            body_text_filepath = os.path.join(email_specific_output_dir, &quot;body.txt&quot;)
            try:
                with open(body_text_filepath, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f_body_txt:
                    f_body_txt.write(body_text_content)
                print(f&quot;    Saved text body to body.txt&quot;)
            except IOError as e:
                print(f&quot;    Error saving body.txt: {e}&quot;)
        
        if body_html_parts:
            body_html_content = &quot;\n\n&lt;hr&gt;&lt;p&gt;--- (Next HTML Part) ---&lt;/p&gt;&lt;hr&gt;\n\n&quot;.join(body_html_parts)
            body_html_filepath = os.path.join(email_specific_output_dir, &quot;body.html&quot;)
            try:
                with open(body_html_filepath, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f_body_html:
                    f_body_html.write(body_html_content)
                print(f&quot;    Saved HTML body to body.html&quot;)
            except IOError as e:
                print(f&quot;    Error saving body.html: {e}&quot;)
                
        # Fallback for non-multipart messages that are purely text and weren&#39;t caught as body
        if not msg.is_multipart() and not body_text_parts and not body_html_parts and msg.get_content_type().startswith(&quot;text/&quot;):
            try:
                payload = msg.get_payload(decode=True)
                if payload is not None:
                    charset = msg.get_content_charset() or &#39;utf-8&#39;
                    body_content = payload.decode(charset, errors=&#39;replace&#39;)
                    subtype = sanitize_filename(msg.get_content_subtype() or &quot;txt&quot;)
                    if not subtype or subtype == &quot;_renamed_file_&quot;: subtype = &quot;txt&quot; # Ensure valid extension
                    body_filepath = os.path.join(email_specific_output_dir, f&quot;body_main.{subtype}&quot;)
                    with open(body_filepath, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f_body_main:
                        f_body_main.write(body_content)
                    print(f&quot;    Saved main text payload to {os.path.basename(body_filepath)}&quot;)
            except Exception as e:
                print(f&quot;    Could not decode/save main text payload for non-multipart email: {e}&quot;)

        if not body_text_parts and not body_html_parts and attachment_idx == 0 and \
           (msg.is_multipart() or not msg.get_content_type().startswith(&quot;text/&quot;)):
            print(f&quot;    Note: No distinct text/html body or attachments were extracted for &#39;{os.path.basename(eml_file_path)}&#39;. The content might be in an unusual format or the EML might be empty/corrupt.&quot;)

        print(f&quot;  Finished processing {os.path.basename(eml_file_path)}&quot;)

    except FileNotFoundError:
        print(f&quot;Error: EML file not found at {eml_file_path}&quot;)
    except Exception as e:
        print(f&quot;An critical error occurred while processing {eml_file_path}: {e}&quot;)
        traceback.print_exc()


if __name__ == &quot;__main__&quot;:
    # --- HOW TO USE THIS SCRIPT ---
    # 1. Save this script as a Python file (e.g., eml_parser_revised.py).
    #
    # 2. CHOOSE ONE of the options below by UNCOMMENTING the relevant block.
    #    To uncomment a block, remove the triple quote characters (&#39;&#39;&#39; or &quot;&quot;&quot;)
    #    from the beginning and end of that block.
    #
    # 3. MODIFY THE PATHS within your chosen uncommented block to point to your
    #    actual EML files and desired output location. Use ABSOLUTE paths if unsure.
    #    e.g., on Linux: &#39;/home/youruser/my_emails/email.eml&#39;
    #    e.g., on Windows: &#39;C:\\Users\\YourUser\\Documents\\MyEMLs&#39; (note the double backslashes)
    #
    # 4. Run the script from your terminal:
    #    python3 eml_parser_revised.py
    #    (Or `python eml_parser_revised.py` if python3 is your default python)
    #
    # The script will create a main output directory, and inside it,
    # a subdirectory for each processed EML file. These subdirectories will
    # contain the extracted headers (_headers.txt), body (body.txt/body.html),
    # and any attachments.

    user_has_configured_an_option = True # This flag will be set if an option is chosen by uncommenting

    # --- OPTION 1: Process a SINGLE .eml file ---
    &quot;&quot;&quot;
    eml_file_to_process = &quot;YOUR_SINGLE_EML_FILE_PATH_HERE.eml&quot;  # &lt;-- *** SET THIS ABSOLUTE OR RELATIVE PATH ***
    main_output_folder = &quot;eml_extracted_single_output&quot;          # &lt;-- SET YOUR DESIRED OUTPUT FOLDER NAME (will be created if not exists)

    # --- Do not edit below this line for Option 1 ---
    if eml_file_to_process == &quot;YOUR_SINGLE_EML_FILE_PATH_HERE.eml&quot;:
        print(&quot;OPTION 1 IS UNCOMMENTED, BUT THE PATH IS STILL THE DEFAULT PLACEHOLDER.&quot;)
        print(&quot;Please edit &#39;eml_file_to_process&#39; to your EML file&#39;s actual path.&quot;)
    elif os.path.isfile(eml_file_to_process):
        try:
            os.makedirs(main_output_folder, exist_ok=True)
            process_eml_file(eml_file_to_process, main_output_folder)
            print(f&quot;\nSingle file processing complete. Output in: {os.path.abspath(main_output_folder)}&quot;)
        except Exception as e_main:
            print(f&quot;Error during Option 1 execution: {e_main}&quot;)
        user_has_configured_an_option = True
    else:
        print(f&quot;OPTION 1 ERROR: EML file not found at &#39;{eml_file_to_process}&#39;&quot;)
    &quot;&quot;&quot;

    # --- OPTION 2: Process ALL .eml files in a DIRECTORY ---
    # &quot;&quot;&quot;
    source_directory_with_emls = &quot;/mnt/mSATA/linaro/Desktop/00-TEMP/EML mails/&quot;  # &lt;-- *** SET THIS ABSOLUTE OR RELATIVE PATH ***
    main_output_folder = &quot;/mnt/mSATA/linaro/Desktop/00-TEMP/EMLout/&quot;                        # &lt;-- SET YOUR DESIRED OUTPUT FOLDER NAME (will be created if not exists)

    # --- Do not edit below this line for Option 2 ---
    if source_directory_with_emls == &quot;YOUR_DIRECTORY_CONTAINING_EML_FILES_HERE&quot;:
        print(&quot;OPTION 2 IS UNCOMMENTED, BUT THE PATH IS STILL THE DEFAULT PLACEHOLDER.&quot;)
        print(&quot;Please edit &#39;source_directory_with_emls&#39; to your EML directory&#39;s actual path.&quot;)
    elif os.path.isdir(source_directory_with_emls):
        try:
            os.makedirs(main_output_folder, exist_ok=True)
            eml_found_in_dir = False
            for item in os.listdir(source_directory_with_emls):
                if item.lower().endswith(&quot;.eml&quot;):
                    eml_found_in_dir = True
                    full_eml_path = os.path.join(source_directory_with_emls, item)
                    process_eml_file(full_eml_path, main_output_folder)
            if not eml_found_in_dir:
                print(f&quot;OPTION 2: No .eml files found in &#39;{source_directory_with_emls}&#39;&quot;)
            else:
                print(f&quot;\nBatch processing complete. Output in: {os.path.abspath(main_output_folder)}&quot;)
        except Exception as e_main:
            print(f&quot;Error during Option 2 execution: {e_main}&quot;)
        user_has_configured_an_option = True
    else:
        print(f&quot;OPTION 2 ERROR: Directory not found at &#39;{source_directory_with_emls}&#39;&quot;)
    # &quot;&quot;&quot;


    # --- OPTION 3: Test with the EML content provided in your prompt ---
    # To use this:
    # 1. Create a file named &quot;my_test_email.eml&quot; in the SAME directory as this script.
    # 2. Paste the FULL EML content (from your original prompt) into that &quot;my_test_email.eml&quot; file and save it.
    # 3. Then, uncomment this block and run the script.
    &quot;&quot;&quot;
    test_eml_filename = &quot;my_test_email.eml&quot; 
    main_output_folder = &quot;eml_extracted_test_sample_output&quot;

    # --- Do not edit below this line for Option 3 ---
    if os.path.isfile(test_eml_filename):
        try:
            os.makedirs(main_output_folder, exist_ok=True)
            process_eml_file(test_eml_filename, main_output_folder)
            print(f&quot;\nTest file processing complete. Output in: {os.path.abspath(main_output_folder)}&quot;)
        except Exception as e_main:
            print(f&quot;Error during Option 3 execution: {e_main}&quot;)
        user_has_configured_an_option = True
    else:
        print(f&quot;OPTION 3: Test file &#39;{test_eml_filename}&#39; not found in the script&#39;s directory.&quot;)
        print(&quot;          Please create it and paste your EML content into it to use this option.&quot;)
    &quot;&quot;&quot;

    # --- If no option was uncommented and configured by the user, print detailed help ---
    if not user_has_configured_an_option:
        print(&quot;\n--- EML EXTRACTION SCRIPT HELP ---&quot;)
        print(&quot;This script extracts content and attachments from .eml (email) files.&quot;)
        print(&quot;\nTO USE THIS SCRIPT:&quot;)
        print(&quot;1. Open this Python script file (the .py file you saved) in a text editor.&quot;)
        print(&quot;2. Scroll down to the end of the file, to the section that starts with:&quot;)
        print(&quot;   &#39;if __name__ == \&quot;__main__\&quot;:&#39;&quot;)
        print(&quot;3. You will see three &#39;OPTION&#39; blocks (OPTION 1, OPTION 2, OPTION 3).&quot;)
        print(&quot;   These blocks are currently &#39;commented out&#39; with triple quote characters&quot;)
        print(&quot;   (&#39;&#39;&#39;) at their beginning and end.&quot;)
        print(&quot;\n4. CHOOSE ONLY ONE OPTION that fits your needs:&quot;)
        print(&quot;   - OPTION 1: If you want to process a single .eml file.&quot;)
        print(&quot;   - OPTION 2: If you want to process all .eml files within a specific folder.&quot;)
        print(&quot;   - OPTION 3: If you want to test the script with a sample &#39;my_test_email.eml&#39; file&quot;)
        print(&quot;               (which you need to create first, as described in the comments for Option 3).&quot;)
        print(&quot;\n5. UNCOMMENT your chosen option&#39;s block. To do this, delete the three quote&quot;)
        print(&quot;   characters (&#39;&#39;&#39;) from the very beginning of that block, AND delete the&quot;)
        print(&quot;   three quote characters (&#39;&#39;&#39;) from the very end of that SAME block.&quot;)
        print(&quot;   Make sure only ONE option block is uncommented.&quot;)
        print(&quot;\n6. IMPORTANT: Inside the option block you just uncommented, you MUST update&quot;)
        print(&quot;   the placeholder paths. For example, change:&quot;)
        print(&quot;     &#39;YOUR_SINGLE_EML_FILE_PATH_HERE.eml&#39;&quot;)
        print(&quot;   to the actual, full path of your EML file, like:&quot;)
        print(&quot;     &#39;/home/yourusername/emails/important_email.eml&#39; (for Linux/macOS)&quot;)
        print(&quot;     &#39;C:\\Users\\YourUserName\\Documents\\Emails\\archive.eml&#39; (for Windows - note double backslashes)&quot;)
        print(&quot;   Similarly, update &#39;YOUR_DIRECTORY_CONTAINING_EML_FILES_HERE&#39; if using Option 2,&quot;)
        print(&quot;   and you can customize &#39;main_output_folder&#39; if desired.&quot;)
        print(&quot;\n7. Save the changes you made to this script file.&quot;)
        print(&quot;\n8. Open a terminal or command prompt.&quot;)
        print(&quot;9. Navigate to the directory where you saved this script file using the &#39;cd&#39; command.&quot;)
        print(&quot;   (e.g., &#39;cd /path/to/where/you/saved/the_script&#39;)&quot;)
        print(&quot;10. Run the script by typing the following command and pressing Enter:&quot;)
        print(&quot;    python3 name_of_this_script.py&quot;)
        print(&quot;    (Replace &#39;name_of_this_script.py&#39; with the actual filename you used, e.g., &#39;eml_parser_revised.py&#39;)&quot;)
        print(&quot;    If &#39;python3&#39; doesn&#39;t work, try &#39;python name_of_this_script.py&#39;.&quot;)
        print(&quot;\n   The script will then run, process your EML files, and save the extracted&quot;)
        print(&quot;   content (headers, body text/html, attachments) into subdirectories within&quot;)
        print(&quot;   the &#39;main_output_folder&#39; you specified (or the default one for that option).&quot;)
        print(&quot;-----------------------------------\n&quot;)</code>
</section>

        </div>
        
          URL: https://ib.bsb.br/eml-mail-converter
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/bash-script-to-leverage-the-fclones-rust-tool-for-dedup-directories/" title="bash script to leverage the `fclones` rust tool for dedup directories" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/justfuckingusehtmlcom-html-template/" title="justfuckingusehtml.com (html template)" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scratchpad"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scratchpad" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/justfuckingusehtmlcom-html-template/" title="justfuckingusehtml.com (html template)" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="/bash-script-to-leverage-the-fclones-rust-tool-for-dedup-directories/" title="bash script to leverage the `fclones` rust tool for dedup directories" rel="next">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2025-07-20 21:32:15
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scratchpad">
                  scratchpad
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/eml-mail-converter/"
        },
        "headline": "`.eml` mail converter",
        "description": "",
        "datePublished": "2025-05-29T00:00:00+00:00",
        "dateModified": "2025-05-29T12:57:27+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
