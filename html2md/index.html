<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      
        html to markdown - infoBAG
      
    </title>
    <meta name="title" content="html to markdown - infoBAG" />
    <meta name="description" content="">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://ib.bsb.br/html2md/">
    <meta property="og:title" content="html to markdown - infoBAG">
    <meta property="og:description" content="">
    <meta property="og:image" content="/favicon.ico">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://ib.bsb.br/html2md/">
    <meta name="twitter:title" content="html to markdown - infoBAG">
    <meta name="twitter:description" content="">
    <meta name="twitter:image" content="/favicon.ico">
    <link rel="canonical" href="https://ib.bsb.br/html2md/">
    <link rel="alternate" type="application/rss+xml" title="infoBAG" href="https://ib.bsb.br/rss.xml">
    
      <meta name="keywords" content="scratchpad">
      
        <meta property="article:tag" content="scratchpad">
      
    
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    
    <link rel="stylesheet" href="/style.css">
  </head>
  <body class="post-content-body">
    <header class="header-container">
      <nav aria-label="Main navigation" class="header-content">
        <a href="/" aria-label="Home">
          <img src="/favicon.ico" alt="Home" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/tags" aria-label="Tags">
          <img src="/assets/Label.gif" alt="Tags" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/send" aria-label="send">
          <img src="/assets/rot.gif" alt="send" class="favicon search-link" width="32" height="32" loading="lazy">
        </a> 
        <a href="/created" aria-label="archive created">
          <img src="/assets/Loose_Stone_Pile.gif" alt="archive created" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/events" aria-label="Events">
          <img src="/assets/Paralyse_Rune.gif" alt="Events" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
        <a href="/modified" aria-label="archive modified">
          <img src="/assets/Hole_(Rock).gif" alt="archive modified" class="favicon search-link" width="32" height="32" loading="lazy">
        </a>
    </nav>
      <h5 class="post-title">
        <a href="#bottom-of-page" aria-label="Go to bottom">
          html to markdown
        </a>
      </h5>
      <div class="post-meta">
        <time datetime="2026-01-09T00:00:00+00:00" class="post-date">
          09 Jan 2026
        </time>
        
          <span class="post-updated">
            ↣
            <time datetime="2026-01-09T15:25:06+00:00">
              09 Jan 2026
            </time>
          </span>
        
        
          <p class="post-slug">
            Slug: <a href="https://ib.bsb.br/html2md" class="tag">html2md</a>
          </p>
        
        
          <p class="post-tags">
            Tags:
            
              <a href="https://ib.bsb.br/tags/#scratchpad" class="tag">scratchpad</a>
            
          </p>
        
      </div>
      <div class="post-actions">
        <div class="page-stats mt-3" role="status" aria-label="Page statistics">
      
      <span class="badge bg-primary">
        35129 characters
      </span>
        <span class="separator mx-2" aria-hidden="true">•</span>
        <span class="badge bg-primary">
        3032 words
      </span>
      </div>
        <div class="action-buttons d-flex flex-wrap gap-2">
          
            
              <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/edit/main/_posts/2026-01-09-html2md.md"
                    method="GET"
                    target="_blank"
                    rel="noopener noreferrer"
                    class="d-inline-block">
                <button type="submit" class="btn btn-danger" aria-label="Edit page content">
                  Improve this page
                </button>
              </form>
            
            <form action="https://github.com/ib-bsb-br/ib-bsb-br.github.io/commits/main/_posts/2026-01-09-html2md.md"
                  method="GET"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="d-inline-block">
              <button type="submit" class="btn btn-danger" aria-label="View page revision history">
                View revision history
              </button>
            </form>
          
        </div>
      </div>
    </header>
    <main class="content">
      <article class="post-wrapper">
        <div class="post-content-body">
          
<ul><li><a href="#key-behaviors">Key behaviors</a></li><li><a href="#install-and-run">Install and run</a><ul><li><a href="#generic-html-file--jekyll-post">Generic HTML file → Jekyll post</a></li><li><a href="#generic-url--jekyll-page">Generic URL → Jekyll page</a></li><li><a href="#when-heuristics-pick-the-wrong-content-container-force-it-with-a-selector">When heuristics pick the wrong content container, force it with a selector</a></li></ul></li><li><a href="#practical-limits">Practical limits</a></li><li><a href="#optional-batch-wrapper-bash">Optional batch wrapper (bash)</a></li><li><a href="#python-script">python script</a></li></ul>
          <p>It accepts a local file, a URL, or stdin; it can emit Jekyll front matter; and it uses conservative conversion rules that tend to render well on GitHub Pages (kramdown).</p>
  <h1 id="key-behaviors">
    
    
     <a href="#key-behaviors">#</a><a href="#" aria-label="Back to top">Key behaviors</a>
        
    
  </h1>
      

<ul>
  <li>Default extraction is <code class="language-plaintext highlighter-rouge">--mode main</code> (tries <code class="language-plaintext highlighter-rouge">&lt;main&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;article&gt;</code>, common content containers, then a “largest text block” heuristic).</li>
  <li>Use <code class="language-plaintext highlighter-rouge">--selector</code> when heuristics pick the wrong container.</li>
  <li>Tables become Markdown tables only when they’re simple; otherwise they become bullets.</li>
</ul>
  <h1 id="install-and-run">
    
    
     <a href="#install-and-run">#</a><a href="#" aria-label="Back to top">Install and run</a>
        
    
  </h1>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>python3 <span class="nt">-m</span> pip <span class="nb">install</span> <span class="nt">--user</span> beautifulsoup4 lxml
</code></section></div></div>
  <h2 id="generic-html-file--jekyll-post">
    
    
     <a href="#generic-html-file--jekyll-post">#</a><a href="#" aria-label="Back to top">Generic HTML file → Jekyll post</a>
        
    
  </h2>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>python3 html_to_jekyll_md.py page.html <span class="nt">-o</span> _posts/2026-01-09-page.md <span class="nt">--layout</span> post <span class="nt">--date-from-meta</span> <span class="nt">--tags</span> imported,html
</code></section></div></div>
  <h2 id="generic-url--jekyll-page">
    
    
     <a href="#generic-url--jekyll-page">#</a><a href="#" aria-label="Back to top">Generic URL → Jekyll page</a>
        
    
  </h2>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>python3 html_to_jekyll_md.py https://example.com/article <span class="nt">-o</span> docs/article.md <span class="nt">--layout</span> page <span class="nt">--permalink</span> /article/ <span class="nt">--date-from-meta</span>
</code></section></div></div>
  <h2 id="when-heuristics-pick-the-wrong-content-container-force-it-with-a-selector">
    
    
     <a href="#when-heuristics-pick-the-wrong-content-container-force-it-with-a-selector">#</a><a href="#" aria-label="Back to top">When heuristics pick the wrong content container, force it with a selector</a>
        
    
  </h2>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code>python3 html_to_jekyll_md.py page.html <span class="nt">--selector</span> <span class="s2">"article"</span> <span class="nt">-o</span> docs/page.md <span class="nt">--layout</span> page
</code></section></div></div>
  <h1 id="practical-limits">
    
    
     <a href="#practical-limits">#</a><a href="#" aria-label="Back to top">Practical limits</a>
        
    
  </h1>
      

<ul>
  <li>If the page is JavaScript-rendered (SPA shells), you need a “rendered HTML snapshot” first (browser “Save page as…”, or a headless browser step). This script converts the HTML it is given; it does not run scripts.</li>
  <li>Highly visual layouts won’t “round-trip” cleanly. The goal here is readable Markdown, not pixel-perfect reconstruction.</li>
  <li>Tables are conservative by design: broken tables are worse than bullet lists on GitHub Pages.</li>
</ul>
  <h1 id="optional-batch-wrapper-bash">
    
    
     <a href="#optional-batch-wrapper-bash">#</a><a href="#" aria-label="Back to top">Optional batch wrapper (bash)</a>
        
    
  </h1>
      

<div class="language-bash highlighter-rouge"><div class="highlight"><section><code><span class="c">#!/usr/bin/env bash</span>
<span class="nb">set</span> <span class="nt">-euo</span> pipefail

<span class="k">in</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">1</span>:?input<span class="p"> (file or URL or </span><span class="s1">'-'</span><span class="p">) required</span><span class="k">}</span><span class="s2">"</span>
<span class="nv">out</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">2</span><span class="k">:-</span><span class="nv">docs</span><span class="p">/</span><span class="si">$(</span><span class="nb">basename</span> <span class="s2">"</span><span class="k">${</span><span class="nv">in</span><span class="p">%.*</span><span class="k">}</span><span class="s2">"</span><span class="si">)</span><span class="p">.md</span><span class="k">}</span><span class="s2">"</span>

python3 ./html_to_jekyll_md.py <span class="s2">"</span><span class="nv">$in</span><span class="s2">"</span> <span class="nt">-o</span> <span class="s2">"</span><span class="nv">$out</span><span class="s2">"</span> <span class="nt">--layout</span> page <span class="nt">--date-from-meta</span>
<span class="nb">echo</span> <span class="s2">"Wrote: </span><span class="nv">$out</span><span class="s2">"</span>
</code></section></div></div>
  <h1 id="python-script">
    
    
     <a href="#python-script">#</a><a href="#" aria-label="Back to top">python script</a>
        
    
  </h1>
      

<section class="code-block-container" role="group" aria-label="Python Code Block" data-filename="python_code_block.py" data-code="#!/usr/bin/env python3
&quot;&quot;&quot;html_to_jekyll_md.py

Universal HTML → Markdown converter with Jekyll front matter.

Goals
- Accept *any* single-page HTML source: local file, URL (http/https), or stdin.
- Emit readable Markdown that works well on GitHub Pages (Jekyll + kramdown).
- Provide an optional HardInfo2 profile (because HardInfo2 uses layout tables).

Install
  python3 -m pip install beautifulsoup4
  (optional, faster/more robust parsing) python3 -m pip install lxml

Examples
  # Local file → Jekyll post
  python3 html_to_jekyll_md.py ./page.html -o _posts/2026-01-09-page.md --layout post --date-from-meta

  # URL → Jekyll page
  python3 html_to_jekyll_md.py https://example.com/article -o docs/article.md --layout page --permalink /article/

  # stdin → stdout
  cat page.html | python3 html_to_jekyll_md.py -

  # HardInfo2 report (auto-detect, or force)
  python3 html_to_jekyll_md.py hardinfo2_report.html --profile hardinfo2 -o docs/hardinfo2.md

Notes
- This converts the HTML it receives; it does not execute JavaScript.
- “Perfect” HTML→Markdown is not generally achievable. This aims for a clean, readable document.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import re
import sys
import urllib.parse
import urllib.request
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Iterable, List, Optional, Sequence, Tuple


# -----------------------------
# Parsing helpers
# -----------------------------

_WS_RE = re.compile(r&quot;[ \t\r\f\v]+&quot;)


def _require_bs4() -&gt; None:
    try:
        import bs4  # noqa: F401
    except Exception:
        print(
            &quot;ERROR: Missing dependency: beautifulsoup4\n&quot;
            &quot;  Install with: python3 -m pip install beautifulsoup4&quot;,
            file=sys.stderr,
        )
        raise


def _make_soup(html: str):
    from bs4 import BeautifulSoup

    try:
        return BeautifulSoup(html, &quot;lxml&quot;)
    except Exception:
        return BeautifulSoup(html, &quot;html.parser&quot;)


def _norm_ws_keep_newlines(s: str) -&gt; str:
    s = s.replace(&quot;\u00a0&quot;, &quot; &quot;)
    s = s.replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)
    lines = [_WS_RE.sub(&quot; &quot;, ln).strip() for ln in s.split(&quot;\n&quot;)]
    out = &quot;\n&quot;.join(lines)
    out = re.sub(r&quot;\n{3,}&quot;, &quot;\n\n&quot;, out)
    return out.strip()


def _yaml_quote(s: str) -&gt; str:
    return &#39;&quot;&#39; + s.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;) + &#39;&quot;&#39;


def _escape_md_inline(s: str) -&gt; str:
    # Minimal escaping; keep it conservative.
    return s.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;`&quot;, &quot;\\`&quot;)


def _escape_table_cell(s: str) -&gt; str:
    s = s.replace(&quot;\\&quot;, &quot;\\\\&quot;)
    s = s.replace(&quot;|&quot;, &quot;\\|&quot;)
    s = s.replace(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;)
    return s.strip()


def _collapse_blank_lines(lines: List[str]) -&gt; List[str]:
    out: List[str] = []
    blank = False
    for ln in lines:
        if not ln.strip():
            if not blank:
                out.append(&quot;&quot;)
            blank = True
        else:
            out.append(ln.rstrip())
            blank = False

    while out and out[0] == &quot;&quot;:
        out.pop(0)
    while out and out[-1] == &quot;&quot;:
        out.pop()
    return out


def _indent_lines(lines: Iterable[str], spaces: int) -&gt; List[str]:
    pad = &quot; &quot; * spaces
    return [(pad + ln) if ln else &quot;&quot; for ln in lines]


def _inline_or_codeblock(text: str) -&gt; Tuple[str, Optional[List[str]]]:
    text = _norm_ws_keep_newlines(text)
    if not text:
        return &quot;&quot;, None

    lines = [ln.rstrip() for ln in text.splitlines() if ln.strip()]
    if len(lines) &lt;= 1:
        return (lines[0] if lines else &quot;&quot;), None

    total = sum(len(ln) for ln in lines)
    if len(lines) &lt;= 3 and total &lt;= 140:
        return &quot; ; &quot;.join(lines), None

    return &quot;&quot;, [&quot;```text&quot;, *lines, &quot;```&quot;]


# -----------------------------
# Input loading
# -----------------------------


def _read_input(input_arg: str, user_agent: str = &quot;html_to_jekyll_md/1.1&quot;) -&gt; Tuple[str, Optional[str]]:
    &quot;&quot;&quot;Return (html, base_url).

    base_url is used to resolve relative links/images.
    - stdin: None
    - file: None
    - URL: the URL
    &quot;&quot;&quot;

    if input_arg == &quot;-&quot;:
        return sys.stdin.read(), None

    if re.match(r&quot;^https?://&quot;, input_arg, flags=re.IGNORECASE):
        req = urllib.request.Request(input_arg, headers={&quot;User-Agent&quot;: user_agent})
        with urllib.request.urlopen(req) as resp:
            charset = resp.headers.get_content_charset() or &quot;utf-8&quot;
            data = resp.read()
            try:
                html = data.decode(charset, errors=&quot;replace&quot;)
            except Exception:
                html = data.decode(&quot;utf-8&quot;, errors=&quot;replace&quot;)
        return html, input_arg

    path = Path(input_arg)
    return path.read_text(encoding=&quot;utf-8&quot;, errors=&quot;replace&quot;), None


def _extract_base_href(soup) -&gt; Optional[str]:
    base = soup.find(&quot;base&quot;)
    if base and base.get(&quot;href&quot;):
        return _norm_ws_keep_newlines(base[&quot;href&quot;]) or None
    return None


# -----------------------------
# Jekyll front matter
# -----------------------------


@dataclass
class FrontMatter:
    layout: str = &quot;post&quot;
    title: str = &quot;Document&quot;
    date: Optional[str] = None
    categories: Optional[List[str]] = None
    tags: Optional[List[str]] = None
    permalink: Optional[str] = None

    def render(self) -&gt; str:
        lines = [&quot;---&quot;, f&quot;layout: {self.layout}&quot;, f&quot;title: {_yaml_quote(self.title)}&quot;]
        if self.date:
            lines.append(f&quot;date: {_yaml_quote(self.date)}&quot;)
        if self.categories:
            lines.append(&quot;categories:&quot;)
            for c in self.categories:
                lines.append(f&quot;  - {c}&quot;)
        if self.tags:
            lines.append(&quot;tags:&quot;)
            for t in self.tags:
                lines.append(f&quot;  - {t}&quot;)
        if self.permalink:
            lines.append(f&quot;permalink: {self.permalink}&quot;)
        lines.append(&quot;---&quot;)
        return &quot;\n&quot;.join(lines) + &quot;\n\n&quot;


def _extract_title(soup, override: Optional[str] = None) -&gt; str:
    if override:
        return override

    t = soup.find(&quot;title&quot;)
    if t and t.get_text(strip=True):
        return _norm_ws_keep_newlines(t.get_text())

    h1 = soup.find(&quot;h1&quot;)
    if h1 and h1.get_text(strip=True):
        return _norm_ws_keep_newlines(h1.get_text())

    return &quot;Document&quot;


def _extract_date_hint(soup) -&gt; Optional[str]:
    meta_props = [
        (&quot;property&quot;, &quot;article:published_time&quot;),
        (&quot;name&quot;, &quot;date&quot;),
        (&quot;name&quot;, &quot;publish-date&quot;),
        (&quot;name&quot;, &quot;pubdate&quot;),
        (&quot;itemprop&quot;, &quot;datePublished&quot;),
    ]

    for attr, key in meta_props:
        m = soup.find(&quot;meta&quot;, attrs={attr: key})
        if m and m.get(&quot;content&quot;):
            return _norm_ws_keep_newlines(m[&quot;content&quot;])

    tm = soup.find(&quot;time&quot;)
    if tm and tm.get(&quot;datetime&quot;):
        return _norm_ws_keep_newlines(tm[&quot;datetime&quot;])

    return None


def _now_with_tz() -&gt; str:
    return datetime.now().astimezone().strftime(&quot;%Y-%m-%d %H:%M:%S %z&quot;)


# -----------------------------
# Content selection
# -----------------------------


def _strip_non_content(soup) -&gt; None:
    # Keep it conservative; do not drop “head” here.
    for sel in [&quot;script&quot;, &quot;style&quot;, &quot;noscript&quot;, &quot;template&quot;, &quot;iframe&quot;]:
        for tag in soup.select(sel):
            tag.decompose()


def _maybe_strip_chrome(root) -&gt; None:
    for sel in [&quot;nav&quot;, &quot;header&quot;, &quot;footer&quot;, &quot;aside&quot;]:
        for tag in root.find_all(sel):
            tag.decompose()


def _text_len(tag) -&gt; int:
    return len(tag.get_text(&quot; &quot;, strip=True))


def _score_candidate(tag) -&gt; int:
    text = tag.get_text(&quot; &quot;, strip=True)
    if not text:
        return 0
    text_len = len(text)
    link_text = &quot; &quot;.join(a.get_text(&quot; &quot;, strip=True) for a in tag.find_all(&quot;a&quot;))
    return max(0, text_len - int(0.7 * len(link_text)))


def _select_root(soup, mode: str, selector: Optional[str]):
    body = soup.body or soup

    if selector:
        found = soup.select_one(selector)
        return found or body

    if mode == &quot;body&quot;:
        return body

    # mode == &quot;main&quot;
    for tagname in [&quot;main&quot;, &quot;article&quot;]:
        t = body.find(tagname)
        if t and _text_len(t) &gt; 50:
            _maybe_strip_chrome(t)
            return t

    for css in [&quot;#content&quot;, &quot;#main&quot;, &quot;.content&quot;, &quot;.main&quot;, &quot;.post&quot;, &quot;.article&quot;, &quot;.entry-content&quot;]:
        t = body.select_one(css)
        if t and _text_len(t) &gt; 80:
            _maybe_strip_chrome(t)
            return t

    candidates = body.find_all([&quot;div&quot;, &quot;section&quot;, &quot;article&quot;, &quot;main&quot;], limit=250)
    best = body
    best_score = _score_candidate(body)
    for c in candidates:
        sc = _score_candidate(c)
        if sc &gt; best_score:
            best, best_score = c, sc

    _maybe_strip_chrome(best)
    return best


# -----------------------------
# HardInfo2 profile (optional)
# -----------------------------


def _looks_like_hardinfo2(soup) -&gt; bool:
    # HardInfo2 exports layout tables with these classes.
    return bool(soup.find(&quot;td&quot;, class_=&quot;stitle&quot;) or soup.find(&quot;h1&quot;, class_=&quot;title&quot;))


def _hardinfo2_text(tag) -&gt; str:
    # HardInfo2 uses &lt;br&gt; and &lt;tt&gt; blocks; preserve newlines.
    return _norm_ws_keep_newlines(tag.get_text(&quot;\n&quot;, strip=True))


def _hardinfo2_iter_rows(table):
    tbody = table.find(&quot;tbody&quot;, recursive=False)
    container = tbody if tbody else table

    for tr in container.find_all(&quot;tr&quot;, recursive=False):
        tds = tr.find_all(&quot;td&quot;, recursive=False)
        if not tds:
            continue

        if any(&quot;stitle&quot; in (td.get(&quot;class&quot;) or []) for td in tds):
            continue

        sst = tr.find(&quot;td&quot;, class_=&quot;sstitle&quot;)
        if sst:
            yield (&quot;sstitle&quot;, _hardinfo2_text(sst))
            continue

        nested_tables = tr.find_all(&quot;table&quot;)
        if nested_tables and len(tds) == 1 and tds[0].get(&quot;colspan&quot;):
            yield (&quot;details&quot;, nested_tables)
            continue

        # Drop icon columns
        data = []
        for td in tds:
            cls = td.get(&quot;class&quot;) or []
            if &quot;icon&quot; in cls or &quot;icon_subtitle&quot; in cls:
                continue
            data.append(td)
        if not data:
            continue

        if &quot;field&quot; in (data[0].get(&quot;class&quot;) or []):
            field = _hardinfo2_text(data[0])
            vals = [_hardinfo2_text(td) for td in data[1:]]
            yield (&quot;kv&quot;, (field, vals, tr.find_all(&quot;table&quot;) or None))
        else:
            yield (&quot;raw&quot;, [_hardinfo2_text(td) for td in data])


def _hardinfo2_render_table(table, heading_level: int) -&gt; List[str]:
    lines: List[str] = []

    st = table.find(&quot;td&quot;, class_=&quot;stitle&quot;)
    title = _hardinfo2_text(st) if st else None
    if title:
        lines.append(&quot;#&quot; * heading_level + f&quot; {_escape_md_inline(title)}&quot;)
        lines.append(&quot;&quot;)

    def render_details(details_table, indent=2) -&gt; List[str]:
        out: List[str] = []
        for kind, payload in _hardinfo2_iter_rows(details_table):
            if kind == &quot;sstitle&quot;:
                out.append(&quot; &quot; * indent + f&quot;- **{_escape_md_inline(payload)}**&quot;)
                continue

            if kind == &quot;details&quot;:
                for t in payload:
                    out.extend(render_details(t, indent=indent + 2))
                continue

            if kind == &quot;kv&quot;:
                field, vals, nested = payload
                val_text = &quot; | &quot;.join(v for v in vals if v)
                inline, code = _inline_or_codeblock(val_text)
                if inline:
                    out.append(&quot; &quot; * indent + f&quot;- **{_escape_md_inline(field)}:** {_escape_md_inline(inline)}&quot;)
                else:
                    out.append(&quot; &quot; * indent + f&quot;- **{_escape_md_inline(field)}:**&quot;)
                    out.extend(_indent_lines(code or [], indent + 4))
                if nested:
                    for t in nested:
                        out.extend(render_details(t, indent=indent + 2))
                continue

            if kind == &quot;raw&quot;:
                txt = &quot; | &quot;.join(payload)
                inline, code = _inline_or_codeblock(txt)
                if inline:
                    out.append(&quot; &quot; * indent + f&quot;- {_escape_md_inline(inline)}&quot;)
                else:
                    out.append(&quot; &quot; * indent + &quot;-&quot;)
                    out.extend(_indent_lines(code or [], indent + 4))

        return out

    for kind, payload in _hardinfo2_iter_rows(table):
        if kind == &quot;sstitle&quot;:
            lines.append(&quot;#&quot; * (heading_level + 1) + f&quot; {_escape_md_inline(payload)}&quot;)
            lines.append(&quot;&quot;)
            continue

        if kind == &quot;details&quot;:
            lines.append(&quot;- **Details:**&quot;)
            for t in payload:
                lines.extend(render_details(t, indent=2))
            lines.append(&quot;&quot;)
            continue

        if kind == &quot;kv&quot;:
            field, vals, nested = payload
            val_text = &quot; | &quot;.join(v for v in vals if v)
            inline, code = _inline_or_codeblock(val_text)
            if inline:
                lines.append(f&quot;- **{_escape_md_inline(field)}:** {_escape_md_inline(inline)}&quot;)
            else:
                lines.append(f&quot;- **{_escape_md_inline(field)}:**&quot;)
                lines.extend(_indent_lines(code or [], 4))
            if nested:
                for t in nested:
                    lines.extend(render_details(t, indent=2))
            continue

        if kind == &quot;raw&quot;:
            txt = &quot; | &quot;.join(payload)
            inline, code = _inline_or_codeblock(txt)
            if inline:
                lines.append(f&quot;- {_escape_md_inline(inline)}&quot;)
            else:
                lines.append(&quot;-&quot;)
                lines.extend(_indent_lines(code or [], 4))

    lines.append(&quot;&quot;)
    return lines


def _hardinfo2_convert(html: str, section_heading_level: int = 2) -&gt; str:
    soup = _make_soup(html)
    root = soup.body or soup

    out: List[str] = []
    for el in root.find_all([&quot;h1&quot;, &quot;table&quot;], recursive=True):
        if el.name == &quot;h1&quot; and &quot;title&quot; in (el.get(&quot;class&quot;) or []):
            out.append(&quot;#&quot; * section_heading_level + f&quot; {_escape_md_inline(_hardinfo2_text(el))}&quot;)
            out.append(&quot;&quot;)
        elif el.name == &quot;table&quot; and el.find_parent(&quot;table&quot;) is None:
            out.extend(_hardinfo2_render_table(el, heading_level=section_heading_level + 1))

    return &quot;\n&quot;.join(_collapse_blank_lines(out)) + &quot;\n&quot;


# -----------------------------
# Generic HTML → Markdown
# -----------------------------


BLOCK_TAGS = {
    &quot;p&quot;,
    &quot;div&quot;,
    &quot;section&quot;,
    &quot;article&quot;,
    &quot;main&quot;,
    &quot;pre&quot;,
    &quot;blockquote&quot;,
    &quot;ul&quot;,
    &quot;ol&quot;,
    &quot;table&quot;,
    &quot;hr&quot;,
    &quot;h1&quot;,
    &quot;h2&quot;,
    &quot;h3&quot;,
    &quot;h4&quot;,
    &quot;h5&quot;,
    &quot;h6&quot;,
}


class _Ctx:
    def __init__(
        self,
        base_url: Optional[str],
        keep_images: bool,
        heading_offset: int,
        max_heading_level: int,
    ):
        self.base_url = base_url
        self.keep_images = keep_images
        self.heading_offset = heading_offset
        self.max_heading_level = max_heading_level


def _resolve_url(href: str, base_url: Optional[str]) -&gt; str:
    if not href:
        return &quot;&quot;
    return urllib.parse.urljoin(base_url, href) if base_url else href


def _extract_text(tag) -&gt; str:
    return _norm_ws_keep_newlines(tag.get_text(&quot; &quot;, strip=True))


def _convert_children(tag, ctx: _Ctx) -&gt; List[str]:
    from bs4 import NavigableString, Tag

    out: List[str] = []
    for child in tag.children:
        if isinstance(child, NavigableString):
            txt = _norm_ws_keep_newlines(str(child))
            if txt:
                out.append(txt)
            continue
        if isinstance(child, Tag):
            out.extend(_convert_node(child, ctx))
    return out


def _convert_children_inline(tag, ctx: _Ctx) -&gt; List[str]:
    from bs4 import NavigableString, Tag

    out: List[str] = []
    for child in tag.children:
        if isinstance(child, NavigableString):
            txt = _norm_ws_keep_newlines(str(child))
            if txt:
                out.append(txt)
            continue
        if isinstance(child, Tag):
            out.append(_convert_inline(child, ctx))
    return out


def _convert_inline(tag, ctx: _Ctx) -&gt; str:
    name = tag.name.lower()

    if name in (&quot;span&quot;, &quot;label&quot;, &quot;small&quot;, &quot;sup&quot;, &quot;sub&quot;):
        return &quot;&quot;.join(_convert_children_inline(tag, ctx))

    if name in (&quot;strong&quot;, &quot;b&quot;):
        inner = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        return f&quot;**{inner}**&quot; if inner else &quot;&quot;

    if name in (&quot;em&quot;, &quot;i&quot;):
        inner = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        return f&quot;*{inner}*&quot; if inner else &quot;&quot;

    if name == &quot;code&quot;:
        inner = _extract_text(tag)
        if &quot;`&quot; in inner:
            return f&quot;``{inner}``&quot;
        return f&quot;`{inner}`&quot;

    if name == &quot;br&quot;:
        return &quot;  \n&quot;

    if name == &quot;a&quot;:
        href = _resolve_url(tag.get(&quot;href&quot;, &quot;&quot;), ctx.base_url)
        text = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip() or href
        return f&quot;[{text}]({href})&quot; if href else text

    if name == &quot;img&quot;:
        if not ctx.keep_images:
            return &quot;&quot;
        alt = (tag.get(&quot;alt&quot;) or &quot;image&quot;).strip() or &quot;image&quot;
        src = _resolve_url(tag.get(&quot;src&quot;, &quot;&quot;), ctx.base_url)
        return f&quot;![{_escape_md_inline(alt)}]({src})&quot; if src else &quot;&quot;

    return &quot;&quot;.join(_convert_children_inline(tag, ctx))


def _table_to_bullets(table, ctx: _Ctx) -&gt; List[str]:
    lines: List[str] = []
    tbody = table.find(&quot;tbody&quot;, recursive=False)
    container = tbody if tbody else table

    for tr in container.find_all(&quot;tr&quot;, recursive=False):
        cells = tr.find_all([&quot;th&quot;, &quot;td&quot;], recursive=False)
        if not cells:
            continue
        vals = [_extract_text(td) for td in cells]
        vals = [v for v in vals if v]
        if not vals:
            continue
        txt = &quot; | &quot;.join(vals)
        inline, code = _inline_or_codeblock(txt)
        if inline:
            lines.append(f&quot;- {_escape_md_inline(inline)}&quot;)
        else:
            lines.append(&quot;-&quot;)
            lines.extend(_indent_lines(code or [], 4))

    lines.append(&quot;&quot;)
    return lines


def _table_to_md(table, ctx: _Ctx) -&gt; List[str]:
    if table.find(&quot;table&quot;):
        return _table_to_bullets(table, ctx)

    rows: List[List[str]] = []
    tbody = table.find(&quot;tbody&quot;, recursive=False)
    container = tbody if tbody else table

    for tr in container.find_all(&quot;tr&quot;, recursive=False):
        cells = tr.find_all([&quot;th&quot;, &quot;td&quot;], recursive=False)
        if not cells:
            continue
        rows.append([_extract_text(td) for td in cells])

    if not rows:
        return []

    has_th = bool(table.find(&quot;th&quot;))
    header = rows[0] if has_th else None
    body_rows = rows[1:] if has_th else rows

    if header is None:
        first = rows[0]
        if first and all(len(c) &lt;= 40 for c in first) and len(first) &lt;= 6:
            header = first
            body_rows = rows[1:]
        else:
            header = [f&quot;Col {i+1}&quot; for i in range(len(rows[0]))]
            body_rows = rows

    col_count = max(len(header), *(len(r) for r in body_rows))

    def pad(r: List[str]) -&gt; List[str]:
        return (r + [&quot;&quot;] * col_count)[:col_count]

    header = pad(header)

    lines: List[str] = []
    lines.append(&quot;| &quot; + &quot; | &quot;.join(_escape_table_cell(c) for c in header) + &quot; |&quot;)
    lines.append(&quot;|&quot; + &quot;|&quot;.join([&quot;---&quot;] * col_count) + &quot;|&quot;)

    for r in body_rows:
        r = pad(r)
        if any(&quot;\n&quot; in c for c in r):
            return _table_to_bullets(table, ctx)
        lines.append(&quot;| &quot; + &quot; | &quot;.join(_escape_table_cell(c) for c in r) + &quot; |&quot;)

    lines.append(&quot;&quot;)
    return lines


def _list_to_md(list_tag, ordered: bool, ctx: _Ctx, indent: int = 0) -&gt; List[str]:
    from bs4 import Tag

    lines: List[str] = []
    items = [li for li in list_tag.find_all(&quot;li&quot;, recursive=False) if isinstance(li, Tag)]

    for idx, li in enumerate(items, start=1):
        prefix = f&quot;{idx}. &quot; if ordered else &quot;- &quot;
        cont_indent = indent + len(prefix)

        # Build “main line” from inline-ish children and the first paragraph-ish block.
        main_fragments: List[str] = []
        extra_blocks: List[List[str]] = []

        for child in li.children:
            if isinstance(child, Tag) and child.name.lower() in (&quot;ul&quot;, &quot;ol&quot;):
                continue

            if isinstance(child, Tag) and child.name.lower() in BLOCK_TAGS:
                block_lines = _convert_node(child, ctx)
                block_lines = _collapse_blank_lines(block_lines)
                if block_lines:
                    if not main_fragments:
                        # Use first non-empty line as the main line.
                        first_line = next((x for x in block_lines if x.strip()), &quot;&quot;)
                        if first_line:
                            main_fragments.append(first_line)
                        rest = [x for x in block_lines if x.strip()][1:]
                        if rest:
                            extra_blocks.append(rest)
                    else:
                        extra_blocks.append([x for x in block_lines if x.strip()])
                continue

            if isinstance(child, Tag):
                main_fragments.append(_convert_inline(child, ctx))
            else:
                txt = _norm_ws_keep_newlines(str(child))
                if txt:
                    main_fragments.append(txt)

        main_line = _norm_ws_keep_newlines(&quot;&quot;.join(main_fragments)).strip()
        lines.append(&quot; &quot; * indent + prefix + main_line)

        for block in extra_blocks:
            for ln in block:
                lines.append(&quot; &quot; * cont_indent + ln)

        for child in li.find_all([&quot;ul&quot;, &quot;ol&quot;], recursive=False):
            lines.extend(_list_to_md(child, ordered=(child.name.lower() == &quot;ol&quot;), ctx=ctx, indent=indent + 2))

    lines.append(&quot;&quot;)
    return lines


def _convert_node(tag, ctx: _Ctx) -&gt; List[str]:
    name = tag.name.lower()

    if name in (&quot;script&quot;, &quot;style&quot;, &quot;noscript&quot;, &quot;template&quot;):
        return []

    if name in (&quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;):
        lvl = int(name[1]) + ctx.heading_offset
        lvl = max(1, min(ctx.max_heading_level, lvl))
        text = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        text = _norm_ws_keep_newlines(text)
        return [&quot;#&quot; * lvl + f&quot; {_escape_md_inline(text)}&quot;, &quot;&quot;] if text else []

    if name == &quot;p&quot;:
        text = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        text = _norm_ws_keep_newlines(text)
        return [text, &quot;&quot;] if text else []

    if name == &quot;hr&quot;:
        return [&quot;---&quot;, &quot;&quot;]

    if name == &quot;blockquote&quot;:
        inner = _collapse_blank_lines(_convert_children(tag, ctx))
        quoted: List[str] = []
        for ln in inner:
            quoted.append(&quot;&gt;&quot; if not ln.strip() else &quot;&gt; &quot; + ln)
        quoted.append(&quot;&quot;)
        return quoted

    if name == &quot;pre&quot;:
        # Try to infer a language from pre/code classes.
        lang = &quot;&quot;
        cls = &quot; &quot;.join(tag.get(&quot;class&quot;) or [])
        m = re.search(r&quot;language-([a-zA-Z0-9_+-]+)&quot;, cls)
        if not m:
            code = tag.find(&quot;code&quot;)
            if code:
                cls2 = &quot; &quot;.join(code.get(&quot;class&quot;) or [])
                m = re.search(r&quot;language-([a-zA-Z0-9_+-]+)&quot;, cls2)
        if m:
            lang = m.group(1)

        code_text = tag.get_text(&quot;\n&quot;, strip=False).replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)
        lines = code_text.splitlines()
        while lines and not lines[0].strip():
            lines.pop(0)
        while lines and not lines[-1].strip():
            lines.pop()
        return [f&quot;```{lang}&quot;.rstrip(), *lines, &quot;```&quot;, &quot;&quot;]

    if name == &quot;ul&quot;:
        return _list_to_md(tag, ordered=False, ctx=ctx)

    if name == &quot;ol&quot;:
        return _list_to_md(tag, ordered=True, ctx=ctx)

    if name == &quot;table&quot;:
        return _table_to_md(tag, ctx)

    if name == &quot;img&quot;:
        inline = _convert_inline(tag, ctx)
        return [inline, &quot;&quot;] if inline else []

    if name in (&quot;div&quot;, &quot;section&quot;, &quot;article&quot;, &quot;main&quot;, &quot;body&quot;):
        return _convert_children(tag, ctx)

    inline = _convert_inline(tag, ctx).strip()
    return [inline] if inline else []


def _generic_convert(
    html: str,
    *,
    base_url: Optional[str],
    mode: str,
    selector: Optional[str],
    keep_images: bool,
    heading_offset: int,
    max_heading_level: int,
) -&gt; str:
    soup = _make_soup(html)
    _strip_non_content(soup)

    root = _select_root(soup, mode=mode, selector=selector)
    ctx = _Ctx(
        base_url=base_url,
        keep_images=keep_images,
        heading_offset=heading_offset,
        max_heading_level=max_heading_level,
    )

    lines = _convert_children(root, ctx)
    lines = _collapse_blank_lines(lines)
    return &quot;\n&quot;.join(lines) + &quot;\n&quot;


def convert_html_to_markdown(
    html: str,
    *,
    base_url: Optional[str] = None,
    mode: str = &quot;main&quot;,  # main|body
    selector: Optional[str] = None,
    keep_images: bool = False,
    heading_offset: int = 0,
    max_heading_level: int = 6,
    profile: str = &quot;auto&quot;,  # auto|generic|hardinfo2
    hardinfo_section_level: int = 2,
) -&gt; str:
    soup = _make_soup(html)
    _strip_non_content(soup)

    if profile == &quot;hardinfo2&quot; or (profile == &quot;auto&quot; and _looks_like_hardinfo2(soup)):
        return _hardinfo2_convert(html, section_heading_level=max(1, hardinfo_section_level))

    return _generic_convert(
        html,
        base_url=base_url,
        mode=mode,
        selector=selector,
        keep_images=keep_images,
        heading_offset=heading_offset,
        max_heading_level=max(1, max_heading_level),
    )


# -----------------------------
# CLI
# -----------------------------


def main(argv: Optional[Sequence[str]] = None) -&gt; int:
    _require_bs4()

    p = argparse.ArgumentParser(description=&quot;Convert HTML (file/URL/stdin) to Jekyll-friendly Markdown&quot;)
    p.add_argument(&quot;input&quot;, help=&quot;Path, URL, or &#39;-&#39; for stdin&quot;)
    p.add_argument(&quot;-o&quot;, &quot;--output&quot;, type=Path, default=None, help=&quot;Output .md file (default: stdout)&quot;)

    # Front matter
    p.add_argument(&quot;--no-front-matter&quot;, action=&quot;store_true&quot;, help=&quot;Do not emit YAML front matter&quot;)
    p.add_argument(&quot;--layout&quot;, default=&quot;post&quot;, help=&quot;Front matter layout (default: post)&quot;)
    p.add_argument(&quot;--title&quot;, default=None, help=&quot;Front matter title override&quot;)
    p.add_argument(&quot;--date&quot;, default=None, help=&quot;Front matter date override&quot;)
    p.add_argument(&quot;--date-from-meta&quot;, action=&quot;store_true&quot;, help=&quot;Try to extract date from meta/time tags&quot;)
    p.add_argument(&quot;--categories&quot;, default=None, help=&quot;Comma-separated categories&quot;)
    p.add_argument(&quot;--tags&quot;, default=None, help=&quot;Comma-separated tags&quot;)
    p.add_argument(&quot;--permalink&quot;, default=None, help=&quot;Front matter permalink&quot;)

    # Conversion knobs
    p.add_argument(&quot;--mode&quot;, choices=[&quot;main&quot;, &quot;body&quot;], default=&quot;main&quot;, help=&quot;Content selection mode&quot;)
    p.add_argument(&quot;--selector&quot;, default=None, help=&quot;CSS selector to choose content root (overrides --mode)&quot;)
    p.add_argument(&quot;--base-url&quot;, default=None, help=&quot;Base URL for resolving relative links/images&quot;)
    p.add_argument(&quot;--keep-images&quot;, action=&quot;store_true&quot;, help=&quot;Include &lt;img&gt; as Markdown images&quot;)
    p.add_argument(&quot;--heading-offset&quot;, type=int, default=0, help=&quot;Add to heading levels (e.g., 1 makes h1→h2)&quot;)
    p.add_argument(&quot;--max-heading-level&quot;, type=int, default=6, help=&quot;Clamp max heading depth (default: 6)&quot;)

    # Profiles
    p.add_argument(
        &quot;--profile&quot;,
        choices=[&quot;auto&quot;, &quot;generic&quot;, &quot;hardinfo2&quot;],
        default=&quot;auto&quot;,
        help=&quot;auto detects HardInfo2; otherwise force generic/hardinfo2&quot;,
    )
    p.add_argument(
        &quot;--hardinfo-section-level&quot;,
        type=int,
        default=2,
        help=&quot;Heading level for HardInfo2 section titles (default: 2)&quot;,
    )

    args = p.parse_args(argv)

    html, inferred_base = _read_input(args.input)
    soup = _make_soup(html)

    # Base URL: CLI &gt; &lt;base href&gt; &gt; inferred (URL input)
    base_url = args.base_url or _extract_base_href(soup) or inferred_base

    fm = None
    if not args.no_front_matter:
        title = _extract_title(soup, args.title)
        date = args.date
        if not date and args.date_from_meta:
            date = _extract_date_hint(soup)
        if not date:
            date = _now_with_tz()

        fm = FrontMatter(
            layout=args.layout,
            title=title,
            date=date,
            categories=[c.strip() for c in (args.categories or &quot;&quot;).split(&quot;,&quot;) if c.strip()] or None,
            tags=[t.strip() for t in (args.tags or &quot;&quot;).split(&quot;,&quot;) if t.strip()] or None,
            permalink=args.permalink,
        )

    md_body = convert_html_to_markdown(
        html,
        base_url=base_url,
        mode=args.mode,
        selector=args.selector,
        keep_images=args.keep_images,
        heading_offset=args.heading_offset,
        max_heading_level=args.max_heading_level,
        profile=args.profile,
        hardinfo_section_level=args.hardinfo_section_level,
    )

    out_text = (fm.render() if fm else &quot;&quot;) + md_body

    if args.output:
        args.output.parent.mkdir(parents=True, exist_ok=True)
        args.output.write_text(out_text, encoding=&quot;utf-8&quot;)
    else:
        sys.stdout.write(out_text)

    return 0


if __name__ == &quot;__main__&quot;:
    raise SystemExit(main())" data-download-link="" data-download-label="Download Python">
  <code class="language-python">#!/usr/bin/env python3
&quot;&quot;&quot;html_to_jekyll_md.py

Universal HTML → Markdown converter with Jekyll front matter.

Goals
- Accept *any* single-page HTML source: local file, URL (http/https), or stdin.
- Emit readable Markdown that works well on GitHub Pages (Jekyll + kramdown).
- Provide an optional HardInfo2 profile (because HardInfo2 uses layout tables).

Install
  python3 -m pip install beautifulsoup4
  (optional, faster/more robust parsing) python3 -m pip install lxml

Examples
  # Local file → Jekyll post
  python3 html_to_jekyll_md.py ./page.html -o _posts/2026-01-09-page.md --layout post --date-from-meta

  # URL → Jekyll page
  python3 html_to_jekyll_md.py https://example.com/article -o docs/article.md --layout page --permalink /article/

  # stdin → stdout
  cat page.html | python3 html_to_jekyll_md.py -

  # HardInfo2 report (auto-detect, or force)
  python3 html_to_jekyll_md.py hardinfo2_report.html --profile hardinfo2 -o docs/hardinfo2.md

Notes
- This converts the HTML it receives; it does not execute JavaScript.
- “Perfect” HTML→Markdown is not generally achievable. This aims for a clean, readable document.
&quot;&quot;&quot;

from __future__ import annotations

import argparse
import re
import sys
import urllib.parse
import urllib.request
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Iterable, List, Optional, Sequence, Tuple


# -----------------------------
# Parsing helpers
# -----------------------------

_WS_RE = re.compile(r&quot;[ \t\r\f\v]+&quot;)


def _require_bs4() -&gt; None:
    try:
        import bs4  # noqa: F401
    except Exception:
        print(
            &quot;ERROR: Missing dependency: beautifulsoup4\n&quot;
            &quot;  Install with: python3 -m pip install beautifulsoup4&quot;,
            file=sys.stderr,
        )
        raise


def _make_soup(html: str):
    from bs4 import BeautifulSoup

    try:
        return BeautifulSoup(html, &quot;lxml&quot;)
    except Exception:
        return BeautifulSoup(html, &quot;html.parser&quot;)


def _norm_ws_keep_newlines(s: str) -&gt; str:
    s = s.replace(&quot;\u00a0&quot;, &quot; &quot;)
    s = s.replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)
    lines = [_WS_RE.sub(&quot; &quot;, ln).strip() for ln in s.split(&quot;\n&quot;)]
    out = &quot;\n&quot;.join(lines)
    out = re.sub(r&quot;\n{3,}&quot;, &quot;\n\n&quot;, out)
    return out.strip()


def _yaml_quote(s: str) -&gt; str:
    return &#39;&quot;&#39; + s.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;) + &#39;&quot;&#39;


def _escape_md_inline(s: str) -&gt; str:
    # Minimal escaping; keep it conservative.
    return s.replace(&quot;\\&quot;, &quot;\\\\&quot;).replace(&quot;`&quot;, &quot;\\`&quot;)


def _escape_table_cell(s: str) -&gt; str:
    s = s.replace(&quot;\\&quot;, &quot;\\\\&quot;)
    s = s.replace(&quot;|&quot;, &quot;\\|&quot;)
    s = s.replace(&quot;\n&quot;, &quot;&lt;br /&gt;&quot;)
    return s.strip()


def _collapse_blank_lines(lines: List[str]) -&gt; List[str]:
    out: List[str] = []
    blank = False
    for ln in lines:
        if not ln.strip():
            if not blank:
                out.append(&quot;&quot;)
            blank = True
        else:
            out.append(ln.rstrip())
            blank = False

    while out and out[0] == &quot;&quot;:
        out.pop(0)
    while out and out[-1] == &quot;&quot;:
        out.pop()
    return out


def _indent_lines(lines: Iterable[str], spaces: int) -&gt; List[str]:
    pad = &quot; &quot; * spaces
    return [(pad + ln) if ln else &quot;&quot; for ln in lines]


def _inline_or_codeblock(text: str) -&gt; Tuple[str, Optional[List[str]]]:
    text = _norm_ws_keep_newlines(text)
    if not text:
        return &quot;&quot;, None

    lines = [ln.rstrip() for ln in text.splitlines() if ln.strip()]
    if len(lines) &lt;= 1:
        return (lines[0] if lines else &quot;&quot;), None

    total = sum(len(ln) for ln in lines)
    if len(lines) &lt;= 3 and total &lt;= 140:
        return &quot; ; &quot;.join(lines), None

    return &quot;&quot;, [&quot;```text&quot;, *lines, &quot;```&quot;]


# -----------------------------
# Input loading
# -----------------------------


def _read_input(input_arg: str, user_agent: str = &quot;html_to_jekyll_md/1.1&quot;) -&gt; Tuple[str, Optional[str]]:
    &quot;&quot;&quot;Return (html, base_url).

    base_url is used to resolve relative links/images.
    - stdin: None
    - file: None
    - URL: the URL
    &quot;&quot;&quot;

    if input_arg == &quot;-&quot;:
        return sys.stdin.read(), None

    if re.match(r&quot;^https?://&quot;, input_arg, flags=re.IGNORECASE):
        req = urllib.request.Request(input_arg, headers={&quot;User-Agent&quot;: user_agent})
        with urllib.request.urlopen(req) as resp:
            charset = resp.headers.get_content_charset() or &quot;utf-8&quot;
            data = resp.read()
            try:
                html = data.decode(charset, errors=&quot;replace&quot;)
            except Exception:
                html = data.decode(&quot;utf-8&quot;, errors=&quot;replace&quot;)
        return html, input_arg

    path = Path(input_arg)
    return path.read_text(encoding=&quot;utf-8&quot;, errors=&quot;replace&quot;), None


def _extract_base_href(soup) -&gt; Optional[str]:
    base = soup.find(&quot;base&quot;)
    if base and base.get(&quot;href&quot;):
        return _norm_ws_keep_newlines(base[&quot;href&quot;]) or None
    return None


# -----------------------------
# Jekyll front matter
# -----------------------------


@dataclass
class FrontMatter:
    layout: str = &quot;post&quot;
    title: str = &quot;Document&quot;
    date: Optional[str] = None
    categories: Optional[List[str]] = None
    tags: Optional[List[str]] = None
    permalink: Optional[str] = None

    def render(self) -&gt; str:
        lines = [&quot;---&quot;, f&quot;layout: {self.layout}&quot;, f&quot;title: {_yaml_quote(self.title)}&quot;]
        if self.date:
            lines.append(f&quot;date: {_yaml_quote(self.date)}&quot;)
        if self.categories:
            lines.append(&quot;categories:&quot;)
            for c in self.categories:
                lines.append(f&quot;  - {c}&quot;)
        if self.tags:
            lines.append(&quot;tags:&quot;)
            for t in self.tags:
                lines.append(f&quot;  - {t}&quot;)
        if self.permalink:
            lines.append(f&quot;permalink: {self.permalink}&quot;)
        lines.append(&quot;---&quot;)
        return &quot;\n&quot;.join(lines) + &quot;\n\n&quot;


def _extract_title(soup, override: Optional[str] = None) -&gt; str:
    if override:
        return override

    t = soup.find(&quot;title&quot;)
    if t and t.get_text(strip=True):
        return _norm_ws_keep_newlines(t.get_text())

    h1 = soup.find(&quot;h1&quot;)
    if h1 and h1.get_text(strip=True):
        return _norm_ws_keep_newlines(h1.get_text())

    return &quot;Document&quot;


def _extract_date_hint(soup) -&gt; Optional[str]:
    meta_props = [
        (&quot;property&quot;, &quot;article:published_time&quot;),
        (&quot;name&quot;, &quot;date&quot;),
        (&quot;name&quot;, &quot;publish-date&quot;),
        (&quot;name&quot;, &quot;pubdate&quot;),
        (&quot;itemprop&quot;, &quot;datePublished&quot;),
    ]

    for attr, key in meta_props:
        m = soup.find(&quot;meta&quot;, attrs={attr: key})
        if m and m.get(&quot;content&quot;):
            return _norm_ws_keep_newlines(m[&quot;content&quot;])

    tm = soup.find(&quot;time&quot;)
    if tm and tm.get(&quot;datetime&quot;):
        return _norm_ws_keep_newlines(tm[&quot;datetime&quot;])

    return None


def _now_with_tz() -&gt; str:
    return datetime.now().astimezone().strftime(&quot;%Y-%m-%d %H:%M:%S %z&quot;)


# -----------------------------
# Content selection
# -----------------------------


def _strip_non_content(soup) -&gt; None:
    # Keep it conservative; do not drop “head” here.
    for sel in [&quot;script&quot;, &quot;style&quot;, &quot;noscript&quot;, &quot;template&quot;, &quot;iframe&quot;]:
        for tag in soup.select(sel):
            tag.decompose()


def _maybe_strip_chrome(root) -&gt; None:
    for sel in [&quot;nav&quot;, &quot;header&quot;, &quot;footer&quot;, &quot;aside&quot;]:
        for tag in root.find_all(sel):
            tag.decompose()


def _text_len(tag) -&gt; int:
    return len(tag.get_text(&quot; &quot;, strip=True))


def _score_candidate(tag) -&gt; int:
    text = tag.get_text(&quot; &quot;, strip=True)
    if not text:
        return 0
    text_len = len(text)
    link_text = &quot; &quot;.join(a.get_text(&quot; &quot;, strip=True) for a in tag.find_all(&quot;a&quot;))
    return max(0, text_len - int(0.7 * len(link_text)))


def _select_root(soup, mode: str, selector: Optional[str]):
    body = soup.body or soup

    if selector:
        found = soup.select_one(selector)
        return found or body

    if mode == &quot;body&quot;:
        return body

    # mode == &quot;main&quot;
    for tagname in [&quot;main&quot;, &quot;article&quot;]:
        t = body.find(tagname)
        if t and _text_len(t) &gt; 50:
            _maybe_strip_chrome(t)
            return t

    for css in [&quot;#content&quot;, &quot;#main&quot;, &quot;.content&quot;, &quot;.main&quot;, &quot;.post&quot;, &quot;.article&quot;, &quot;.entry-content&quot;]:
        t = body.select_one(css)
        if t and _text_len(t) &gt; 80:
            _maybe_strip_chrome(t)
            return t

    candidates = body.find_all([&quot;div&quot;, &quot;section&quot;, &quot;article&quot;, &quot;main&quot;], limit=250)
    best = body
    best_score = _score_candidate(body)
    for c in candidates:
        sc = _score_candidate(c)
        if sc &gt; best_score:
            best, best_score = c, sc

    _maybe_strip_chrome(best)
    return best


# -----------------------------
# HardInfo2 profile (optional)
# -----------------------------


def _looks_like_hardinfo2(soup) -&gt; bool:
    # HardInfo2 exports layout tables with these classes.
    return bool(soup.find(&quot;td&quot;, class_=&quot;stitle&quot;) or soup.find(&quot;h1&quot;, class_=&quot;title&quot;))


def _hardinfo2_text(tag) -&gt; str:
    # HardInfo2 uses &lt;br&gt; and &lt;tt&gt; blocks; preserve newlines.
    return _norm_ws_keep_newlines(tag.get_text(&quot;\n&quot;, strip=True))


def _hardinfo2_iter_rows(table):
    tbody = table.find(&quot;tbody&quot;, recursive=False)
    container = tbody if tbody else table

    for tr in container.find_all(&quot;tr&quot;, recursive=False):
        tds = tr.find_all(&quot;td&quot;, recursive=False)
        if not tds:
            continue

        if any(&quot;stitle&quot; in (td.get(&quot;class&quot;) or []) for td in tds):
            continue

        sst = tr.find(&quot;td&quot;, class_=&quot;sstitle&quot;)
        if sst:
            yield (&quot;sstitle&quot;, _hardinfo2_text(sst))
            continue

        nested_tables = tr.find_all(&quot;table&quot;)
        if nested_tables and len(tds) == 1 and tds[0].get(&quot;colspan&quot;):
            yield (&quot;details&quot;, nested_tables)
            continue

        # Drop icon columns
        data = []
        for td in tds:
            cls = td.get(&quot;class&quot;) or []
            if &quot;icon&quot; in cls or &quot;icon_subtitle&quot; in cls:
                continue
            data.append(td)
        if not data:
            continue

        if &quot;field&quot; in (data[0].get(&quot;class&quot;) or []):
            field = _hardinfo2_text(data[0])
            vals = [_hardinfo2_text(td) for td in data[1:]]
            yield (&quot;kv&quot;, (field, vals, tr.find_all(&quot;table&quot;) or None))
        else:
            yield (&quot;raw&quot;, [_hardinfo2_text(td) for td in data])


def _hardinfo2_render_table(table, heading_level: int) -&gt; List[str]:
    lines: List[str] = []

    st = table.find(&quot;td&quot;, class_=&quot;stitle&quot;)
    title = _hardinfo2_text(st) if st else None
    if title:
        lines.append(&quot;#&quot; * heading_level + f&quot; {_escape_md_inline(title)}&quot;)
        lines.append(&quot;&quot;)

    def render_details(details_table, indent=2) -&gt; List[str]:
        out: List[str] = []
        for kind, payload in _hardinfo2_iter_rows(details_table):
            if kind == &quot;sstitle&quot;:
                out.append(&quot; &quot; * indent + f&quot;- **{_escape_md_inline(payload)}**&quot;)
                continue

            if kind == &quot;details&quot;:
                for t in payload:
                    out.extend(render_details(t, indent=indent + 2))
                continue

            if kind == &quot;kv&quot;:
                field, vals, nested = payload
                val_text = &quot; | &quot;.join(v for v in vals if v)
                inline, code = _inline_or_codeblock(val_text)
                if inline:
                    out.append(&quot; &quot; * indent + f&quot;- **{_escape_md_inline(field)}:** {_escape_md_inline(inline)}&quot;)
                else:
                    out.append(&quot; &quot; * indent + f&quot;- **{_escape_md_inline(field)}:**&quot;)
                    out.extend(_indent_lines(code or [], indent + 4))
                if nested:
                    for t in nested:
                        out.extend(render_details(t, indent=indent + 2))
                continue

            if kind == &quot;raw&quot;:
                txt = &quot; | &quot;.join(payload)
                inline, code = _inline_or_codeblock(txt)
                if inline:
                    out.append(&quot; &quot; * indent + f&quot;- {_escape_md_inline(inline)}&quot;)
                else:
                    out.append(&quot; &quot; * indent + &quot;-&quot;)
                    out.extend(_indent_lines(code or [], indent + 4))

        return out

    for kind, payload in _hardinfo2_iter_rows(table):
        if kind == &quot;sstitle&quot;:
            lines.append(&quot;#&quot; * (heading_level + 1) + f&quot; {_escape_md_inline(payload)}&quot;)
            lines.append(&quot;&quot;)
            continue

        if kind == &quot;details&quot;:
            lines.append(&quot;- **Details:**&quot;)
            for t in payload:
                lines.extend(render_details(t, indent=2))
            lines.append(&quot;&quot;)
            continue

        if kind == &quot;kv&quot;:
            field, vals, nested = payload
            val_text = &quot; | &quot;.join(v for v in vals if v)
            inline, code = _inline_or_codeblock(val_text)
            if inline:
                lines.append(f&quot;- **{_escape_md_inline(field)}:** {_escape_md_inline(inline)}&quot;)
            else:
                lines.append(f&quot;- **{_escape_md_inline(field)}:**&quot;)
                lines.extend(_indent_lines(code or [], 4))
            if nested:
                for t in nested:
                    lines.extend(render_details(t, indent=2))
            continue

        if kind == &quot;raw&quot;:
            txt = &quot; | &quot;.join(payload)
            inline, code = _inline_or_codeblock(txt)
            if inline:
                lines.append(f&quot;- {_escape_md_inline(inline)}&quot;)
            else:
                lines.append(&quot;-&quot;)
                lines.extend(_indent_lines(code or [], 4))

    lines.append(&quot;&quot;)
    return lines


def _hardinfo2_convert(html: str, section_heading_level: int = 2) -&gt; str:
    soup = _make_soup(html)
    root = soup.body or soup

    out: List[str] = []
    for el in root.find_all([&quot;h1&quot;, &quot;table&quot;], recursive=True):
        if el.name == &quot;h1&quot; and &quot;title&quot; in (el.get(&quot;class&quot;) or []):
            out.append(&quot;#&quot; * section_heading_level + f&quot; {_escape_md_inline(_hardinfo2_text(el))}&quot;)
            out.append(&quot;&quot;)
        elif el.name == &quot;table&quot; and el.find_parent(&quot;table&quot;) is None:
            out.extend(_hardinfo2_render_table(el, heading_level=section_heading_level + 1))

    return &quot;\n&quot;.join(_collapse_blank_lines(out)) + &quot;\n&quot;


# -----------------------------
# Generic HTML → Markdown
# -----------------------------


BLOCK_TAGS = {
    &quot;p&quot;,
    &quot;div&quot;,
    &quot;section&quot;,
    &quot;article&quot;,
    &quot;main&quot;,
    &quot;pre&quot;,
    &quot;blockquote&quot;,
    &quot;ul&quot;,
    &quot;ol&quot;,
    &quot;table&quot;,
    &quot;hr&quot;,
    &quot;h1&quot;,
    &quot;h2&quot;,
    &quot;h3&quot;,
    &quot;h4&quot;,
    &quot;h5&quot;,
    &quot;h6&quot;,
}


class _Ctx:
    def __init__(
        self,
        base_url: Optional[str],
        keep_images: bool,
        heading_offset: int,
        max_heading_level: int,
    ):
        self.base_url = base_url
        self.keep_images = keep_images
        self.heading_offset = heading_offset
        self.max_heading_level = max_heading_level


def _resolve_url(href: str, base_url: Optional[str]) -&gt; str:
    if not href:
        return &quot;&quot;
    return urllib.parse.urljoin(base_url, href) if base_url else href


def _extract_text(tag) -&gt; str:
    return _norm_ws_keep_newlines(tag.get_text(&quot; &quot;, strip=True))


def _convert_children(tag, ctx: _Ctx) -&gt; List[str]:
    from bs4 import NavigableString, Tag

    out: List[str] = []
    for child in tag.children:
        if isinstance(child, NavigableString):
            txt = _norm_ws_keep_newlines(str(child))
            if txt:
                out.append(txt)
            continue
        if isinstance(child, Tag):
            out.extend(_convert_node(child, ctx))
    return out


def _convert_children_inline(tag, ctx: _Ctx) -&gt; List[str]:
    from bs4 import NavigableString, Tag

    out: List[str] = []
    for child in tag.children:
        if isinstance(child, NavigableString):
            txt = _norm_ws_keep_newlines(str(child))
            if txt:
                out.append(txt)
            continue
        if isinstance(child, Tag):
            out.append(_convert_inline(child, ctx))
    return out


def _convert_inline(tag, ctx: _Ctx) -&gt; str:
    name = tag.name.lower()

    if name in (&quot;span&quot;, &quot;label&quot;, &quot;small&quot;, &quot;sup&quot;, &quot;sub&quot;):
        return &quot;&quot;.join(_convert_children_inline(tag, ctx))

    if name in (&quot;strong&quot;, &quot;b&quot;):
        inner = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        return f&quot;**{inner}**&quot; if inner else &quot;&quot;

    if name in (&quot;em&quot;, &quot;i&quot;):
        inner = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        return f&quot;*{inner}*&quot; if inner else &quot;&quot;

    if name == &quot;code&quot;:
        inner = _extract_text(tag)
        if &quot;`&quot; in inner:
            return f&quot;``{inner}``&quot;
        return f&quot;`{inner}`&quot;

    if name == &quot;br&quot;:
        return &quot;  \n&quot;

    if name == &quot;a&quot;:
        href = _resolve_url(tag.get(&quot;href&quot;, &quot;&quot;), ctx.base_url)
        text = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip() or href
        return f&quot;[{text}]({href})&quot; if href else text

    if name == &quot;img&quot;:
        if not ctx.keep_images:
            return &quot;&quot;
        alt = (tag.get(&quot;alt&quot;) or &quot;image&quot;).strip() or &quot;image&quot;
        src = _resolve_url(tag.get(&quot;src&quot;, &quot;&quot;), ctx.base_url)
        return f&quot;![{_escape_md_inline(alt)}]({src})&quot; if src else &quot;&quot;

    return &quot;&quot;.join(_convert_children_inline(tag, ctx))


def _table_to_bullets(table, ctx: _Ctx) -&gt; List[str]:
    lines: List[str] = []
    tbody = table.find(&quot;tbody&quot;, recursive=False)
    container = tbody if tbody else table

    for tr in container.find_all(&quot;tr&quot;, recursive=False):
        cells = tr.find_all([&quot;th&quot;, &quot;td&quot;], recursive=False)
        if not cells:
            continue
        vals = [_extract_text(td) for td in cells]
        vals = [v for v in vals if v]
        if not vals:
            continue
        txt = &quot; | &quot;.join(vals)
        inline, code = _inline_or_codeblock(txt)
        if inline:
            lines.append(f&quot;- {_escape_md_inline(inline)}&quot;)
        else:
            lines.append(&quot;-&quot;)
            lines.extend(_indent_lines(code or [], 4))

    lines.append(&quot;&quot;)
    return lines


def _table_to_md(table, ctx: _Ctx) -&gt; List[str]:
    if table.find(&quot;table&quot;):
        return _table_to_bullets(table, ctx)

    rows: List[List[str]] = []
    tbody = table.find(&quot;tbody&quot;, recursive=False)
    container = tbody if tbody else table

    for tr in container.find_all(&quot;tr&quot;, recursive=False):
        cells = tr.find_all([&quot;th&quot;, &quot;td&quot;], recursive=False)
        if not cells:
            continue
        rows.append([_extract_text(td) for td in cells])

    if not rows:
        return []

    has_th = bool(table.find(&quot;th&quot;))
    header = rows[0] if has_th else None
    body_rows = rows[1:] if has_th else rows

    if header is None:
        first = rows[0]
        if first and all(len(c) &lt;= 40 for c in first) and len(first) &lt;= 6:
            header = first
            body_rows = rows[1:]
        else:
            header = [f&quot;Col {i+1}&quot; for i in range(len(rows[0]))]
            body_rows = rows

    col_count = max(len(header), *(len(r) for r in body_rows))

    def pad(r: List[str]) -&gt; List[str]:
        return (r + [&quot;&quot;] * col_count)[:col_count]

    header = pad(header)

    lines: List[str] = []
    lines.append(&quot;| &quot; + &quot; | &quot;.join(_escape_table_cell(c) for c in header) + &quot; |&quot;)
    lines.append(&quot;|&quot; + &quot;|&quot;.join([&quot;---&quot;] * col_count) + &quot;|&quot;)

    for r in body_rows:
        r = pad(r)
        if any(&quot;\n&quot; in c for c in r):
            return _table_to_bullets(table, ctx)
        lines.append(&quot;| &quot; + &quot; | &quot;.join(_escape_table_cell(c) for c in r) + &quot; |&quot;)

    lines.append(&quot;&quot;)
    return lines


def _list_to_md(list_tag, ordered: bool, ctx: _Ctx, indent: int = 0) -&gt; List[str]:
    from bs4 import Tag

    lines: List[str] = []
    items = [li for li in list_tag.find_all(&quot;li&quot;, recursive=False) if isinstance(li, Tag)]

    for idx, li in enumerate(items, start=1):
        prefix = f&quot;{idx}. &quot; if ordered else &quot;- &quot;
        cont_indent = indent + len(prefix)

        # Build “main line” from inline-ish children and the first paragraph-ish block.
        main_fragments: List[str] = []
        extra_blocks: List[List[str]] = []

        for child in li.children:
            if isinstance(child, Tag) and child.name.lower() in (&quot;ul&quot;, &quot;ol&quot;):
                continue

            if isinstance(child, Tag) and child.name.lower() in BLOCK_TAGS:
                block_lines = _convert_node(child, ctx)
                block_lines = _collapse_blank_lines(block_lines)
                if block_lines:
                    if not main_fragments:
                        # Use first non-empty line as the main line.
                        first_line = next((x for x in block_lines if x.strip()), &quot;&quot;)
                        if first_line:
                            main_fragments.append(first_line)
                        rest = [x for x in block_lines if x.strip()][1:]
                        if rest:
                            extra_blocks.append(rest)
                    else:
                        extra_blocks.append([x for x in block_lines if x.strip()])
                continue

            if isinstance(child, Tag):
                main_fragments.append(_convert_inline(child, ctx))
            else:
                txt = _norm_ws_keep_newlines(str(child))
                if txt:
                    main_fragments.append(txt)

        main_line = _norm_ws_keep_newlines(&quot;&quot;.join(main_fragments)).strip()
        lines.append(&quot; &quot; * indent + prefix + main_line)

        for block in extra_blocks:
            for ln in block:
                lines.append(&quot; &quot; * cont_indent + ln)

        for child in li.find_all([&quot;ul&quot;, &quot;ol&quot;], recursive=False):
            lines.extend(_list_to_md(child, ordered=(child.name.lower() == &quot;ol&quot;), ctx=ctx, indent=indent + 2))

    lines.append(&quot;&quot;)
    return lines


def _convert_node(tag, ctx: _Ctx) -&gt; List[str]:
    name = tag.name.lower()

    if name in (&quot;script&quot;, &quot;style&quot;, &quot;noscript&quot;, &quot;template&quot;):
        return []

    if name in (&quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;):
        lvl = int(name[1]) + ctx.heading_offset
        lvl = max(1, min(ctx.max_heading_level, lvl))
        text = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        text = _norm_ws_keep_newlines(text)
        return [&quot;#&quot; * lvl + f&quot; {_escape_md_inline(text)}&quot;, &quot;&quot;] if text else []

    if name == &quot;p&quot;:
        text = &quot;&quot;.join(_convert_children_inline(tag, ctx)).strip()
        text = _norm_ws_keep_newlines(text)
        return [text, &quot;&quot;] if text else []

    if name == &quot;hr&quot;:
        return [&quot;---&quot;, &quot;&quot;]

    if name == &quot;blockquote&quot;:
        inner = _collapse_blank_lines(_convert_children(tag, ctx))
        quoted: List[str] = []
        for ln in inner:
            quoted.append(&quot;&gt;&quot; if not ln.strip() else &quot;&gt; &quot; + ln)
        quoted.append(&quot;&quot;)
        return quoted

    if name == &quot;pre&quot;:
        # Try to infer a language from pre/code classes.
        lang = &quot;&quot;
        cls = &quot; &quot;.join(tag.get(&quot;class&quot;) or [])
        m = re.search(r&quot;language-([a-zA-Z0-9_+-]+)&quot;, cls)
        if not m:
            code = tag.find(&quot;code&quot;)
            if code:
                cls2 = &quot; &quot;.join(code.get(&quot;class&quot;) or [])
                m = re.search(r&quot;language-([a-zA-Z0-9_+-]+)&quot;, cls2)
        if m:
            lang = m.group(1)

        code_text = tag.get_text(&quot;\n&quot;, strip=False).replace(&quot;\r\n&quot;, &quot;\n&quot;).replace(&quot;\r&quot;, &quot;\n&quot;)
        lines = code_text.splitlines()
        while lines and not lines[0].strip():
            lines.pop(0)
        while lines and not lines[-1].strip():
            lines.pop()
        return [f&quot;```{lang}&quot;.rstrip(), *lines, &quot;```&quot;, &quot;&quot;]

    if name == &quot;ul&quot;:
        return _list_to_md(tag, ordered=False, ctx=ctx)

    if name == &quot;ol&quot;:
        return _list_to_md(tag, ordered=True, ctx=ctx)

    if name == &quot;table&quot;:
        return _table_to_md(tag, ctx)

    if name == &quot;img&quot;:
        inline = _convert_inline(tag, ctx)
        return [inline, &quot;&quot;] if inline else []

    if name in (&quot;div&quot;, &quot;section&quot;, &quot;article&quot;, &quot;main&quot;, &quot;body&quot;):
        return _convert_children(tag, ctx)

    inline = _convert_inline(tag, ctx).strip()
    return [inline] if inline else []


def _generic_convert(
    html: str,
    *,
    base_url: Optional[str],
    mode: str,
    selector: Optional[str],
    keep_images: bool,
    heading_offset: int,
    max_heading_level: int,
) -&gt; str:
    soup = _make_soup(html)
    _strip_non_content(soup)

    root = _select_root(soup, mode=mode, selector=selector)
    ctx = _Ctx(
        base_url=base_url,
        keep_images=keep_images,
        heading_offset=heading_offset,
        max_heading_level=max_heading_level,
    )

    lines = _convert_children(root, ctx)
    lines = _collapse_blank_lines(lines)
    return &quot;\n&quot;.join(lines) + &quot;\n&quot;


def convert_html_to_markdown(
    html: str,
    *,
    base_url: Optional[str] = None,
    mode: str = &quot;main&quot;,  # main|body
    selector: Optional[str] = None,
    keep_images: bool = False,
    heading_offset: int = 0,
    max_heading_level: int = 6,
    profile: str = &quot;auto&quot;,  # auto|generic|hardinfo2
    hardinfo_section_level: int = 2,
) -&gt; str:
    soup = _make_soup(html)
    _strip_non_content(soup)

    if profile == &quot;hardinfo2&quot; or (profile == &quot;auto&quot; and _looks_like_hardinfo2(soup)):
        return _hardinfo2_convert(html, section_heading_level=max(1, hardinfo_section_level))

    return _generic_convert(
        html,
        base_url=base_url,
        mode=mode,
        selector=selector,
        keep_images=keep_images,
        heading_offset=heading_offset,
        max_heading_level=max(1, max_heading_level),
    )


# -----------------------------
# CLI
# -----------------------------


def main(argv: Optional[Sequence[str]] = None) -&gt; int:
    _require_bs4()

    p = argparse.ArgumentParser(description=&quot;Convert HTML (file/URL/stdin) to Jekyll-friendly Markdown&quot;)
    p.add_argument(&quot;input&quot;, help=&quot;Path, URL, or &#39;-&#39; for stdin&quot;)
    p.add_argument(&quot;-o&quot;, &quot;--output&quot;, type=Path, default=None, help=&quot;Output .md file (default: stdout)&quot;)

    # Front matter
    p.add_argument(&quot;--no-front-matter&quot;, action=&quot;store_true&quot;, help=&quot;Do not emit YAML front matter&quot;)
    p.add_argument(&quot;--layout&quot;, default=&quot;post&quot;, help=&quot;Front matter layout (default: post)&quot;)
    p.add_argument(&quot;--title&quot;, default=None, help=&quot;Front matter title override&quot;)
    p.add_argument(&quot;--date&quot;, default=None, help=&quot;Front matter date override&quot;)
    p.add_argument(&quot;--date-from-meta&quot;, action=&quot;store_true&quot;, help=&quot;Try to extract date from meta/time tags&quot;)
    p.add_argument(&quot;--categories&quot;, default=None, help=&quot;Comma-separated categories&quot;)
    p.add_argument(&quot;--tags&quot;, default=None, help=&quot;Comma-separated tags&quot;)
    p.add_argument(&quot;--permalink&quot;, default=None, help=&quot;Front matter permalink&quot;)

    # Conversion knobs
    p.add_argument(&quot;--mode&quot;, choices=[&quot;main&quot;, &quot;body&quot;], default=&quot;main&quot;, help=&quot;Content selection mode&quot;)
    p.add_argument(&quot;--selector&quot;, default=None, help=&quot;CSS selector to choose content root (overrides --mode)&quot;)
    p.add_argument(&quot;--base-url&quot;, default=None, help=&quot;Base URL for resolving relative links/images&quot;)
    p.add_argument(&quot;--keep-images&quot;, action=&quot;store_true&quot;, help=&quot;Include &lt;img&gt; as Markdown images&quot;)
    p.add_argument(&quot;--heading-offset&quot;, type=int, default=0, help=&quot;Add to heading levels (e.g., 1 makes h1→h2)&quot;)
    p.add_argument(&quot;--max-heading-level&quot;, type=int, default=6, help=&quot;Clamp max heading depth (default: 6)&quot;)

    # Profiles
    p.add_argument(
        &quot;--profile&quot;,
        choices=[&quot;auto&quot;, &quot;generic&quot;, &quot;hardinfo2&quot;],
        default=&quot;auto&quot;,
        help=&quot;auto detects HardInfo2; otherwise force generic/hardinfo2&quot;,
    )
    p.add_argument(
        &quot;--hardinfo-section-level&quot;,
        type=int,
        default=2,
        help=&quot;Heading level for HardInfo2 section titles (default: 2)&quot;,
    )

    args = p.parse_args(argv)

    html, inferred_base = _read_input(args.input)
    soup = _make_soup(html)

    # Base URL: CLI &gt; &lt;base href&gt; &gt; inferred (URL input)
    base_url = args.base_url or _extract_base_href(soup) or inferred_base

    fm = None
    if not args.no_front_matter:
        title = _extract_title(soup, args.title)
        date = args.date
        if not date and args.date_from_meta:
            date = _extract_date_hint(soup)
        if not date:
            date = _now_with_tz()

        fm = FrontMatter(
            layout=args.layout,
            title=title,
            date=date,
            categories=[c.strip() for c in (args.categories or &quot;&quot;).split(&quot;,&quot;) if c.strip()] or None,
            tags=[t.strip() for t in (args.tags or &quot;&quot;).split(&quot;,&quot;) if t.strip()] or None,
            permalink=args.permalink,
        )

    md_body = convert_html_to_markdown(
        html,
        base_url=base_url,
        mode=args.mode,
        selector=args.selector,
        keep_images=args.keep_images,
        heading_offset=args.heading_offset,
        max_heading_level=args.max_heading_level,
        profile=args.profile,
        hardinfo_section_level=args.hardinfo_section_level,
    )

    out_text = (fm.render() if fm else &quot;&quot;) + md_body

    if args.output:
        args.output.parent.mkdir(parents=True, exist_ok=True)
        args.output.write_text(out_text, encoding=&quot;utf-8&quot;)
    else:
        sys.stdout.write(out_text)

    return 0


if __name__ == &quot;__main__&quot;:
    raise SystemExit(main())</code>
</section>

        </div>
        
          URL: https://ib.bsb.br/html2md
        
      </article>
      <nav class="post-navigation-combined" aria-label="Post navigation">
        <!-- Chronological Navigation (always visible at 40vh) -->
        
          <div class="nav-arrow chronological prev">
            <a href="/rk3588-custom/" title="rk3588 custom documentation" rel="prev">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
        
          <div class="nav-arrow chronological next">
            <a href="/rk3588-dts/" title="RK3588 DXB LP4 V10 Device Tree Source" rel="next">
              <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next article" width="45" height="45" loading="lazy">
            </a>
          </div>
        
            
            
              
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
              
                
                  
                  
              
              
              
              <!-- Navigation block for tag "scratchpad"; default display for the first tag -->
              <div class="nav-group tags" id="tag-nav-scratchpad" style="display: block;">
                <div class="nav-arrow tags prev">
                  
                    <a href="/treesheets-build/" title="TreeSheets Debian 11 arm64 build" rel="prev">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAxVJREFUaEPt18FqG1cUBuD/nLkzI42UiVInkFLTCAKhS+9KA+3Kq1L8AAHjhR7AKz+ADV55qUfoqhvThTfdmC4KzTKmYJrELshJW9PIlSeKRpqZe88pUtouihvVRknqMNoMzD1zdPXNrzMM4RJ+6BLuGeWm39RdK6VL6VcIlPEo41HG401loJQupS8mUM7pi7md/6p3UtoHUJzf4vVecZb0e0EQfB7H8b0kSeqqummt/eb1buN83SebNsZ8QkQCYHVpaenu/v7+ra2tLRwdHWF1ddWq6hfM3BCRE2b+FcBHACQAHo1E5v9c+5mIhkR0e3z0VQ8LotuqWlXVw/GRmT8QkdMK89McuAOAAfwoIu8z85yIHBPRKRGN1/IAeDx0rul53hivo6psrf2ejDGfEtFOu92u7O3tBWtra2i322g0GhgOh9je3ka325UPax7fCR0iw+lp4aLxr70aeOmgkChTRY3JGSb73EroERD73uB54WpOgdhwZkXNQNQLiVDzOU1yFymAhu+lqZVopIqISQKmPLFS+atHv3A1q8AVQ+lXP/VHRPQx+b6frKysxMvLy1hfX0ez2USv18PCwgLiOEaSJKhWq/jhwQN8dnIfVOS4dsWHqCJ5YREGjBuNEMfd0eTc9WshBqnFYGhRqxrUIoNuLwMT4eb1Cp6dZshywdW6mZzr9QsEPuPmXIhfno3gnGKuEWCUC14MLKoVb1L72+8Zvj3JOl/udZt/S7darUqn0wlarRZ2d3cxPz+PJ8dPsPP1Doq8kIbL+cawjxBIM8MRFAidpBlRpIbhFc55gM2NF5IIQtVBRlRTZgTWZQ4wzvc8spO1NPM4Gr9Wh1bSDIjU98C5E0PIC8OVSX+Rlz08hl+4/LsML6X/menFxcW7BwcHtzY2NvDw8CE21zf/NdMAHskFMs3MT/EfMg3gsTsr02f8byfTo16v3+v3+//f6fGKgXNp5vT5huZbqH4nH+NvwXH6V5bS041mU1FKz8ZxepdSerrRbCpK6dk4Tu9SSk83mk1FKT0bx+ldSunpRrOpuJTSfwBcuImxpyA7XgAAAABJRU5ErkJggg==" alt="Previous in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
                <div class="nav-arrow tags next">
                  
                    <a href="/rk3588-npu/" title="rk3588 npu" rel="next">
                      <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAAAXNSR0IArs4c6QAAAwdJREFUaEPtl01rG1cUht9z7p070ijKWLVS3I9YULtNMBRn2UIXxZtuvCjedNWfoKVXBvsHeOUfoIUx5AeY0pVXXSR052UxBJSi0kDiRplII83HvadI9CMtOFjCmBjubC7cc8+Zc555eYdLuIEP3cCe4Zu+rq/mSXvSbyHg5eHl4eVxXRrwpD3p+Qh4n56P2+xZnvTszC7MCAAUF0XfOdJa62+IaCeO40GSJA/zPP8RwB9vDjBtWmv9JRE5ImpZawdVpbo58CkAIyJnIrLAzEvOuXNm/h3AfQDOAGdj5z5m5gXn3G9ENCKilckaiDwpiFZEpCoiTyYrM3/knOtXmHs58BkABvCLc+4DZl6cxIjoh4ODA728vIzt7W2sra09PT4+fgTgQES4LMvHZIy5LyI/f/dJvfK6FKMJqAdqmBS2ZgWINY9zJyZ1whUiRJrTfmGjybSxUemwcFEmghqT1UxlUrpQEXD7jRq3NWelEz10okIi1AJOX+U2EgALgUrT0kVnmcKvQ+uazSZvbW2hWq2i3++j3W5jf38f6+vrebvdHovI5pT09+vN7teLYev990K8GpQYjS1u1TQqhnHez6EU4cM7FTw7z5AXDo16ACcyPRsaxp2FEM9ejKd7zUaIYVpiOCpRq2rUIo0XLzMwEZaaFTzvZ8hyh/iWnu69fF1AAoOfFr/A5w8eYDQaIY5jJEmC09NTNBoNdLtd7O3t4ejoCIeHh8k/pL8KUSkCZcg6hCLDjLk2ufYGpRuXAuOMYiosQiDNNEcQILQuzYgi0QxVWKuAMtcqJPdXDaKaMMOUNrOAtoFSVE5jaaY4mtQPS5dmQPS8WkdfGReYgDe/3cTdpbvo9XrY2NhAp9NBq9XKO53Ov6T/r2mlVBeX0DSAMzeHppm5h7doemdvR99buYfd3V2srq4+PTk5+a+mr9CmrqTU3+5Rr9cHg8HgYve4krddbZGb5dOXmf2d+7n4pi9D4LrOeHl40v42fl0a8KQ96fkIeJ+ej9vsWZ707Mzmy/Ck5+M2e9afhmuAz1BhwewAAAAASUVORK5CYII=" alt="Next in Tag" width="45" height="45" loading="lazy">
                    </a>
                  
                </div>
              </div>
            
          
          <!-- JavaScript to Toggle the Tag-based Navigation -->
          <script>
            document.addEventListener("DOMContentLoaded", function(){
              var tagLinks = document.querySelectorAll('.tag-option');
              tagLinks.forEach(function(link){
                link.addEventListener('click', function(event){
                  event.preventDefault();
                  // Remove "active" class from all tag options.
                  tagLinks.forEach(function(el){ el.classList.remove('active'); });
                  // Add active class to the clicked tag option.
                  this.classList.add('active');
                  // Hide all tag navigation blocks.
                  document.querySelectorAll('.nav-group.tags').forEach(function(block){
                    block.style.display = 'none';
                  });
                  // Show the navigation block corresponding to the selected tag.
                  var tagSlug = this.getAttribute('data-tag');
                  var target = document.getElementById('tag-nav-' + tagSlug);
                  if(target) {
                    target.style.display = 'block';
                  }
                });
              });
            });
          </script>
      </nav>
      
    </main>
    <footer id="bottom-of-page" class="site-footer">
      <div class="footer-content">
        <!-- Back to top link -->
        <a href="#" aria-label="Back to top" class="back2top-link">
          <span class="sronly">Back to top</span>
        </a>
    
        <!-- Liquid Time Calculation and Display -->
        
        
        
        <a href="https://ib.bsb.br/404" aria-label="404">
          2026-01-15 10:13:08
        </a>
        &#x23;
    
        <!-- Tag Selector -->
        <ul class="tag-selector">
          
            
            
              <li>
                <a href="#" class="tag-option active" data-tag="scratchpad">
                  scratchpad
                </a>
              </li>
            
          
        </ul>
        &hArr;
    
        <!-- GitHub Link -->
        <a href="https://github.com/ib-bsb-br/ib-bsb-br.github.io" aria-label="GitHub">
          &#8505;
        </a>
    
        <!-- Homepage Link -->
        <a href="/" aria-label="Homepage">
          infoBAG
        </a>
    
        <!-- Copy All Code Button -->
        <button id="copyAllButton" aria-label="Copy all code">
          &copy;
        </button>
      </div>
    </footer>
    <style>
      .back2top-link {
        display: inline-block;
        width: 32px;
        height: 32px;
        background: url("/assets/Rope_(Old).gif") center center no-repeat;
        background-size: contain;
        text-decoration: none;
        vertical-align: middle;
      }
      .sronly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "Article",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://ib.bsb.br/html2md/"
        },
        "headline": "html to markdown",
        "description": "",
        "datePublished": "2026-01-09T00:00:00+00:00",
        "dateModified": "2026-01-09T15:25:06+00:00",
        "author": {
          "@type": "Person",
          "name": "Author"
        },
        "publisher": {
          "@type": "Organization",
          "name": "infoBAG"
          
        }
        
      }
    </script>
    <script src="/assets/js/prism.js" defer></script>
    <script src="/assets/js/copy-all-code.js"></script>
  </body>
</html>
